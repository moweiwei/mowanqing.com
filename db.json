{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1},{"_id":"source/img/2021-12-01-1.png","path":"img/2021-12-01-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-01-1.jpeg","path":"img/2022-01-01-1.jpeg","modified":1,"renderable":0},{"_id":"source/img/2021-12-22-1.png","path":"img/2021-12-22-1.png","modified":1,"renderable":0},{"_id":"source/img/2021-12-15-1.png","path":"img/2021-12-15-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-13-1.png","path":"img/2022-01-13-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-14-1.png","path":"img/2022-01-14-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-14-3.png","path":"img/2022-01-14-3.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-14-2.png","path":"img/2022-01-14-2.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-22-1.jpeg","path":"img/2022-01-22-1.jpeg","modified":1,"renderable":0},{"_id":"source/img/2022-01-24-1.png","path":"img/2022-01-24-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-24-3.png","path":"img/2022-01-24-3.png","modified":1,"renderable":0},{"_id":"source/img/2022-02-06-1.png","path":"img/2022-02-06-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-24-4.png","path":"img/2022-01-24-4.png","modified":1,"renderable":0},{"_id":"source/img/2022-02-08-1.jpeg","path":"img/2022-02-08-1.jpeg","modified":1,"renderable":0},{"_id":"source/img/2022-02-22-1.jpeg","path":"img/2022-02-22-1.jpeg","modified":1,"renderable":0},{"_id":"source/img/2022-02-16-1.jpeg","path":"img/2022-02-16-1.jpeg","modified":1,"renderable":0},{"_id":"source/img/2022-03-07-1.png","path":"img/2022-03-07-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-03-16-1.png","path":"img/2022-03-16-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-03-20-1.webp","path":"img/2022-03-20-1.webp","modified":1,"renderable":0},{"_id":"source/img/2022-04-07-1.png","path":"img/2022-04-07-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-04-18-1.png","path":"img/2022-04-18-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-24-2.png","path":"img/2022-01-24-2.png","modified":1,"renderable":0},{"_id":"source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":0},{"_id":"source/img/default.jpg","path":"img/default.jpg","modified":1,"renderable":0},{"_id":"source/img/2022-04-29-3.jpeg","path":"img/2022-04-29-3.jpeg","modified":1,"renderable":0},{"_id":"source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":0},{"_id":"source/img/index-img.png","path":"img/index-img.png","modified":1,"renderable":0},{"_id":"source/img/miaomiao.JPG","path":"img/miaomiao.JPG","modified":1,"renderable":0},{"_id":"source/img/2022-04-29-2.jpeg","path":"img/2022-04-29-2.jpeg","modified":1,"renderable":0},{"_id":"source/img/2022-04-29-1.jpeg","path":"img/2022-04-29-1.jpeg","modified":1,"renderable":0}],"Cache":[{"_id":"source/_drafts/0.实习生前端工程师面试题.md","hash":"8e9b37c10d7938e1295824780aa62dd35c4b1443","modified":1646186560709},{"_id":"source/.DS_Store","hash":"1fa609ea60713abfb4539948629053750f55fb1a","modified":1651198223615},{"_id":"source/_drafts/2.每日 3+1.md","hash":"b082c0914458ca1f27c29903da3d89f48a9ad518","modified":1646618058869},{"_id":"source/_drafts/1.大厂面试题.md","hash":"869909570578d68b516c1164eb20278e92a95750","modified":1647446155184},{"_id":"source/_drafts/3.优秀文章合集.md","hash":"5f5eb8887fb8b5363a1da602a354118f46cb64ad","modified":1650248519205},{"_id":"source/_drafts/7.React + TypeScript.md","hash":"e25e323436479e58f2fbe7fe1126a8019eb29482","modified":1650016634856},{"_id":"source/_drafts/4.Mobx 原理分析.md","hash":"9451cd81dc24149e0aa36981010b2bf5e845b6fa","modified":1646102803070},{"_id":"source/_drafts/5.Webpack 原理分析.md","hash":"65d14b79d69b3bc74275d3247784fbc5dfa63a3e","modified":1646102805810},{"_id":"source/_drafts/6.JS 代码 Bad & Good.md","hash":"dc59ebbc7e5d0b68acb8759164c74e1ffd63bd2a","modified":1646102800356},{"_id":"source/_drafts/8.React Hooks 之闭包.md","hash":"6995900dc849afe061ebf4d5eb43ca601b738264","modified":1649920447866},{"_id":"source/_posts/0.前端工程师面试题.md","hash":"841922b73094932b123de3a5bd935457f42e8202","modified":1650016746736},{"_id":"source/_posts/10.React 中常用 TS 类型.md","hash":"deefaa8ff5da75dd82af1f01e4a23f341e158465","modified":1650016738516},{"_id":"source/_posts/1.FE-Interview.md","hash":"dcaa61e33a0a7854a9c83e4f73e441c99ff346ae","modified":1646622909912},{"_id":"source/_posts/11.React Hooks 之 useEffect.md","hash":"3b9056d873689f472dec6766ef02b3d4bf1720b3","modified":1650250483768},{"_id":"source/_posts/12.React Hooks 之 useCallback.md","hash":"764d1e2ecf5882c6a20222c27c8301200c5fe929","modified":1650335655712},{"_id":"source/_posts/13.Antd 源码分析之 useMergedState.md","hash":"1b5f4e2541da24f6cc53bbe59faca826bf776541","modified":1651198115703},{"_id":"source/_posts/14.Antd 源码分析之 useMountMergeState.md","hash":"9159b4e595b4003d15ae99d8a2efbbc6c1eb53ea","modified":1651198125170},{"_id":"source/_posts/3.使用 useRef 跨生命周期保存变量.md","hash":"a81748df39bbc7f339ce166670daecd5252cf864","modified":1646103372117},{"_id":"source/_posts/15.Antd 源码分析之常用 hooks.md","hash":"ebb1ffb2da6cfdc126f5c469beec36a0c6ed08fb","modified":1651198055808},{"_id":"source/_posts/2.日常使用的容器镜像操作命令.md","hash":"b409f3cc70c74732362f1ab9b98c269c0d2b531e","modified":1646103372118},{"_id":"source/_posts/5.如何在 class 组件中使用 hooks.md","hash":"752a5a596d426c067bceca23ad460c76fe9bc1eb","modified":1646103372119},{"_id":"source/_posts/7.Vue3 学习笔记.md","hash":"7136e5e112fc88a8139a4384ddba4edb1baff547","modified":1646103372121},{"_id":"source/_posts/8.VS Code 配置.md","hash":"f2753b78a638b4a6ce93b32ff95e51a8a22ed71b","modified":1650016733884},{"_id":"source/css/custom.css","hash":"f24fec7800ead60a19749e06b7f7f64c00a4633d","modified":1645772214842},{"_id":"source/about/index.md","hash":"620975b1605593924abc83376419b88505002570","modified":1646117194534},{"_id":"source/_posts/9.TypeScript 笔记.md","hash":"e3593076f895e8d587324a0f843fcadbc433b08f","modified":1647767819149},{"_id":"source/js/custom.js","hash":"038c6dc73f8c0638456353e0f56e57b99cefb1be","modified":1646647368657},{"_id":"source/_posts/6.map 到底改不改变原数组.md","hash":"dbc4124c1e5d4e14d87040cef30da1d92e08e3f4","modified":1646103372119},{"_id":"source/_posts/4.useState 引用类型数据更新不触发重新渲染问题.md","hash":"1ea53e212b4364debaa0b1ba30f01246c55d4ad9","modified":1646103372115},{"_id":"source/img/.DS_Store","hash":"e08573c5d06518bf87ab62165176cc6eee9fa975","modified":1646126682526},{"_id":"source/img/2021-12-01-1.png","hash":"62808e649d5dd5c68db4bad0bc894d3e8158e784","modified":1646102636847},{"_id":"source/img/2022-01-01-1.jpeg","hash":"637bfc4c59e0448a36da0992dab88b32449bacc2","modified":1646014956663},{"_id":"source/img/2022-01-13-1.png","hash":"ca711c0f3099cc42172cb5b0e72a322d7f6d3eae","modified":1646015981781},{"_id":"source/img/2021-12-15-1.png","hash":"0bb7c1fe8c45832813e1b155a1b93859bdb64d6c","modified":1646015938987},{"_id":"source/img/2022-01-14-3.png","hash":"038e34cdfb8ee37c9b12ce22a931c3f54b765756","modified":1646016196232},{"_id":"source/img/2022-01-14-2.png","hash":"1b573758b98a28cb7b9f276413152c4ff826ea38","modified":1646016169557},{"_id":"source/img/2022-01-14-1.png","hash":"457563e3b79c3c5f22d065b8bb966b58ed413e77","modified":1646016128450},{"_id":"source/img/2022-01-22-1.jpeg","hash":"104465a44f28ae47be6bb42740896883fc6e9d97","modified":1646016233814},{"_id":"source/img/2022-01-24-1.png","hash":"7cac7a9aef2c512af1e8b8b1cc8a8b20cac94745","modified":1646016262776},{"_id":"source/img/2022-01-24-3.png","hash":"30f86b353805b575ed8516fccb258143fa79d01e","modified":1646016394604},{"_id":"source/img/2022-01-24-4.png","hash":"868d8a69b778000e352ab17d22aa72c3b8eed312","modified":1646016437004},{"_id":"source/img/2022-02-08-1.jpeg","hash":"3e4ed33f30d6f54d5bf437062ec55c6348a4fc66","modified":1646016830499},{"_id":"source/img/2022-02-22-1.jpeg","hash":"e34dc1856ace7e149c338048fbc92d21d21d8cd1","modified":1646016746310},{"_id":"source/img/2022-02-16-1.jpeg","hash":"c049a498846cbc8d2bf6e45be0b43c97fd3d9edf","modified":1646016606165},{"_id":"source/img/2022-02-06-1.png","hash":"86b9a8a41e2c853053e909387d6ec33e4877366b","modified":1647477386463},{"_id":"source/img/2022-03-16-1.png","hash":"3836172c33012b8886c54ed062bc0857e8cca93e","modified":1647445910122},{"_id":"source/img/2022-03-07-1.png","hash":"563d429ae97eac009674098dd57517551c37e03f","modified":1647445868249},{"_id":"source/img/2022-03-20-1.webp","hash":"f95a32645c06b594bf0e9e8d01cba118f9a6caa8","modified":1647768265159},{"_id":"source/img/2022-04-07-1.png","hash":"22a729b5064126094b4985f989b3f402ed8f1286","modified":1649342157397},{"_id":"source/img/2022-01-24-2.png","hash":"6fa5684418ffd50020153e1173830e3d8ee71327","modified":1646016305143},{"_id":"source/img/avatar.png","hash":"7ba2b5e584fdcff16ac464c31012e0717df0e154","modified":1642143447663},{"_id":"source/img/2022-04-29-3.jpeg","hash":"4d75a9a8466fb910f8ede6baaa12ee0fa684e568","modified":1651198166853},{"_id":"source/img/favicon.png","hash":"7ba2b5e584fdcff16ac464c31012e0717df0e154","modified":1642143447663},{"_id":"source/img/2022-04-29-2.jpeg","hash":"bc1be3edb79e96ea0ba4bcf625ec3abd0d641dc1","modified":1651198166836},{"_id":"source/img/miaomiao.JPG","hash":"60b94fd56002070d8be535b35adfef67f0b4be6c","modified":1642146142925},{"_id":"source/img/2022-04-29-1.jpeg","hash":"2f631a9b78b2ea94e7e26abb5e727838294499d7","modified":1651198166980},{"_id":"source/img/2021-12-22-1.png","hash":"023912be2857823f083116c0bb43078f83cb9c2a","modified":1646014018177},{"_id":"source/img/2022-04-18-1.png","hash":"0525d8a00579950752409c5c23d4b046f97ce5f6","modified":1650250230589},{"_id":"source/img/index-img.png","hash":"f7314828a14a3e236deecbe33816f99d0f65c5cf","modified":1646016966643},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README_en.md","hash":"ca8fd19a4948de1f253616a62c0e8a7d81f692f5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"ee5f90b4642735bb42161c389e4b86b00bc4fac5","modified":1642149993961},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"03cfa8e5f149514b57ef80dcb84eb7fea261370d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"df5b54be535593d5442cebafbea34eb9bd69b987","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"ad6fed7b646d3ca961db83db0fbe020e3a5d42ad","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"8a7f1534c228538e2ab56249d5a65829650170ed","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"20c2a195a109d2a263b5fa6e79cbcc62932508ad","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"472d0813ca5b88000a7bc6039f33b7e27b5a3216","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"58291dfec65c36889dfce0ddc603540b67e4c598","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"f3ae4395e751c4a02d5895e07856b1e8edfdda08","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7f566edf750241e62d7c54abfbb0c504fdab850a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"1014b901d396f4fc445cb1ffc938d5380d894d71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"2a7b49f0f9aecf07550b5a0b99242aab5654cf2b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"79e3679a7069351a6172c281b9d09f59d7580484","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"0ad89eb7c92a822980fa9a85285e6d94ad845d1d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a0c7984495d4f2d33b64adfa33adebbf768a5ac3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"13a6a799415fc2f6f69ebd1a399fb44426a5d641","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"1a6d415446da11dee5c5f400e7d67544fbe743ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"af977ed0792508bb0766ea8afe82d34ef1e8fb3c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"16d33eb89ecf90f4046720fde5395d972c7ba1fd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/archive-list.ejs","hash":"53a4f6029373a40394a87aba9284696a71610f90","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/beian.ejs","hash":"58b4bbe36386de4305a8da5ffd7d56802df23049","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/css.ejs","hash":"c363829a4b80f74fc1c565e41f6dab41c95006ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/footer.ejs","hash":"a62278c38a310da495d96c39abacacef266945cb","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/head.ejs","hash":"f7f3494ed001e8cdcdc3e8a1d2cd1195cff2ded5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/nav.ejs","hash":"e71b3c4aa263163597d31b1f91e5a1a877084cfd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/post-meta.ejs","hash":"32a17edadeed40da6db21d2d8031bd47d2fc9bf4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/scripts.ejs","hash":"0ee838b6fcd895d21a29d9d67dbb99b752d623d1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"44faef3e77ab08b91e4c5c6f1cd9087a9faff443","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"6c37e9f1ac1d6d00b3c32794e02e244dba942cd9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"cde964c8cd3217268a231de5e018a62c53c2e047","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/toc.ejs","hash":"3d2fb5552f373e5a0c56bc356702d807bcbcb411","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"3aa5b4ea879cd34d3a32468d88da18d72cbcc8e0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"b917b893b1777e6ffcb53188f9f5644510e5f20d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"649457796374c79e49a19bd541e4ad8e78fe8995","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"f1fdd512f3ef92ff5db4a49f5a3143d5ddea9858","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"633f0142c657805359b0197f287e12ae4bcde731","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"d058f30bd09b28769c4d8313428ff23dfc8d52dd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"53987b7a668ea0623370eb83ed5311766221b557","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"4a43f2700e91937650bef511fd438825b001c4c6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/twikoo.ejs","hash":"1af53bc0be642610a3a4d4e7c05287854a821508","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/valine.ejs","hash":"4052ab2a8f78efa92f0fe17abe8f66135943390a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/utterances.ejs","hash":"e1ed6530dfd7310f91060a75766a93ac3c39be3a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/waline.ejs","hash":"21e00443054802e893aac1f668b69d5bb4b39b3a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"b5fd5a2d9c463eb59318af0f47c591c485b6ad27","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"28e186c32576eb3d5d923273471a001c47fe8071","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/math.ejs","hash":"df6941bd3b860180d01fd39ee859ed2d42f4d1f0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"c1db1a4f9eca6e36b660530641e3a4fb6a30c8d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"fd5fcb6a61ad865197a778eeae889b80484227dd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/typed.ejs","hash":"e8e01c5db46b383748855452aecd70fcda99f598","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"08b455b848b21d57e0563b87071c4bae2b63bafe","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"c2d8bfd04bf0734b387c049402b46a06a05fc582","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"80098e8354069631bde8edcd1181a53091a92949","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"d547ab0b91f84eb0acd0bc0c5d716ce17c30361a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/rewrite.styl","hash":"a2993f23701de9a83e3f428300e62c5c52b4ff4b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/tag_plugin.styl","hash":"b89b96c8a6a433a6f372b42710554b05cab85a24","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"616c1f7147078c3d532dd1cfd2af09c0c3a816f0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post.styl","hash":"5e86487de0f16c30ca3e16460ab94b57620e31c5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"7e32a3268accf3d524209c213e15e2d5d5e2e1a6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"30f8fab95a5214d79df0ccc02b937df8bd885676","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"9f932ca3f9625c13aa5353f58319881e62c0c653","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"0ce7552dc4993926426019398d73e817cfd841a1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"d8011325756eb6e4ce619b3e7b4d6d80c2de8a57","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"55e10a6965462f8f62f85e75fd5e143af02a4b44","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":499162500000},{"_id":"source/img/default.jpg","hash":"d48e1d1c2a174a0286776448c0e74f95aaa5fa5e","modified":1645520847967},{"_id":"public/css/custom.css","hash":"f24fec7800ead60a19749e06b7f7f64c00a4633d","modified":1651219285553},{"_id":"public/js/custom.js","hash":"038c6dc73f8c0638456353e0f56e57b99cefb1be","modified":1651219285553},{"_id":"public/baidusitemap.xml","hash":"49e0a6dd661ba13ab81991ab35c397fae9b28404","modified":1651219285553},{"_id":"public/atom.xml","hash":"1c15897b399dca6d95add00110d2de02eb12501b","modified":1651219285553},{"_id":"public/sitemap.xml","hash":"774a6f9e5380c123285e613694ea394cafaffa2e","modified":1651219285553},{"_id":"public/local-search.xml","hash":"4296f161fa4064567dbc6de506bec27a6e062872","modified":1651219285553},{"_id":"public/posts/e509b107/index.html","hash":"e9054ce0f0a320daac6e65d572ca6f2b511623a5","modified":1651219285553},{"_id":"public/about/index.html","hash":"42a17867b3123b78920c038f077b910b612fd3ea","modified":1651219285553},{"_id":"public/archives/index.html","hash":"9131fabddc80ef41268c236aa093092a22ebb5df","modified":1651219285553},{"_id":"public/archives/page/2/index.html","hash":"1e51bb0607778cc2c477acb76e6661391422abbd","modified":1651219285553},{"_id":"public/archives/2021/index.html","hash":"8db6c105b777f6546464f6ae8def945931cccd84","modified":1651219285553},{"_id":"public/archives/2021/12/index.html","hash":"57ab4ccfa2cc930ee275f55761e672223495d8ab","modified":1651219285553},{"_id":"public/archives/2022/index.html","hash":"9842214665ebe574dd595c06cd5a048e3bf55a51","modified":1651219285553},{"_id":"public/archives/2022/page/2/index.html","hash":"22b25ef8b0cc80ddc05554d65c0d19dc0e129ba5","modified":1651219285553},{"_id":"public/archives/2022/01/index.html","hash":"b8c6a3768bc7dd792e2b9cde2e9e1b52729fe5b3","modified":1651219285553},{"_id":"public/archives/2022/02/index.html","hash":"801a6b5864b8f9b44561f47b936905956b8e1b47","modified":1651219285553},{"_id":"public/archives/2022/03/index.html","hash":"f28e56fcd800dccf4ee60405bb368a38f12f5c12","modified":1651219285553},{"_id":"public/archives/2022/04/index.html","hash":"ccf4418416064b72079908063fd6de522379f432","modified":1651219285553},{"_id":"public/categories/面试/index.html","hash":"11a0dc5a6945453a9e07522e9364af2ccfae0978","modified":1651219285553},{"_id":"public/categories/JS/index.html","hash":"6fde7a7030694aa297809da562478920569bd865","modified":1651219285553},{"_id":"public/categories/React-Hook/index.html","hash":"5e9a404d19839f80dd5e43add718506871713a24","modified":1651219285553},{"_id":"public/categories/React/index.html","hash":"9374530c00d9252d87e61db2073490a6b92544c3","modified":1651219285553},{"_id":"public/categories/Vue/index.html","hash":"c577bfd40540919f0ffaae803dd6d144650f19bd","modified":1651219285553},{"_id":"public/categories/vscode/index.html","hash":"6d92ad604f533529392bd7178c1334ca6852b0f9","modified":1651219285553},{"_id":"public/categories/TypeScript/index.html","hash":"e83f4447c8c45122a3f7655e5ac8ca0c82d99047","modified":1651219285553},{"_id":"public/tags/前端/index.html","hash":"2d16795250b5d414625ebb39412bf9e95b175e51","modified":1651219285553},{"_id":"public/tags/useEffect/index.html","hash":"40b044b654563062e536cd3481e9eac90b3d65d4","modified":1651219285553},{"_id":"public/tags/React-TypeScript/index.html","hash":"c85bf743fa38252515f97c3aa4916746f7c0a255","modified":1651219285553},{"_id":"public/tags/Hook/index.html","hash":"cbd5134ac2a14221f75a4b0022354397be39c6eb","modified":1651219285553},{"_id":"public/tags/useCallback/index.html","hash":"c8ddb4729531fc127238a7ee00879bb762a05c53","modified":1651219285553},{"_id":"public/tags/React/index.html","hash":"af710120613626ca66b952164c9d4c9771b4f259","modified":1651219285553},{"_id":"public/tags/Vue3/index.html","hash":"447e1a3b8ca1433047084e6e7e0509b500ad4568","modified":1651219285553},{"_id":"public/tags/HooK/index.html","hash":"d194ed7310c7903efd0a3c67b7448cc1862e6503","modified":1651219285553},{"_id":"public/tags/vscode/index.html","hash":"da90907095c9152e1d0a30a130f93d781d8fef4b","modified":1651219285553},{"_id":"public/tags/map/index.html","hash":"dcbdf4140d9487f7d260bdce707c68021e81788d","modified":1651219285553},{"_id":"public/tags/TypeScript/index.html","hash":"6d7d16a3dc36a6834f6483980780927edcb50eb4","modified":1651219285553},{"_id":"public/404.html","hash":"7593add168bbbd4bbd5399e701f96405fa68715d","modified":1651219285553},{"_id":"public/tags/index.html","hash":"28335f31379c640c98e87b38e41fab784b4bf416","modified":1651219285553},{"_id":"public/links/index.html","hash":"074a93b33f617a3e507b3c89a04a37a2f34913ad","modified":1651219285553},{"_id":"public/posts/f806f23d/index.html","hash":"9ddb80b6afc1d800a03b9366a1b7e9290b3f67a4","modified":1651219285553},{"_id":"public/posts/e6886795/index.html","hash":"c1cb5984dbe14d20a2d54ff585cdaff90f8ee5a9","modified":1651219285553},{"_id":"public/posts/b3515e96/index.html","hash":"1e2798a87a96e754788b8e2a802279dc13370fa1","modified":1651219285553},{"_id":"public/posts/0/index.html","hash":"3063d894887257dded4d04428abd799dd8af72e6","modified":1651219285553},{"_id":"public/posts/25e26362/index.html","hash":"01d0b133720c0475e5ba4c133d67c4e480712473","modified":1651219285553},{"_id":"public/posts/81dvefb9/index.html","hash":"64fdd8c894590731468853d419dfdc59ed8dfe49","modified":1651219285553},{"_id":"public/posts/1ad5be0d/index.html","hash":"ebafa791fe0d46a213308c2cdebc780e8ec6b89b","modified":1651219285553},{"_id":"public/posts/a18c0ac9/index.html","hash":"d6b1f0868152a486282210e94542d09e2237af57","modified":1651219285553},{"_id":"public/posts/e372be48/index.html","hash":"1a48cc79acf170e40d54fc26e47b4df1e252b056","modified":1651219285553},{"_id":"public/posts/d177e434/index.html","hash":"d3a510b9845f8d6109ac03379e79840239564150","modified":1651219285553},{"_id":"public/posts/ee7a9294/index.html","hash":"ee91eff5da2d5f8b0a923aabae32e867a54c35bb","modified":1651219285553},{"_id":"public/posts/b195fb80/index.html","hash":"78a9410cba50b62a633749d282be62e87f2c8c5f","modified":1651219285553},{"_id":"public/posts/bb88c12/index.html","hash":"3ea941031c8132e474f86cbdf2c9accb8de98268","modified":1651219285553},{"_id":"public/posts/25d325e2/index.html","hash":"e9f37cef10a37db63727f417d867dcfe5527beff","modified":1651219285553},{"_id":"public/posts/12d2438b/index.html","hash":"9864f11ca6a02073ff5a7c1fa107ed6d3587238f","modified":1651219285553},{"_id":"public/index.html","hash":"2617680522d4cfad9aec54e5fac13a254c25b371","modified":1651219285553},{"_id":"public/page/2/index.html","hash":"aa83d832575303bd31ebb2cef07a9e848876f1d5","modified":1651219285553},{"_id":"public/categories/index.html","hash":"9cab1c3d9099b52309d01add03b6890def1d2d9a","modified":1651219285553},{"_id":"public/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1651219285553},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1651219285553},{"_id":"public/img/favicon.png","hash":"7ba2b5e584fdcff16ac464c31012e0717df0e154","modified":1651219285553},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1651219285553},{"_id":"public/img/2022-01-01-1.jpeg","hash":"637bfc4c59e0448a36da0992dab88b32449bacc2","modified":1651219285553},{"_id":"public/img/2021-12-01-1.png","hash":"62808e649d5dd5c68db4bad0bc894d3e8158e784","modified":1651219285553},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1651219285553},{"_id":"public/img/2022-01-13-1.png","hash":"ca711c0f3099cc42172cb5b0e72a322d7f6d3eae","modified":1651219285553},{"_id":"public/img/2022-01-14-1.png","hash":"457563e3b79c3c5f22d065b8bb966b58ed413e77","modified":1651219285553},{"_id":"public/img/2022-01-22-1.jpeg","hash":"104465a44f28ae47be6bb42740896883fc6e9d97","modified":1651219285553},{"_id":"public/img/2021-12-15-1.png","hash":"0bb7c1fe8c45832813e1b155a1b93859bdb64d6c","modified":1651219285553},{"_id":"public/img/2022-01-14-3.png","hash":"038e34cdfb8ee37c9b12ce22a931c3f54b765756","modified":1651219285553},{"_id":"public/img/2022-02-06-1.png","hash":"86b9a8a41e2c853053e909387d6ec33e4877366b","modified":1651219285553},{"_id":"public/img/2022-01-24-3.png","hash":"30f86b353805b575ed8516fccb258143fa79d01e","modified":1651219285553},{"_id":"public/img/2022-01-24-1.png","hash":"7cac7a9aef2c512af1e8b8b1cc8a8b20cac94745","modified":1651219285553},{"_id":"public/img/2022-01-24-4.png","hash":"868d8a69b778000e352ab17d22aa72c3b8eed312","modified":1651219285553},{"_id":"public/img/2022-02-22-1.jpeg","hash":"e34dc1856ace7e149c338048fbc92d21d21d8cd1","modified":1651219285553},{"_id":"public/img/2022-02-08-1.jpeg","hash":"3e4ed33f30d6f54d5bf437062ec55c6348a4fc66","modified":1651219285553},{"_id":"public/img/2022-03-07-1.png","hash":"563d429ae97eac009674098dd57517551c37e03f","modified":1651219285553},{"_id":"public/img/2022-01-14-2.png","hash":"1b573758b98a28cb7b9f276413152c4ff826ea38","modified":1651219285553},{"_id":"public/img/2022-03-16-1.png","hash":"3836172c33012b8886c54ed062bc0857e8cca93e","modified":1651219285553},{"_id":"public/img/2022-03-20-1.webp","hash":"f95a32645c06b594bf0e9e8d01cba118f9a6caa8","modified":1651219285553},{"_id":"public/img/2022-04-07-1.png","hash":"22a729b5064126094b4985f989b3f402ed8f1286","modified":1651219285553},{"_id":"public/img/2022-01-24-2.png","hash":"6fa5684418ffd50020153e1173830e3d8ee71327","modified":1651219285553},{"_id":"public/img/2022-02-16-1.jpeg","hash":"c049a498846cbc8d2bf6e45be0b43c97fd3d9edf","modified":1651219285553},{"_id":"public/img/2022-04-29-3.jpeg","hash":"4d75a9a8466fb910f8ede6baaa12ee0fa684e568","modified":1651219285553},{"_id":"public/img/2022-04-29-2.jpeg","hash":"bc1be3edb79e96ea0ba4bcf625ec3abd0d641dc1","modified":1651219285553},{"_id":"public/img/avatar.png","hash":"7ba2b5e584fdcff16ac464c31012e0717df0e154","modified":1651219285553},{"_id":"public/img/miaomiao.JPG","hash":"60b94fd56002070d8be535b35adfef67f0b4be6c","modified":1651219285553},{"_id":"public/img/2022-04-29-1.jpeg","hash":"2f631a9b78b2ea94e7e26abb5e727838294499d7","modified":1651219285553},{"_id":"public/img/2021-12-22-1.png","hash":"023912be2857823f083116c0bb43078f83cb9c2a","modified":1651219285553},{"_id":"public/img/2022-04-18-1.png","hash":"0525d8a00579950752409c5c23d4b046f97ce5f6","modified":1651219285553},{"_id":"public/js/color-schema.js","hash":"f1fdd512f3ef92ff5db4a49f5a3143d5ddea9858","modified":1651219285553},{"_id":"public/js/local-search.js","hash":"633f0142c657805359b0197f287e12ae4bcde731","modified":1651219285553},{"_id":"public/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":1651219285553},{"_id":"public/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":1651219285553},{"_id":"public/js/plugins.js","hash":"d058f30bd09b28769c4d8313428ff23dfc8d52dd","modified":1651219285553},{"_id":"public/js/leancloud.js","hash":"53987b7a668ea0623370eb83ed5311766221b557","modified":1651219285553},{"_id":"public/js/utils.js","hash":"4a43f2700e91937650bef511fd438825b001c4c6","modified":1651219285553},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1651219285553},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1651219285553},{"_id":"public/css/main.css","hash":"63bc59b8ca4b03afa2b93883143c349d461b1052","modified":1651219285553},{"_id":"public/img/index-img.png","hash":"f7314828a14a3e236deecbe33816f99d0f65c5cf","modified":1651219285553},{"_id":"public/img/default.jpg","hash":"d48e1d1c2a174a0286776448c0e74f95aaa5fa5e","modified":1651219285553}],"Category":[{"name":"面试","_id":"cl2k5bv6t00050h3l2lhrav8t"},{"name":"Mobx","_id":"cl2k5bv70000f0h3l2vzd8c2y"},{"name":"JS","_id":"cl2k5bv73000m0h3l8b0vcwfe"},{"name":"webpack","_id":"cl2k5bv77000t0h3ld1e2fhwx"},{"name":"React Hook","_id":"cl2k5bv7800100h3lb464hukr"},{"name":"React","_id":"cl2k5bv7b001c0h3lc8t7e70w"},{"name":"Vue","_id":"cl2k5bv7h002a0h3l1z6uet2p"},{"name":"vscode","_id":"cl2k5bv7i002g0h3l7g3zfgvn"},{"name":"TypeScript","_id":"cl2k5bv7p002y0h3l7r12bttt"}],"Data":[],"Page":[{"title":"about","date":"2022-01-12T15:32:19.000Z","layout":"about","_content":"\n1、关于我\n\n```text\n  前端开发一枚、家有贤妻、女儿奴、有只蓝白，叫喵喵。\n```\n\n2、职业技能\n\n- 前端主流技术栈、框架\n- HTML、CSS、JS、TS\n- React 技术栈\n- Vue 技术栈\n- Node\n- Kubernetes、Docker 简单概念，日常操作, CKA\n\n3、工作状况\n\n- 目前就职于九州云\n- 容器云相关\n\n4、学习计划\n\n- 深入学习 React\n\n5、联系我\n\n- Email: moweiwei6@gmail.com\n- GitHub: https://github.com/moweiwei\n\n6、END\n\n- Stay hungry. Stay foolish.\n- 知人者智，自知者明。胜人者有力，自胜者强。\n\n---\n\n![](/img/miaomiao.JPG)\n\n---\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2022-01-12 23:32:19\nlayout: about\n---\n\n1、关于我\n\n```text\n  前端开发一枚、家有贤妻、女儿奴、有只蓝白，叫喵喵。\n```\n\n2、职业技能\n\n- 前端主流技术栈、框架\n- HTML、CSS、JS、TS\n- React 技术栈\n- Vue 技术栈\n- Node\n- Kubernetes、Docker 简单概念，日常操作, CKA\n\n3、工作状况\n\n- 目前就职于九州云\n- 容器云相关\n\n4、学习计划\n\n- 深入学习 React\n\n5、联系我\n\n- Email: moweiwei6@gmail.com\n- GitHub: https://github.com/moweiwei\n\n6、END\n\n- Stay hungry. Stay foolish.\n- 知人者智，自知者明。胜人者有力，自胜者强。\n\n---\n\n![](/img/miaomiao.JPG)\n\n---\n","updated":"2022-03-01T06:46:34.534Z","path":"about/index.html","comments":1,"_id":"cl2k5bv6c00000h3l10v33x7u","content":"<p>1、关于我</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs text\">前端开发一枚、家有贤妻、女儿奴、有只蓝白，叫喵喵。</code></pre></div>\n\n<p>2、职业技能</p>\n<ul>\n<li>前端主流技术栈、框架</li>\n<li>HTML、CSS、JS、TS</li>\n<li>React 技术栈</li>\n<li>Vue 技术栈</li>\n<li>Node</li>\n<li>Kubernetes、Docker 简单概念，日常操作, CKA</li>\n</ul>\n<p>3、工作状况</p>\n<ul>\n<li>目前就职于九州云</li>\n<li>容器云相关</li>\n</ul>\n<p>4、学习计划</p>\n<ul>\n<li>深入学习 React</li>\n</ul>\n<p>5、联系我</p>\n<ul>\n<li>Email: <a href=\"mailto:&#x6d;&#111;&#119;&#x65;&#105;&#x77;&#x65;&#x69;&#54;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;\">&#x6d;&#111;&#119;&#x65;&#105;&#x77;&#x65;&#x69;&#54;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;</a></li>\n<li>GitHub: <a href=\"https://github.com/moweiwei\">https://github.com/moweiwei</a></li>\n</ul>\n<p>6、END</p>\n<ul>\n<li>Stay hungry. Stay foolish.</li>\n<li>知人者智，自知者明。胜人者有力，自胜者强。</li>\n</ul>\n<hr>\n<p><img src=\"/img/miaomiao.JPG\"></p>\n<hr>\n","site":{"data":{}},"wordcount":347,"excerpt":"","more":"<p>1、关于我</p>\n<pre><code class=\"hljs text\">前端开发一枚、家有贤妻、女儿奴、有只蓝白，叫喵喵。</code></pre>\n\n<p>2、职业技能</p>\n<ul>\n<li>前端主流技术栈、框架</li>\n<li>HTML、CSS、JS、TS</li>\n<li>React 技术栈</li>\n<li>Vue 技术栈</li>\n<li>Node</li>\n<li>Kubernetes、Docker 简单概念，日常操作, CKA</li>\n</ul>\n<p>3、工作状况</p>\n<ul>\n<li>目前就职于九州云</li>\n<li>容器云相关</li>\n</ul>\n<p>4、学习计划</p>\n<ul>\n<li>深入学习 React</li>\n</ul>\n<p>5、联系我</p>\n<ul>\n<li>Email: <a href=\"mailto:&#x6d;&#111;&#119;&#x65;&#105;&#x77;&#x65;&#x69;&#54;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;\">&#x6d;&#111;&#119;&#x65;&#105;&#x77;&#x65;&#x69;&#54;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;</a></li>\n<li>GitHub: <a href=\"https://github.com/moweiwei\">https://github.com/moweiwei</a></li>\n</ul>\n<p>6、END</p>\n<ul>\n<li>Stay hungry. Stay foolish.</li>\n<li>知人者智，自知者明。胜人者有力，自胜者强。</li>\n</ul>\n<hr>\n<p><img src=\"/img/miaomiao.JPG\"></p>\n<hr>\n"},{"_content":"/* 代码块折叠 */\nfigure.highlight {\n  background: #21252b;\n  border-radius: 0.5rem;\n}\nfigure.highlight table {\n  border-radius: 0 0 0.5rem 0.5rem;\n}\nfigure.highlight > i {\n  color: #777;\n  margin-left: 10px;\n  line-height: 2rem;\n  transform: rotate(90deg);\n  transition: transform 0.2s ease-in-out;\n}\nfigure.highlight > i.collapsed {\n  transform: rotate(0deg);\n}\nfigure.highlight > span {\n  color: #777;\n  margin-left: 5px;\n  font-size: 0.875rem;\n}\nfigure.highlight td:first-child {\n  position: sticky;\n  left: 0;\n  z-index: 1;\n}\nfigure.highlight > i:before {\n  content: \"\\f2c3\";\n}\n\n/* 复制 */\n.copy-btn {\n  top: 5px;\n  font-size: 0.875rem;\n}\n.copy-btn > i {\n  font-size: 0.875rem;\n}\n.copy-btn-dark {\n  color: #2f4f4f;\n}\n","source":"css/custom.css","raw":"/* 代码块折叠 */\nfigure.highlight {\n  background: #21252b;\n  border-radius: 0.5rem;\n}\nfigure.highlight table {\n  border-radius: 0 0 0.5rem 0.5rem;\n}\nfigure.highlight > i {\n  color: #777;\n  margin-left: 10px;\n  line-height: 2rem;\n  transform: rotate(90deg);\n  transition: transform 0.2s ease-in-out;\n}\nfigure.highlight > i.collapsed {\n  transform: rotate(0deg);\n}\nfigure.highlight > span {\n  color: #777;\n  margin-left: 5px;\n  font-size: 0.875rem;\n}\nfigure.highlight td:first-child {\n  position: sticky;\n  left: 0;\n  z-index: 1;\n}\nfigure.highlight > i:before {\n  content: \"\\f2c3\";\n}\n\n/* 复制 */\n.copy-btn {\n  top: 5px;\n  font-size: 0.875rem;\n}\n.copy-btn > i {\n  font-size: 0.875rem;\n}\n.copy-btn-dark {\n  color: #2f4f4f;\n}\n","date":"2022-02-25T06:56:54.842Z","updated":"2022-02-25T06:56:54.842Z","path":"css/custom.css","layout":"false","title":"","comments":1,"_id":"cl2k5bv6o00010h3lel2g9t4z","content":"/* 代码块折叠 */\nfigure.highlight {\n  background: #21252b;\n  border-radius: 0.5rem;\n}\nfigure.highlight table {\n  border-radius: 0 0 0.5rem 0.5rem;\n}\nfigure.highlight > i {\n  color: #777;\n  margin-left: 10px;\n  line-height: 2rem;\n  transform: rotate(90deg);\n  transition: transform 0.2s ease-in-out;\n}\nfigure.highlight > i.collapsed {\n  transform: rotate(0deg);\n}\nfigure.highlight > span {\n  color: #777;\n  margin-left: 5px;\n  font-size: 0.875rem;\n}\nfigure.highlight td:first-child {\n  position: sticky;\n  left: 0;\n  z-index: 1;\n}\nfigure.highlight > i:before {\n  content: \"\\f2c3\";\n}\n\n/* 复制 */\n.copy-btn {\n  top: 5px;\n  font-size: 0.875rem;\n}\n.copy-btn > i {\n  font-size: 0.875rem;\n}\n.copy-btn-dark {\n  color: #2f4f4f;\n}\n","site":{"data":{}},"wordcount":580,"excerpt":"","more":"/* 代码块折叠 */\nfigure.highlight {\n  background: #21252b;\n  border-radius: 0.5rem;\n}\nfigure.highlight table {\n  border-radius: 0 0 0.5rem 0.5rem;\n}\nfigure.highlight > i {\n  color: #777;\n  margin-left: 10px;\n  line-height: 2rem;\n  transform: rotate(90deg);\n  transition: transform 0.2s ease-in-out;\n}\nfigure.highlight > i.collapsed {\n  transform: rotate(0deg);\n}\nfigure.highlight > span {\n  color: #777;\n  margin-left: 5px;\n  font-size: 0.875rem;\n}\nfigure.highlight td:first-child {\n  position: sticky;\n  left: 0;\n  z-index: 1;\n}\nfigure.highlight > i:before {\n  content: \"\\f2c3\";\n}\n\n/* 复制 */\n.copy-btn {\n  top: 5px;\n  font-size: 0.875rem;\n}\n.copy-btn > i {\n  font-size: 0.875rem;\n}\n.copy-btn-dark {\n  color: #2f4f4f;\n}\n"},{"_content":"// 代码语言标准形式（这里应该有更合理的解决方式，但是我不会写）\nvar code_language = {\n  txt: \"\",\n  md: \"Markdown\",\n  markdwon: \"Markdown\",\n\n  yml: \"YAML\",\n  yaml: \"YAML\",\n  json: \"JSON\",\n\n  xml: \"XML\",\n  html: \"HTML\",\n  css: \"CSS\",\n  styl: \"Stylus\",\n  stylus: \"Stylus\",\n\n  js: \"JavaScript\",\n  javascript: \"JavaScript\",\n  ts: \"TypeScript\",\n  typescript: \"TypeScript\",\n  py: \"Python\",\n  python: \"Python\",\n\n  c: \"C\",\n  \"c++\": \"C++\",\n  cpp: \"C++\",\n  cxx: \"C++\",\n  \"c#\": \"C#\",\n  cs: \"C#\",\n  csharp: \"C#\",\n  java: \"Java\"\n};\n\n// 代码语言格式化\nfunction getLanguage(lang) {\n  var lang_lower = lang.toLowerCase();\n  return lang_lower in code_language ? code_language[lang_lower] : lang;\n}\n\n// 获取唯一 ID\nfunction getUuiD() {\n  return Math.random().toString(36).substring(2, 8) + Date.now().toString(36);\n}\n\nfunction addLanguage() {\n  // 获取所有 figure.highlight 元素\n  var hs = $(\"figure.highlight\");\n  for (var i = 0; i < hs.length; i++) {\n    // 获取代码语言\n    var lang = hs[i].firstChild.firstChild.firstChild.lastChild.firstChild.firstChild.firstChild.classList[1];\n\n    // 折叠块的 id\n    var id = `kiyan-collapse-${getUuiD()}`;\n    // 前面折叠按钮，这里我使用了 FAS 图标\n    // 注意：这里是 bootstrap 的 collapse 功能的简略代码，使用时会自动补全，补全后的 HTML 可以通过浏览器 F12 查看，此外也可查看官方文档\n    var btn = `<i class=\"iconfont .icon-arrowdown\" type=\"button\" data-toggle=\"collapse\" data-target=\"#${id}\"></i>`;\n    // 代码语言\n    var span = `<span>${getLanguage(lang)}</span>`;\n    // 折叠块包裹原来的内容\n    var div = `<div class=\"collapse show\" id=\"${id}\">${hs[i].innerHTML}</div>`;\n    hs[i].innerHTML = btn + span + div;\n  }\n}\n\nfunction init() {\n  addLanguage();\n}\n\n$(document).ready(init);\n","source":"js/custom.js","raw":"// 代码语言标准形式（这里应该有更合理的解决方式，但是我不会写）\nvar code_language = {\n  txt: \"\",\n  md: \"Markdown\",\n  markdwon: \"Markdown\",\n\n  yml: \"YAML\",\n  yaml: \"YAML\",\n  json: \"JSON\",\n\n  xml: \"XML\",\n  html: \"HTML\",\n  css: \"CSS\",\n  styl: \"Stylus\",\n  stylus: \"Stylus\",\n\n  js: \"JavaScript\",\n  javascript: \"JavaScript\",\n  ts: \"TypeScript\",\n  typescript: \"TypeScript\",\n  py: \"Python\",\n  python: \"Python\",\n\n  c: \"C\",\n  \"c++\": \"C++\",\n  cpp: \"C++\",\n  cxx: \"C++\",\n  \"c#\": \"C#\",\n  cs: \"C#\",\n  csharp: \"C#\",\n  java: \"Java\"\n};\n\n// 代码语言格式化\nfunction getLanguage(lang) {\n  var lang_lower = lang.toLowerCase();\n  return lang_lower in code_language ? code_language[lang_lower] : lang;\n}\n\n// 获取唯一 ID\nfunction getUuiD() {\n  return Math.random().toString(36).substring(2, 8) + Date.now().toString(36);\n}\n\nfunction addLanguage() {\n  // 获取所有 figure.highlight 元素\n  var hs = $(\"figure.highlight\");\n  for (var i = 0; i < hs.length; i++) {\n    // 获取代码语言\n    var lang = hs[i].firstChild.firstChild.firstChild.lastChild.firstChild.firstChild.firstChild.classList[1];\n\n    // 折叠块的 id\n    var id = `kiyan-collapse-${getUuiD()}`;\n    // 前面折叠按钮，这里我使用了 FAS 图标\n    // 注意：这里是 bootstrap 的 collapse 功能的简略代码，使用时会自动补全，补全后的 HTML 可以通过浏览器 F12 查看，此外也可查看官方文档\n    var btn = `<i class=\"iconfont .icon-arrowdown\" type=\"button\" data-toggle=\"collapse\" data-target=\"#${id}\"></i>`;\n    // 代码语言\n    var span = `<span>${getLanguage(lang)}</span>`;\n    // 折叠块包裹原来的内容\n    var div = `<div class=\"collapse show\" id=\"${id}\">${hs[i].innerHTML}</div>`;\n    hs[i].innerHTML = btn + span + div;\n  }\n}\n\nfunction init() {\n  addLanguage();\n}\n\n$(document).ready(init);\n","date":"2022-03-07T10:02:48.657Z","updated":"2022-03-07T10:02:48.657Z","path":"js/custom.js","layout":"false","title":"","comments":1,"_id":"cl2k5bv6s00030h3lebjxgrvt","content":"// 代码语言标准形式（这里应该有更合理的解决方式，但是我不会写）\nvar code_language = {\n  txt: \"\",\n  md: \"Markdown\",\n  markdwon: \"Markdown\",\n\n  yml: \"YAML\",\n  yaml: \"YAML\",\n  json: \"JSON\",\n\n  xml: \"XML\",\n  html: \"HTML\",\n  css: \"CSS\",\n  styl: \"Stylus\",\n  stylus: \"Stylus\",\n\n  js: \"JavaScript\",\n  javascript: \"JavaScript\",\n  ts: \"TypeScript\",\n  typescript: \"TypeScript\",\n  py: \"Python\",\n  python: \"Python\",\n\n  c: \"C\",\n  \"c++\": \"C++\",\n  cpp: \"C++\",\n  cxx: \"C++\",\n  \"c#\": \"C#\",\n  cs: \"C#\",\n  csharp: \"C#\",\n  java: \"Java\"\n};\n\n// 代码语言格式化\nfunction getLanguage(lang) {\n  var lang_lower = lang.toLowerCase();\n  return lang_lower in code_language ? code_language[lang_lower] : lang;\n}\n\n// 获取唯一 ID\nfunction getUuiD() {\n  return Math.random().toString(36).substring(2, 8) + Date.now().toString(36);\n}\n\nfunction addLanguage() {\n  // 获取所有 figure.highlight 元素\n  var hs = $(\"figure.highlight\");\n  for (var i = 0; i < hs.length; i++) {\n    // 获取代码语言\n    var lang = hs[i].firstChild.firstChild.firstChild.lastChild.firstChild.firstChild.firstChild.classList[1];\n\n    // 折叠块的 id\n    var id = `kiyan-collapse-${getUuiD()}`;\n    // 前面折叠按钮，这里我使用了 FAS 图标\n    // 注意：这里是 bootstrap 的 collapse 功能的简略代码，使用时会自动补全，补全后的 HTML 可以通过浏览器 F12 查看，此外也可查看官方文档\n    var btn = `<i class=\"iconfont .icon-arrowdown\" type=\"button\" data-toggle=\"collapse\" data-target=\"#${id}\"></i>`;\n    // 代码语言\n    var span = `<span>${getLanguage(lang)}</span>`;\n    // 折叠块包裹原来的内容\n    var div = `<div class=\"collapse show\" id=\"${id}\">${hs[i].innerHTML}</div>`;\n    hs[i].innerHTML = btn + span + div;\n  }\n}\n\nfunction init() {\n  addLanguage();\n}\n\n$(document).ready(init);\n","site":{"data":{}},"wordcount":1131,"excerpt":"","more":"// 代码语言标准形式（这里应该有更合理的解决方式，但是我不会写）\nvar code_language = {\n  txt: \"\",\n  md: \"Markdown\",\n  markdwon: \"Markdown\",\n\n  yml: \"YAML\",\n  yaml: \"YAML\",\n  json: \"JSON\",\n\n  xml: \"XML\",\n  html: \"HTML\",\n  css: \"CSS\",\n  styl: \"Stylus\",\n  stylus: \"Stylus\",\n\n  js: \"JavaScript\",\n  javascript: \"JavaScript\",\n  ts: \"TypeScript\",\n  typescript: \"TypeScript\",\n  py: \"Python\",\n  python: \"Python\",\n\n  c: \"C\",\n  \"c++\": \"C++\",\n  cpp: \"C++\",\n  cxx: \"C++\",\n  \"c#\": \"C#\",\n  cs: \"C#\",\n  csharp: \"C#\",\n  java: \"Java\"\n};\n\n// 代码语言格式化\nfunction getLanguage(lang) {\n  var lang_lower = lang.toLowerCase();\n  return lang_lower in code_language ? code_language[lang_lower] : lang;\n}\n\n// 获取唯一 ID\nfunction getUuiD() {\n  return Math.random().toString(36).substring(2, 8) + Date.now().toString(36);\n}\n\nfunction addLanguage() {\n  // 获取所有 figure.highlight 元素\n  var hs = $(\"figure.highlight\");\n  for (var i = 0; i < hs.length; i++) {\n    // 获取代码语言\n    var lang = hs[i].firstChild.firstChild.firstChild.lastChild.firstChild.firstChild.firstChild.classList[1];\n\n    // 折叠块的 id\n    var id = `kiyan-collapse-${getUuiD()}`;\n    // 前面折叠按钮，这里我使用了 FAS 图标\n    // 注意：这里是 bootstrap 的 collapse 功能的简略代码，使用时会自动补全，补全后的 HTML 可以通过浏览器 F12 查看，此外也可查看官方文档\n    var btn = `<i class=\"iconfont .icon-arrowdown\" type=\"button\" data-toggle=\"collapse\" data-target=\"#${id}\"></i>`;\n    // 代码语言\n    var span = `<span>${getLanguage(lang)}</span>`;\n    // 折叠块包裹原来的内容\n    var div = `<div class=\"collapse show\" id=\"${id}\">${hs[i].innerHTML}</div>`;\n    hs[i].innerHTML = btn + span + div;\n  }\n}\n\nfunction init() {\n  addLanguage();\n}\n\n$(document).ready(init);\n"}],"Post":[{"title":"实习生前端工程师面试题","index_img":"/img/2022-02-22-1.jpeg","date":"2022-02-22T10:03:22.000Z","_content":"\n\n## CSS\n\n- 介绍下 BFC 及其应用\n\n  BFC（Block Format Context）块级格式化上下文，是页面盒模型中的一种 `CSS` 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。\n\n  创建 `BFC` 的方式有：\n\n  1. `html` 根元素\n  2. `float` 浮动\n  3. 绝对定位\n  4. `overflow` 不为 `visible`\n  5. `display` 为表格布局或者弹性布局；\n\n  `BFC` 主要的作用是：\n\n  1. 清除浮动\n  2. 防止同一 `BFC` 容器中的相邻元素间的外边距重叠问题\n\n- 怎么让一个 div 水平垂直居中？\n\n  ```html\n  <div class=\"parent\">\n    <div class=\"child\"></div>\n  </div>\n  ```\n\n  ```css\n  <!-- 1 -->\n  div.parent {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n  <!-- 2 -->\n  div.parent {\n    position: relative;\n  }\n  div.child {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%);\n  }\n  <!-- 3 -->\n  div.parent {\n    display: grid;\n  }\n  div.child {\n    justify-self: center;\n    align-self: center;\n  }\n  <!-- 4 -->\n  div.parent {\n    font-size: 0;\n    text-align: center;\n    &::before {\n      content: \"\";\n      display: inline-block;\n      width: 0;\n      height: 100%;\n      vertical-align: middle;\n    }\n  }\n  div.child {\n    display: inline-block;\n    vertical-align: middle;\n  }\n  ```\n\n- 简述 Rem 及其转换原理\n\n  `rem` 是 CSS3 新增的相对长度单位，是指相对于根元素 `html` 的 `font-size` 计算值的大小。\n\n  默认根元素的 `font-size` 都是 `16px`的。如果想要设置 `12px` 的字体大小也就是 `12px/16px = 0.75rem`。\n\n  - 由于 `px` 是相对固定单位，字号大小直接被定死，无法随着浏览器进行缩放；\n  - `rem` 直接相对于根元素 `html`，避开层级关系，移动端新型浏览器对其支持较好；\n\n  个人用 `vw` + 百分比布局用的比较多，可以使用 `webpack` 的 `postcss-loader` 的一个插件 `postcss-px-to-viewport` 实现对 `px` 到 `vw` 的自动转换，非常适合开发。\n\n- 简述伪类和伪元素\n\n  - 伪类\n\n  伪类用于当已有元素处于某种状态时，为其添加对应的样式，这个状态是根据用户行为变化而变化的。比如说 `:hover`。它只有处于 dom 树无法描述的状态才能为元素添加样式，所以称为伪类。\n\n  -  伪元素\n\n  伪元素用于创建一些原本不在文档树中的元素，并为其添加样式，比如说 `::before`。虽然用户可以看到这些内容，但是其实他不在文档树中。\n\n\n  - 区别\n\n  伪类的操作对象是文档树中已存在的元素，而伪元素是创建一个文档树外的元素。\n\n  css 规范中用双冒号 `::` 表示伪元素，用一个冒号 `:` 表示伪类。\n\n## JS\n\n### JS 中数据类型有哪些？\n\n数值（number）、字符串（string）、布尔值（boolean）、undefined、null、对象（object）\n\n","source":"_drafts/0.实习生前端工程师面试题.md","raw":"---\ntitle: 实习生前端工程师面试题\nindex_img: /img/2022-02-22-1.jpeg\ndate: 2022-02-22 18:03:22\ntags: 前端实习生\ncategories: 面试\n---\n\n\n## CSS\n\n- 介绍下 BFC 及其应用\n\n  BFC（Block Format Context）块级格式化上下文，是页面盒模型中的一种 `CSS` 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。\n\n  创建 `BFC` 的方式有：\n\n  1. `html` 根元素\n  2. `float` 浮动\n  3. 绝对定位\n  4. `overflow` 不为 `visible`\n  5. `display` 为表格布局或者弹性布局；\n\n  `BFC` 主要的作用是：\n\n  1. 清除浮动\n  2. 防止同一 `BFC` 容器中的相邻元素间的外边距重叠问题\n\n- 怎么让一个 div 水平垂直居中？\n\n  ```html\n  <div class=\"parent\">\n    <div class=\"child\"></div>\n  </div>\n  ```\n\n  ```css\n  <!-- 1 -->\n  div.parent {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n  <!-- 2 -->\n  div.parent {\n    position: relative;\n  }\n  div.child {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%);\n  }\n  <!-- 3 -->\n  div.parent {\n    display: grid;\n  }\n  div.child {\n    justify-self: center;\n    align-self: center;\n  }\n  <!-- 4 -->\n  div.parent {\n    font-size: 0;\n    text-align: center;\n    &::before {\n      content: \"\";\n      display: inline-block;\n      width: 0;\n      height: 100%;\n      vertical-align: middle;\n    }\n  }\n  div.child {\n    display: inline-block;\n    vertical-align: middle;\n  }\n  ```\n\n- 简述 Rem 及其转换原理\n\n  `rem` 是 CSS3 新增的相对长度单位，是指相对于根元素 `html` 的 `font-size` 计算值的大小。\n\n  默认根元素的 `font-size` 都是 `16px`的。如果想要设置 `12px` 的字体大小也就是 `12px/16px = 0.75rem`。\n\n  - 由于 `px` 是相对固定单位，字号大小直接被定死，无法随着浏览器进行缩放；\n  - `rem` 直接相对于根元素 `html`，避开层级关系，移动端新型浏览器对其支持较好；\n\n  个人用 `vw` + 百分比布局用的比较多，可以使用 `webpack` 的 `postcss-loader` 的一个插件 `postcss-px-to-viewport` 实现对 `px` 到 `vw` 的自动转换，非常适合开发。\n\n- 简述伪类和伪元素\n\n  - 伪类\n\n  伪类用于当已有元素处于某种状态时，为其添加对应的样式，这个状态是根据用户行为变化而变化的。比如说 `:hover`。它只有处于 dom 树无法描述的状态才能为元素添加样式，所以称为伪类。\n\n  -  伪元素\n\n  伪元素用于创建一些原本不在文档树中的元素，并为其添加样式，比如说 `::before`。虽然用户可以看到这些内容，但是其实他不在文档树中。\n\n\n  - 区别\n\n  伪类的操作对象是文档树中已存在的元素，而伪元素是创建一个文档树外的元素。\n\n  css 规范中用双冒号 `::` 表示伪元素，用一个冒号 `:` 表示伪类。\n\n## JS\n\n### JS 中数据类型有哪些？\n\n数值（number）、字符串（string）、布尔值（boolean）、undefined、null、对象（object）\n\n","slug":"0-实习生前端工程师面试题","published":0,"updated":"2022-03-02T02:02:40.709Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k5bv6p00020h3l10748t2d","content":"<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><ul>\n<li><p>介绍下 BFC 及其应用</p>\n<p>BFC（Block Format Context）块级格式化上下文，是页面盒模型中的一种 <code>CSS</code> 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。</p>\n<p>创建 <code>BFC</code> 的方式有：</p>\n<ol>\n<li><code>html</code> 根元素</li>\n<li><code>float</code> 浮动</li>\n<li>绝对定位</li>\n<li><code>overflow</code> 不为 <code>visible</code></li>\n<li><code>display</code> 为表格布局或者弹性布局；</li>\n</ol>\n<p><code>BFC</code> 主要的作用是：</p>\n<ol>\n<li>清除浮动</li>\n<li>防止同一 <code>BFC</code> 容器中的相邻元素间的外边距重叠问题</li>\n</ol>\n</li>\n<li><p>怎么让一个 div 水平垂直居中？</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;parent&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;child&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre></div>\n\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs css\">&lt;!-- <span class=\"hljs-number\">1</span> --&gt;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;\n  <span class=\"hljs-attribute\">display</span>: flex;\n  <span class=\"hljs-attribute\">justify-content</span>: center;\n  <span class=\"hljs-attribute\">align-items</span>: center;\n&#125;\n&lt;!-- <span class=\"hljs-number\">2</span> --&gt;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;\n  <span class=\"hljs-attribute\">position</span>: relative;\n&#125;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.child</span> &#123;\n  <span class=\"hljs-attribute\">position</span>: absolute;\n  <span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">50%</span>;\n  <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">50%</span>;\n  <span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-built_in\">translate</span>(-<span class=\"hljs-number\">50%</span>, -<span class=\"hljs-number\">50%</span>);\n&#125;\n&lt;!-- <span class=\"hljs-number\">3</span> --&gt;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;\n  <span class=\"hljs-attribute\">display</span>: grid;\n&#125;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.child</span> &#123;\n  justify-self: center;\n  <span class=\"hljs-attribute\">align-self</span>: center;\n&#125;\n&lt;!-- <span class=\"hljs-number\">4</span> --&gt;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;\n  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-attribute\">text-align</span>: center;\n  &amp;<span class=\"hljs-selector-pseudo\">::before</span> &#123;\n    <span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">&quot;&quot;</span>;\n    <span class=\"hljs-attribute\">display</span>: inline-block;\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100%</span>;\n    <span class=\"hljs-attribute\">vertical-align</span>: middle;\n  &#125;\n&#125;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.child</span> &#123;\n  <span class=\"hljs-attribute\">display</span>: inline-block;\n  <span class=\"hljs-attribute\">vertical-align</span>: middle;\n&#125;</code></pre></div></li>\n<li><p>简述 Rem 及其转换原理</p>\n<p><code>rem</code> 是 CSS3 新增的相对长度单位，是指相对于根元素 <code>html</code> 的 <code>font-size</code> 计算值的大小。</p>\n<p>默认根元素的 <code>font-size</code> 都是 <code>16px</code>的。如果想要设置 <code>12px</code> 的字体大小也就是 <code>12px/16px = 0.75rem</code>。</p>\n<ul>\n<li>由于 <code>px</code> 是相对固定单位，字号大小直接被定死，无法随着浏览器进行缩放；</li>\n<li><code>rem</code> 直接相对于根元素 <code>html</code>，避开层级关系，移动端新型浏览器对其支持较好；</li>\n</ul>\n<p>个人用 <code>vw</code> + 百分比布局用的比较多，可以使用 <code>webpack</code> 的 <code>postcss-loader</code> 的一个插件 <code>postcss-px-to-viewport</code> 实现对 <code>px</code> 到 <code>vw</code> 的自动转换，非常适合开发。</p>\n</li>\n<li><p>简述伪类和伪元素</p>\n<ul>\n<li>伪类</li>\n</ul>\n<p>伪类用于当已有元素处于某种状态时，为其添加对应的样式，这个状态是根据用户行为变化而变化的。比如说 <code>:hover</code>。它只有处于 dom 树无法描述的状态才能为元素添加样式，所以称为伪类。</p>\n<ul>\n<li> 伪元素</li>\n</ul>\n<p>伪元素用于创建一些原本不在文档树中的元素，并为其添加样式，比如说 <code>::before</code>。虽然用户可以看到这些内容，但是其实他不在文档树中。</p>\n</li>\n</ul>\n<ul>\n<li>区别</li>\n</ul>\n<p>  伪类的操作对象是文档树中已存在的元素，而伪元素是创建一个文档树外的元素。</p>\n<p>  css 规范中用双冒号 <code>::</code> 表示伪元素，用一个冒号 <code>:</code> 表示伪类。</p>\n<h2 id=\"JS\"><a href=\"#JS\" class=\"headerlink\" title=\"JS\"></a>JS</h2><h3 id=\"JS-中数据类型有哪些？\"><a href=\"#JS-中数据类型有哪些？\" class=\"headerlink\" title=\"JS 中数据类型有哪些？\"></a>JS 中数据类型有哪些？</h3><p>数值（number）、字符串（string）、布尔值（boolean）、undefined、null、对象（object）</p>\n","site":{"data":{}},"wordcount":1468,"excerpt":"","more":"<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><ul>\n<li><p>介绍下 BFC 及其应用</p>\n<p>BFC（Block Format Context）块级格式化上下文，是页面盒模型中的一种 <code>CSS</code> 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。</p>\n<p>创建 <code>BFC</code> 的方式有：</p>\n<ol>\n<li><code>html</code> 根元素</li>\n<li><code>float</code> 浮动</li>\n<li>绝对定位</li>\n<li><code>overflow</code> 不为 <code>visible</code></li>\n<li><code>display</code> 为表格布局或者弹性布局；</li>\n</ol>\n<p><code>BFC</code> 主要的作用是：</p>\n<ol>\n<li>清除浮动</li>\n<li>防止同一 <code>BFC</code> 容器中的相邻元素间的外边距重叠问题</li>\n</ol>\n</li>\n<li><p>怎么让一个 div 水平垂直居中？</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;parent&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;child&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n\n<pre><code class=\"hljs css\">&lt;!-- <span class=\"hljs-number\">1</span> --&gt;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;\n  <span class=\"hljs-attribute\">display</span>: flex;\n  <span class=\"hljs-attribute\">justify-content</span>: center;\n  <span class=\"hljs-attribute\">align-items</span>: center;\n&#125;\n&lt;!-- <span class=\"hljs-number\">2</span> --&gt;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;\n  <span class=\"hljs-attribute\">position</span>: relative;\n&#125;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.child</span> &#123;\n  <span class=\"hljs-attribute\">position</span>: absolute;\n  <span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">50%</span>;\n  <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">50%</span>;\n  <span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-built_in\">translate</span>(-<span class=\"hljs-number\">50%</span>, -<span class=\"hljs-number\">50%</span>);\n&#125;\n&lt;!-- <span class=\"hljs-number\">3</span> --&gt;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;\n  <span class=\"hljs-attribute\">display</span>: grid;\n&#125;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.child</span> &#123;\n  justify-self: center;\n  <span class=\"hljs-attribute\">align-self</span>: center;\n&#125;\n&lt;!-- <span class=\"hljs-number\">4</span> --&gt;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;\n  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-attribute\">text-align</span>: center;\n  &amp;<span class=\"hljs-selector-pseudo\">::before</span> &#123;\n    <span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">&quot;&quot;</span>;\n    <span class=\"hljs-attribute\">display</span>: inline-block;\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100%</span>;\n    <span class=\"hljs-attribute\">vertical-align</span>: middle;\n  &#125;\n&#125;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.child</span> &#123;\n  <span class=\"hljs-attribute\">display</span>: inline-block;\n  <span class=\"hljs-attribute\">vertical-align</span>: middle;\n&#125;</code></pre></li>\n<li><p>简述 Rem 及其转换原理</p>\n<p><code>rem</code> 是 CSS3 新增的相对长度单位，是指相对于根元素 <code>html</code> 的 <code>font-size</code> 计算值的大小。</p>\n<p>默认根元素的 <code>font-size</code> 都是 <code>16px</code>的。如果想要设置 <code>12px</code> 的字体大小也就是 <code>12px/16px = 0.75rem</code>。</p>\n<ul>\n<li>由于 <code>px</code> 是相对固定单位，字号大小直接被定死，无法随着浏览器进行缩放；</li>\n<li><code>rem</code> 直接相对于根元素 <code>html</code>，避开层级关系，移动端新型浏览器对其支持较好；</li>\n</ul>\n<p>个人用 <code>vw</code> + 百分比布局用的比较多，可以使用 <code>webpack</code> 的 <code>postcss-loader</code> 的一个插件 <code>postcss-px-to-viewport</code> 实现对 <code>px</code> 到 <code>vw</code> 的自动转换，非常适合开发。</p>\n</li>\n<li><p>简述伪类和伪元素</p>\n<ul>\n<li>伪类</li>\n</ul>\n<p>伪类用于当已有元素处于某种状态时，为其添加对应的样式，这个状态是根据用户行为变化而变化的。比如说 <code>:hover</code>。它只有处于 dom 树无法描述的状态才能为元素添加样式，所以称为伪类。</p>\n<ul>\n<li> 伪元素</li>\n</ul>\n<p>伪元素用于创建一些原本不在文档树中的元素，并为其添加样式，比如说 <code>::before</code>。虽然用户可以看到这些内容，但是其实他不在文档树中。</p>\n</li>\n</ul>\n<ul>\n<li>区别</li>\n</ul>\n<p>  伪类的操作对象是文档树中已存在的元素，而伪元素是创建一个文档树外的元素。</p>\n<p>  css 规范中用双冒号 <code>::</code> 表示伪元素，用一个冒号 <code>:</code> 表示伪类。</p>\n<h2 id=\"JS\"><a href=\"#JS\" class=\"headerlink\" title=\"JS\"></a>JS</h2><h3 id=\"JS-中数据类型有哪些？\"><a href=\"#JS-中数据类型有哪些？\" class=\"headerlink\" title=\"JS 中数据类型有哪些？\"></a>JS 中数据类型有哪些？</h3><p>数值（number）、字符串（string）、布尔值（boolean）、undefined、null、对象（object）</p>\n"},{"title":"1","index_img":"/img/index-img.png","date":"2022-04-18T02:12:38.000Z","_content":"\n## 面试题\n\n- [面试分享：两年工作经验成功面试阿里P6总结](https://juejin.cn/post/6844903928442667015)\n- [在阿里我是如何当面试官的](https://juejin.cn/post/6844904093425598471#heading-39)\n","source":"_drafts/3.优秀文章合集.md","raw":"---\ntitle: 1\nindex_img: /img/index-img.png\ndate: 2022-04-18 10:12:38\ntags:\ncategories:\n---\n\n## 面试题\n\n- [面试分享：两年工作经验成功面试阿里P6总结](https://juejin.cn/post/6844903928442667015)\n- [在阿里我是如何当面试官的](https://juejin.cn/post/6844904093425598471#heading-39)\n","slug":"3-优秀文章合集","published":0,"updated":"2022-04-18T02:21:59.205Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k5bv6s00040h3l7qsth5pn","content":"<h2 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h2><ul>\n<li><a href=\"https://juejin.cn/post/6844903928442667015\">面试分享：两年工作经验成功面试阿里P6总结</a></li>\n<li><a href=\"https://juejin.cn/post/6844904093425598471#heading-39\">在阿里我是如何当面试官的</a></li>\n</ul>\n","site":{"data":{}},"wordcount":36,"excerpt":"","more":"<h2 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h2><ul>\n<li><a href=\"https://juejin.cn/post/6844903928442667015\">面试分享：两年工作经验成功面试阿里P6总结</a></li>\n<li><a href=\"https://juejin.cn/post/6844904093425598471#heading-39\">在阿里我是如何当面试官的</a></li>\n</ul>\n"},{"title":"大厂面试题","index_img":"/img/2022-03-07-1.png","abbrlink":"83dcefb7","date":"2022-03-07T07:52:23.000Z","_content":"\n腾讯\n一面\n1. 写一个 LRU 缓存函数\n2. 写个防抖和节流函数\n3. 你们服务是怎么部署的?Node Agent 做了什么工作?\n4. Grpc 的优缺点?\n5. http2 的相关特性?\n6. viewport 和移动端布局方案\n7. 实现一个 compose 函数\n8. 开发中有遇到过比较难定位的问题吗?Node 内存泄露有遇到过 吗?\n二面\n1. react ssr 是在什么场景下做的?\n2. react ssr 双端怎么做构建的?区别在哪里?\n3. 有没有做过同构组件?服务端和客户端怎么同步状态的?\n4. render 和 renderToString 的底层实现上的区别?\n5. 客户端怎么处理 JS 事件失效的问题?客户端不重新加载 JS 的 情况下怎么实现?\n6. 做服务端渲染的时候有没有遇到过比较难的点?\n7. react ssr 和 ejs 性能的差异?\n8. 服务回滚是怎么做的?上线流程是怎样的?k8s 回滚、拉取以前的 镜像\n9. webpack plugin 的原理是什么?\n10. plugin 中有异步请求会阻塞后面的 plugin 吗?\n11.做过哪些 webpack 的性能优化?\n12. hard-source-webpack-plugin 是怎么做缓存的?修改文件后会 怎么样?\n13. parallel 的原理是什么?多个子进程怎么通信?\n14.你们 webpack 是怎么做拆包的? \n15.服务端监控是怎么做的?服务有上报过什么指标?\n16. Node 服务怎么去定位 CPU 占用暴涨的情况?怎么去定位内存泄\n露?\n17.编写 grpc 服务和 http 服务的区别?\n18.做过哪些 react 相关的优化?函数组件怎么实现 shouldComponentUpdate?\n19.如果有一个非常大的 react 页面，我想优先渲染某一部分，这该怎 么做?\n20. react 函数组件和 class 组件里面 state 的区别?\n21. react useEffect 对应 class 组件的哪些生命周期? 22.前端的监控是怎么做的?除了 sentry 还做了其他异常处理吗?\n三面\n1. 讲一下你做的比较复杂的项目?以及你在项目中担当了什么角色?\n2. 你是怎么看待现在各种造轮子的?\n3. 有一个一亿长度的字符串，怎么存储设计可以让它更好去查询、修\n改?\n4. 怎么优化 H5 让它可以在 300ms 之内打开?\n5. 你们 WebView 加载一般耗时多久?\n6. 你们为什么从 Python 重构到 Node?好处是什么?\n \n7. 你是怎么看待做后台管理系统的?很多人觉得它没有难点，你觉得 呢?(问这个问题是因为我现在在做后台管理系统)\n总监面(有点儿记不清了)\n1. 新加坡和深圳内网是怎么连通的?\n2. 未来的职业规划是什么样的?\n3. 对当前新的技术有了解吗?\n4. 对客户端知识有了解吗?\n5. 为什么要离职?拒了，岗位不是很喜欢\n\n拼多多\n一面\n1. 有没有做过比较复杂的页面?携程的 React-imvc 做了什么? \n2. 使用 Redux 的好处，以及和 Mobx 的区别\n3. 对 React 最新特性有了解吗?class 组件和函数组件的区别? \n4. useState 为什么不能放到条件语句里面?\n5. 实现一个 Promise.all\n6. React SSR 是怎么实现的?\n7. 有用过代码规范相关的吗?Eslint 和 Prettier 冲突怎么解决? \n8. 实现一个数组转树形结构的函数\n二面\n1. 说几个你觉得足够复杂的项目? \n2. 你是怎么去做 React SSR 的?\n3. 有没有做过性能优化相关的?\n4. 实现一个深拷贝\n5. 实现一个二叉搜索树转链表的方法 拒了，不想去卖命\n商汤\n一面\n1. 在工作中，主要是做什么内容?\n2. 有用过 lerna 吗?多个项目之间共用的东西怎么共享?\n3. 讲一讲微前端是怎么做的?怎么独立部署?子应用通信怎么做?\n4. webpack 构建流程是怎样的?\n5. webpack loader 和 plugin 的原理和区别?\n6. webpack 热更新原理?\n7. webpack 怎么做分包?\n8. 做过 webpack 性能优化吗?有用过 rollup 吗? \n9. react-imvc 是什么?它做了什么?\n10. react 和\n11. redux 和 mobx 的区别和优劣?用过\nreact-dom 的区别是什么?\nredux-saga 吗? 的复杂度，以及 react diff 的原理\n12. react diff\n13. react class 组件和 hooks 的区别? \n14.什么是 TS 泛型?\n15.从输入 url 到页面展示经过了哪些步骤?\n16.讲一下重绘和回流\n17.知道 BFC 吗?使用场景有哪些?\n18.怎么判断是否为数组? \n19.页面卡顿怎么去定位?\n20.数组有 10 万个数据，取第一个和取第 10 万个的耗时多久? \n21.有用过 canvas 相关的吗?\n22. JS 垃圾回收机制?怎么定位 Node 内存泄露问题?\n23.你是怎么理解前端的? \n24.工作中遇到过最难的问题?有没有什么让你自豪的项目? \n25.周末你都在做什么?学习前端的途径是什么?\n\n蚂蚁\n一面\n1. React setState 怎么获取到更新后的值?异步函数中为什么 setState 会立即更新?\n2. 做过离线包吗?H5 离线包的原理?客户端根据什么拦截静态资源 请求?\n3. JS Bridge 的原理?你们这套方案的 s 优缺点?\n4. 怎么判断 webview 是否加载完成?\n5. 怎么实现 App 头部和页面的背景渐变?\n6. PC 端做过比较有意义的项目?\n7. 微前端子应用之间怎么通信?有没有了解过业界的一些方案? 二面\n1. 你们部署的 Jenkins 是怎么做的?\n2. JS Bridge 原理?有没有安全漏洞?\n3. 有没有做过和安全相关的?waf 主要做了什么?\n4. 有没有做过埋点和性能上报相关?\n5. 如果你们用一个第三方的上报库，但页面加载这个 JS 失败了，还\n想上报该怎么办?\n6. 实现两个大数相加\n7. 实现 DOM 字符串转虚拟 DOM 对象(不能用 DOM 相关的 api)\n8. 有木有做过你觉得比较困难的项目?\n三面\n1. 管理系统都做了哪些业务?有没有做一些提高开发效率的东西?\n2. 常用的组件是哪个?解决了什么问题?\n3. 平时 Node 都用来做什么?怎么实现的?\n4. SSR 的实现原理是什么?\n5. 项目中遇到的技术难点有哪些?\n6. 你觉得你们比 lazada 做得更好是哪些原因?","source":"_drafts/1.大厂面试题.md","raw":"---\ntitle: 大厂面试题\nindex_img: /img/2022-03-07-1.png\nabbrlink: 83dcefb7\ndate: 2022-03-07 15:52:23\ntags: 前端\ncategories: 面试\n---\n\n腾讯\n一面\n1. 写一个 LRU 缓存函数\n2. 写个防抖和节流函数\n3. 你们服务是怎么部署的?Node Agent 做了什么工作?\n4. Grpc 的优缺点?\n5. http2 的相关特性?\n6. viewport 和移动端布局方案\n7. 实现一个 compose 函数\n8. 开发中有遇到过比较难定位的问题吗?Node 内存泄露有遇到过 吗?\n二面\n1. react ssr 是在什么场景下做的?\n2. react ssr 双端怎么做构建的?区别在哪里?\n3. 有没有做过同构组件?服务端和客户端怎么同步状态的?\n4. render 和 renderToString 的底层实现上的区别?\n5. 客户端怎么处理 JS 事件失效的问题?客户端不重新加载 JS 的 情况下怎么实现?\n6. 做服务端渲染的时候有没有遇到过比较难的点?\n7. react ssr 和 ejs 性能的差异?\n8. 服务回滚是怎么做的?上线流程是怎样的?k8s 回滚、拉取以前的 镜像\n9. webpack plugin 的原理是什么?\n10. plugin 中有异步请求会阻塞后面的 plugin 吗?\n11.做过哪些 webpack 的性能优化?\n12. hard-source-webpack-plugin 是怎么做缓存的?修改文件后会 怎么样?\n13. parallel 的原理是什么?多个子进程怎么通信?\n14.你们 webpack 是怎么做拆包的? \n15.服务端监控是怎么做的?服务有上报过什么指标?\n16. Node 服务怎么去定位 CPU 占用暴涨的情况?怎么去定位内存泄\n露?\n17.编写 grpc 服务和 http 服务的区别?\n18.做过哪些 react 相关的优化?函数组件怎么实现 shouldComponentUpdate?\n19.如果有一个非常大的 react 页面，我想优先渲染某一部分，这该怎 么做?\n20. react 函数组件和 class 组件里面 state 的区别?\n21. react useEffect 对应 class 组件的哪些生命周期? 22.前端的监控是怎么做的?除了 sentry 还做了其他异常处理吗?\n三面\n1. 讲一下你做的比较复杂的项目?以及你在项目中担当了什么角色?\n2. 你是怎么看待现在各种造轮子的?\n3. 有一个一亿长度的字符串，怎么存储设计可以让它更好去查询、修\n改?\n4. 怎么优化 H5 让它可以在 300ms 之内打开?\n5. 你们 WebView 加载一般耗时多久?\n6. 你们为什么从 Python 重构到 Node?好处是什么?\n \n7. 你是怎么看待做后台管理系统的?很多人觉得它没有难点，你觉得 呢?(问这个问题是因为我现在在做后台管理系统)\n总监面(有点儿记不清了)\n1. 新加坡和深圳内网是怎么连通的?\n2. 未来的职业规划是什么样的?\n3. 对当前新的技术有了解吗?\n4. 对客户端知识有了解吗?\n5. 为什么要离职?拒了，岗位不是很喜欢\n\n拼多多\n一面\n1. 有没有做过比较复杂的页面?携程的 React-imvc 做了什么? \n2. 使用 Redux 的好处，以及和 Mobx 的区别\n3. 对 React 最新特性有了解吗?class 组件和函数组件的区别? \n4. useState 为什么不能放到条件语句里面?\n5. 实现一个 Promise.all\n6. React SSR 是怎么实现的?\n7. 有用过代码规范相关的吗?Eslint 和 Prettier 冲突怎么解决? \n8. 实现一个数组转树形结构的函数\n二面\n1. 说几个你觉得足够复杂的项目? \n2. 你是怎么去做 React SSR 的?\n3. 有没有做过性能优化相关的?\n4. 实现一个深拷贝\n5. 实现一个二叉搜索树转链表的方法 拒了，不想去卖命\n商汤\n一面\n1. 在工作中，主要是做什么内容?\n2. 有用过 lerna 吗?多个项目之间共用的东西怎么共享?\n3. 讲一讲微前端是怎么做的?怎么独立部署?子应用通信怎么做?\n4. webpack 构建流程是怎样的?\n5. webpack loader 和 plugin 的原理和区别?\n6. webpack 热更新原理?\n7. webpack 怎么做分包?\n8. 做过 webpack 性能优化吗?有用过 rollup 吗? \n9. react-imvc 是什么?它做了什么?\n10. react 和\n11. redux 和 mobx 的区别和优劣?用过\nreact-dom 的区别是什么?\nredux-saga 吗? 的复杂度，以及 react diff 的原理\n12. react diff\n13. react class 组件和 hooks 的区别? \n14.什么是 TS 泛型?\n15.从输入 url 到页面展示经过了哪些步骤?\n16.讲一下重绘和回流\n17.知道 BFC 吗?使用场景有哪些?\n18.怎么判断是否为数组? \n19.页面卡顿怎么去定位?\n20.数组有 10 万个数据，取第一个和取第 10 万个的耗时多久? \n21.有用过 canvas 相关的吗?\n22. JS 垃圾回收机制?怎么定位 Node 内存泄露问题?\n23.你是怎么理解前端的? \n24.工作中遇到过最难的问题?有没有什么让你自豪的项目? \n25.周末你都在做什么?学习前端的途径是什么?\n\n蚂蚁\n一面\n1. React setState 怎么获取到更新后的值?异步函数中为什么 setState 会立即更新?\n2. 做过离线包吗?H5 离线包的原理?客户端根据什么拦截静态资源 请求?\n3. JS Bridge 的原理?你们这套方案的 s 优缺点?\n4. 怎么判断 webview 是否加载完成?\n5. 怎么实现 App 头部和页面的背景渐变?\n6. PC 端做过比较有意义的项目?\n7. 微前端子应用之间怎么通信?有没有了解过业界的一些方案? 二面\n1. 你们部署的 Jenkins 是怎么做的?\n2. JS Bridge 原理?有没有安全漏洞?\n3. 有没有做过和安全相关的?waf 主要做了什么?\n4. 有没有做过埋点和性能上报相关?\n5. 如果你们用一个第三方的上报库，但页面加载这个 JS 失败了，还\n想上报该怎么办?\n6. 实现两个大数相加\n7. 实现 DOM 字符串转虚拟 DOM 对象(不能用 DOM 相关的 api)\n8. 有木有做过你觉得比较困难的项目?\n三面\n1. 管理系统都做了哪些业务?有没有做一些提高开发效率的东西?\n2. 常用的组件是哪个?解决了什么问题?\n3. 平时 Node 都用来做什么?怎么实现的?\n4. SSR 的实现原理是什么?\n5. 项目中遇到的技术难点有哪些?\n6. 你觉得你们比 lazada 做得更好是哪些原因?","slug":"1-大厂面试题","published":0,"updated":"2022-03-16T15:55:55.184Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k5bv6u00070h3l086s1m0s","content":"<p>腾讯<br>一面</p>\n<ol>\n<li>写一个 LRU 缓存函数</li>\n<li>写个防抖和节流函数</li>\n<li>你们服务是怎么部署的?Node Agent 做了什么工作?</li>\n<li>Grpc 的优缺点?</li>\n<li>http2 的相关特性?</li>\n<li>viewport 和移动端布局方案</li>\n<li>实现一个 compose 函数</li>\n<li>开发中有遇到过比较难定位的问题吗?Node 内存泄露有遇到过 吗?<br>二面</li>\n<li>react ssr 是在什么场景下做的?</li>\n<li>react ssr 双端怎么做构建的?区别在哪里?</li>\n<li>有没有做过同构组件?服务端和客户端怎么同步状态的?</li>\n<li>render 和 renderToString 的底层实现上的区别?</li>\n<li>客户端怎么处理 JS 事件失效的问题?客户端不重新加载 JS 的 情况下怎么实现?</li>\n<li>做服务端渲染的时候有没有遇到过比较难的点?</li>\n<li>react ssr 和 ejs 性能的差异?</li>\n<li>服务回滚是怎么做的?上线流程是怎样的?k8s 回滚、拉取以前的 镜像</li>\n<li>webpack plugin 的原理是什么?</li>\n<li>plugin 中有异步请求会阻塞后面的 plugin 吗?</li>\n<li>做过哪些 webpack 的性能优化?</li>\n<li>hard-source-webpack-plugin 是怎么做缓存的?修改文件后会 怎么样?</li>\n<li>parallel 的原理是什么?多个子进程怎么通信?</li>\n<li>你们 webpack 是怎么做拆包的? </li>\n<li>服务端监控是怎么做的?服务有上报过什么指标?</li>\n<li>Node 服务怎么去定位 CPU 占用暴涨的情况?怎么去定位内存泄<br>露?</li>\n<li>编写 grpc 服务和 http 服务的区别?</li>\n<li>做过哪些 react 相关的优化?函数组件怎么实现 shouldComponentUpdate?</li>\n<li>如果有一个非常大的 react 页面，我想优先渲染某一部分，这该怎 么做?</li>\n<li>react 函数组件和 class 组件里面 state 的区别?</li>\n<li>react useEffect 对应 class 组件的哪些生命周期? 22.前端的监控是怎么做的?除了 sentry 还做了其他异常处理吗?<br>三面</li>\n<li>讲一下你做的比较复杂的项目?以及你在项目中担当了什么角色?</li>\n<li>你是怎么看待现在各种造轮子的?</li>\n<li>有一个一亿长度的字符串，怎么存储设计可以让它更好去查询、修<br>改?</li>\n<li>怎么优化 H5 让它可以在 300ms 之内打开?</li>\n<li>你们 WebView 加载一般耗时多久?</li>\n<li>你们为什么从 Python 重构到 Node?好处是什么?</li>\n<li>你是怎么看待做后台管理系统的?很多人觉得它没有难点，你觉得 呢?(问这个问题是因为我现在在做后台管理系统)<br>总监面(有点儿记不清了)</li>\n<li>新加坡和深圳内网是怎么连通的?</li>\n<li>未来的职业规划是什么样的?</li>\n<li>对当前新的技术有了解吗?</li>\n<li>对客户端知识有了解吗?</li>\n<li>为什么要离职?拒了，岗位不是很喜欢</li>\n</ol>\n<p>拼多多<br>一面</p>\n<ol>\n<li>有没有做过比较复杂的页面?携程的 React-imvc 做了什么? </li>\n<li>使用 Redux 的好处，以及和 Mobx 的区别</li>\n<li>对 React 最新特性有了解吗?class 组件和函数组件的区别? </li>\n<li>useState 为什么不能放到条件语句里面?</li>\n<li>实现一个 Promise.all</li>\n<li>React SSR 是怎么实现的?</li>\n<li>有用过代码规范相关的吗?Eslint 和 Prettier 冲突怎么解决? </li>\n<li>实现一个数组转树形结构的函数<br>二面</li>\n<li>说几个你觉得足够复杂的项目? </li>\n<li>你是怎么去做 React SSR 的?</li>\n<li>有没有做过性能优化相关的?</li>\n<li>实现一个深拷贝</li>\n<li>实现一个二叉搜索树转链表的方法 拒了，不想去卖命<br>商汤<br>一面</li>\n<li>在工作中，主要是做什么内容?</li>\n<li>有用过 lerna 吗?多个项目之间共用的东西怎么共享?</li>\n<li>讲一讲微前端是怎么做的?怎么独立部署?子应用通信怎么做?</li>\n<li>webpack 构建流程是怎样的?</li>\n<li>webpack loader 和 plugin 的原理和区别?</li>\n<li>webpack 热更新原理?</li>\n<li>webpack 怎么做分包?</li>\n<li>做过 webpack 性能优化吗?有用过 rollup 吗? </li>\n<li>react-imvc 是什么?它做了什么?</li>\n<li>react 和</li>\n<li>redux 和 mobx 的区别和优劣?用过<br>react-dom 的区别是什么?<br>redux-saga 吗? 的复杂度，以及 react diff 的原理</li>\n<li>react diff</li>\n<li>react class 组件和 hooks 的区别? </li>\n<li>什么是 TS 泛型?</li>\n<li>从输入 url 到页面展示经过了哪些步骤?</li>\n<li>讲一下重绘和回流</li>\n<li>知道 BFC 吗?使用场景有哪些?</li>\n<li>怎么判断是否为数组? </li>\n<li>页面卡顿怎么去定位?</li>\n<li>数组有 10 万个数据，取第一个和取第 10 万个的耗时多久? </li>\n<li>有用过 canvas 相关的吗?</li>\n<li>JS 垃圾回收机制?怎么定位 Node 内存泄露问题?</li>\n<li>你是怎么理解前端的? </li>\n<li>工作中遇到过最难的问题?有没有什么让你自豪的项目? </li>\n<li>周末你都在做什么?学习前端的途径是什么?</li>\n</ol>\n<p>蚂蚁<br>一面</p>\n<ol>\n<li>React setState 怎么获取到更新后的值?异步函数中为什么 setState 会立即更新?</li>\n<li>做过离线包吗?H5 离线包的原理?客户端根据什么拦截静态资源 请求?</li>\n<li>JS Bridge 的原理?你们这套方案的 s 优缺点?</li>\n<li>怎么判断 webview 是否加载完成?</li>\n<li>怎么实现 App 头部和页面的背景渐变?</li>\n<li>PC 端做过比较有意义的项目?</li>\n<li>微前端子应用之间怎么通信?有没有了解过业界的一些方案? 二面</li>\n<li>你们部署的 Jenkins 是怎么做的?</li>\n<li>JS Bridge 原理?有没有安全漏洞?</li>\n<li>有没有做过和安全相关的?waf 主要做了什么?</li>\n<li>有没有做过埋点和性能上报相关?</li>\n<li>如果你们用一个第三方的上报库，但页面加载这个 JS 失败了，还<br>想上报该怎么办?</li>\n<li>实现两个大数相加</li>\n<li>实现 DOM 字符串转虚拟 DOM 对象(不能用 DOM 相关的 api)</li>\n<li>有木有做过你觉得比较困难的项目?<br>三面</li>\n<li>管理系统都做了哪些业务?有没有做一些提高开发效率的东西?</li>\n<li>常用的组件是哪个?解决了什么问题?</li>\n<li>平时 Node 都用来做什么?怎么实现的?</li>\n<li>SSR 的实现原理是什么?</li>\n<li>项目中遇到的技术难点有哪些?</li>\n<li>你觉得你们比 lazada 做得更好是哪些原因?</li>\n</ol>\n","site":{"data":{}},"wordcount":2210,"excerpt":"","more":"<p>腾讯<br>一面</p>\n<ol>\n<li>写一个 LRU 缓存函数</li>\n<li>写个防抖和节流函数</li>\n<li>你们服务是怎么部署的?Node Agent 做了什么工作?</li>\n<li>Grpc 的优缺点?</li>\n<li>http2 的相关特性?</li>\n<li>viewport 和移动端布局方案</li>\n<li>实现一个 compose 函数</li>\n<li>开发中有遇到过比较难定位的问题吗?Node 内存泄露有遇到过 吗?<br>二面</li>\n<li>react ssr 是在什么场景下做的?</li>\n<li>react ssr 双端怎么做构建的?区别在哪里?</li>\n<li>有没有做过同构组件?服务端和客户端怎么同步状态的?</li>\n<li>render 和 renderToString 的底层实现上的区别?</li>\n<li>客户端怎么处理 JS 事件失效的问题?客户端不重新加载 JS 的 情况下怎么实现?</li>\n<li>做服务端渲染的时候有没有遇到过比较难的点?</li>\n<li>react ssr 和 ejs 性能的差异?</li>\n<li>服务回滚是怎么做的?上线流程是怎样的?k8s 回滚、拉取以前的 镜像</li>\n<li>webpack plugin 的原理是什么?</li>\n<li>plugin 中有异步请求会阻塞后面的 plugin 吗?</li>\n<li>做过哪些 webpack 的性能优化?</li>\n<li>hard-source-webpack-plugin 是怎么做缓存的?修改文件后会 怎么样?</li>\n<li>parallel 的原理是什么?多个子进程怎么通信?</li>\n<li>你们 webpack 是怎么做拆包的? </li>\n<li>服务端监控是怎么做的?服务有上报过什么指标?</li>\n<li>Node 服务怎么去定位 CPU 占用暴涨的情况?怎么去定位内存泄<br>露?</li>\n<li>编写 grpc 服务和 http 服务的区别?</li>\n<li>做过哪些 react 相关的优化?函数组件怎么实现 shouldComponentUpdate?</li>\n<li>如果有一个非常大的 react 页面，我想优先渲染某一部分，这该怎 么做?</li>\n<li>react 函数组件和 class 组件里面 state 的区别?</li>\n<li>react useEffect 对应 class 组件的哪些生命周期? 22.前端的监控是怎么做的?除了 sentry 还做了其他异常处理吗?<br>三面</li>\n<li>讲一下你做的比较复杂的项目?以及你在项目中担当了什么角色?</li>\n<li>你是怎么看待现在各种造轮子的?</li>\n<li>有一个一亿长度的字符串，怎么存储设计可以让它更好去查询、修<br>改?</li>\n<li>怎么优化 H5 让它可以在 300ms 之内打开?</li>\n<li>你们 WebView 加载一般耗时多久?</li>\n<li>你们为什么从 Python 重构到 Node?好处是什么?</li>\n<li>你是怎么看待做后台管理系统的?很多人觉得它没有难点，你觉得 呢?(问这个问题是因为我现在在做后台管理系统)<br>总监面(有点儿记不清了)</li>\n<li>新加坡和深圳内网是怎么连通的?</li>\n<li>未来的职业规划是什么样的?</li>\n<li>对当前新的技术有了解吗?</li>\n<li>对客户端知识有了解吗?</li>\n<li>为什么要离职?拒了，岗位不是很喜欢</li>\n</ol>\n<p>拼多多<br>一面</p>\n<ol>\n<li>有没有做过比较复杂的页面?携程的 React-imvc 做了什么? </li>\n<li>使用 Redux 的好处，以及和 Mobx 的区别</li>\n<li>对 React 最新特性有了解吗?class 组件和函数组件的区别? </li>\n<li>useState 为什么不能放到条件语句里面?</li>\n<li>实现一个 Promise.all</li>\n<li>React SSR 是怎么实现的?</li>\n<li>有用过代码规范相关的吗?Eslint 和 Prettier 冲突怎么解决? </li>\n<li>实现一个数组转树形结构的函数<br>二面</li>\n<li>说几个你觉得足够复杂的项目? </li>\n<li>你是怎么去做 React SSR 的?</li>\n<li>有没有做过性能优化相关的?</li>\n<li>实现一个深拷贝</li>\n<li>实现一个二叉搜索树转链表的方法 拒了，不想去卖命<br>商汤<br>一面</li>\n<li>在工作中，主要是做什么内容?</li>\n<li>有用过 lerna 吗?多个项目之间共用的东西怎么共享?</li>\n<li>讲一讲微前端是怎么做的?怎么独立部署?子应用通信怎么做?</li>\n<li>webpack 构建流程是怎样的?</li>\n<li>webpack loader 和 plugin 的原理和区别?</li>\n<li>webpack 热更新原理?</li>\n<li>webpack 怎么做分包?</li>\n<li>做过 webpack 性能优化吗?有用过 rollup 吗? </li>\n<li>react-imvc 是什么?它做了什么?</li>\n<li>react 和</li>\n<li>redux 和 mobx 的区别和优劣?用过<br>react-dom 的区别是什么?<br>redux-saga 吗? 的复杂度，以及 react diff 的原理</li>\n<li>react diff</li>\n<li>react class 组件和 hooks 的区别? </li>\n<li>什么是 TS 泛型?</li>\n<li>从输入 url 到页面展示经过了哪些步骤?</li>\n<li>讲一下重绘和回流</li>\n<li>知道 BFC 吗?使用场景有哪些?</li>\n<li>怎么判断是否为数组? </li>\n<li>页面卡顿怎么去定位?</li>\n<li>数组有 10 万个数据，取第一个和取第 10 万个的耗时多久? </li>\n<li>有用过 canvas 相关的吗?</li>\n<li>JS 垃圾回收机制?怎么定位 Node 内存泄露问题?</li>\n<li>你是怎么理解前端的? </li>\n<li>工作中遇到过最难的问题?有没有什么让你自豪的项目? </li>\n<li>周末你都在做什么?学习前端的途径是什么?</li>\n</ol>\n<p>蚂蚁<br>一面</p>\n<ol>\n<li>React setState 怎么获取到更新后的值?异步函数中为什么 setState 会立即更新?</li>\n<li>做过离线包吗?H5 离线包的原理?客户端根据什么拦截静态资源 请求?</li>\n<li>JS Bridge 的原理?你们这套方案的 s 优缺点?</li>\n<li>怎么判断 webview 是否加载完成?</li>\n<li>怎么实现 App 头部和页面的背景渐变?</li>\n<li>PC 端做过比较有意义的项目?</li>\n<li>微前端子应用之间怎么通信?有没有了解过业界的一些方案? 二面</li>\n<li>你们部署的 Jenkins 是怎么做的?</li>\n<li>JS Bridge 原理?有没有安全漏洞?</li>\n<li>有没有做过和安全相关的?waf 主要做了什么?</li>\n<li>有没有做过埋点和性能上报相关?</li>\n<li>如果你们用一个第三方的上报库，但页面加载这个 JS 失败了，还<br>想上报该怎么办?</li>\n<li>实现两个大数相加</li>\n<li>实现 DOM 字符串转虚拟 DOM 对象(不能用 DOM 相关的 api)</li>\n<li>有木有做过你觉得比较困难的项目?<br>三面</li>\n<li>管理系统都做了哪些业务?有没有做一些提高开发效率的东西?</li>\n<li>常用的组件是哪个?解决了什么问题?</li>\n<li>平时 Node 都用来做什么?怎么实现的?</li>\n<li>SSR 的实现原理是什么?</li>\n<li>项目中遇到的技术难点有哪些?</li>\n<li>你觉得你们比 lazada 做得更好是哪些原因?</li>\n</ol>\n"},{"title":"1","index_img":"/img/index-img.png","date":"2022-03-15T10:09:33.000Z","_content":"\n\n- [React + TypeScript 实践](https://mp.weixin.qq.com/s/mUblBpj6pmdxz9mLKEDJTw)","source":"_drafts/7.React + TypeScript.md","raw":"---\ntitle: 1\nindex_img: /img/index-img.png\ndate: 2022-03-15 18:09:33\ntags:\ncategories:\n---\n\n\n- [React + TypeScript 实践](https://mp.weixin.qq.com/s/mUblBpj6pmdxz9mLKEDJTw)","slug":"7-React-TypeScript","published":0,"updated":"2022-04-15T09:57:14.856Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k5bv6v00080h3lep1ed0va","content":"<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/mUblBpj6pmdxz9mLKEDJTw\">React + TypeScript 实践</a></li>\n</ul>\n","site":{"data":{}},"wordcount":18,"excerpt":"","more":"<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/mUblBpj6pmdxz9mLKEDJTw\">React + TypeScript 实践</a></li>\n</ul>\n"},{"title":"Mobx 原理分析","index_img":"/img/2021-12-22-1.png","date":"2021-12-22T15:12:17.000Z","_content":"\n","source":"_drafts/4.Mobx 原理分析.md","raw":"---\ntitle: Mobx 原理分析\nindex_img: /img/2021-12-22-1.png\ndate: 2021-12-22 23:12:17\ntags: Mobx\ncategories: Mobx\n---\n\n","slug":"4-Mobx-原理分析","published":0,"updated":"2022-03-01T02:46:43.070Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k5bv6v00090h3la1vk7rsz","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""},{"title":"JS 代码 Bad & Good","index_img":"/img/2021-12-15-1.png","date":"2021-12-15T15:13:22.000Z","_content":"\n","source":"_drafts/6.JS 代码 Bad & Good.md","raw":"---\ntitle: JS 代码 Bad & Good\nindex_img: /img/2021-12-15-1.png\ndate: 2021-12-15 23:13:22\ntags: Bad&Good\ncategories: JS\n---\n\n","slug":"6-JS-代码-Bad-Good","published":0,"updated":"2022-03-01T02:46:40.356Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k5bv6y000d0h3l416xbufi","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""},{"title":"Webpack 原理分析","index_img":"/img/2022-02-08-1.jpeg","date":"2022-02-08T02:29:04.000Z","_content":"\n","source":"_drafts/5.Webpack 原理分析.md","raw":"---\ntitle: Webpack 原理分析\nindex_img: /img/2022-02-08-1.jpeg\ndate: 2022-02-08 10:29:04\ntags: webpack\ncategories: webpack\n---\n\n","slug":"5-Webpack-原理分析","published":0,"updated":"2022-03-01T02:46:45.810Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k5bv6z000e0h3l2fia7obw","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""},{"title":"React Hooks 之闭包","index_img":"/img/index-img.png","abbrlink":"44dd3b46","date":"2022-04-14T03:24:48.000Z","_content":"\n\n## References\n\n- [https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/](https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/)","source":"_drafts/8.React Hooks 之闭包.md","raw":"---\ntitle: React Hooks 之闭包\nindex_img: /img/index-img.png\ntags: 闭包\ncategories: React Hook\nabbrlink: 44dd3b46\ndate: 2022-04-14 11:24:48\n---\n\n\n## References\n\n- [https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/](https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/)","slug":"8-React-Hooks-之闭包","published":0,"updated":"2022-04-14T07:14:07.866Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k5bv71000i0h3laejafuyh","content":"<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><ul>\n<li><a href=\"https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/\">https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/</a></li>\n</ul>\n","site":{"data":{}},"wordcount":71,"excerpt":"","more":"<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><ul>\n<li><a href=\"https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/\">https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/</a></li>\n</ul>\n"},{"title":"FE-Interview","index_img":"/img/2022-01-01-1.jpeg","abbrlink":"12d2438b","date":"2022-01-01T15:28:37.000Z","_content":"\n---\n\n第 1 天（2022.2.28）\n\n## 1. 什么时候使用状态管理器？\n\n1. 组件状态要在多个组件共享时\n1. 某个组件状态需要在任何地方可以拿到\n1. 一个组件需要改变全局状态时\n1. 一个组件需要改变另一个组件状态时\n1. 组件状态提升提升不能满足需求时，层级过多时。\n\n## 2. render 函数中 return 如果没有使用()会有什么问题？\n\n避免遇到自动插入分号陷阱。\n\n我们在使用 JSX 语法书写 react 代码时，babel 会将 JSX 语法编译成 js，同时会在每行自动添加分号（；），如果 return 后换行了，那么就会变成 return； 一般情况下会报错：\n\nNothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.\n上面这段英文翻译成中文：\n\n渲染没有返回任何内容。这通常意味着缺少 return 语句。或者，为了不渲染，返回 null。\n为了代码可读性我们一般会在 return 后面添加括号这样代码可以折行书写，否则就在 return 后面紧跟着语句，这样也是可以的。\n\n举两个正确的书写例子：\n\n```jsx\nconst Nav = () => {\n  return (\n    <nav className=\"c_navbar\">\n      { some jsx magic here }\n    </nav>\n    )\n  }\n\nconst Nav = () => {\nreturn <nav className=\"c_navbar\">\n    { some jsx magic here }\n  </nav>\n}\n```\n\n错误的写法：\n\n```jsx\nconst Nav = () => {\n  return\n    <nav className=\"c_navbar\">\n      { some jsx magic here }\n    </nav>\n}\n```\n\n## 3. componentWillUpdate 可以直接修改 state 的值吗？\n\n直接修改不可以，但是加上条件就可以。\n\n文档原文：“你也可以在 componentDidUpdate() 中直接调用 setState()，但请注意它必须被包裹在一个条件语句里，正如上述的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。”\n\ncomponentWillReceiveProps 同理\n\n## 4. 说说你对 React 的渲染原理的理解\n\n1. React 会调用 React.render()构建一颗 DOM 树，生成虚拟 dom。\n2. 通过改变 state 或 props 触发更新。\n3. 对比新旧虚拟 dom，diff 算法，深度优先，将实际需要改变的反应到真实 dom。\n\n---\n\n第 2 天（2022.3.1）\n\n## 5. 什么渲染劫持？\n\n一般和高阶组件（HOC）一起解释。\n\n高阶组件在 render 的时候可以做其他操作，从而控制原组件的渲染输出，这种改变原组件渲染的方式称为 渲染劫持。\n\n在高阶组件中，组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可实现渲染劫持，还可以增强原组件 render 函数。\n\n除了 HOC，当新写一个组件，继承自一个已有的组件，可以随便修改 render 函数，使用 state、props 等改变原组件的渲染，都叫渲染劫持。\n\nPS: HOC 反向继承\n\nTODO：\n\n## 6. React Intl是什么原理？\n\nReact Intl 用途是国际化库，提供组件、日期等国际化方法。\n\n做国际化就类似于字体文件，通过切换语言，加载不同语言包到本地.\n\n最外层包一个Provider。调用库中方法，完成国际化。\n\n前端国际化核心步骤有两步：\n\n- 创建资源文件，以 key-value 方式存储\n- 加载资源文件，将页面上 key 的内容替换为相关 value\n\n## 7. 怎么实现React组件的国际化呢？\n\n 使用 i18next 以及 react-i18next 配合 i18next-scanner，通过 grunt 跑 task 自动扫描生成 json 文件。\n\n 现在大厂比较常用的方案是，使用AST，每次开发完新版本，通过AST去扫描所有的代码，找出代码中的中文，以中文为key，调用智能翻译服务，去帮项目自动生成json文件。这样，再也不需要人为去维护json文件，一切都依赖工具进行自动化。\n\n---\n\n第 3 天（2022.3.2）\n\n## 8. 说说Context有哪些属性？\n\ncontext属于一种解决组件间层级过多传递数据的问题，避免了层层嵌套的通过props传递的形式，同时对于不需要使用到redux时，是一种解决方案。\n\nContext.Provider：生产者，数据提供方；通过value属性来定义需要被传递的数据\nContext.Consumer：消费者，数据获取方；根据是函数组件还是class组件，有不同的使用形式；class组件可以指定contextType来确定要使用哪一个context对象的值，函数组件需要使用回调函数的形式来获取context的值；需要显示的指定context对象；\n\n## 9. 怎么使用Context开发组件？\n\n```jsx\nconst themes = {\n  light: {\n    foreground: \"#000000\",\n    background: \"#eeeeee\"\n  },\n  dark: {\n    foreground: \"#ffffff\",\n    background: \"#222222\"\n  }\n};\n// 首先创建一个 context 对象这里命名为：ThemeContext\nconst ThemeContext = React.createContext(themes.light);\n\n// 创建一个祖先组件组件 内部使用Provier 这个对象创建一个组件 其中 value 属性是真实传递的属性\nfunction App() {\n  return (\n    <ThemeContext.Provider value={themes.dark}>\n      <Toolbar />\n    </ThemeContext.Provider>\n  );\n}\n\n// 渲染 button 组件的外层包裹的属性\nfunction Toolbar(props) {\n  return (\n    <div>\n      <ThemedButton />\n    </div>\n  );\n}\n\n// 在 Toolbar 中渲染的button 组件 使用 useContext，将 value 值跨组件传递给 // ThemeButton 组件\nfunction ThemedButton() {\n  const theme = useContext(ThemeContext);\n  return (\n    <button style={{ background: theme.background, color: theme.foreground }}>\n      I am styled by theme context!\n    </button>\n  );\n}\n```\n\n## 10. 为什么React并不推荐我们优先考虑使用Context？\n\n1、Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。\n2、尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context\n3、对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。\n4、context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注。\n\n---\n\n第 4 天（2022.3.3）\n\n## 11. childContextTypes是什么？它有什么用？\n\nchildContextTypes用来定义context数据类型，该api从16.3开始已被废弃\n\n使用方式\n\n```jsx\nclass MessageList extends React.Component {\n  getChildContext() {\n    return {color: \"purple\"};\n  }\n\n  render() {\n    return <div>MessageList</div>;\n  }\n}\n\nMessageList.childContextTypes = {\n  color: PropTypes.string\n};\n\n```\n\n## 12. Consumer向上找不到Provider的时候怎么办？\n\n当consumer向上层找不到provider时，此时就会取创建context时传给createContext的那个值，也就是当前context对象的默认值，在定义provider时的value中的值不是默认值，而是表示需要被传递的值.\n\n---\n\n第 5 天（2022.3.4）\n\n## 13. 说说你对windowing的了解\n\n展示长列表\n如果你的应用会渲染大量的列表数据，我们建议使用一种称为‘windowing’的技术，这种技术下在任何给定的时间内只会渲染一小部分数据列表，并可以减少列表项的重复渲染（即再次渲染已经渲染过的数据）。\n\nreact-window和react-virtualized都是流行的使用windowing技术的库，他们都提供了一系列可重用的组件，这些组件能够帮助你以最好的性能展示列表以及表格数据\n\n## 14. 举例说明React的 portal 有哪些运用场景？\n\nportal可以将内容插入到除了父节点的dom之外的地方去渲染，所以modal是一个通过portal实现的典型例子；并且对于事件绑定，因为使用了事件冒泡，所以并不用担心被渲染到父组件结构之外的内容，不能去监听事件\n\n## 15. 你有用过React的插槽(Portals)吗？怎么用？\n\n1、首先简单的介绍下react中的插槽（Portals），通过ReactDOM.createPortal(child, container)创建，是ReactDOM提供的接口，可以实现将子节点渲染到父组件DOM层次结构之外的DOM节点。\n2、第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 片段(fragment)。第二个参数（container）则是一个 DOM 元素。\n3、对于 portal 的一个典型用例是当父组件有 overflow: hidden 或 z-index 样式，但你需要子组件能够在视觉上 “跳出(break out)” 其容器。例如，对话框、hovercards以及提示框。所以一般react组件里的模态框，就是这样实现的。\n\n如果一个子组件的真实DOM结构必须渲染到当前组件外，但又想保留这两者的父子关系，就可以用Protals。\n\n```jsx\nconst Modal = (props) => {\n  const modal = document.body.createElement('div');\n  document.appendChild(modal);\n  useEffect(() => {\n    return () => {\n      document.body.removeChild(modal);\n    }\n  }, []);\n  return React.createPortal(this.props.children, modal);\n}\nconst Parent = () => {\n  const [sum, setSum] = useState(0);\n  const add = () => setSum(sum + 1);\n  return <div onClick={add}>\n    <Modal>加一</Modal>\n  </div>\n}\n```\n\n---\n\n第 6 天（2022.3.5）\n\n## 16. React的严格模式有什么用处？\n\nStrictMode 目前有助于：\n\n- 识别不安全的生命周期\n- 关于使用过时字符串 ref API 的警告\n- 关于使用废弃的 findDOMNode 方法的警告\n- 检测意外的副作用\n- 检测过时的 context API\n\n可以为程序的任何部分使用严格模式\n\n```jsx\nimport React from 'react';\n\nfunction ExampleApplication() {\n  return (\n    <div>\n      <Header />\n      <React.StrictMode>\n        <div>\n          <ComponentOne />\n          <ComponentTwo />\n        </div>\n      </React.StrictMode>\n      <Footer />\n    </div>\n  );\n}\n// 不会对 Header 和 Footer 组件运行严格模式检查。但是，ComponentOne 和 ComponentTwo 以及它们的所有后代元素都将进行检查。\n```\n\n## 17. React如何进行代码拆分？拆分的原则是什么？\n\nreact的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。\n\n在我们的react项目中：\n1、在 api 层面我们单独封装，对外暴露http请求的结果。\n2、数据层我们使用的react-redux 异步中间件使用的是redux-thunk 分装处理异步请求，合业务逻辑处理。\n3、视图层，尽量使用 redux 层面的传递过来的数据，修改逻辑 也是重新触发action 更改props。\n4、静态类型的资源单独放置\n5、公共组件、高阶组件、插件单独放置\n6、工具类文件单独放置\n\n## 18. React组件的构造函数有什么作用？\n\n官网中，构造函数仅用于以下两种情况：\n\n- 通过给 this.state 赋值对象来初始化内部 state。\n- 为事件处理函数绑定实例\n\n```jsx\nconstructor(props) {\n  super(props);\n  // 不要在这里调用 this.setState()\n  this.state = { counter: 0 };\n  this.handleClick = this.handleClick.bind(this);\n}\n```\n\n避免将 props 的值复制给 state！这是一个常见的错误：\n\n```jsx\nconstructor(props) {\n super(props);\n // 不要这样做\n this.state = { color: props.color };\n}\n```\n\n如此做毫无必要（你可以直接使用 this.props.color），同时还产生了 bug（更新 prop 中的 color 时，并不会影响 state）。\n\n## 19. React组件的构造函数是必须的吗？\n\nfunction组件不用考虑构造函数；\n对于class组件，如果不写构造函数，默认会被隐式调用.\n\n对于无状态组件，内部没有维护自己的state，只接收外部传入的props 是不需要声明构造函数的.\n\n---\n\n第 7 天（2022.3.6）\n\n## 20. React中在哪捕获错误？\n\n可以使用错误边界组件来捕获异常；这样可以使用替代ui来代替错误位置的渲染；而不是让程序崩溃；\n主要来捕获生命周期异常，渲染中的异常\n\n使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息\n\n定义错误边界当做常规组件包裹ui组件, 官网例子：\n\n```jsx\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    // 更新 state 使下一次渲染能够显示降级后的 UI\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // 你同样可以将错误日志上报给服务器\n    logErrorToMyService(error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // 你可以自定义降级后的 UI 并渲染\n      return <h1>Something went wrong.</h1>;\n    }\n\n    return this.props.children; \n  }\n}\n```\n\n```jsx\n<ErrorBoundary>\n  <MyWidget />\n</ErrorBoundary>\n```\n\n但是错误边界不会捕获 :\n\n```jsx\ntry{}catch(err){}\n///异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）\n///服务端渲染\n///它自身抛出来的错误（并非它的子组件)\n```\n\n## 21. React怎样引入svg的文件？\n\n方法1： 这种写法会由webpack转为url方式引入。\n\n```jsx\n// svg png等类型图片\nimport logo from './logo.svg';\n//...\n<img src={logo} className=\"App-logo\" alt=\"logo\" />\n//...\n```\n\n方法2： 这种方式仅对SVG图片生效，将svg看作组件导入：\n\n```jsx\n// ...\nimport { ReactComponent as Logo } from './logo.svg'\n// ...\n<Logo />\n```\n\n## 22. 在React中你有经常使用常量吗？\n\n在redux的action文件里面定义不同的行为可能会使用常量的形式。\n\n---\n\n第 8 天（2022.3.7）\n\n## 23. 为什么说React中的props是只读的？\n\n往单向数据流上答：\n保证react的单向数据流的设计模式，使状态更可预测。\n如果允许自组件修改，那么一个父组件将状态传递给好几个子组件，这几个子组件随意修改，就完全不可预测，不知道在什么地方修改了状态。\n所以我们必须像纯函数一样保护 props 不被修改\n\n## 24. 如果组件的属性没有传值，那么它的默认值是什么？\n\n[官网](https://zh-hans.reactjs.org/docs/jsx-in-depth.html#props-default-to-true)，如果你没给 prop 赋值，它的默认值是 true。以下两个 JSX 表达式是等价的：\n\n```jsx\n<MyTextBox autocomplete />\n\n<MyTextBox autocomplete={true} />\n```\n\n通常，我们不建议不传递 value 给 prop，因为这可能与 ES6 对象简写混淆，{foo} 是 {foo: foo} 的简写，而不是 {foo: true}。这样实现只是为了保持和 HTML 中标签属性的行为一致。\n\n## 25. `super()`和`super(props)`有什么区别？\n\nreact 中的class 是基于es6的规范实现的, 继承是使用extends关键字实现继承的，子类必须在constructor()中调用super() 方法否则新建实例就会报错，报错的原因是 子类是没有自己的this对象的，它只能继承父类的this对象，然后对其进行加工，而super()就是将父类中的this对象继承给子类的，没有super() 子类就得不到this对象。\n\n如果你使用了constructor就必须写super() 这个是用来初始化this的，可以绑定事件到this上\n如果你想要在constructor中使用this.props,就必须给super添加参数 super(props)\n注意，无论有没有 constructor，在render中的this.props都是可以使用的，这是react自动附带的\n如果没有用到constructor 是可以不写的，react会默认添加一个空的constroctor.\n\nsuper 指的是父类（即超类）的构造函数。\n\n在调用父类的构造函数之前，你是不能在 constructor 中使用 this 关键字的.\n\n参考 [why-do-we-write-super-props](https://overreacted.io/zh-hans/why-do-we-write-super-props/)","source":"_posts/1.FE-Interview.md","raw":"---\ntitle: FE-Interview\nindex_img: /img/2022-01-01-1.jpeg\ntags: 前端\ncategories: 面试\nabbrlink: 12d2438b\ndate: 2022-01-01 23:28:37\n---\n\n---\n\n第 1 天（2022.2.28）\n\n## 1. 什么时候使用状态管理器？\n\n1. 组件状态要在多个组件共享时\n1. 某个组件状态需要在任何地方可以拿到\n1. 一个组件需要改变全局状态时\n1. 一个组件需要改变另一个组件状态时\n1. 组件状态提升提升不能满足需求时，层级过多时。\n\n## 2. render 函数中 return 如果没有使用()会有什么问题？\n\n避免遇到自动插入分号陷阱。\n\n我们在使用 JSX 语法书写 react 代码时，babel 会将 JSX 语法编译成 js，同时会在每行自动添加分号（；），如果 return 后换行了，那么就会变成 return； 一般情况下会报错：\n\nNothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.\n上面这段英文翻译成中文：\n\n渲染没有返回任何内容。这通常意味着缺少 return 语句。或者，为了不渲染，返回 null。\n为了代码可读性我们一般会在 return 后面添加括号这样代码可以折行书写，否则就在 return 后面紧跟着语句，这样也是可以的。\n\n举两个正确的书写例子：\n\n```jsx\nconst Nav = () => {\n  return (\n    <nav className=\"c_navbar\">\n      { some jsx magic here }\n    </nav>\n    )\n  }\n\nconst Nav = () => {\nreturn <nav className=\"c_navbar\">\n    { some jsx magic here }\n  </nav>\n}\n```\n\n错误的写法：\n\n```jsx\nconst Nav = () => {\n  return\n    <nav className=\"c_navbar\">\n      { some jsx magic here }\n    </nav>\n}\n```\n\n## 3. componentWillUpdate 可以直接修改 state 的值吗？\n\n直接修改不可以，但是加上条件就可以。\n\n文档原文：“你也可以在 componentDidUpdate() 中直接调用 setState()，但请注意它必须被包裹在一个条件语句里，正如上述的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。”\n\ncomponentWillReceiveProps 同理\n\n## 4. 说说你对 React 的渲染原理的理解\n\n1. React 会调用 React.render()构建一颗 DOM 树，生成虚拟 dom。\n2. 通过改变 state 或 props 触发更新。\n3. 对比新旧虚拟 dom，diff 算法，深度优先，将实际需要改变的反应到真实 dom。\n\n---\n\n第 2 天（2022.3.1）\n\n## 5. 什么渲染劫持？\n\n一般和高阶组件（HOC）一起解释。\n\n高阶组件在 render 的时候可以做其他操作，从而控制原组件的渲染输出，这种改变原组件渲染的方式称为 渲染劫持。\n\n在高阶组件中，组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可实现渲染劫持，还可以增强原组件 render 函数。\n\n除了 HOC，当新写一个组件，继承自一个已有的组件，可以随便修改 render 函数，使用 state、props 等改变原组件的渲染，都叫渲染劫持。\n\nPS: HOC 反向继承\n\nTODO：\n\n## 6. React Intl是什么原理？\n\nReact Intl 用途是国际化库，提供组件、日期等国际化方法。\n\n做国际化就类似于字体文件，通过切换语言，加载不同语言包到本地.\n\n最外层包一个Provider。调用库中方法，完成国际化。\n\n前端国际化核心步骤有两步：\n\n- 创建资源文件，以 key-value 方式存储\n- 加载资源文件，将页面上 key 的内容替换为相关 value\n\n## 7. 怎么实现React组件的国际化呢？\n\n 使用 i18next 以及 react-i18next 配合 i18next-scanner，通过 grunt 跑 task 自动扫描生成 json 文件。\n\n 现在大厂比较常用的方案是，使用AST，每次开发完新版本，通过AST去扫描所有的代码，找出代码中的中文，以中文为key，调用智能翻译服务，去帮项目自动生成json文件。这样，再也不需要人为去维护json文件，一切都依赖工具进行自动化。\n\n---\n\n第 3 天（2022.3.2）\n\n## 8. 说说Context有哪些属性？\n\ncontext属于一种解决组件间层级过多传递数据的问题，避免了层层嵌套的通过props传递的形式，同时对于不需要使用到redux时，是一种解决方案。\n\nContext.Provider：生产者，数据提供方；通过value属性来定义需要被传递的数据\nContext.Consumer：消费者，数据获取方；根据是函数组件还是class组件，有不同的使用形式；class组件可以指定contextType来确定要使用哪一个context对象的值，函数组件需要使用回调函数的形式来获取context的值；需要显示的指定context对象；\n\n## 9. 怎么使用Context开发组件？\n\n```jsx\nconst themes = {\n  light: {\n    foreground: \"#000000\",\n    background: \"#eeeeee\"\n  },\n  dark: {\n    foreground: \"#ffffff\",\n    background: \"#222222\"\n  }\n};\n// 首先创建一个 context 对象这里命名为：ThemeContext\nconst ThemeContext = React.createContext(themes.light);\n\n// 创建一个祖先组件组件 内部使用Provier 这个对象创建一个组件 其中 value 属性是真实传递的属性\nfunction App() {\n  return (\n    <ThemeContext.Provider value={themes.dark}>\n      <Toolbar />\n    </ThemeContext.Provider>\n  );\n}\n\n// 渲染 button 组件的外层包裹的属性\nfunction Toolbar(props) {\n  return (\n    <div>\n      <ThemedButton />\n    </div>\n  );\n}\n\n// 在 Toolbar 中渲染的button 组件 使用 useContext，将 value 值跨组件传递给 // ThemeButton 组件\nfunction ThemedButton() {\n  const theme = useContext(ThemeContext);\n  return (\n    <button style={{ background: theme.background, color: theme.foreground }}>\n      I am styled by theme context!\n    </button>\n  );\n}\n```\n\n## 10. 为什么React并不推荐我们优先考虑使用Context？\n\n1、Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。\n2、尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context\n3、对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。\n4、context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注。\n\n---\n\n第 4 天（2022.3.3）\n\n## 11. childContextTypes是什么？它有什么用？\n\nchildContextTypes用来定义context数据类型，该api从16.3开始已被废弃\n\n使用方式\n\n```jsx\nclass MessageList extends React.Component {\n  getChildContext() {\n    return {color: \"purple\"};\n  }\n\n  render() {\n    return <div>MessageList</div>;\n  }\n}\n\nMessageList.childContextTypes = {\n  color: PropTypes.string\n};\n\n```\n\n## 12. Consumer向上找不到Provider的时候怎么办？\n\n当consumer向上层找不到provider时，此时就会取创建context时传给createContext的那个值，也就是当前context对象的默认值，在定义provider时的value中的值不是默认值，而是表示需要被传递的值.\n\n---\n\n第 5 天（2022.3.4）\n\n## 13. 说说你对windowing的了解\n\n展示长列表\n如果你的应用会渲染大量的列表数据，我们建议使用一种称为‘windowing’的技术，这种技术下在任何给定的时间内只会渲染一小部分数据列表，并可以减少列表项的重复渲染（即再次渲染已经渲染过的数据）。\n\nreact-window和react-virtualized都是流行的使用windowing技术的库，他们都提供了一系列可重用的组件，这些组件能够帮助你以最好的性能展示列表以及表格数据\n\n## 14. 举例说明React的 portal 有哪些运用场景？\n\nportal可以将内容插入到除了父节点的dom之外的地方去渲染，所以modal是一个通过portal实现的典型例子；并且对于事件绑定，因为使用了事件冒泡，所以并不用担心被渲染到父组件结构之外的内容，不能去监听事件\n\n## 15. 你有用过React的插槽(Portals)吗？怎么用？\n\n1、首先简单的介绍下react中的插槽（Portals），通过ReactDOM.createPortal(child, container)创建，是ReactDOM提供的接口，可以实现将子节点渲染到父组件DOM层次结构之外的DOM节点。\n2、第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 片段(fragment)。第二个参数（container）则是一个 DOM 元素。\n3、对于 portal 的一个典型用例是当父组件有 overflow: hidden 或 z-index 样式，但你需要子组件能够在视觉上 “跳出(break out)” 其容器。例如，对话框、hovercards以及提示框。所以一般react组件里的模态框，就是这样实现的。\n\n如果一个子组件的真实DOM结构必须渲染到当前组件外，但又想保留这两者的父子关系，就可以用Protals。\n\n```jsx\nconst Modal = (props) => {\n  const modal = document.body.createElement('div');\n  document.appendChild(modal);\n  useEffect(() => {\n    return () => {\n      document.body.removeChild(modal);\n    }\n  }, []);\n  return React.createPortal(this.props.children, modal);\n}\nconst Parent = () => {\n  const [sum, setSum] = useState(0);\n  const add = () => setSum(sum + 1);\n  return <div onClick={add}>\n    <Modal>加一</Modal>\n  </div>\n}\n```\n\n---\n\n第 6 天（2022.3.5）\n\n## 16. React的严格模式有什么用处？\n\nStrictMode 目前有助于：\n\n- 识别不安全的生命周期\n- 关于使用过时字符串 ref API 的警告\n- 关于使用废弃的 findDOMNode 方法的警告\n- 检测意外的副作用\n- 检测过时的 context API\n\n可以为程序的任何部分使用严格模式\n\n```jsx\nimport React from 'react';\n\nfunction ExampleApplication() {\n  return (\n    <div>\n      <Header />\n      <React.StrictMode>\n        <div>\n          <ComponentOne />\n          <ComponentTwo />\n        </div>\n      </React.StrictMode>\n      <Footer />\n    </div>\n  );\n}\n// 不会对 Header 和 Footer 组件运行严格模式检查。但是，ComponentOne 和 ComponentTwo 以及它们的所有后代元素都将进行检查。\n```\n\n## 17. React如何进行代码拆分？拆分的原则是什么？\n\nreact的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。\n\n在我们的react项目中：\n1、在 api 层面我们单独封装，对外暴露http请求的结果。\n2、数据层我们使用的react-redux 异步中间件使用的是redux-thunk 分装处理异步请求，合业务逻辑处理。\n3、视图层，尽量使用 redux 层面的传递过来的数据，修改逻辑 也是重新触发action 更改props。\n4、静态类型的资源单独放置\n5、公共组件、高阶组件、插件单独放置\n6、工具类文件单独放置\n\n## 18. React组件的构造函数有什么作用？\n\n官网中，构造函数仅用于以下两种情况：\n\n- 通过给 this.state 赋值对象来初始化内部 state。\n- 为事件处理函数绑定实例\n\n```jsx\nconstructor(props) {\n  super(props);\n  // 不要在这里调用 this.setState()\n  this.state = { counter: 0 };\n  this.handleClick = this.handleClick.bind(this);\n}\n```\n\n避免将 props 的值复制给 state！这是一个常见的错误：\n\n```jsx\nconstructor(props) {\n super(props);\n // 不要这样做\n this.state = { color: props.color };\n}\n```\n\n如此做毫无必要（你可以直接使用 this.props.color），同时还产生了 bug（更新 prop 中的 color 时，并不会影响 state）。\n\n## 19. React组件的构造函数是必须的吗？\n\nfunction组件不用考虑构造函数；\n对于class组件，如果不写构造函数，默认会被隐式调用.\n\n对于无状态组件，内部没有维护自己的state，只接收外部传入的props 是不需要声明构造函数的.\n\n---\n\n第 7 天（2022.3.6）\n\n## 20. React中在哪捕获错误？\n\n可以使用错误边界组件来捕获异常；这样可以使用替代ui来代替错误位置的渲染；而不是让程序崩溃；\n主要来捕获生命周期异常，渲染中的异常\n\n使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息\n\n定义错误边界当做常规组件包裹ui组件, 官网例子：\n\n```jsx\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    // 更新 state 使下一次渲染能够显示降级后的 UI\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // 你同样可以将错误日志上报给服务器\n    logErrorToMyService(error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // 你可以自定义降级后的 UI 并渲染\n      return <h1>Something went wrong.</h1>;\n    }\n\n    return this.props.children; \n  }\n}\n```\n\n```jsx\n<ErrorBoundary>\n  <MyWidget />\n</ErrorBoundary>\n```\n\n但是错误边界不会捕获 :\n\n```jsx\ntry{}catch(err){}\n///异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）\n///服务端渲染\n///它自身抛出来的错误（并非它的子组件)\n```\n\n## 21. React怎样引入svg的文件？\n\n方法1： 这种写法会由webpack转为url方式引入。\n\n```jsx\n// svg png等类型图片\nimport logo from './logo.svg';\n//...\n<img src={logo} className=\"App-logo\" alt=\"logo\" />\n//...\n```\n\n方法2： 这种方式仅对SVG图片生效，将svg看作组件导入：\n\n```jsx\n// ...\nimport { ReactComponent as Logo } from './logo.svg'\n// ...\n<Logo />\n```\n\n## 22. 在React中你有经常使用常量吗？\n\n在redux的action文件里面定义不同的行为可能会使用常量的形式。\n\n---\n\n第 8 天（2022.3.7）\n\n## 23. 为什么说React中的props是只读的？\n\n往单向数据流上答：\n保证react的单向数据流的设计模式，使状态更可预测。\n如果允许自组件修改，那么一个父组件将状态传递给好几个子组件，这几个子组件随意修改，就完全不可预测，不知道在什么地方修改了状态。\n所以我们必须像纯函数一样保护 props 不被修改\n\n## 24. 如果组件的属性没有传值，那么它的默认值是什么？\n\n[官网](https://zh-hans.reactjs.org/docs/jsx-in-depth.html#props-default-to-true)，如果你没给 prop 赋值，它的默认值是 true。以下两个 JSX 表达式是等价的：\n\n```jsx\n<MyTextBox autocomplete />\n\n<MyTextBox autocomplete={true} />\n```\n\n通常，我们不建议不传递 value 给 prop，因为这可能与 ES6 对象简写混淆，{foo} 是 {foo: foo} 的简写，而不是 {foo: true}。这样实现只是为了保持和 HTML 中标签属性的行为一致。\n\n## 25. `super()`和`super(props)`有什么区别？\n\nreact 中的class 是基于es6的规范实现的, 继承是使用extends关键字实现继承的，子类必须在constructor()中调用super() 方法否则新建实例就会报错，报错的原因是 子类是没有自己的this对象的，它只能继承父类的this对象，然后对其进行加工，而super()就是将父类中的this对象继承给子类的，没有super() 子类就得不到this对象。\n\n如果你使用了constructor就必须写super() 这个是用来初始化this的，可以绑定事件到this上\n如果你想要在constructor中使用this.props,就必须给super添加参数 super(props)\n注意，无论有没有 constructor，在render中的this.props都是可以使用的，这是react自动附带的\n如果没有用到constructor 是可以不写的，react会默认添加一个空的constroctor.\n\nsuper 指的是父类（即超类）的构造函数。\n\n在调用父类的构造函数之前，你是不能在 constructor 中使用 this 关键字的.\n\n参考 [why-do-we-write-super-props](https://overreacted.io/zh-hans/why-do-we-write-super-props/)","slug":"1-FE-Interview","published":1,"updated":"2022-03-07T03:15:09.912Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k5bv72000k0h3le07zc068","content":"<hr>\n<p>第 1 天（2022.2.28）</p>\n<h2 id=\"1-什么时候使用状态管理器？\"><a href=\"#1-什么时候使用状态管理器？\" class=\"headerlink\" title=\"1. 什么时候使用状态管理器？\"></a>1. 什么时候使用状态管理器？</h2><ol>\n<li>组件状态要在多个组件共享时</li>\n<li>某个组件状态需要在任何地方可以拿到</li>\n<li>一个组件需要改变全局状态时</li>\n<li>一个组件需要改变另一个组件状态时</li>\n<li>组件状态提升提升不能满足需求时，层级过多时。</li>\n</ol>\n<h2 id=\"2-render-函数中-return-如果没有使用-会有什么问题？\"><a href=\"#2-render-函数中-return-如果没有使用-会有什么问题？\" class=\"headerlink\" title=\"2. render 函数中 return 如果没有使用()会有什么问题？\"></a>2. render 函数中 return 如果没有使用()会有什么问题？</h2><p>避免遇到自动插入分号陷阱。</p>\n<p>我们在使用 JSX 语法书写 react 代码时，babel 会将 JSX 语法编译成 js，同时会在每行自动添加分号（；），如果 return 后换行了，那么就会变成 return； 一般情况下会报错：</p>\n<p>Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.<br>上面这段英文翻译成中文：</p>\n<p>渲染没有返回任何内容。这通常意味着缺少 return 语句。或者，为了不渲染，返回 null。<br>为了代码可读性我们一般会在 return 后面添加括号这样代码可以折行书写，否则就在 return 后面紧跟着语句，这样也是可以的。</p>\n<p>举两个正确的书写例子：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Nav = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;c_navbar&quot;</span>&gt;</span></span>\n<span class=\"xml\">      &#123; some jsx magic here &#125;</span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span></span>\n    )\n  &#125;\n\n<span class=\"hljs-keyword\">const</span> Nav = <span class=\"hljs-function\">() =&gt;</span> &#123;\n<span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;c_navbar&quot;</span>&gt;</span></span>\n<span class=\"xml\">    &#123; some jsx magic here &#125;</span>\n<span class=\"xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span></span>\n&#125;</code></pre></div>\n\n<p>错误的写法：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Nav = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">return</span>\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;c_navbar&quot;</span>&gt;</span></span>\n<span class=\"xml\">      &#123; some jsx magic here &#125;</span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span></span>\n&#125;</code></pre></div>\n\n<h2 id=\"3-componentWillUpdate-可以直接修改-state-的值吗？\"><a href=\"#3-componentWillUpdate-可以直接修改-state-的值吗？\" class=\"headerlink\" title=\"3. componentWillUpdate 可以直接修改 state 的值吗？\"></a>3. componentWillUpdate 可以直接修改 state 的值吗？</h2><p>直接修改不可以，但是加上条件就可以。</p>\n<p>文档原文：“你也可以在 componentDidUpdate() 中直接调用 setState()，但请注意它必须被包裹在一个条件语句里，正如上述的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。”</p>\n<p>componentWillReceiveProps 同理</p>\n<h2 id=\"4-说说你对-React-的渲染原理的理解\"><a href=\"#4-说说你对-React-的渲染原理的理解\" class=\"headerlink\" title=\"4. 说说你对 React 的渲染原理的理解\"></a>4. 说说你对 React 的渲染原理的理解</h2><ol>\n<li>React 会调用 React.render()构建一颗 DOM 树，生成虚拟 dom。</li>\n<li>通过改变 state 或 props 触发更新。</li>\n<li>对比新旧虚拟 dom，diff 算法，深度优先，将实际需要改变的反应到真实 dom。</li>\n</ol>\n<hr>\n<p>第 2 天（2022.3.1）</p>\n<h2 id=\"5-什么渲染劫持？\"><a href=\"#5-什么渲染劫持？\" class=\"headerlink\" title=\"5. 什么渲染劫持？\"></a>5. 什么渲染劫持？</h2><p>一般和高阶组件（HOC）一起解释。</p>\n<p>高阶组件在 render 的时候可以做其他操作，从而控制原组件的渲染输出，这种改变原组件渲染的方式称为 渲染劫持。</p>\n<p>在高阶组件中，组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可实现渲染劫持，还可以增强原组件 render 函数。</p>\n<p>除了 HOC，当新写一个组件，继承自一个已有的组件，可以随便修改 render 函数，使用 state、props 等改变原组件的渲染，都叫渲染劫持。</p>\n<p>PS: HOC 反向继承</p>\n<p>TODO：</p>\n<h2 id=\"6-React-Intl是什么原理？\"><a href=\"#6-React-Intl是什么原理？\" class=\"headerlink\" title=\"6. React Intl是什么原理？\"></a>6. React Intl是什么原理？</h2><p>React Intl 用途是国际化库，提供组件、日期等国际化方法。</p>\n<p>做国际化就类似于字体文件，通过切换语言，加载不同语言包到本地.</p>\n<p>最外层包一个Provider。调用库中方法，完成国际化。</p>\n<p>前端国际化核心步骤有两步：</p>\n<ul>\n<li>创建资源文件，以 key-value 方式存储</li>\n<li>加载资源文件，将页面上 key 的内容替换为相关 value</li>\n</ul>\n<h2 id=\"7-怎么实现React组件的国际化呢？\"><a href=\"#7-怎么实现React组件的国际化呢？\" class=\"headerlink\" title=\"7. 怎么实现React组件的国际化呢？\"></a>7. 怎么实现React组件的国际化呢？</h2><p> 使用 i18next 以及 react-i18next 配合 i18next-scanner，通过 grunt 跑 task 自动扫描生成 json 文件。</p>\n<p> 现在大厂比较常用的方案是，使用AST，每次开发完新版本，通过AST去扫描所有的代码，找出代码中的中文，以中文为key，调用智能翻译服务，去帮项目自动生成json文件。这样，再也不需要人为去维护json文件，一切都依赖工具进行自动化。</p>\n<hr>\n<p>第 3 天（2022.3.2）</p>\n<h2 id=\"8-说说Context有哪些属性？\"><a href=\"#8-说说Context有哪些属性？\" class=\"headerlink\" title=\"8. 说说Context有哪些属性？\"></a>8. 说说Context有哪些属性？</h2><p>context属于一种解决组件间层级过多传递数据的问题，避免了层层嵌套的通过props传递的形式，同时对于不需要使用到redux时，是一种解决方案。</p>\n<p>Context.Provider：生产者，数据提供方；通过value属性来定义需要被传递的数据<br>Context.Consumer：消费者，数据获取方；根据是函数组件还是class组件，有不同的使用形式；class组件可以指定contextType来确定要使用哪一个context对象的值，函数组件需要使用回调函数的形式来获取context的值；需要显示的指定context对象；</p>\n<h2 id=\"9-怎么使用Context开发组件？\"><a href=\"#9-怎么使用Context开发组件？\" class=\"headerlink\" title=\"9. 怎么使用Context开发组件？\"></a>9. 怎么使用Context开发组件？</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> themes = &#123;\n  <span class=\"hljs-attr\">light</span>: &#123;\n    <span class=\"hljs-attr\">foreground</span>: <span class=\"hljs-string\">&quot;#000000&quot;</span>,\n    <span class=\"hljs-attr\">background</span>: <span class=\"hljs-string\">&quot;#eeeeee&quot;</span>\n  &#125;,\n  <span class=\"hljs-attr\">dark</span>: &#123;\n    <span class=\"hljs-attr\">foreground</span>: <span class=\"hljs-string\">&quot;#ffffff&quot;</span>,\n    <span class=\"hljs-attr\">background</span>: <span class=\"hljs-string\">&quot;#222222&quot;</span>\n  &#125;\n&#125;;\n<span class=\"hljs-comment\">// 首先创建一个 context 对象这里命名为：ThemeContext</span>\n<span class=\"hljs-keyword\">const</span> ThemeContext = React.createContext(themes.light);\n\n<span class=\"hljs-comment\">// 创建一个祖先组件组件 内部使用Provier 这个对象创建一个组件 其中 value 属性是真实传递的属性</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ThemeContext.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;themes.dark&#125;</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Toolbar</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ThemeContext.Provider</span>&gt;</span></span>\n  );\n&#125;\n\n<span class=\"hljs-comment\">// 渲染 button 组件的外层包裹的属性</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Toolbar</span>(<span class=\"hljs-params\">props</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ThemedButton</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;\n\n<span class=\"hljs-comment\">// 在 Toolbar 中渲染的button 组件 使用 useContext，将 value 值跨组件传递给 // ThemeButton 组件</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ThemedButton</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> theme = useContext(ThemeContext);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&#123;&#123;</span> <span class=\"hljs-attr\">background:</span> <span class=\"hljs-attr\">theme.background</span>, <span class=\"hljs-attr\">color:</span> <span class=\"hljs-attr\">theme.foreground</span> &#125;&#125;&gt;</span></span>\n<span class=\"xml\">      I am styled by theme context!</span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n  );\n&#125;</code></pre></div>\n\n<h2 id=\"10-为什么React并不推荐我们优先考虑使用Context？\"><a href=\"#10-为什么React并不推荐我们优先考虑使用Context？\" class=\"headerlink\" title=\"10. 为什么React并不推荐我们优先考虑使用Context？\"></a>10. 为什么React并不推荐我们优先考虑使用Context？</h2><p>1、Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。<br>2、尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context<br>3、对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。<br>4、context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注。</p>\n<hr>\n<p>第 4 天（2022.3.3）</p>\n<h2 id=\"11-childContextTypes是什么？它有什么用？\"><a href=\"#11-childContextTypes是什么？它有什么用？\" class=\"headerlink\" title=\"11. childContextTypes是什么？它有什么用？\"></a>11. childContextTypes是什么？它有什么用？</h2><p>childContextTypes用来定义context数据类型，该api从16.3开始已被废弃</p>\n<p>使用方式</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MessageList</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">getChildContext</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;purple&quot;</span>&#125;;\n  &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>MessageList<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n  &#125;\n&#125;\n\nMessageList.childContextTypes = &#123;\n  <span class=\"hljs-attr\">color</span>: PropTypes.string\n&#125;;\n</code></pre></div>\n\n<h2 id=\"12-Consumer向上找不到Provider的时候怎么办？\"><a href=\"#12-Consumer向上找不到Provider的时候怎么办？\" class=\"headerlink\" title=\"12. Consumer向上找不到Provider的时候怎么办？\"></a>12. Consumer向上找不到Provider的时候怎么办？</h2><p>当consumer向上层找不到provider时，此时就会取创建context时传给createContext的那个值，也就是当前context对象的默认值，在定义provider时的value中的值不是默认值，而是表示需要被传递的值.</p>\n<hr>\n<p>第 5 天（2022.3.4）</p>\n<h2 id=\"13-说说你对windowing的了解\"><a href=\"#13-说说你对windowing的了解\" class=\"headerlink\" title=\"13. 说说你对windowing的了解\"></a>13. 说说你对windowing的了解</h2><p>展示长列表<br>如果你的应用会渲染大量的列表数据，我们建议使用一种称为‘windowing’的技术，这种技术下在任何给定的时间内只会渲染一小部分数据列表，并可以减少列表项的重复渲染（即再次渲染已经渲染过的数据）。</p>\n<p>react-window和react-virtualized都是流行的使用windowing技术的库，他们都提供了一系列可重用的组件，这些组件能够帮助你以最好的性能展示列表以及表格数据</p>\n<h2 id=\"14-举例说明React的-portal-有哪些运用场景？\"><a href=\"#14-举例说明React的-portal-有哪些运用场景？\" class=\"headerlink\" title=\"14. 举例说明React的 portal 有哪些运用场景？\"></a>14. 举例说明React的 portal 有哪些运用场景？</h2><p>portal可以将内容插入到除了父节点的dom之外的地方去渲染，所以modal是一个通过portal实现的典型例子；并且对于事件绑定，因为使用了事件冒泡，所以并不用担心被渲染到父组件结构之外的内容，不能去监听事件</p>\n<h2 id=\"15-你有用过React的插槽-Portals-吗？怎么用？\"><a href=\"#15-你有用过React的插槽-Portals-吗？怎么用？\" class=\"headerlink\" title=\"15. 你有用过React的插槽(Portals)吗？怎么用？\"></a>15. 你有用过React的插槽(Portals)吗？怎么用？</h2><p>1、首先简单的介绍下react中的插槽（Portals），通过ReactDOM.createPortal(child, container)创建，是ReactDOM提供的接口，可以实现将子节点渲染到父组件DOM层次结构之外的DOM节点。<br>2、第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 片段(fragment)。第二个参数（container）则是一个 DOM 元素。<br>3、对于 portal 的一个典型用例是当父组件有 overflow: hidden 或 z-index 样式，但你需要子组件能够在视觉上 “跳出(break out)” 其容器。例如，对话框、hovercards以及提示框。所以一般react组件里的模态框，就是这样实现的。</p>\n<p>如果一个子组件的真实DOM结构必须渲染到当前组件外，但又想保留这两者的父子关系，就可以用Protals。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Modal = <span class=\"hljs-function\">(<span class=\"hljs-params\">props</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> modal = <span class=\"hljs-built_in\">document</span>.body.createElement(<span class=\"hljs-string\">&#x27;div&#x27;</span>);\n  <span class=\"hljs-built_in\">document</span>.appendChild(modal);\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">document</span>.body.removeChild(modal);\n    &#125;\n  &#125;, []);\n  <span class=\"hljs-keyword\">return</span> React.createPortal(<span class=\"hljs-built_in\">this</span>.props.children, modal);\n&#125;\n<span class=\"hljs-keyword\">const</span> Parent = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> [sum, setSum] = useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\">() =&gt;</span> setSum(sum + <span class=\"hljs-number\">1</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;add&#125;</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Modal</span>&gt;</span>加一<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Modal</span>&gt;</span></span>\n<span class=\"xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n&#125;</code></pre></div>\n\n<hr>\n<p>第 6 天（2022.3.5）</p>\n<h2 id=\"16-React的严格模式有什么用处？\"><a href=\"#16-React的严格模式有什么用处？\" class=\"headerlink\" title=\"16. React的严格模式有什么用处？\"></a>16. React的严格模式有什么用处？</h2><p>StrictMode 目前有助于：</p>\n<ul>\n<li>识别不安全的生命周期</li>\n<li>关于使用过时字符串 ref API 的警告</li>\n<li>关于使用废弃的 findDOMNode 方法的警告</li>\n<li>检测意外的副作用</li>\n<li>检测过时的 context API</li>\n</ul>\n<p>可以为程序的任何部分使用严格模式</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ExampleApplication</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Header</span> /&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">React.StrictMode</span>&gt;</span></span>\n<span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ComponentOne</span> /&gt;</span></span>\n<span class=\"xml\">          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ComponentTwo</span> /&gt;</span></span>\n<span class=\"xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">React.StrictMode</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Footer</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;\n<span class=\"hljs-comment\">// 不会对 Header 和 Footer 组件运行严格模式检查。但是，ComponentOne 和 ComponentTwo 以及它们的所有后代元素都将进行检查。</span></code></pre></div>\n\n<h2 id=\"17-React如何进行代码拆分？拆分的原则是什么？\"><a href=\"#17-React如何进行代码拆分？拆分的原则是什么？\" class=\"headerlink\" title=\"17. React如何进行代码拆分？拆分的原则是什么？\"></a>17. React如何进行代码拆分？拆分的原则是什么？</h2><p>react的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。</p>\n<p>在我们的react项目中：<br>1、在 api 层面我们单独封装，对外暴露http请求的结果。<br>2、数据层我们使用的react-redux 异步中间件使用的是redux-thunk 分装处理异步请求，合业务逻辑处理。<br>3、视图层，尽量使用 redux 层面的传递过来的数据，修改逻辑 也是重新触发action 更改props。<br>4、静态类型的资源单独放置<br>5、公共组件、高阶组件、插件单独放置<br>6、工具类文件单独放置</p>\n<h2 id=\"18-React组件的构造函数有什么作用？\"><a href=\"#18-React组件的构造函数有什么作用？\" class=\"headerlink\" title=\"18. React组件的构造函数有什么作用？\"></a>18. React组件的构造函数有什么作用？</h2><p>官网中，构造函数仅用于以下两种情况：</p>\n<ul>\n<li>通过给 this.state 赋值对象来初始化内部 state。</li>\n<li>为事件处理函数绑定实例</li>\n</ul>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;\n  <span class=\"hljs-built_in\">super</span>(props);\n  <span class=\"hljs-comment\">// 不要在这里调用 this.setState()</span>\n  <span class=\"hljs-built_in\">this</span>.state = &#123; <span class=\"hljs-attr\">counter</span>: <span class=\"hljs-number\">0</span> &#125;;\n  <span class=\"hljs-built_in\">this</span>.handleClick = <span class=\"hljs-built_in\">this</span>.handleClick.bind(<span class=\"hljs-built_in\">this</span>);\n&#125;</code></pre></div>\n\n<p>避免将 props 的值复制给 state！这是一个常见的错误：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;\n <span class=\"hljs-built_in\">super</span>(props);\n <span class=\"hljs-comment\">// 不要这样做</span>\n <span class=\"hljs-built_in\">this</span>.state = &#123; <span class=\"hljs-attr\">color</span>: props.color &#125;;\n&#125;</code></pre></div>\n\n<p>如此做毫无必要（你可以直接使用 this.props.color），同时还产生了 bug（更新 prop 中的 color 时，并不会影响 state）。</p>\n<h2 id=\"19-React组件的构造函数是必须的吗？\"><a href=\"#19-React组件的构造函数是必须的吗？\" class=\"headerlink\" title=\"19. React组件的构造函数是必须的吗？\"></a>19. React组件的构造函数是必须的吗？</h2><p>function组件不用考虑构造函数；<br>对于class组件，如果不写构造函数，默认会被隐式调用.</p>\n<p>对于无状态组件，内部没有维护自己的state，只接收外部传入的props 是不需要声明构造函数的.</p>\n<hr>\n<p>第 7 天（2022.3.6）</p>\n<h2 id=\"20-React中在哪捕获错误？\"><a href=\"#20-React中在哪捕获错误？\" class=\"headerlink\" title=\"20. React中在哪捕获错误？\"></a>20. React中在哪捕获错误？</h2><p>可以使用错误边界组件来捕获异常；这样可以使用替代ui来代替错误位置的渲染；而不是让程序崩溃；<br>主要来捕获生命周期异常，渲染中的异常</p>\n<p>使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息</p>\n<p>定义错误边界当做常规组件包裹ui组件, 官网例子：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ErrorBoundary</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;\n    <span class=\"hljs-built_in\">super</span>(props);\n    <span class=\"hljs-built_in\">this</span>.state = &#123; <span class=\"hljs-attr\">hasError</span>: <span class=\"hljs-literal\">false</span> &#125;;\n  &#125;\n\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-function\"><span class=\"hljs-title\">getDerivedStateFromError</span>(<span class=\"hljs-params\">error</span>)</span> &#123;\n    <span class=\"hljs-comment\">// 更新 state 使下一次渲染能够显示降级后的 UI</span>\n    <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">hasError</span>: <span class=\"hljs-literal\">true</span> &#125;;\n  &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidCatch</span>(<span class=\"hljs-params\">error, errorInfo</span>)</span> &#123;\n    <span class=\"hljs-comment\">// 你同样可以将错误日志上报给服务器</span>\n    logErrorToMyService(error, errorInfo);\n  &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.state.hasError) &#123;\n      <span class=\"hljs-comment\">// 你可以自定义降级后的 UI 并渲染</span>\n      <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Something went wrong.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n    &#125;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.props.children; \n  &#125;\n&#125;</code></pre></div>\n\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\">&lt;ErrorBoundary&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyWidget</span> /&gt;</span></span>\n&lt;/ErrorBoundary&gt;</code></pre></div>\n\n<p>但是错误边界不会捕获 :</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">try</span>&#123;&#125;<span class=\"hljs-keyword\">catch</span>(err)&#123;&#125;\n<span class=\"hljs-comment\">///异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）</span>\n<span class=\"hljs-comment\">///服务端渲染</span>\n<span class=\"hljs-comment\">///它自身抛出来的错误（并非它的子组件)</span></code></pre></div>\n\n<h2 id=\"21-React怎样引入svg的文件？\"><a href=\"#21-React怎样引入svg的文件？\" class=\"headerlink\" title=\"21. React怎样引入svg的文件？\"></a>21. React怎样引入svg的文件？</h2><p>方法1： 这种写法会由webpack转为url方式引入。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// svg png等类型图片</span>\n<span class=\"hljs-keyword\">import</span> logo <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./logo.svg&#x27;</span>;\n<span class=\"hljs-comment\">//...</span>\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&#123;logo&#125;</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;App-logo&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;logo&quot;</span> /&gt;</span></span>\n<span class=\"hljs-comment\">//...</span></code></pre></div>\n\n<p>方法2： 这种方式仅对SVG图片生效，将svg看作组件导入：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-keyword\">import</span> &#123; ReactComponent <span class=\"hljs-keyword\">as</span> Logo &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./logo.svg&#x27;</span>\n<span class=\"hljs-comment\">// ...</span>\n&lt;Logo /&gt;</code></pre></div>\n\n<h2 id=\"22-在React中你有经常使用常量吗？\"><a href=\"#22-在React中你有经常使用常量吗？\" class=\"headerlink\" title=\"22. 在React中你有经常使用常量吗？\"></a>22. 在React中你有经常使用常量吗？</h2><p>在redux的action文件里面定义不同的行为可能会使用常量的形式。</p>\n<hr>\n<p>第 8 天（2022.3.7）</p>\n<h2 id=\"23-为什么说React中的props是只读的？\"><a href=\"#23-为什么说React中的props是只读的？\" class=\"headerlink\" title=\"23. 为什么说React中的props是只读的？\"></a>23. 为什么说React中的props是只读的？</h2><p>往单向数据流上答：<br>保证react的单向数据流的设计模式，使状态更可预测。<br>如果允许自组件修改，那么一个父组件将状态传递给好几个子组件，这几个子组件随意修改，就完全不可预测，不知道在什么地方修改了状态。<br>所以我们必须像纯函数一样保护 props 不被修改</p>\n<h2 id=\"24-如果组件的属性没有传值，那么它的默认值是什么？\"><a href=\"#24-如果组件的属性没有传值，那么它的默认值是什么？\" class=\"headerlink\" title=\"24. 如果组件的属性没有传值，那么它的默认值是什么？\"></a>24. 如果组件的属性没有传值，那么它的默认值是什么？</h2><p><a href=\"https://zh-hans.reactjs.org/docs/jsx-in-depth.html#props-default-to-true\">官网</a>，如果你没给 prop 赋值，它的默认值是 true。以下两个 JSX 表达式是等价的：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\">&lt;MyTextBox autocomplete /&gt;\n\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyTextBox</span> <span class=\"hljs-attr\">autocomplete</span>=<span class=\"hljs-string\">&#123;true&#125;</span> /&gt;</span></span></code></pre></div>\n\n<p>通常，我们不建议不传递 value 给 prop，因为这可能与 ES6 对象简写混淆，{foo} 是 {foo: foo} 的简写，而不是 {foo: true}。这样实现只是为了保持和 HTML 中标签属性的行为一致。</p>\n<h2 id=\"25-super-和super-props-有什么区别？\"><a href=\"#25-super-和super-props-有什么区别？\" class=\"headerlink\" title=\"25. super()和super(props)有什么区别？\"></a>25. <code>super()</code>和<code>super(props)</code>有什么区别？</h2><p>react 中的class 是基于es6的规范实现的, 继承是使用extends关键字实现继承的，子类必须在constructor()中调用super() 方法否则新建实例就会报错，报错的原因是 子类是没有自己的this对象的，它只能继承父类的this对象，然后对其进行加工，而super()就是将父类中的this对象继承给子类的，没有super() 子类就得不到this对象。</p>\n<p>如果你使用了constructor就必须写super() 这个是用来初始化this的，可以绑定事件到this上<br>如果你想要在constructor中使用this.props,就必须给super添加参数 super(props)<br>注意，无论有没有 constructor，在render中的this.props都是可以使用的，这是react自动附带的<br>如果没有用到constructor 是可以不写的，react会默认添加一个空的constroctor.</p>\n<p>super 指的是父类（即超类）的构造函数。</p>\n<p>在调用父类的构造函数之前，你是不能在 constructor 中使用 this 关键字的.</p>\n<p>参考 <a href=\"https://overreacted.io/zh-hans/why-do-we-write-super-props/\">why-do-we-write-super-props</a></p>\n","site":{"data":{}},"wordcount":8450,"excerpt":"","more":"<hr>\n<p>第 1 天（2022.2.28）</p>\n<h2 id=\"1-什么时候使用状态管理器？\"><a href=\"#1-什么时候使用状态管理器？\" class=\"headerlink\" title=\"1. 什么时候使用状态管理器？\"></a>1. 什么时候使用状态管理器？</h2><ol>\n<li>组件状态要在多个组件共享时</li>\n<li>某个组件状态需要在任何地方可以拿到</li>\n<li>一个组件需要改变全局状态时</li>\n<li>一个组件需要改变另一个组件状态时</li>\n<li>组件状态提升提升不能满足需求时，层级过多时。</li>\n</ol>\n<h2 id=\"2-render-函数中-return-如果没有使用-会有什么问题？\"><a href=\"#2-render-函数中-return-如果没有使用-会有什么问题？\" class=\"headerlink\" title=\"2. render 函数中 return 如果没有使用()会有什么问题？\"></a>2. render 函数中 return 如果没有使用()会有什么问题？</h2><p>避免遇到自动插入分号陷阱。</p>\n<p>我们在使用 JSX 语法书写 react 代码时，babel 会将 JSX 语法编译成 js，同时会在每行自动添加分号（；），如果 return 后换行了，那么就会变成 return； 一般情况下会报错：</p>\n<p>Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.<br>上面这段英文翻译成中文：</p>\n<p>渲染没有返回任何内容。这通常意味着缺少 return 语句。或者，为了不渲染，返回 null。<br>为了代码可读性我们一般会在 return 后面添加括号这样代码可以折行书写，否则就在 return 后面紧跟着语句，这样也是可以的。</p>\n<p>举两个正确的书写例子：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Nav = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;c_navbar&quot;</span>&gt;</span></span>\n<span class=\"xml\">      &#123; some jsx magic here &#125;</span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span></span>\n    )\n  &#125;\n\n<span class=\"hljs-keyword\">const</span> Nav = <span class=\"hljs-function\">() =&gt;</span> &#123;\n<span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;c_navbar&quot;</span>&gt;</span></span>\n<span class=\"xml\">    &#123; some jsx magic here &#125;</span>\n<span class=\"xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span></span>\n&#125;</code></pre>\n\n<p>错误的写法：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Nav = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">return</span>\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;c_navbar&quot;</span>&gt;</span></span>\n<span class=\"xml\">      &#123; some jsx magic here &#125;</span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span></span>\n&#125;</code></pre>\n\n<h2 id=\"3-componentWillUpdate-可以直接修改-state-的值吗？\"><a href=\"#3-componentWillUpdate-可以直接修改-state-的值吗？\" class=\"headerlink\" title=\"3. componentWillUpdate 可以直接修改 state 的值吗？\"></a>3. componentWillUpdate 可以直接修改 state 的值吗？</h2><p>直接修改不可以，但是加上条件就可以。</p>\n<p>文档原文：“你也可以在 componentDidUpdate() 中直接调用 setState()，但请注意它必须被包裹在一个条件语句里，正如上述的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。”</p>\n<p>componentWillReceiveProps 同理</p>\n<h2 id=\"4-说说你对-React-的渲染原理的理解\"><a href=\"#4-说说你对-React-的渲染原理的理解\" class=\"headerlink\" title=\"4. 说说你对 React 的渲染原理的理解\"></a>4. 说说你对 React 的渲染原理的理解</h2><ol>\n<li>React 会调用 React.render()构建一颗 DOM 树，生成虚拟 dom。</li>\n<li>通过改变 state 或 props 触发更新。</li>\n<li>对比新旧虚拟 dom，diff 算法，深度优先，将实际需要改变的反应到真实 dom。</li>\n</ol>\n<hr>\n<p>第 2 天（2022.3.1）</p>\n<h2 id=\"5-什么渲染劫持？\"><a href=\"#5-什么渲染劫持？\" class=\"headerlink\" title=\"5. 什么渲染劫持？\"></a>5. 什么渲染劫持？</h2><p>一般和高阶组件（HOC）一起解释。</p>\n<p>高阶组件在 render 的时候可以做其他操作，从而控制原组件的渲染输出，这种改变原组件渲染的方式称为 渲染劫持。</p>\n<p>在高阶组件中，组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可实现渲染劫持，还可以增强原组件 render 函数。</p>\n<p>除了 HOC，当新写一个组件，继承自一个已有的组件，可以随便修改 render 函数，使用 state、props 等改变原组件的渲染，都叫渲染劫持。</p>\n<p>PS: HOC 反向继承</p>\n<p>TODO：</p>\n<h2 id=\"6-React-Intl是什么原理？\"><a href=\"#6-React-Intl是什么原理？\" class=\"headerlink\" title=\"6. React Intl是什么原理？\"></a>6. React Intl是什么原理？</h2><p>React Intl 用途是国际化库，提供组件、日期等国际化方法。</p>\n<p>做国际化就类似于字体文件，通过切换语言，加载不同语言包到本地.</p>\n<p>最外层包一个Provider。调用库中方法，完成国际化。</p>\n<p>前端国际化核心步骤有两步：</p>\n<ul>\n<li>创建资源文件，以 key-value 方式存储</li>\n<li>加载资源文件，将页面上 key 的内容替换为相关 value</li>\n</ul>\n<h2 id=\"7-怎么实现React组件的国际化呢？\"><a href=\"#7-怎么实现React组件的国际化呢？\" class=\"headerlink\" title=\"7. 怎么实现React组件的国际化呢？\"></a>7. 怎么实现React组件的国际化呢？</h2><p> 使用 i18next 以及 react-i18next 配合 i18next-scanner，通过 grunt 跑 task 自动扫描生成 json 文件。</p>\n<p> 现在大厂比较常用的方案是，使用AST，每次开发完新版本，通过AST去扫描所有的代码，找出代码中的中文，以中文为key，调用智能翻译服务，去帮项目自动生成json文件。这样，再也不需要人为去维护json文件，一切都依赖工具进行自动化。</p>\n<hr>\n<p>第 3 天（2022.3.2）</p>\n<h2 id=\"8-说说Context有哪些属性？\"><a href=\"#8-说说Context有哪些属性？\" class=\"headerlink\" title=\"8. 说说Context有哪些属性？\"></a>8. 说说Context有哪些属性？</h2><p>context属于一种解决组件间层级过多传递数据的问题，避免了层层嵌套的通过props传递的形式，同时对于不需要使用到redux时，是一种解决方案。</p>\n<p>Context.Provider：生产者，数据提供方；通过value属性来定义需要被传递的数据<br>Context.Consumer：消费者，数据获取方；根据是函数组件还是class组件，有不同的使用形式；class组件可以指定contextType来确定要使用哪一个context对象的值，函数组件需要使用回调函数的形式来获取context的值；需要显示的指定context对象；</p>\n<h2 id=\"9-怎么使用Context开发组件？\"><a href=\"#9-怎么使用Context开发组件？\" class=\"headerlink\" title=\"9. 怎么使用Context开发组件？\"></a>9. 怎么使用Context开发组件？</h2><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> themes = &#123;\n  <span class=\"hljs-attr\">light</span>: &#123;\n    <span class=\"hljs-attr\">foreground</span>: <span class=\"hljs-string\">&quot;#000000&quot;</span>,\n    <span class=\"hljs-attr\">background</span>: <span class=\"hljs-string\">&quot;#eeeeee&quot;</span>\n  &#125;,\n  <span class=\"hljs-attr\">dark</span>: &#123;\n    <span class=\"hljs-attr\">foreground</span>: <span class=\"hljs-string\">&quot;#ffffff&quot;</span>,\n    <span class=\"hljs-attr\">background</span>: <span class=\"hljs-string\">&quot;#222222&quot;</span>\n  &#125;\n&#125;;\n<span class=\"hljs-comment\">// 首先创建一个 context 对象这里命名为：ThemeContext</span>\n<span class=\"hljs-keyword\">const</span> ThemeContext = React.createContext(themes.light);\n\n<span class=\"hljs-comment\">// 创建一个祖先组件组件 内部使用Provier 这个对象创建一个组件 其中 value 属性是真实传递的属性</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ThemeContext.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;themes.dark&#125;</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Toolbar</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ThemeContext.Provider</span>&gt;</span></span>\n  );\n&#125;\n\n<span class=\"hljs-comment\">// 渲染 button 组件的外层包裹的属性</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Toolbar</span>(<span class=\"hljs-params\">props</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ThemedButton</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;\n\n<span class=\"hljs-comment\">// 在 Toolbar 中渲染的button 组件 使用 useContext，将 value 值跨组件传递给 // ThemeButton 组件</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ThemedButton</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> theme = useContext(ThemeContext);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&#123;&#123;</span> <span class=\"hljs-attr\">background:</span> <span class=\"hljs-attr\">theme.background</span>, <span class=\"hljs-attr\">color:</span> <span class=\"hljs-attr\">theme.foreground</span> &#125;&#125;&gt;</span></span>\n<span class=\"xml\">      I am styled by theme context!</span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n  );\n&#125;</code></pre>\n\n<h2 id=\"10-为什么React并不推荐我们优先考虑使用Context？\"><a href=\"#10-为什么React并不推荐我们优先考虑使用Context？\" class=\"headerlink\" title=\"10. 为什么React并不推荐我们优先考虑使用Context？\"></a>10. 为什么React并不推荐我们优先考虑使用Context？</h2><p>1、Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。<br>2、尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context<br>3、对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。<br>4、context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注。</p>\n<hr>\n<p>第 4 天（2022.3.3）</p>\n<h2 id=\"11-childContextTypes是什么？它有什么用？\"><a href=\"#11-childContextTypes是什么？它有什么用？\" class=\"headerlink\" title=\"11. childContextTypes是什么？它有什么用？\"></a>11. childContextTypes是什么？它有什么用？</h2><p>childContextTypes用来定义context数据类型，该api从16.3开始已被废弃</p>\n<p>使用方式</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MessageList</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">getChildContext</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;purple&quot;</span>&#125;;\n  &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>MessageList<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n  &#125;\n&#125;\n\nMessageList.childContextTypes = &#123;\n  <span class=\"hljs-attr\">color</span>: PropTypes.string\n&#125;;\n</code></pre>\n\n<h2 id=\"12-Consumer向上找不到Provider的时候怎么办？\"><a href=\"#12-Consumer向上找不到Provider的时候怎么办？\" class=\"headerlink\" title=\"12. Consumer向上找不到Provider的时候怎么办？\"></a>12. Consumer向上找不到Provider的时候怎么办？</h2><p>当consumer向上层找不到provider时，此时就会取创建context时传给createContext的那个值，也就是当前context对象的默认值，在定义provider时的value中的值不是默认值，而是表示需要被传递的值.</p>\n<hr>\n<p>第 5 天（2022.3.4）</p>\n<h2 id=\"13-说说你对windowing的了解\"><a href=\"#13-说说你对windowing的了解\" class=\"headerlink\" title=\"13. 说说你对windowing的了解\"></a>13. 说说你对windowing的了解</h2><p>展示长列表<br>如果你的应用会渲染大量的列表数据，我们建议使用一种称为‘windowing’的技术，这种技术下在任何给定的时间内只会渲染一小部分数据列表，并可以减少列表项的重复渲染（即再次渲染已经渲染过的数据）。</p>\n<p>react-window和react-virtualized都是流行的使用windowing技术的库，他们都提供了一系列可重用的组件，这些组件能够帮助你以最好的性能展示列表以及表格数据</p>\n<h2 id=\"14-举例说明React的-portal-有哪些运用场景？\"><a href=\"#14-举例说明React的-portal-有哪些运用场景？\" class=\"headerlink\" title=\"14. 举例说明React的 portal 有哪些运用场景？\"></a>14. 举例说明React的 portal 有哪些运用场景？</h2><p>portal可以将内容插入到除了父节点的dom之外的地方去渲染，所以modal是一个通过portal实现的典型例子；并且对于事件绑定，因为使用了事件冒泡，所以并不用担心被渲染到父组件结构之外的内容，不能去监听事件</p>\n<h2 id=\"15-你有用过React的插槽-Portals-吗？怎么用？\"><a href=\"#15-你有用过React的插槽-Portals-吗？怎么用？\" class=\"headerlink\" title=\"15. 你有用过React的插槽(Portals)吗？怎么用？\"></a>15. 你有用过React的插槽(Portals)吗？怎么用？</h2><p>1、首先简单的介绍下react中的插槽（Portals），通过ReactDOM.createPortal(child, container)创建，是ReactDOM提供的接口，可以实现将子节点渲染到父组件DOM层次结构之外的DOM节点。<br>2、第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 片段(fragment)。第二个参数（container）则是一个 DOM 元素。<br>3、对于 portal 的一个典型用例是当父组件有 overflow: hidden 或 z-index 样式，但你需要子组件能够在视觉上 “跳出(break out)” 其容器。例如，对话框、hovercards以及提示框。所以一般react组件里的模态框，就是这样实现的。</p>\n<p>如果一个子组件的真实DOM结构必须渲染到当前组件外，但又想保留这两者的父子关系，就可以用Protals。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Modal = <span class=\"hljs-function\">(<span class=\"hljs-params\">props</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> modal = <span class=\"hljs-built_in\">document</span>.body.createElement(<span class=\"hljs-string\">&#x27;div&#x27;</span>);\n  <span class=\"hljs-built_in\">document</span>.appendChild(modal);\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">document</span>.body.removeChild(modal);\n    &#125;\n  &#125;, []);\n  <span class=\"hljs-keyword\">return</span> React.createPortal(<span class=\"hljs-built_in\">this</span>.props.children, modal);\n&#125;\n<span class=\"hljs-keyword\">const</span> Parent = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> [sum, setSum] = useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\">() =&gt;</span> setSum(sum + <span class=\"hljs-number\">1</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;add&#125;</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Modal</span>&gt;</span>加一<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Modal</span>&gt;</span></span>\n<span class=\"xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n&#125;</code></pre>\n\n<hr>\n<p>第 6 天（2022.3.5）</p>\n<h2 id=\"16-React的严格模式有什么用处？\"><a href=\"#16-React的严格模式有什么用处？\" class=\"headerlink\" title=\"16. React的严格模式有什么用处？\"></a>16. React的严格模式有什么用处？</h2><p>StrictMode 目前有助于：</p>\n<ul>\n<li>识别不安全的生命周期</li>\n<li>关于使用过时字符串 ref API 的警告</li>\n<li>关于使用废弃的 findDOMNode 方法的警告</li>\n<li>检测意外的副作用</li>\n<li>检测过时的 context API</li>\n</ul>\n<p>可以为程序的任何部分使用严格模式</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ExampleApplication</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Header</span> /&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">React.StrictMode</span>&gt;</span></span>\n<span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ComponentOne</span> /&gt;</span></span>\n<span class=\"xml\">          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ComponentTwo</span> /&gt;</span></span>\n<span class=\"xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">React.StrictMode</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Footer</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;\n<span class=\"hljs-comment\">// 不会对 Header 和 Footer 组件运行严格模式检查。但是，ComponentOne 和 ComponentTwo 以及它们的所有后代元素都将进行检查。</span></code></pre>\n\n<h2 id=\"17-React如何进行代码拆分？拆分的原则是什么？\"><a href=\"#17-React如何进行代码拆分？拆分的原则是什么？\" class=\"headerlink\" title=\"17. React如何进行代码拆分？拆分的原则是什么？\"></a>17. React如何进行代码拆分？拆分的原则是什么？</h2><p>react的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。</p>\n<p>在我们的react项目中：<br>1、在 api 层面我们单独封装，对外暴露http请求的结果。<br>2、数据层我们使用的react-redux 异步中间件使用的是redux-thunk 分装处理异步请求，合业务逻辑处理。<br>3、视图层，尽量使用 redux 层面的传递过来的数据，修改逻辑 也是重新触发action 更改props。<br>4、静态类型的资源单独放置<br>5、公共组件、高阶组件、插件单独放置<br>6、工具类文件单独放置</p>\n<h2 id=\"18-React组件的构造函数有什么作用？\"><a href=\"#18-React组件的构造函数有什么作用？\" class=\"headerlink\" title=\"18. React组件的构造函数有什么作用？\"></a>18. React组件的构造函数有什么作用？</h2><p>官网中，构造函数仅用于以下两种情况：</p>\n<ul>\n<li>通过给 this.state 赋值对象来初始化内部 state。</li>\n<li>为事件处理函数绑定实例</li>\n</ul>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;\n  <span class=\"hljs-built_in\">super</span>(props);\n  <span class=\"hljs-comment\">// 不要在这里调用 this.setState()</span>\n  <span class=\"hljs-built_in\">this</span>.state = &#123; <span class=\"hljs-attr\">counter</span>: <span class=\"hljs-number\">0</span> &#125;;\n  <span class=\"hljs-built_in\">this</span>.handleClick = <span class=\"hljs-built_in\">this</span>.handleClick.bind(<span class=\"hljs-built_in\">this</span>);\n&#125;</code></pre>\n\n<p>避免将 props 的值复制给 state！这是一个常见的错误：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;\n <span class=\"hljs-built_in\">super</span>(props);\n <span class=\"hljs-comment\">// 不要这样做</span>\n <span class=\"hljs-built_in\">this</span>.state = &#123; <span class=\"hljs-attr\">color</span>: props.color &#125;;\n&#125;</code></pre>\n\n<p>如此做毫无必要（你可以直接使用 this.props.color），同时还产生了 bug（更新 prop 中的 color 时，并不会影响 state）。</p>\n<h2 id=\"19-React组件的构造函数是必须的吗？\"><a href=\"#19-React组件的构造函数是必须的吗？\" class=\"headerlink\" title=\"19. React组件的构造函数是必须的吗？\"></a>19. React组件的构造函数是必须的吗？</h2><p>function组件不用考虑构造函数；<br>对于class组件，如果不写构造函数，默认会被隐式调用.</p>\n<p>对于无状态组件，内部没有维护自己的state，只接收外部传入的props 是不需要声明构造函数的.</p>\n<hr>\n<p>第 7 天（2022.3.6）</p>\n<h2 id=\"20-React中在哪捕获错误？\"><a href=\"#20-React中在哪捕获错误？\" class=\"headerlink\" title=\"20. React中在哪捕获错误？\"></a>20. React中在哪捕获错误？</h2><p>可以使用错误边界组件来捕获异常；这样可以使用替代ui来代替错误位置的渲染；而不是让程序崩溃；<br>主要来捕获生命周期异常，渲染中的异常</p>\n<p>使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息</p>\n<p>定义错误边界当做常规组件包裹ui组件, 官网例子：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ErrorBoundary</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;\n    <span class=\"hljs-built_in\">super</span>(props);\n    <span class=\"hljs-built_in\">this</span>.state = &#123; <span class=\"hljs-attr\">hasError</span>: <span class=\"hljs-literal\">false</span> &#125;;\n  &#125;\n\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-function\"><span class=\"hljs-title\">getDerivedStateFromError</span>(<span class=\"hljs-params\">error</span>)</span> &#123;\n    <span class=\"hljs-comment\">// 更新 state 使下一次渲染能够显示降级后的 UI</span>\n    <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">hasError</span>: <span class=\"hljs-literal\">true</span> &#125;;\n  &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidCatch</span>(<span class=\"hljs-params\">error, errorInfo</span>)</span> &#123;\n    <span class=\"hljs-comment\">// 你同样可以将错误日志上报给服务器</span>\n    logErrorToMyService(error, errorInfo);\n  &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.state.hasError) &#123;\n      <span class=\"hljs-comment\">// 你可以自定义降级后的 UI 并渲染</span>\n      <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Something went wrong.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n    &#125;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.props.children; \n  &#125;\n&#125;</code></pre>\n\n<pre><code class=\"hljs jsx\">&lt;ErrorBoundary&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyWidget</span> /&gt;</span></span>\n&lt;/ErrorBoundary&gt;</code></pre>\n\n<p>但是错误边界不会捕获 :</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">try</span>&#123;&#125;<span class=\"hljs-keyword\">catch</span>(err)&#123;&#125;\n<span class=\"hljs-comment\">///异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）</span>\n<span class=\"hljs-comment\">///服务端渲染</span>\n<span class=\"hljs-comment\">///它自身抛出来的错误（并非它的子组件)</span></code></pre>\n\n<h2 id=\"21-React怎样引入svg的文件？\"><a href=\"#21-React怎样引入svg的文件？\" class=\"headerlink\" title=\"21. React怎样引入svg的文件？\"></a>21. React怎样引入svg的文件？</h2><p>方法1： 这种写法会由webpack转为url方式引入。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// svg png等类型图片</span>\n<span class=\"hljs-keyword\">import</span> logo <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./logo.svg&#x27;</span>;\n<span class=\"hljs-comment\">//...</span>\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&#123;logo&#125;</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;App-logo&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;logo&quot;</span> /&gt;</span></span>\n<span class=\"hljs-comment\">//...</span></code></pre>\n\n<p>方法2： 这种方式仅对SVG图片生效，将svg看作组件导入：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-keyword\">import</span> &#123; ReactComponent <span class=\"hljs-keyword\">as</span> Logo &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./logo.svg&#x27;</span>\n<span class=\"hljs-comment\">// ...</span>\n&lt;Logo /&gt;</code></pre>\n\n<h2 id=\"22-在React中你有经常使用常量吗？\"><a href=\"#22-在React中你有经常使用常量吗？\" class=\"headerlink\" title=\"22. 在React中你有经常使用常量吗？\"></a>22. 在React中你有经常使用常量吗？</h2><p>在redux的action文件里面定义不同的行为可能会使用常量的形式。</p>\n<hr>\n<p>第 8 天（2022.3.7）</p>\n<h2 id=\"23-为什么说React中的props是只读的？\"><a href=\"#23-为什么说React中的props是只读的？\" class=\"headerlink\" title=\"23. 为什么说React中的props是只读的？\"></a>23. 为什么说React中的props是只读的？</h2><p>往单向数据流上答：<br>保证react的单向数据流的设计模式，使状态更可预测。<br>如果允许自组件修改，那么一个父组件将状态传递给好几个子组件，这几个子组件随意修改，就完全不可预测，不知道在什么地方修改了状态。<br>所以我们必须像纯函数一样保护 props 不被修改</p>\n<h2 id=\"24-如果组件的属性没有传值，那么它的默认值是什么？\"><a href=\"#24-如果组件的属性没有传值，那么它的默认值是什么？\" class=\"headerlink\" title=\"24. 如果组件的属性没有传值，那么它的默认值是什么？\"></a>24. 如果组件的属性没有传值，那么它的默认值是什么？</h2><p><a href=\"https://zh-hans.reactjs.org/docs/jsx-in-depth.html#props-default-to-true\">官网</a>，如果你没给 prop 赋值，它的默认值是 true。以下两个 JSX 表达式是等价的：</p>\n<pre><code class=\"hljs jsx\">&lt;MyTextBox autocomplete /&gt;\n\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyTextBox</span> <span class=\"hljs-attr\">autocomplete</span>=<span class=\"hljs-string\">&#123;true&#125;</span> /&gt;</span></span></code></pre>\n\n<p>通常，我们不建议不传递 value 给 prop，因为这可能与 ES6 对象简写混淆，{foo} 是 {foo: foo} 的简写，而不是 {foo: true}。这样实现只是为了保持和 HTML 中标签属性的行为一致。</p>\n<h2 id=\"25-super-和super-props-有什么区别？\"><a href=\"#25-super-和super-props-有什么区别？\" class=\"headerlink\" title=\"25. super()和super(props)有什么区别？\"></a>25. <code>super()</code>和<code>super(props)</code>有什么区别？</h2><p>react 中的class 是基于es6的规范实现的, 继承是使用extends关键字实现继承的，子类必须在constructor()中调用super() 方法否则新建实例就会报错，报错的原因是 子类是没有自己的this对象的，它只能继承父类的this对象，然后对其进行加工，而super()就是将父类中的this对象继承给子类的，没有super() 子类就得不到this对象。</p>\n<p>如果你使用了constructor就必须写super() 这个是用来初始化this的，可以绑定事件到this上<br>如果你想要在constructor中使用this.props,就必须给super添加参数 super(props)<br>注意，无论有没有 constructor，在render中的this.props都是可以使用的，这是react自动附带的<br>如果没有用到constructor 是可以不写的，react会默认添加一个空的constroctor.</p>\n<p>super 指的是父类（即超类）的构造函数。</p>\n<p>在调用父类的构造函数之前，你是不能在 constructor 中使用 this 关键字的.</p>\n<p>参考 <a href=\"https://overreacted.io/zh-hans/why-do-we-write-super-props/\">why-do-we-write-super-props</a></p>\n"},{"index_img":"/img/2022-04-07-1.png","abbrlink":"0","date":"2022-04-07T14:04:17.000Z","title":"React Hooks 之 useEffect","_content":"\nFunction Component 是更彻底的状态驱动抽象。要彻底理解 Hooks 需要忘掉 Class Component 生命周期,理解 FC 的思维方式。\n\n## 每次渲染都有他自己的 props 和 state\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\n`<p>You clicked {count} times</p>` 该行中的 count 如何理解？\n\n第一感觉是 count 是会“监听”状态变化自动更新。它不是 data binding、watcher、proxy。\n\n```jsx\nconst count = 42; // count 只是一个数字\n// ...\n<p>You clicked {count} times</p>\n// ...\n```\n\n组件第一次渲染，count 初始值是 0。 调用 setCount(1),react 再次渲染组件，这次 count 是 1。以此类推。。。\n\n```jsx\n// During first render\nfunction Counter() {\n  const count = 0; // Returned by useState()\n  // ...\n  <p>You clicked {count} times</p>\n  // ...\n}\n\n// After a click, our function is called again\nfunction Counter() {\n  const count = 1; // Returned by useState()\n  // ...\n  <p>You clicked {count} times</p>\n  // ...\n}\n\n// After another click, our function is called again\nfunction Counter() {\n  const count = 2; // Returned by useState()\n  // ...\n  <p>You clicked {count} times</p>\n  // ...\n}\n```\n\n每次状态更新，react 重新渲染组件。每一次的渲染中的 count 都是独立的值，这个状态值是函数中的一个常量。\n\n任意一次渲染中的count常量都不会随着时间改变。渲染输出会变是因为我们的组件被一次次调用，而每一次调用引起的渲染中，它包含的count值独立于其他渲染。\n\n## 每次渲染都有它自己的事件处理函数\n\n```jsx\nconst App = () => {\n  const [temp, setTemp] = React.useState(5);\n\n  const log = () => {\n    setTimeout(() => {\n      console.log(\"3 秒前 temp = 5，现在 temp =\", temp);\n    }, 3000);\n  };\n\n  return (\n    <div\n      onClick={() => {\n        log();\n        setTemp(3);\n        // 3 秒前 temp = 5，现在 temp = 5\n      }}\n    >\n      xyz\n    </div>\n  );\n};\n```\n\n上述代码输出 5，而不是 3\n\nlog 函数执行的那个 render 过程， temp 可以看作常量 5。执行 setTemp(3) 后会由一个全新的 render 渲染。所以不会执行 log 函数。而 3 秒后执行的内容是由 temp 为 5 的那个 render 发出的。所以结果为 5。\n\n## 每次 Render 都有自己的 Effects\n\nuseEffect 在 DOM 渲染完毕后执行， 也一样拿到的是某次渲染时的值。\n\n每次 render 过程，拿到的 count 都是固化的常量。\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  });\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  );\n}\n```\n\n## 单次渲染内，props 和 state 始终保持不变\n\n所以，每一个组件内的函数（包括事件处理函数，effects，定时器或者API调用等等）会捕获某次渲染中定义的props 和 state。\n\n下面两个例子是相等的：\n\n```jsx\nfunction Example(props) {\n  useEffect(() => {\n    setTimeout(() => {\n      console.log(props.counter);\n    }, 1000);\n  });\n  // ...\n}\n```\n\n```jsx\nfunction Example(props) {\n  const counter = props.counter;\n  useEffect(() => {\n    setTimeout(() => {\n      console.log(counter);\n    }, 1000);\n  });\n  // ...\n}\n```\n\n在组件内，什么时候读 props 和 state 都一样。在单次渲染内，他们始终保持不变。\n\n## 如何拿最新的值，而不是捕获的值\n\nuseRef 可以绕过 Capture Value 的特性。可以认为 ref 在所有 Render 过程中保持着唯一引用，因此所有对 ref 的赋值或取值，拿到的都只有一个最终状态，而不会在每个 Render 间存在隔离。\n\n```jsx\nfunction Example() {\n  const [count, setCount] = useState(0);\n  const latestCount = useRef(count);\n\n  useEffect(() => {\n    // Set the mutable latest value\n    latestCount.current = count;\n    setTimeout(() => {\n      // Read the mutable latest value\n      console.log(`You clicked ${latestCount.current} times`);\n    }, 3000);\n  });\n  // ...\n```\n\n也可以认为，ref 是 Mutable 的，而 state 是 Immutable 的。\n\n## useEffect 回收机制\n\n```jsx\nuseEffect(() => {\n    ChatAPI.subscribeToFriendStatus(props.id, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(props.id, handleStatusChange);\n    };\n  });\n```\n\n假设第一次渲染的时候props是{id: 10}，第二次渲染的时候是{id: 20}。你可能认为顺序如下：\n\n- React 清除了 {id: 10}的effect。\n- React 渲染{id: 20}的UI。\n- React 运行{id: 20}的effect。\n\n实际上并不是这样，react 只会在浏览器绘制之后运行 useEffect。上一次的 effect 会在重新渲染后被清楚。\n\n- React 渲染{id: 20}的UI。\n- 浏览器绘制。我们在屏幕上看到{id: 20}的UI。\n- React 清除{id: 10}的effect。\n- React 运行{id: 20}的effect。\n\n那为什么清楚上一次的 effect 发生在 props 变为 {id: 20} 之后，却还能看到旧的 {id: 10} ？\n\neffect的清除并不会读取“最新”的props。它只能读取到定义它的那次渲染中的props值。由于 Capture Value 特性，每次 “注册” “回收” 拿到的都是成对的固定值。\n\n确切的说清除上一次的副作用发生在“每次重新渲染之后，副作用函数重新运行执行”。\n\n## 同步，而非生命周期\n\nReact会根据我们当前的props和state同步到DOM。“mount”和“update”之于渲染并没有什么区别。\n\n用相同的方式去思考effects。useEffect使你能够根据props和state同步React tree之外的东西。\n\n## 告诉 React 如何对比 Effect\n\nreact 在 DOM渲染时会 diff 内容，只对改变的部分做修改。但是对于 effect 却做不到这样。\n\n如何避免 effect 重复调用，需要给 effect 提供一个 deps，deps 内变量改变的时候才执行。\n\n```jsx\nuseEffect(() => {\n    document.title = 'Hello, ' + name;\n  }, [name]); // Our deps\n```\n\n## 依赖项不要撒谎\n\n```jsx\nfunction SearchResults() {\n  async function fetchData() {\n    // ...\n  }\n\n  useEffect(() => {\n    fetchData();\n  }, []); // Is this okay? Not always -- and there's a better way to write it.\n\n  // ...\n}\n```\n\n你设置了依赖项，effect中用到的所有组件内的值都要包含在依赖中。这包括 props，state，函数。\n\n这样做可能会遇到一些问题，比如会遇到重复渲染、无限请求等。解决问题的办法不是移除依赖性。后续再说。\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(count + 1);\n    }, 1000);\n    return () => clearInterval(id);\n  }, []);\n\n  return <h1>{count}</h1>;\n}\n```\n\nsetInterval 只想只想一次，依赖写为 []。\n\n但是，因为 useEffect 拿到的是那次渲染时候的值。count 值永远是 0。setCount 没产生作用。\n\n## 对依赖诚实的代价\n\n对依赖诚实，那就把 count 加到依赖中：\n\n```jsx\nuseEffect(() => {\n  const id = setInterval(() => {\n    setCount(count + 1);\n  }, 1000);\n  return () => clearInterval(id);\n}, [count]);\n```\n\n此时能够拿到最新的 count，但是有问题：\n\n- 每次变化都生成、销毁定时器，性能不好。\n- 每次重新定时，不准。\n\n## 让 useEffect 自给自足\n\n上述代码 对只想执行一次的 useEffect 里依赖了外部变量。\n\n解决办法就是 不依赖外部变量。\n\n```jsx\nuseEffect(() => {\n  const id = setInterval(() => {\n    setCount(c => c + 1);\n  }, 1000);\n  return () => clearInterval(id);\n}, []);\n```\n\nsetCount 回调写法，对旧值进行修改。此时 useEffect 只允许一次，count 也能拿到最新的值。\n\n## 解耦来自 Actions 的更新\n\nsetCount(c => c + 1) 并不能解决所有场景问题。如果我们有两个互相依赖的状态，或者我们想基于一个prop来计算下一次的state，它并不能做到。幸运的是， setCount(c => c + 1)有一个更强大的姐妹模式，它的名字叫useReducer。\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const [step, setStep] = useState(1);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(c => c + step);\n    }, 1000);\n    return () => clearInterval(id);\n  }, [step]);\n\n  return (\n    <>\n      <h1>{count}</h1>\n      <input value={step} onChange={e => setStep(Number(e.target.value))} />\n    </>\n  );\n}\n```\n\n上述例子中没有依赖撒谎。但是 step 改变时，不想重启定时器怎么办？\n\n当你想更新一个状态，并且这个状态更新依赖于另一个状态的值时，你可能需要用useReducer去替换它们。\n\n利用 useReducer 函数，将更新与动作解耦：\n\n```jsx\nconst [state, dispatch] = useReducer(reducer, initialState);\nconst { count, step } = state;\n\nuseEffect(() => {\n  const id = setInterval(() => {\n    dispatch({ type: \"tick\" }); // Instead of setCount(c => c + step);\n  }, 1000);\n  return () => clearInterval(id);\n}, [dispatch]);\n```\n\nReact会保证 dispatc 在组件的声明周期内保持不变。\n\n## 依赖 props 计算状态\n\n前面介绍了如何移除effect的依赖，不管状态更新是依赖上一个状态还是依赖另一个状态。\n\n但假如我们需要依赖props去计算下一个状态呢。\n\n`<Counter step={1} />`，此时如何避免依赖 props.step 呢？\n\n把 reducer 函数放到组件内部去读取 props：\n\n```jsx\nfunction Counter({ step }) {\n  const [count, dispatch] = useReducer(reducer, 0);\n\n  function reducer(state, action) {\n    if (action.type === 'tick') {\n      return state + step;\n    } else {\n      throw new Error();\n    }\n  }\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      dispatch({ type: 'tick' });\n    }, 1000);\n    return () => clearInterval(id);\n  }, [dispatch]);\n\n  return <h1>{count}</h1>;\n}\n```\n\n此时 react 仍能保证 dispatch 在每次渲染中都是一样的。\n\n这可以帮助我移除不必需的依赖，避免不必要的effect调用。\n\n## 把函数移到 Effects 里\n\n如果某些函数仅在effect中调用，你可以把它们的定义移到effect中：\n\n```jsx\nfunction SearchResults() {\n  const [query, setQuery] = useState('react');\n\n  useEffect(() => {\n    function getFetchUrl() {\n      return 'https://hn.algolia.com/api/v1/search?query=' + query;\n    }\n\n    async function fetchData() {\n      const result = await axios(getFetchUrl());\n      setData(result.data);\n    }\n\n    fetchData();\n  }, [query]); // ✅ Deps are OK\n\n  // ...\n}\n\n```\n\n## 当函数不能放在 Effects 里\n\n有时函数不能放在 effects 里，如：\n\n- 组件内几个函数使用了相同的函数\n- 这个函数是一个 prop\n\n此时能忽略对函数的依赖么？最好不要，effects 对依赖不要撒谎。\n\n两种情况：\n\n- 1、函数内没有使用组件内的任何值，就提到组件外。\n\n```jsx\n/ ✅ Not affected by the data flow\nfunction getFetchUrl(query) {\n  return 'https://hn.algolia.com/api/v1/search?query=' + query;\n}\n\nfunction SearchResults() {\n  useEffect(() => {\n    const url = getFetchUrl('react');\n    // ... Fetch data and do something ...\n  }, []); // ✅ Deps are OK\n\n  useEffect(() => {\n    const url = getFetchUrl('redux');\n    // ... Fetch data and do something ...\n  }, []); // ✅ Deps are OK\n\n  // ...\n}\n```\n\n- 2、放组件内，用 useCallback 包装, 将函数添加到依赖\n\n```jsx\nfunction SearchResults() {\n  const [query, setQuery] = useState('react');\n\n  // ✅ Preserves identity until query changes\n  const getFetchUrl = useCallback(() => {\n    return 'https://hn.algolia.com/api/v1/search?query=' + query;\n  }, [query]);  // ✅ Callback deps are OK\n\n  useEffect(() => {\n    const url = getFetchUrl();\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ✅ Effect deps are OK\n\n  // ...\n}\n```\n\n使用 useCallback，因为如果query 保持不变，getFetchUrl也会保持不变，我们的effect也不会重新运行。\n\n父组件传入函数的情况，也适用该方法：\n\n```jsx\nfunction Parent() {\n  const [query, setQuery] = useState('react');\n\n  // ✅ Preserves identity until query changes\n  const fetchData = useCallback(() => {\n    const url = 'https://hn.algolia.com/api/v1/search?query=' + query;\n    // ... Fetch data and return it ...\n  }, [query]);  // ✅ Callback deps are OK\n\n  return <Child fetchData={fetchData} />\n}\n\nfunction Child({ fetchData }) {\n  let [data, setData] = useState(null);\n\n  useEffect(() => {\n    fetchData().then(setData);\n  }, [fetchData]); // ✅ Effect deps are OK\n\n  // ...\n}\n```\n\n避免到处使用 useCallback。\n\n当我们需要将函数传递下去并且函数会在子组件的effect中被调用的时候，useCallback 是很好的技巧且非常有用。或者你想试图减少对子组件的记忆负担，也不妨一试。\n\n- 3、更好的方式可能是把他抽成自定义 Hook，把 fetchData 放在 effect 里。\n\nuseEffect 只是底层 API，未来业务接触到的是更多封装后的上层 API，比如 useFetch 或者 useTheme，它们会更好用。\n\n```jsx\nimport React, { useState, useEffect, useReducer } from 'react'\n\nconst GITHUB_API = 'https://api.github.com/repos/chanshiyucx/blog/issues?page=10&per_page='\n\nexport default () => {\n  const [list, setList] = useState([])\n  const [page, setPage] = useState(1)\n\n  const { data, doFetch } = useDataApi(`${GITHUB_API}${page}`, [])\n  // 翻页时重新获取列表\n  useEffect(() => doFetch(`${GITHUB_API}${page}`), [page])\n  useEffect(() => setList(data), [data])\n\n  const handleNextPage = () => setPage(page + 1)\n\n  return (\n    <div>\n      <button onClick={handleNextPage}>NextPage</button>\n      <ul>\n        {list.map(o => (\n          <li key={o.id}>{o.title}</li>\n        ))}\n      </ul>\n\n      {isError && <div>Something went wrong ...</div>}\n      {isLoading && <div>Loading ...</div>}\n    </div>\n  )\n}\n```\n\nreducer:\n\n```jsx\nconst dataFetchReducer = (state, action) => {\n  switch (action.type) {\n    case 'FETCH_INIT':\n      return {\n        ...state,\n        isLoading: true,\n        isError: false\n      }\n    case 'FETCH_SUCCESS':\n      return {\n        ...state,\n        isLoading: false,\n        isError: false,\n        data: action.payload\n      }\n    case 'FETCH_FAILURE':\n      return {\n        ...state,\n        isLoading: false,\n        isError: true\n      }\n    default:\n      throw new Error()\n  }\n}\n```\n\n自定义 Hook：\n\n```jsx\nconst useDataApi = (initialUrl, initialData) => {\n  const [url, setUrl] = useState(initialUrl)\n\n  const [state, dispatch] = useReducer(dataFetchReducer, {\n    isLoading: false,\n    isError: false,\n    data: initialData\n  })\n\n  useEffect(() => {\n    let didCancel = false\n\n    const fetchData = async () => {\n      dispatch({ type: 'FETCH_INIT' })\n      try {\n        const response = await fetch(url)\n        const data = await response.json()\n        if (!didCancel) {\n          dispatch({ type: 'FETCH_SUCCESS', payload: data })\n        }\n      } catch (error) {\n        if (!didCancel) {\n          dispatch({ type: 'FETCH_FAILURE' })\n        }\n      }\n    }\n    fetchData()\n\n    return () => {\n      didCancel = true\n    }\n  }, [url])\n\n  const doFetch = url => {\n    setUrl(url)\n  }\n\n  return { ...state, doFetch }\n}\n```\n\n## 参考资料\n\n- [a-complete-guide-to-useeffect](https://overreacted.io/a-complete-guide-to-useeffect/)\n- [https://www.robinwieruch.de/react-hooks-fetch-data/](https://www.robinwieruch.de/react-hooks-fetch-data/)\n","source":"_posts/11.React Hooks 之 useEffect.md","raw":"---\nindex_img: /img/2022-04-07-1.png\nabbrlink: '0'\ndate: 2022-04-07 22:04:17\ntitle: React Hooks 之 useEffect\ntags: useEffect\ncategories:\n- [React Hook]\n- [React]\n---\n\nFunction Component 是更彻底的状态驱动抽象。要彻底理解 Hooks 需要忘掉 Class Component 生命周期,理解 FC 的思维方式。\n\n## 每次渲染都有他自己的 props 和 state\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\n`<p>You clicked {count} times</p>` 该行中的 count 如何理解？\n\n第一感觉是 count 是会“监听”状态变化自动更新。它不是 data binding、watcher、proxy。\n\n```jsx\nconst count = 42; // count 只是一个数字\n// ...\n<p>You clicked {count} times</p>\n// ...\n```\n\n组件第一次渲染，count 初始值是 0。 调用 setCount(1),react 再次渲染组件，这次 count 是 1。以此类推。。。\n\n```jsx\n// During first render\nfunction Counter() {\n  const count = 0; // Returned by useState()\n  // ...\n  <p>You clicked {count} times</p>\n  // ...\n}\n\n// After a click, our function is called again\nfunction Counter() {\n  const count = 1; // Returned by useState()\n  // ...\n  <p>You clicked {count} times</p>\n  // ...\n}\n\n// After another click, our function is called again\nfunction Counter() {\n  const count = 2; // Returned by useState()\n  // ...\n  <p>You clicked {count} times</p>\n  // ...\n}\n```\n\n每次状态更新，react 重新渲染组件。每一次的渲染中的 count 都是独立的值，这个状态值是函数中的一个常量。\n\n任意一次渲染中的count常量都不会随着时间改变。渲染输出会变是因为我们的组件被一次次调用，而每一次调用引起的渲染中，它包含的count值独立于其他渲染。\n\n## 每次渲染都有它自己的事件处理函数\n\n```jsx\nconst App = () => {\n  const [temp, setTemp] = React.useState(5);\n\n  const log = () => {\n    setTimeout(() => {\n      console.log(\"3 秒前 temp = 5，现在 temp =\", temp);\n    }, 3000);\n  };\n\n  return (\n    <div\n      onClick={() => {\n        log();\n        setTemp(3);\n        // 3 秒前 temp = 5，现在 temp = 5\n      }}\n    >\n      xyz\n    </div>\n  );\n};\n```\n\n上述代码输出 5，而不是 3\n\nlog 函数执行的那个 render 过程， temp 可以看作常量 5。执行 setTemp(3) 后会由一个全新的 render 渲染。所以不会执行 log 函数。而 3 秒后执行的内容是由 temp 为 5 的那个 render 发出的。所以结果为 5。\n\n## 每次 Render 都有自己的 Effects\n\nuseEffect 在 DOM 渲染完毕后执行， 也一样拿到的是某次渲染时的值。\n\n每次 render 过程，拿到的 count 都是固化的常量。\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  });\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  );\n}\n```\n\n## 单次渲染内，props 和 state 始终保持不变\n\n所以，每一个组件内的函数（包括事件处理函数，effects，定时器或者API调用等等）会捕获某次渲染中定义的props 和 state。\n\n下面两个例子是相等的：\n\n```jsx\nfunction Example(props) {\n  useEffect(() => {\n    setTimeout(() => {\n      console.log(props.counter);\n    }, 1000);\n  });\n  // ...\n}\n```\n\n```jsx\nfunction Example(props) {\n  const counter = props.counter;\n  useEffect(() => {\n    setTimeout(() => {\n      console.log(counter);\n    }, 1000);\n  });\n  // ...\n}\n```\n\n在组件内，什么时候读 props 和 state 都一样。在单次渲染内，他们始终保持不变。\n\n## 如何拿最新的值，而不是捕获的值\n\nuseRef 可以绕过 Capture Value 的特性。可以认为 ref 在所有 Render 过程中保持着唯一引用，因此所有对 ref 的赋值或取值，拿到的都只有一个最终状态，而不会在每个 Render 间存在隔离。\n\n```jsx\nfunction Example() {\n  const [count, setCount] = useState(0);\n  const latestCount = useRef(count);\n\n  useEffect(() => {\n    // Set the mutable latest value\n    latestCount.current = count;\n    setTimeout(() => {\n      // Read the mutable latest value\n      console.log(`You clicked ${latestCount.current} times`);\n    }, 3000);\n  });\n  // ...\n```\n\n也可以认为，ref 是 Mutable 的，而 state 是 Immutable 的。\n\n## useEffect 回收机制\n\n```jsx\nuseEffect(() => {\n    ChatAPI.subscribeToFriendStatus(props.id, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(props.id, handleStatusChange);\n    };\n  });\n```\n\n假设第一次渲染的时候props是{id: 10}，第二次渲染的时候是{id: 20}。你可能认为顺序如下：\n\n- React 清除了 {id: 10}的effect。\n- React 渲染{id: 20}的UI。\n- React 运行{id: 20}的effect。\n\n实际上并不是这样，react 只会在浏览器绘制之后运行 useEffect。上一次的 effect 会在重新渲染后被清楚。\n\n- React 渲染{id: 20}的UI。\n- 浏览器绘制。我们在屏幕上看到{id: 20}的UI。\n- React 清除{id: 10}的effect。\n- React 运行{id: 20}的effect。\n\n那为什么清楚上一次的 effect 发生在 props 变为 {id: 20} 之后，却还能看到旧的 {id: 10} ？\n\neffect的清除并不会读取“最新”的props。它只能读取到定义它的那次渲染中的props值。由于 Capture Value 特性，每次 “注册” “回收” 拿到的都是成对的固定值。\n\n确切的说清除上一次的副作用发生在“每次重新渲染之后，副作用函数重新运行执行”。\n\n## 同步，而非生命周期\n\nReact会根据我们当前的props和state同步到DOM。“mount”和“update”之于渲染并没有什么区别。\n\n用相同的方式去思考effects。useEffect使你能够根据props和state同步React tree之外的东西。\n\n## 告诉 React 如何对比 Effect\n\nreact 在 DOM渲染时会 diff 内容，只对改变的部分做修改。但是对于 effect 却做不到这样。\n\n如何避免 effect 重复调用，需要给 effect 提供一个 deps，deps 内变量改变的时候才执行。\n\n```jsx\nuseEffect(() => {\n    document.title = 'Hello, ' + name;\n  }, [name]); // Our deps\n```\n\n## 依赖项不要撒谎\n\n```jsx\nfunction SearchResults() {\n  async function fetchData() {\n    // ...\n  }\n\n  useEffect(() => {\n    fetchData();\n  }, []); // Is this okay? Not always -- and there's a better way to write it.\n\n  // ...\n}\n```\n\n你设置了依赖项，effect中用到的所有组件内的值都要包含在依赖中。这包括 props，state，函数。\n\n这样做可能会遇到一些问题，比如会遇到重复渲染、无限请求等。解决问题的办法不是移除依赖性。后续再说。\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(count + 1);\n    }, 1000);\n    return () => clearInterval(id);\n  }, []);\n\n  return <h1>{count}</h1>;\n}\n```\n\nsetInterval 只想只想一次，依赖写为 []。\n\n但是，因为 useEffect 拿到的是那次渲染时候的值。count 值永远是 0。setCount 没产生作用。\n\n## 对依赖诚实的代价\n\n对依赖诚实，那就把 count 加到依赖中：\n\n```jsx\nuseEffect(() => {\n  const id = setInterval(() => {\n    setCount(count + 1);\n  }, 1000);\n  return () => clearInterval(id);\n}, [count]);\n```\n\n此时能够拿到最新的 count，但是有问题：\n\n- 每次变化都生成、销毁定时器，性能不好。\n- 每次重新定时，不准。\n\n## 让 useEffect 自给自足\n\n上述代码 对只想执行一次的 useEffect 里依赖了外部变量。\n\n解决办法就是 不依赖外部变量。\n\n```jsx\nuseEffect(() => {\n  const id = setInterval(() => {\n    setCount(c => c + 1);\n  }, 1000);\n  return () => clearInterval(id);\n}, []);\n```\n\nsetCount 回调写法，对旧值进行修改。此时 useEffect 只允许一次，count 也能拿到最新的值。\n\n## 解耦来自 Actions 的更新\n\nsetCount(c => c + 1) 并不能解决所有场景问题。如果我们有两个互相依赖的状态，或者我们想基于一个prop来计算下一次的state，它并不能做到。幸运的是， setCount(c => c + 1)有一个更强大的姐妹模式，它的名字叫useReducer。\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const [step, setStep] = useState(1);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(c => c + step);\n    }, 1000);\n    return () => clearInterval(id);\n  }, [step]);\n\n  return (\n    <>\n      <h1>{count}</h1>\n      <input value={step} onChange={e => setStep(Number(e.target.value))} />\n    </>\n  );\n}\n```\n\n上述例子中没有依赖撒谎。但是 step 改变时，不想重启定时器怎么办？\n\n当你想更新一个状态，并且这个状态更新依赖于另一个状态的值时，你可能需要用useReducer去替换它们。\n\n利用 useReducer 函数，将更新与动作解耦：\n\n```jsx\nconst [state, dispatch] = useReducer(reducer, initialState);\nconst { count, step } = state;\n\nuseEffect(() => {\n  const id = setInterval(() => {\n    dispatch({ type: \"tick\" }); // Instead of setCount(c => c + step);\n  }, 1000);\n  return () => clearInterval(id);\n}, [dispatch]);\n```\n\nReact会保证 dispatc 在组件的声明周期内保持不变。\n\n## 依赖 props 计算状态\n\n前面介绍了如何移除effect的依赖，不管状态更新是依赖上一个状态还是依赖另一个状态。\n\n但假如我们需要依赖props去计算下一个状态呢。\n\n`<Counter step={1} />`，此时如何避免依赖 props.step 呢？\n\n把 reducer 函数放到组件内部去读取 props：\n\n```jsx\nfunction Counter({ step }) {\n  const [count, dispatch] = useReducer(reducer, 0);\n\n  function reducer(state, action) {\n    if (action.type === 'tick') {\n      return state + step;\n    } else {\n      throw new Error();\n    }\n  }\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      dispatch({ type: 'tick' });\n    }, 1000);\n    return () => clearInterval(id);\n  }, [dispatch]);\n\n  return <h1>{count}</h1>;\n}\n```\n\n此时 react 仍能保证 dispatch 在每次渲染中都是一样的。\n\n这可以帮助我移除不必需的依赖，避免不必要的effect调用。\n\n## 把函数移到 Effects 里\n\n如果某些函数仅在effect中调用，你可以把它们的定义移到effect中：\n\n```jsx\nfunction SearchResults() {\n  const [query, setQuery] = useState('react');\n\n  useEffect(() => {\n    function getFetchUrl() {\n      return 'https://hn.algolia.com/api/v1/search?query=' + query;\n    }\n\n    async function fetchData() {\n      const result = await axios(getFetchUrl());\n      setData(result.data);\n    }\n\n    fetchData();\n  }, [query]); // ✅ Deps are OK\n\n  // ...\n}\n\n```\n\n## 当函数不能放在 Effects 里\n\n有时函数不能放在 effects 里，如：\n\n- 组件内几个函数使用了相同的函数\n- 这个函数是一个 prop\n\n此时能忽略对函数的依赖么？最好不要，effects 对依赖不要撒谎。\n\n两种情况：\n\n- 1、函数内没有使用组件内的任何值，就提到组件外。\n\n```jsx\n/ ✅ Not affected by the data flow\nfunction getFetchUrl(query) {\n  return 'https://hn.algolia.com/api/v1/search?query=' + query;\n}\n\nfunction SearchResults() {\n  useEffect(() => {\n    const url = getFetchUrl('react');\n    // ... Fetch data and do something ...\n  }, []); // ✅ Deps are OK\n\n  useEffect(() => {\n    const url = getFetchUrl('redux');\n    // ... Fetch data and do something ...\n  }, []); // ✅ Deps are OK\n\n  // ...\n}\n```\n\n- 2、放组件内，用 useCallback 包装, 将函数添加到依赖\n\n```jsx\nfunction SearchResults() {\n  const [query, setQuery] = useState('react');\n\n  // ✅ Preserves identity until query changes\n  const getFetchUrl = useCallback(() => {\n    return 'https://hn.algolia.com/api/v1/search?query=' + query;\n  }, [query]);  // ✅ Callback deps are OK\n\n  useEffect(() => {\n    const url = getFetchUrl();\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ✅ Effect deps are OK\n\n  // ...\n}\n```\n\n使用 useCallback，因为如果query 保持不变，getFetchUrl也会保持不变，我们的effect也不会重新运行。\n\n父组件传入函数的情况，也适用该方法：\n\n```jsx\nfunction Parent() {\n  const [query, setQuery] = useState('react');\n\n  // ✅ Preserves identity until query changes\n  const fetchData = useCallback(() => {\n    const url = 'https://hn.algolia.com/api/v1/search?query=' + query;\n    // ... Fetch data and return it ...\n  }, [query]);  // ✅ Callback deps are OK\n\n  return <Child fetchData={fetchData} />\n}\n\nfunction Child({ fetchData }) {\n  let [data, setData] = useState(null);\n\n  useEffect(() => {\n    fetchData().then(setData);\n  }, [fetchData]); // ✅ Effect deps are OK\n\n  // ...\n}\n```\n\n避免到处使用 useCallback。\n\n当我们需要将函数传递下去并且函数会在子组件的effect中被调用的时候，useCallback 是很好的技巧且非常有用。或者你想试图减少对子组件的记忆负担，也不妨一试。\n\n- 3、更好的方式可能是把他抽成自定义 Hook，把 fetchData 放在 effect 里。\n\nuseEffect 只是底层 API，未来业务接触到的是更多封装后的上层 API，比如 useFetch 或者 useTheme，它们会更好用。\n\n```jsx\nimport React, { useState, useEffect, useReducer } from 'react'\n\nconst GITHUB_API = 'https://api.github.com/repos/chanshiyucx/blog/issues?page=10&per_page='\n\nexport default () => {\n  const [list, setList] = useState([])\n  const [page, setPage] = useState(1)\n\n  const { data, doFetch } = useDataApi(`${GITHUB_API}${page}`, [])\n  // 翻页时重新获取列表\n  useEffect(() => doFetch(`${GITHUB_API}${page}`), [page])\n  useEffect(() => setList(data), [data])\n\n  const handleNextPage = () => setPage(page + 1)\n\n  return (\n    <div>\n      <button onClick={handleNextPage}>NextPage</button>\n      <ul>\n        {list.map(o => (\n          <li key={o.id}>{o.title}</li>\n        ))}\n      </ul>\n\n      {isError && <div>Something went wrong ...</div>}\n      {isLoading && <div>Loading ...</div>}\n    </div>\n  )\n}\n```\n\nreducer:\n\n```jsx\nconst dataFetchReducer = (state, action) => {\n  switch (action.type) {\n    case 'FETCH_INIT':\n      return {\n        ...state,\n        isLoading: true,\n        isError: false\n      }\n    case 'FETCH_SUCCESS':\n      return {\n        ...state,\n        isLoading: false,\n        isError: false,\n        data: action.payload\n      }\n    case 'FETCH_FAILURE':\n      return {\n        ...state,\n        isLoading: false,\n        isError: true\n      }\n    default:\n      throw new Error()\n  }\n}\n```\n\n自定义 Hook：\n\n```jsx\nconst useDataApi = (initialUrl, initialData) => {\n  const [url, setUrl] = useState(initialUrl)\n\n  const [state, dispatch] = useReducer(dataFetchReducer, {\n    isLoading: false,\n    isError: false,\n    data: initialData\n  })\n\n  useEffect(() => {\n    let didCancel = false\n\n    const fetchData = async () => {\n      dispatch({ type: 'FETCH_INIT' })\n      try {\n        const response = await fetch(url)\n        const data = await response.json()\n        if (!didCancel) {\n          dispatch({ type: 'FETCH_SUCCESS', payload: data })\n        }\n      } catch (error) {\n        if (!didCancel) {\n          dispatch({ type: 'FETCH_FAILURE' })\n        }\n      }\n    }\n    fetchData()\n\n    return () => {\n      didCancel = true\n    }\n  }, [url])\n\n  const doFetch = url => {\n    setUrl(url)\n  }\n\n  return { ...state, doFetch }\n}\n```\n\n## 参考资料\n\n- [a-complete-guide-to-useeffect](https://overreacted.io/a-complete-guide-to-useeffect/)\n- [https://www.robinwieruch.de/react-hooks-fetch-data/](https://www.robinwieruch.de/react-hooks-fetch-data/)\n","slug":"11-React-Hooks-之-useEffect","published":1,"updated":"2022-04-18T02:54:43.768Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k5bv73000o0h3leg51e76w","content":"<p>Function Component 是更彻底的状态驱动抽象。要彻底理解 Hooks 需要忘掉 Class Component 生命周期,理解 FC 的思维方式。</p>\n<h2 id=\"每次渲染都有他自己的-props-和-state\"><a href=\"#每次渲染都有他自己的-props-和-state\" class=\"headerlink\" title=\"每次渲染都有他自己的 props 和 state\"></a>每次渲染都有他自己的 props 和 state</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span>\n<span class=\"xml\">        Click me</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;</code></pre></div>\n\n<p><code>&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</code> 该行中的 count 如何理解？</p>\n<p>第一感觉是 count 是会“监听”状态变化自动更新。它不是 data binding、watcher、proxy。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> count = <span class=\"hljs-number\">42</span>; <span class=\"hljs-comment\">// count 只是一个数字</span>\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n<span class=\"hljs-comment\">// ...</span></code></pre></div>\n\n<p>组件第一次渲染，count 初始值是 0。 调用 setCount(1),react 再次渲染组件，这次 count 是 1。以此类推。。。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// During first render</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> count = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// Returned by useState()</span>\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n\n<span class=\"hljs-comment\">// After a click, our function is called again</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> count = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// Returned by useState()</span>\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n\n<span class=\"hljs-comment\">// After another click, our function is called again</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> count = <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// Returned by useState()</span>\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre></div>\n\n<p>每次状态更新，react 重新渲染组件。每一次的渲染中的 count 都是独立的值，这个状态值是函数中的一个常量。</p>\n<p>任意一次渲染中的count常量都不会随着时间改变。渲染输出会变是因为我们的组件被一次次调用，而每一次调用引起的渲染中，它包含的count值独立于其他渲染。</p>\n<h2 id=\"每次渲染都有它自己的事件处理函数\"><a href=\"#每次渲染都有它自己的事件处理函数\" class=\"headerlink\" title=\"每次渲染都有它自己的事件处理函数\"></a>每次渲染都有它自己的事件处理函数</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> App = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> [temp, setTemp] = React.useState(<span class=\"hljs-number\">5</span>);\n\n  <span class=\"hljs-keyword\">const</span> log = <span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;3 秒前 temp = 5，现在 temp =&quot;</span>, temp);\n    &#125;, <span class=\"hljs-number\">3000</span>);\n  &#125;;\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span></span></span>\n<span class=\"hljs-tag\"><span class=\"xml\">      <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span>\n<span class=\"xml\">        log();</span>\n<span class=\"xml\">        setTemp(3);</span>\n<span class=\"xml\">        // 3 秒前 temp = 5，现在 temp = 5</span>\n<span class=\"xml\">      &#125;&#125;</span>\n<span class=\"xml\">    &gt;</span>\n<span class=\"xml\">      xyz</span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;;</code></pre></div>\n\n<p>上述代码输出 5，而不是 3</p>\n<p>log 函数执行的那个 render 过程， temp 可以看作常量 5。执行 setTemp(3) 后会由一个全新的 render 渲染。所以不会执行 log 函数。而 3 秒后执行的内容是由 temp 为 5 的那个 render 发出的。所以结果为 5。</p>\n<h2 id=\"每次-Render-都有自己的-Effects\"><a href=\"#每次-Render-都有自己的-Effects\" class=\"headerlink\" title=\"每次 Render 都有自己的 Effects\"></a>每次 Render 都有自己的 Effects</h2><p>useEffect 在 DOM 渲染完毕后执行， 也一样拿到的是某次渲染时的值。</p>\n<p>每次 render 过程，拿到的 count 都是固化的常量。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">document</span>.title = <span class=\"hljs-string\">`You clicked <span class=\"hljs-subst\">$&#123;count&#125;</span> times`</span>;\n  &#125;);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Click me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;</code></pre></div>\n\n<h2 id=\"单次渲染内，props-和-state-始终保持不变\"><a href=\"#单次渲染内，props-和-state-始终保持不变\" class=\"headerlink\" title=\"单次渲染内，props 和 state 始终保持不变\"></a>单次渲染内，props 和 state 始终保持不变</h2><p>所以，每一个组件内的函数（包括事件处理函数，effects，定时器或者API调用等等）会捕获某次渲染中定义的props 和 state。</p>\n<p>下面两个例子是相等的：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\">props</span>) </span>&#123;\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">console</span>.log(props.counter);\n    &#125;, <span class=\"hljs-number\">1000</span>);\n  &#125;);\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre></div>\n\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\">props</span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> counter = props.counter;\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">console</span>.log(counter);\n    &#125;, <span class=\"hljs-number\">1000</span>);\n  &#125;);\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre></div>\n\n<p>在组件内，什么时候读 props 和 state 都一样。在单次渲染内，他们始终保持不变。</p>\n<h2 id=\"如何拿最新的值，而不是捕获的值\"><a href=\"#如何拿最新的值，而不是捕获的值\" class=\"headerlink\" title=\"如何拿最新的值，而不是捕获的值\"></a>如何拿最新的值，而不是捕获的值</h2><p>useRef 可以绕过 Capture Value 的特性。可以认为 ref 在所有 Render 过程中保持着唯一引用，因此所有对 ref 的赋值或取值，拿到的都只有一个最终状态，而不会在每个 Render 间存在隔离。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">const</span> latestCount = useRef(count);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-comment\">// Set the mutable latest value</span>\n    latestCount.current = count;\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-comment\">// Read the mutable latest value</span>\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`You clicked <span class=\"hljs-subst\">$&#123;latestCount.current&#125;</span> times`</span>);\n    &#125;, <span class=\"hljs-number\">3000</span>);\n  &#125;);\n  <span class=\"hljs-comment\">// ...</span></code></pre></div>\n\n<p>也可以认为，ref 是 Mutable 的，而 state 是 Immutable 的。</p>\n<h2 id=\"useEffect-回收机制\"><a href=\"#useEffect-回收机制\" class=\"headerlink\" title=\"useEffect 回收机制\"></a>useEffect 回收机制</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\">useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    ChatAPI.subscribeToFriendStatus(props.id, handleStatusChange);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      ChatAPI.unsubscribeFromFriendStatus(props.id, handleStatusChange);\n    &#125;;\n  &#125;);</code></pre></div>\n\n<p>假设第一次渲染的时候props是{id: 10}，第二次渲染的时候是{id: 20}。你可能认为顺序如下：</p>\n<ul>\n<li>React 清除了 {id: 10}的effect。</li>\n<li>React 渲染{id: 20}的UI。</li>\n<li>React 运行{id: 20}的effect。</li>\n</ul>\n<p>实际上并不是这样，react 只会在浏览器绘制之后运行 useEffect。上一次的 effect 会在重新渲染后被清楚。</p>\n<ul>\n<li>React 渲染{id: 20}的UI。</li>\n<li>浏览器绘制。我们在屏幕上看到{id: 20}的UI。</li>\n<li>React 清除{id: 10}的effect。</li>\n<li>React 运行{id: 20}的effect。</li>\n</ul>\n<p>那为什么清楚上一次的 effect 发生在 props 变为 {id: 20} 之后，却还能看到旧的 {id: 10} ？</p>\n<p>effect的清除并不会读取“最新”的props。它只能读取到定义它的那次渲染中的props值。由于 Capture Value 特性，每次 “注册” “回收” 拿到的都是成对的固定值。</p>\n<p>确切的说清除上一次的副作用发生在“每次重新渲染之后，副作用函数重新运行执行”。</p>\n<h2 id=\"同步，而非生命周期\"><a href=\"#同步，而非生命周期\" class=\"headerlink\" title=\"同步，而非生命周期\"></a>同步，而非生命周期</h2><p>React会根据我们当前的props和state同步到DOM。“mount”和“update”之于渲染并没有什么区别。</p>\n<p>用相同的方式去思考effects。useEffect使你能够根据props和state同步React tree之外的东西。</p>\n<h2 id=\"告诉-React-如何对比-Effect\"><a href=\"#告诉-React-如何对比-Effect\" class=\"headerlink\" title=\"告诉 React 如何对比 Effect\"></a>告诉 React 如何对比 Effect</h2><p>react 在 DOM渲染时会 diff 内容，只对改变的部分做修改。但是对于 effect 却做不到这样。</p>\n<p>如何避免 effect 重复调用，需要给 effect 提供一个 deps，deps 内变量改变的时候才执行。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\">useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">document</span>.title = <span class=\"hljs-string\">&#x27;Hello, &#x27;</span> + name;\n  &#125;, [name]); <span class=\"hljs-comment\">// Our deps</span></code></pre></div>\n\n<h2 id=\"依赖项不要撒谎\"><a href=\"#依赖项不要撒谎\" class=\"headerlink\" title=\"依赖项不要撒谎\"></a>依赖项不要撒谎</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SearchResults</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fetchData</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    fetchData();\n  &#125;, []); <span class=\"hljs-comment\">// Is this okay? Not always -- and there&#x27;s a better way to write it.</span>\n\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre></div>\n\n<p>你设置了依赖项，effect中用到的所有组件内的值都要包含在依赖中。这包括 props，state，函数。</p>\n<p>这样做可能会遇到一些问题，比如会遇到重复渲染、无限请求等。解决问题的办法不是移除依赖性。后续再说。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      setCount(count + <span class=\"hljs-number\">1</span>);\n    &#125;, <span class=\"hljs-number\">1000</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(id);\n  &#125;, []);\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n&#125;</code></pre></div>\n\n<p>setInterval 只想只想一次，依赖写为 []。</p>\n<p>但是，因为 useEffect 拿到的是那次渲染时候的值。count 值永远是 0。setCount 没产生作用。</p>\n<h2 id=\"对依赖诚实的代价\"><a href=\"#对依赖诚实的代价\" class=\"headerlink\" title=\"对依赖诚实的代价\"></a>对依赖诚实的代价</h2><p>对依赖诚实，那就把 count 加到依赖中：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\">useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    setCount(count + <span class=\"hljs-number\">1</span>);\n  &#125;, <span class=\"hljs-number\">1000</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(id);\n&#125;, [count]);</code></pre></div>\n\n<p>此时能够拿到最新的 count，但是有问题：</p>\n<ul>\n<li>每次变化都生成、销毁定时器，性能不好。</li>\n<li>每次重新定时，不准。</li>\n</ul>\n<h2 id=\"让-useEffect-自给自足\"><a href=\"#让-useEffect-自给自足\" class=\"headerlink\" title=\"让 useEffect 自给自足\"></a>让 useEffect 自给自足</h2><p>上述代码 对只想执行一次的 useEffect 里依赖了外部变量。</p>\n<p>解决办法就是 不依赖外部变量。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\">useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    setCount(<span class=\"hljs-function\"><span class=\"hljs-params\">c</span> =&gt;</span> c + <span class=\"hljs-number\">1</span>);\n  &#125;, <span class=\"hljs-number\">1000</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(id);\n&#125;, []);</code></pre></div>\n\n<p>setCount 回调写法，对旧值进行修改。此时 useEffect 只允许一次，count 也能拿到最新的值。</p>\n<h2 id=\"解耦来自-Actions-的更新\"><a href=\"#解耦来自-Actions-的更新\" class=\"headerlink\" title=\"解耦来自 Actions 的更新\"></a>解耦来自 Actions 的更新</h2><p>setCount(c =&gt; c + 1) 并不能解决所有场景问题。如果我们有两个互相依赖的状态，或者我们想基于一个prop来计算下一次的state，它并不能做到。幸运的是， setCount(c =&gt; c + 1)有一个更强大的姐妹模式，它的名字叫useReducer。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">const</span> [step, setStep] = useState(<span class=\"hljs-number\">1</span>);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      setCount(<span class=\"hljs-function\"><span class=\"hljs-params\">c</span> =&gt;</span> c + step);\n    &#125;, <span class=\"hljs-number\">1000</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(id);\n  &#125;, [step]);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;step&#125;</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">&#123;e</span> =&gt;</span> setStep(Number(e.target.value))&#125; /&gt;</span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n&#125;</code></pre></div>\n\n<p>上述例子中没有依赖撒谎。但是 step 改变时，不想重启定时器怎么办？</p>\n<p>当你想更新一个状态，并且这个状态更新依赖于另一个状态的值时，你可能需要用useReducer去替换它们。</p>\n<p>利用 useReducer 函数，将更新与动作解耦：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> [state, dispatch] = useReducer(reducer, initialState);\n<span class=\"hljs-keyword\">const</span> &#123; count, step &#125; = state;\n\nuseEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    dispatch(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;tick&quot;</span> &#125;); <span class=\"hljs-comment\">// Instead of setCount(c =&gt; c + step);</span>\n  &#125;, <span class=\"hljs-number\">1000</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(id);\n&#125;, [dispatch]);</code></pre></div>\n\n<p>React会保证 dispatc 在组件的声明周期内保持不变。</p>\n<h2 id=\"依赖-props-计算状态\"><a href=\"#依赖-props-计算状态\" class=\"headerlink\" title=\"依赖 props 计算状态\"></a>依赖 props 计算状态</h2><p>前面介绍了如何移除effect的依赖，不管状态更新是依赖上一个状态还是依赖另一个状态。</p>\n<p>但假如我们需要依赖props去计算下一个状态呢。</p>\n<p><code>&lt;Counter step=&#123;1&#125; /&gt;</code>，此时如何避免依赖 props.step 呢？</p>\n<p>把 reducer 函数放到组件内部去读取 props：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\">&#123; step &#125;</span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, dispatch] = useReducer(reducer, <span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reducer</span>(<span class=\"hljs-params\">state, action</span>) </span>&#123;\n    <span class=\"hljs-keyword\">if</span> (action.type === <span class=\"hljs-string\">&#x27;tick&#x27;</span>) &#123;\n      <span class=\"hljs-keyword\">return</span> state + step;\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>();\n    &#125;\n  &#125;\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      dispatch(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;tick&#x27;</span> &#125;);\n    &#125;, <span class=\"hljs-number\">1000</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(id);\n  &#125;, [dispatch]);\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n&#125;</code></pre></div>\n\n<p>此时 react 仍能保证 dispatch 在每次渲染中都是一样的。</p>\n<p>这可以帮助我移除不必需的依赖，避免不必要的effect调用。</p>\n<h2 id=\"把函数移到-Effects-里\"><a href=\"#把函数移到-Effects-里\" class=\"headerlink\" title=\"把函数移到 Effects 里\"></a>把函数移到 Effects 里</h2><p>如果某些函数仅在effect中调用，你可以把它们的定义移到effect中：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SearchResults</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [query, setQuery] = useState(<span class=\"hljs-string\">&#x27;react&#x27;</span>);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getFetchUrl</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;\n    &#125;\n\n    <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fetchData</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">await</span> axios(getFetchUrl());\n      setData(result.data);\n    &#125;\n\n    fetchData();\n  &#125;, [query]); <span class=\"hljs-comment\">// ✅ Deps are OK</span>\n\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n</code></pre></div>\n\n<h2 id=\"当函数不能放在-Effects-里\"><a href=\"#当函数不能放在-Effects-里\" class=\"headerlink\" title=\"当函数不能放在 Effects 里\"></a>当函数不能放在 Effects 里</h2><p>有时函数不能放在 effects 里，如：</p>\n<ul>\n<li>组件内几个函数使用了相同的函数</li>\n<li>这个函数是一个 prop</li>\n</ul>\n<p>此时能忽略对函数的依赖么？最好不要，effects 对依赖不要撒谎。</p>\n<p>两种情况：</p>\n<ul>\n<li>1、函数内没有使用组件内的任何值，就提到组件外。</li>\n</ul>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\">/ ✅ Not affected by the data flow\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getFetchUrl</span>(<span class=\"hljs-params\">query</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SearchResults</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> url = getFetchUrl(<span class=\"hljs-string\">&#x27;react&#x27;</span>);\n    <span class=\"hljs-comment\">// ... Fetch data and do something ...</span>\n  &#125;, []); <span class=\"hljs-comment\">// ✅ Deps are OK</span>\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> url = getFetchUrl(<span class=\"hljs-string\">&#x27;redux&#x27;</span>);\n    <span class=\"hljs-comment\">// ... Fetch data and do something ...</span>\n  &#125;, []); <span class=\"hljs-comment\">// ✅ Deps are OK</span>\n\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre></div>\n\n<ul>\n<li>2、放组件内，用 useCallback 包装, 将函数添加到依赖</li>\n</ul>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SearchResults</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [query, setQuery] = useState(<span class=\"hljs-string\">&#x27;react&#x27;</span>);\n\n  <span class=\"hljs-comment\">// ✅ Preserves identity until query changes</span>\n  <span class=\"hljs-keyword\">const</span> getFetchUrl = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;\n  &#125;, [query]);  <span class=\"hljs-comment\">// ✅ Callback deps are OK</span>\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> url = getFetchUrl();\n    <span class=\"hljs-comment\">// ... Fetch data and do something ...</span>\n  &#125;, [getFetchUrl]); <span class=\"hljs-comment\">// ✅ Effect deps are OK</span>\n\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre></div>\n\n<p>使用 useCallback，因为如果query 保持不变，getFetchUrl也会保持不变，我们的effect也不会重新运行。</p>\n<p>父组件传入函数的情况，也适用该方法：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Parent</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [query, setQuery] = useState(<span class=\"hljs-string\">&#x27;react&#x27;</span>);\n\n  <span class=\"hljs-comment\">// ✅ Preserves identity until query changes</span>\n  <span class=\"hljs-keyword\">const</span> fetchData = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> url = <span class=\"hljs-string\">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;\n    <span class=\"hljs-comment\">// ... Fetch data and return it ...</span>\n  &#125;, [query]);  <span class=\"hljs-comment\">// ✅ Callback deps are OK</span>\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Child</span> <span class=\"hljs-attr\">fetchData</span>=<span class=\"hljs-string\">&#123;fetchData&#125;</span> /&gt;</span></span>\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Child</span>(<span class=\"hljs-params\">&#123; fetchData &#125;</span>) </span>&#123;\n  <span class=\"hljs-keyword\">let</span> [data, setData] = useState(<span class=\"hljs-literal\">null</span>);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    fetchData().then(setData);\n  &#125;, [fetchData]); <span class=\"hljs-comment\">// ✅ Effect deps are OK</span>\n\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre></div>\n\n<p>避免到处使用 useCallback。</p>\n<p>当我们需要将函数传递下去并且函数会在子组件的effect中被调用的时候，useCallback 是很好的技巧且非常有用。或者你想试图减少对子组件的记忆负担，也不妨一试。</p>\n<ul>\n<li>3、更好的方式可能是把他抽成自定义 Hook，把 fetchData 放在 effect 里。</li>\n</ul>\n<p>useEffect 只是底层 API，未来业务接触到的是更多封装后的上层 API，比如 useFetch 或者 useTheme，它们会更好用。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React, &#123; useState, useEffect, useReducer &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>\n\n<span class=\"hljs-keyword\">const</span> GITHUB_API = <span class=\"hljs-string\">&#x27;https://api.github.com/repos/chanshiyucx/blog/issues?page=10&amp;per_page=&#x27;</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> () =&gt; &#123;\n  <span class=\"hljs-keyword\">const</span> [list, setList] = useState([])\n  <span class=\"hljs-keyword\">const</span> [page, setPage] = useState(<span class=\"hljs-number\">1</span>)\n\n  <span class=\"hljs-keyword\">const</span> &#123; data, doFetch &#125; = useDataApi(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;GITHUB_API&#125;</span><span class=\"hljs-subst\">$&#123;page&#125;</span>`</span>, [])\n  <span class=\"hljs-comment\">// 翻页时重新获取列表</span>\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> doFetch(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;GITHUB_API&#125;</span><span class=\"hljs-subst\">$&#123;page&#125;</span>`</span>), [page])\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> setList(data), [data])\n\n  <span class=\"hljs-keyword\">const</span> handleNextPage = <span class=\"hljs-function\">() =&gt;</span> setPage(page + <span class=\"hljs-number\">1</span>)\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;handleNextPage&#125;</span>&gt;</span>NextPage<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span></span>\n<span class=\"xml\">        &#123;list.map(o =&gt; (</span>\n<span class=\"xml\">          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#123;o.id&#125;</span>&gt;</span>&#123;o.title&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span>\n<span class=\"xml\">        ))&#125;</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></span>\n<span class=\"xml\"></span>\n<span class=\"xml\">      &#123;isError &amp;&amp; <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Something went wrong ...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>&#125;</span>\n<span class=\"xml\">      &#123;isLoading &amp;&amp; <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Loading ...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>&#125;</span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  )\n&#125;</code></pre></div>\n\n<p>reducer:</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> dataFetchReducer = <span class=\"hljs-function\">(<span class=\"hljs-params\">state, action</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">switch</span> (action.type) &#123;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;FETCH_INIT&#x27;</span>:\n      <span class=\"hljs-keyword\">return</span> &#123;\n        ...state,\n        <span class=\"hljs-attr\">isLoading</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">isError</span>: <span class=\"hljs-literal\">false</span>\n      &#125;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;FETCH_SUCCESS&#x27;</span>:\n      <span class=\"hljs-keyword\">return</span> &#123;\n        ...state,\n        <span class=\"hljs-attr\">isLoading</span>: <span class=\"hljs-literal\">false</span>,\n        <span class=\"hljs-attr\">isError</span>: <span class=\"hljs-literal\">false</span>,\n        <span class=\"hljs-attr\">data</span>: action.payload\n      &#125;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;FETCH_FAILURE&#x27;</span>:\n      <span class=\"hljs-keyword\">return</span> &#123;\n        ...state,\n        <span class=\"hljs-attr\">isLoading</span>: <span class=\"hljs-literal\">false</span>,\n        <span class=\"hljs-attr\">isError</span>: <span class=\"hljs-literal\">true</span>\n      &#125;\n    <span class=\"hljs-attr\">default</span>:\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>()\n  &#125;\n&#125;</code></pre></div>\n\n<p>自定义 Hook：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> useDataApi = <span class=\"hljs-function\">(<span class=\"hljs-params\">initialUrl, initialData</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> [url, setUrl] = useState(initialUrl)\n\n  <span class=\"hljs-keyword\">const</span> [state, dispatch] = useReducer(dataFetchReducer, &#123;\n    <span class=\"hljs-attr\">isLoading</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">isError</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">data</span>: initialData\n  &#125;)\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">let</span> didCancel = <span class=\"hljs-literal\">false</span>\n\n    <span class=\"hljs-keyword\">const</span> fetchData = <span class=\"hljs-keyword\">async</span> () =&gt; &#123;\n      dispatch(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;FETCH_INIT&#x27;</span> &#125;)\n      <span class=\"hljs-keyword\">try</span> &#123;\n        <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> fetch(url)\n        <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> response.json()\n        <span class=\"hljs-keyword\">if</span> (!didCancel) &#123;\n          dispatch(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;FETCH_SUCCESS&#x27;</span>, <span class=\"hljs-attr\">payload</span>: data &#125;)\n        &#125;\n      &#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;\n        <span class=\"hljs-keyword\">if</span> (!didCancel) &#123;\n          dispatch(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;FETCH_FAILURE&#x27;</span> &#125;)\n        &#125;\n      &#125;\n    &#125;\n    fetchData()\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      didCancel = <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;, [url])\n\n  <span class=\"hljs-keyword\">const</span> doFetch = <span class=\"hljs-function\"><span class=\"hljs-params\">url</span> =&gt;</span> &#123;\n    setUrl(url)\n  &#125;\n\n  <span class=\"hljs-keyword\">return</span> &#123; ...state, doFetch &#125;\n&#125;</code></pre></div>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://overreacted.io/a-complete-guide-to-useeffect/\">a-complete-guide-to-useeffect</a></li>\n<li><a href=\"https://www.robinwieruch.de/react-hooks-fetch-data/\">https://www.robinwieruch.de/react-hooks-fetch-data/</a></li>\n</ul>\n","site":{"data":{}},"wordcount":10778,"excerpt":"","more":"<p>Function Component 是更彻底的状态驱动抽象。要彻底理解 Hooks 需要忘掉 Class Component 生命周期,理解 FC 的思维方式。</p>\n<h2 id=\"每次渲染都有他自己的-props-和-state\"><a href=\"#每次渲染都有他自己的-props-和-state\" class=\"headerlink\" title=\"每次渲染都有他自己的 props 和 state\"></a>每次渲染都有他自己的 props 和 state</h2><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span>\n<span class=\"xml\">        Click me</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;</code></pre>\n\n<p><code>&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</code> 该行中的 count 如何理解？</p>\n<p>第一感觉是 count 是会“监听”状态变化自动更新。它不是 data binding、watcher、proxy。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> count = <span class=\"hljs-number\">42</span>; <span class=\"hljs-comment\">// count 只是一个数字</span>\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n<span class=\"hljs-comment\">// ...</span></code></pre>\n\n<p>组件第一次渲染，count 初始值是 0。 调用 setCount(1),react 再次渲染组件，这次 count 是 1。以此类推。。。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// During first render</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> count = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// Returned by useState()</span>\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n\n<span class=\"hljs-comment\">// After a click, our function is called again</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> count = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// Returned by useState()</span>\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n\n<span class=\"hljs-comment\">// After another click, our function is called again</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> count = <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// Returned by useState()</span>\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n\n<p>每次状态更新，react 重新渲染组件。每一次的渲染中的 count 都是独立的值，这个状态值是函数中的一个常量。</p>\n<p>任意一次渲染中的count常量都不会随着时间改变。渲染输出会变是因为我们的组件被一次次调用，而每一次调用引起的渲染中，它包含的count值独立于其他渲染。</p>\n<h2 id=\"每次渲染都有它自己的事件处理函数\"><a href=\"#每次渲染都有它自己的事件处理函数\" class=\"headerlink\" title=\"每次渲染都有它自己的事件处理函数\"></a>每次渲染都有它自己的事件处理函数</h2><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> App = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> [temp, setTemp] = React.useState(<span class=\"hljs-number\">5</span>);\n\n  <span class=\"hljs-keyword\">const</span> log = <span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;3 秒前 temp = 5，现在 temp =&quot;</span>, temp);\n    &#125;, <span class=\"hljs-number\">3000</span>);\n  &#125;;\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span></span></span>\n<span class=\"hljs-tag\"><span class=\"xml\">      <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span>\n<span class=\"xml\">        log();</span>\n<span class=\"xml\">        setTemp(3);</span>\n<span class=\"xml\">        // 3 秒前 temp = 5，现在 temp = 5</span>\n<span class=\"xml\">      &#125;&#125;</span>\n<span class=\"xml\">    &gt;</span>\n<span class=\"xml\">      xyz</span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;;</code></pre>\n\n<p>上述代码输出 5，而不是 3</p>\n<p>log 函数执行的那个 render 过程， temp 可以看作常量 5。执行 setTemp(3) 后会由一个全新的 render 渲染。所以不会执行 log 函数。而 3 秒后执行的内容是由 temp 为 5 的那个 render 发出的。所以结果为 5。</p>\n<h2 id=\"每次-Render-都有自己的-Effects\"><a href=\"#每次-Render-都有自己的-Effects\" class=\"headerlink\" title=\"每次 Render 都有自己的 Effects\"></a>每次 Render 都有自己的 Effects</h2><p>useEffect 在 DOM 渲染完毕后执行， 也一样拿到的是某次渲染时的值。</p>\n<p>每次 render 过程，拿到的 count 都是固化的常量。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">document</span>.title = <span class=\"hljs-string\">`You clicked <span class=\"hljs-subst\">$&#123;count&#125;</span> times`</span>;\n  &#125;);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Click me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;</code></pre>\n\n<h2 id=\"单次渲染内，props-和-state-始终保持不变\"><a href=\"#单次渲染内，props-和-state-始终保持不变\" class=\"headerlink\" title=\"单次渲染内，props 和 state 始终保持不变\"></a>单次渲染内，props 和 state 始终保持不变</h2><p>所以，每一个组件内的函数（包括事件处理函数，effects，定时器或者API调用等等）会捕获某次渲染中定义的props 和 state。</p>\n<p>下面两个例子是相等的：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\">props</span>) </span>&#123;\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">console</span>.log(props.counter);\n    &#125;, <span class=\"hljs-number\">1000</span>);\n  &#125;);\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\">props</span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> counter = props.counter;\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">console</span>.log(counter);\n    &#125;, <span class=\"hljs-number\">1000</span>);\n  &#125;);\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n\n<p>在组件内，什么时候读 props 和 state 都一样。在单次渲染内，他们始终保持不变。</p>\n<h2 id=\"如何拿最新的值，而不是捕获的值\"><a href=\"#如何拿最新的值，而不是捕获的值\" class=\"headerlink\" title=\"如何拿最新的值，而不是捕获的值\"></a>如何拿最新的值，而不是捕获的值</h2><p>useRef 可以绕过 Capture Value 的特性。可以认为 ref 在所有 Render 过程中保持着唯一引用，因此所有对 ref 的赋值或取值，拿到的都只有一个最终状态，而不会在每个 Render 间存在隔离。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">const</span> latestCount = useRef(count);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-comment\">// Set the mutable latest value</span>\n    latestCount.current = count;\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-comment\">// Read the mutable latest value</span>\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`You clicked <span class=\"hljs-subst\">$&#123;latestCount.current&#125;</span> times`</span>);\n    &#125;, <span class=\"hljs-number\">3000</span>);\n  &#125;);\n  <span class=\"hljs-comment\">// ...</span></code></pre>\n\n<p>也可以认为，ref 是 Mutable 的，而 state 是 Immutable 的。</p>\n<h2 id=\"useEffect-回收机制\"><a href=\"#useEffect-回收机制\" class=\"headerlink\" title=\"useEffect 回收机制\"></a>useEffect 回收机制</h2><pre><code class=\"hljs jsx\">useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    ChatAPI.subscribeToFriendStatus(props.id, handleStatusChange);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      ChatAPI.unsubscribeFromFriendStatus(props.id, handleStatusChange);\n    &#125;;\n  &#125;);</code></pre>\n\n<p>假设第一次渲染的时候props是{id: 10}，第二次渲染的时候是{id: 20}。你可能认为顺序如下：</p>\n<ul>\n<li>React 清除了 {id: 10}的effect。</li>\n<li>React 渲染{id: 20}的UI。</li>\n<li>React 运行{id: 20}的effect。</li>\n</ul>\n<p>实际上并不是这样，react 只会在浏览器绘制之后运行 useEffect。上一次的 effect 会在重新渲染后被清楚。</p>\n<ul>\n<li>React 渲染{id: 20}的UI。</li>\n<li>浏览器绘制。我们在屏幕上看到{id: 20}的UI。</li>\n<li>React 清除{id: 10}的effect。</li>\n<li>React 运行{id: 20}的effect。</li>\n</ul>\n<p>那为什么清楚上一次的 effect 发生在 props 变为 {id: 20} 之后，却还能看到旧的 {id: 10} ？</p>\n<p>effect的清除并不会读取“最新”的props。它只能读取到定义它的那次渲染中的props值。由于 Capture Value 特性，每次 “注册” “回收” 拿到的都是成对的固定值。</p>\n<p>确切的说清除上一次的副作用发生在“每次重新渲染之后，副作用函数重新运行执行”。</p>\n<h2 id=\"同步，而非生命周期\"><a href=\"#同步，而非生命周期\" class=\"headerlink\" title=\"同步，而非生命周期\"></a>同步，而非生命周期</h2><p>React会根据我们当前的props和state同步到DOM。“mount”和“update”之于渲染并没有什么区别。</p>\n<p>用相同的方式去思考effects。useEffect使你能够根据props和state同步React tree之外的东西。</p>\n<h2 id=\"告诉-React-如何对比-Effect\"><a href=\"#告诉-React-如何对比-Effect\" class=\"headerlink\" title=\"告诉 React 如何对比 Effect\"></a>告诉 React 如何对比 Effect</h2><p>react 在 DOM渲染时会 diff 内容，只对改变的部分做修改。但是对于 effect 却做不到这样。</p>\n<p>如何避免 effect 重复调用，需要给 effect 提供一个 deps，deps 内变量改变的时候才执行。</p>\n<pre><code class=\"hljs jsx\">useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">document</span>.title = <span class=\"hljs-string\">&#x27;Hello, &#x27;</span> + name;\n  &#125;, [name]); <span class=\"hljs-comment\">// Our deps</span></code></pre>\n\n<h2 id=\"依赖项不要撒谎\"><a href=\"#依赖项不要撒谎\" class=\"headerlink\" title=\"依赖项不要撒谎\"></a>依赖项不要撒谎</h2><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SearchResults</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fetchData</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    fetchData();\n  &#125;, []); <span class=\"hljs-comment\">// Is this okay? Not always -- and there&#x27;s a better way to write it.</span>\n\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n\n<p>你设置了依赖项，effect中用到的所有组件内的值都要包含在依赖中。这包括 props，state，函数。</p>\n<p>这样做可能会遇到一些问题，比如会遇到重复渲染、无限请求等。解决问题的办法不是移除依赖性。后续再说。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      setCount(count + <span class=\"hljs-number\">1</span>);\n    &#125;, <span class=\"hljs-number\">1000</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(id);\n  &#125;, []);\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n&#125;</code></pre>\n\n<p>setInterval 只想只想一次，依赖写为 []。</p>\n<p>但是，因为 useEffect 拿到的是那次渲染时候的值。count 值永远是 0。setCount 没产生作用。</p>\n<h2 id=\"对依赖诚实的代价\"><a href=\"#对依赖诚实的代价\" class=\"headerlink\" title=\"对依赖诚实的代价\"></a>对依赖诚实的代价</h2><p>对依赖诚实，那就把 count 加到依赖中：</p>\n<pre><code class=\"hljs jsx\">useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    setCount(count + <span class=\"hljs-number\">1</span>);\n  &#125;, <span class=\"hljs-number\">1000</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(id);\n&#125;, [count]);</code></pre>\n\n<p>此时能够拿到最新的 count，但是有问题：</p>\n<ul>\n<li>每次变化都生成、销毁定时器，性能不好。</li>\n<li>每次重新定时，不准。</li>\n</ul>\n<h2 id=\"让-useEffect-自给自足\"><a href=\"#让-useEffect-自给自足\" class=\"headerlink\" title=\"让 useEffect 自给自足\"></a>让 useEffect 自给自足</h2><p>上述代码 对只想执行一次的 useEffect 里依赖了外部变量。</p>\n<p>解决办法就是 不依赖外部变量。</p>\n<pre><code class=\"hljs jsx\">useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    setCount(<span class=\"hljs-function\"><span class=\"hljs-params\">c</span> =&gt;</span> c + <span class=\"hljs-number\">1</span>);\n  &#125;, <span class=\"hljs-number\">1000</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(id);\n&#125;, []);</code></pre>\n\n<p>setCount 回调写法，对旧值进行修改。此时 useEffect 只允许一次，count 也能拿到最新的值。</p>\n<h2 id=\"解耦来自-Actions-的更新\"><a href=\"#解耦来自-Actions-的更新\" class=\"headerlink\" title=\"解耦来自 Actions 的更新\"></a>解耦来自 Actions 的更新</h2><p>setCount(c =&gt; c + 1) 并不能解决所有场景问题。如果我们有两个互相依赖的状态，或者我们想基于一个prop来计算下一次的state，它并不能做到。幸运的是， setCount(c =&gt; c + 1)有一个更强大的姐妹模式，它的名字叫useReducer。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">const</span> [step, setStep] = useState(<span class=\"hljs-number\">1</span>);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      setCount(<span class=\"hljs-function\"><span class=\"hljs-params\">c</span> =&gt;</span> c + step);\n    &#125;, <span class=\"hljs-number\">1000</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(id);\n  &#125;, [step]);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;step&#125;</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">&#123;e</span> =&gt;</span> setStep(Number(e.target.value))&#125; /&gt;</span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n&#125;</code></pre>\n\n<p>上述例子中没有依赖撒谎。但是 step 改变时，不想重启定时器怎么办？</p>\n<p>当你想更新一个状态，并且这个状态更新依赖于另一个状态的值时，你可能需要用useReducer去替换它们。</p>\n<p>利用 useReducer 函数，将更新与动作解耦：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> [state, dispatch] = useReducer(reducer, initialState);\n<span class=\"hljs-keyword\">const</span> &#123; count, step &#125; = state;\n\nuseEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    dispatch(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;tick&quot;</span> &#125;); <span class=\"hljs-comment\">// Instead of setCount(c =&gt; c + step);</span>\n  &#125;, <span class=\"hljs-number\">1000</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(id);\n&#125;, [dispatch]);</code></pre>\n\n<p>React会保证 dispatc 在组件的声明周期内保持不变。</p>\n<h2 id=\"依赖-props-计算状态\"><a href=\"#依赖-props-计算状态\" class=\"headerlink\" title=\"依赖 props 计算状态\"></a>依赖 props 计算状态</h2><p>前面介绍了如何移除effect的依赖，不管状态更新是依赖上一个状态还是依赖另一个状态。</p>\n<p>但假如我们需要依赖props去计算下一个状态呢。</p>\n<p><code>&lt;Counter step=&#123;1&#125; /&gt;</code>，此时如何避免依赖 props.step 呢？</p>\n<p>把 reducer 函数放到组件内部去读取 props：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\">&#123; step &#125;</span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, dispatch] = useReducer(reducer, <span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reducer</span>(<span class=\"hljs-params\">state, action</span>) </span>&#123;\n    <span class=\"hljs-keyword\">if</span> (action.type === <span class=\"hljs-string\">&#x27;tick&#x27;</span>) &#123;\n      <span class=\"hljs-keyword\">return</span> state + step;\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>();\n    &#125;\n  &#125;\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      dispatch(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;tick&#x27;</span> &#125;);\n    &#125;, <span class=\"hljs-number\">1000</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(id);\n  &#125;, [dispatch]);\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n&#125;</code></pre>\n\n<p>此时 react 仍能保证 dispatch 在每次渲染中都是一样的。</p>\n<p>这可以帮助我移除不必需的依赖，避免不必要的effect调用。</p>\n<h2 id=\"把函数移到-Effects-里\"><a href=\"#把函数移到-Effects-里\" class=\"headerlink\" title=\"把函数移到 Effects 里\"></a>把函数移到 Effects 里</h2><p>如果某些函数仅在effect中调用，你可以把它们的定义移到effect中：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SearchResults</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [query, setQuery] = useState(<span class=\"hljs-string\">&#x27;react&#x27;</span>);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getFetchUrl</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;\n    &#125;\n\n    <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fetchData</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">await</span> axios(getFetchUrl());\n      setData(result.data);\n    &#125;\n\n    fetchData();\n  &#125;, [query]); <span class=\"hljs-comment\">// ✅ Deps are OK</span>\n\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n</code></pre>\n\n<h2 id=\"当函数不能放在-Effects-里\"><a href=\"#当函数不能放在-Effects-里\" class=\"headerlink\" title=\"当函数不能放在 Effects 里\"></a>当函数不能放在 Effects 里</h2><p>有时函数不能放在 effects 里，如：</p>\n<ul>\n<li>组件内几个函数使用了相同的函数</li>\n<li>这个函数是一个 prop</li>\n</ul>\n<p>此时能忽略对函数的依赖么？最好不要，effects 对依赖不要撒谎。</p>\n<p>两种情况：</p>\n<ul>\n<li>1、函数内没有使用组件内的任何值，就提到组件外。</li>\n</ul>\n<pre><code class=\"hljs jsx\">/ ✅ Not affected by the data flow\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getFetchUrl</span>(<span class=\"hljs-params\">query</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SearchResults</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> url = getFetchUrl(<span class=\"hljs-string\">&#x27;react&#x27;</span>);\n    <span class=\"hljs-comment\">// ... Fetch data and do something ...</span>\n  &#125;, []); <span class=\"hljs-comment\">// ✅ Deps are OK</span>\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> url = getFetchUrl(<span class=\"hljs-string\">&#x27;redux&#x27;</span>);\n    <span class=\"hljs-comment\">// ... Fetch data and do something ...</span>\n  &#125;, []); <span class=\"hljs-comment\">// ✅ Deps are OK</span>\n\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n\n<ul>\n<li>2、放组件内，用 useCallback 包装, 将函数添加到依赖</li>\n</ul>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SearchResults</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [query, setQuery] = useState(<span class=\"hljs-string\">&#x27;react&#x27;</span>);\n\n  <span class=\"hljs-comment\">// ✅ Preserves identity until query changes</span>\n  <span class=\"hljs-keyword\">const</span> getFetchUrl = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;\n  &#125;, [query]);  <span class=\"hljs-comment\">// ✅ Callback deps are OK</span>\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> url = getFetchUrl();\n    <span class=\"hljs-comment\">// ... Fetch data and do something ...</span>\n  &#125;, [getFetchUrl]); <span class=\"hljs-comment\">// ✅ Effect deps are OK</span>\n\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n\n<p>使用 useCallback，因为如果query 保持不变，getFetchUrl也会保持不变，我们的effect也不会重新运行。</p>\n<p>父组件传入函数的情况，也适用该方法：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Parent</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [query, setQuery] = useState(<span class=\"hljs-string\">&#x27;react&#x27;</span>);\n\n  <span class=\"hljs-comment\">// ✅ Preserves identity until query changes</span>\n  <span class=\"hljs-keyword\">const</span> fetchData = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> url = <span class=\"hljs-string\">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;\n    <span class=\"hljs-comment\">// ... Fetch data and return it ...</span>\n  &#125;, [query]);  <span class=\"hljs-comment\">// ✅ Callback deps are OK</span>\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Child</span> <span class=\"hljs-attr\">fetchData</span>=<span class=\"hljs-string\">&#123;fetchData&#125;</span> /&gt;</span></span>\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Child</span>(<span class=\"hljs-params\">&#123; fetchData &#125;</span>) </span>&#123;\n  <span class=\"hljs-keyword\">let</span> [data, setData] = useState(<span class=\"hljs-literal\">null</span>);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    fetchData().then(setData);\n  &#125;, [fetchData]); <span class=\"hljs-comment\">// ✅ Effect deps are OK</span>\n\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n\n<p>避免到处使用 useCallback。</p>\n<p>当我们需要将函数传递下去并且函数会在子组件的effect中被调用的时候，useCallback 是很好的技巧且非常有用。或者你想试图减少对子组件的记忆负担，也不妨一试。</p>\n<ul>\n<li>3、更好的方式可能是把他抽成自定义 Hook，把 fetchData 放在 effect 里。</li>\n</ul>\n<p>useEffect 只是底层 API，未来业务接触到的是更多封装后的上层 API，比如 useFetch 或者 useTheme，它们会更好用。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React, &#123; useState, useEffect, useReducer &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>\n\n<span class=\"hljs-keyword\">const</span> GITHUB_API = <span class=\"hljs-string\">&#x27;https://api.github.com/repos/chanshiyucx/blog/issues?page=10&amp;per_page=&#x27;</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> () =&gt; &#123;\n  <span class=\"hljs-keyword\">const</span> [list, setList] = useState([])\n  <span class=\"hljs-keyword\">const</span> [page, setPage] = useState(<span class=\"hljs-number\">1</span>)\n\n  <span class=\"hljs-keyword\">const</span> &#123; data, doFetch &#125; = useDataApi(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;GITHUB_API&#125;</span><span class=\"hljs-subst\">$&#123;page&#125;</span>`</span>, [])\n  <span class=\"hljs-comment\">// 翻页时重新获取列表</span>\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> doFetch(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;GITHUB_API&#125;</span><span class=\"hljs-subst\">$&#123;page&#125;</span>`</span>), [page])\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> setList(data), [data])\n\n  <span class=\"hljs-keyword\">const</span> handleNextPage = <span class=\"hljs-function\">() =&gt;</span> setPage(page + <span class=\"hljs-number\">1</span>)\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;handleNextPage&#125;</span>&gt;</span>NextPage<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span></span>\n<span class=\"xml\">        &#123;list.map(o =&gt; (</span>\n<span class=\"xml\">          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#123;o.id&#125;</span>&gt;</span>&#123;o.title&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span>\n<span class=\"xml\">        ))&#125;</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></span>\n<span class=\"xml\"></span>\n<span class=\"xml\">      &#123;isError &amp;&amp; <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Something went wrong ...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>&#125;</span>\n<span class=\"xml\">      &#123;isLoading &amp;&amp; <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Loading ...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>&#125;</span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  )\n&#125;</code></pre>\n\n<p>reducer:</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> dataFetchReducer = <span class=\"hljs-function\">(<span class=\"hljs-params\">state, action</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">switch</span> (action.type) &#123;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;FETCH_INIT&#x27;</span>:\n      <span class=\"hljs-keyword\">return</span> &#123;\n        ...state,\n        <span class=\"hljs-attr\">isLoading</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">isError</span>: <span class=\"hljs-literal\">false</span>\n      &#125;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;FETCH_SUCCESS&#x27;</span>:\n      <span class=\"hljs-keyword\">return</span> &#123;\n        ...state,\n        <span class=\"hljs-attr\">isLoading</span>: <span class=\"hljs-literal\">false</span>,\n        <span class=\"hljs-attr\">isError</span>: <span class=\"hljs-literal\">false</span>,\n        <span class=\"hljs-attr\">data</span>: action.payload\n      &#125;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;FETCH_FAILURE&#x27;</span>:\n      <span class=\"hljs-keyword\">return</span> &#123;\n        ...state,\n        <span class=\"hljs-attr\">isLoading</span>: <span class=\"hljs-literal\">false</span>,\n        <span class=\"hljs-attr\">isError</span>: <span class=\"hljs-literal\">true</span>\n      &#125;\n    <span class=\"hljs-attr\">default</span>:\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>()\n  &#125;\n&#125;</code></pre>\n\n<p>自定义 Hook：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> useDataApi = <span class=\"hljs-function\">(<span class=\"hljs-params\">initialUrl, initialData</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> [url, setUrl] = useState(initialUrl)\n\n  <span class=\"hljs-keyword\">const</span> [state, dispatch] = useReducer(dataFetchReducer, &#123;\n    <span class=\"hljs-attr\">isLoading</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">isError</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">data</span>: initialData\n  &#125;)\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">let</span> didCancel = <span class=\"hljs-literal\">false</span>\n\n    <span class=\"hljs-keyword\">const</span> fetchData = <span class=\"hljs-keyword\">async</span> () =&gt; &#123;\n      dispatch(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;FETCH_INIT&#x27;</span> &#125;)\n      <span class=\"hljs-keyword\">try</span> &#123;\n        <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> fetch(url)\n        <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> response.json()\n        <span class=\"hljs-keyword\">if</span> (!didCancel) &#123;\n          dispatch(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;FETCH_SUCCESS&#x27;</span>, <span class=\"hljs-attr\">payload</span>: data &#125;)\n        &#125;\n      &#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;\n        <span class=\"hljs-keyword\">if</span> (!didCancel) &#123;\n          dispatch(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;FETCH_FAILURE&#x27;</span> &#125;)\n        &#125;\n      &#125;\n    &#125;\n    fetchData()\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      didCancel = <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;, [url])\n\n  <span class=\"hljs-keyword\">const</span> doFetch = <span class=\"hljs-function\"><span class=\"hljs-params\">url</span> =&gt;</span> &#123;\n    setUrl(url)\n  &#125;\n\n  <span class=\"hljs-keyword\">return</span> &#123; ...state, doFetch &#125;\n&#125;</code></pre>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://overreacted.io/a-complete-guide-to-useeffect/\">a-complete-guide-to-useeffect</a></li>\n<li><a href=\"https://www.robinwieruch.de/react-hooks-fetch-data/\">https://www.robinwieruch.de/react-hooks-fetch-data/</a></li>\n</ul>\n"},{"title":"React 中常用 TS 类型","index_img":"/img/2022-03-20-1.webp","abbrlink":"25e26362","date":"2022-03-20T09:21:09.000Z","_content":"\n## 函数组件注解\n\n```ts\nconst Test = React.FC<Props>\n```\n\n## 类组件注解\n\n```ts\nclass Test extends React.Component<Props,States>\n```\n\n## 泛型 class 组件\n\n```ts\ninterface SelectProps<T> {\n  items: T[]\n}\n\nclass Select<T> extends React.Component<SelectProps<T>, {}> {\n  // ...\n}\n\nconst Form = () => <Select<string> items={['a', 'b']} />\n```\n","source":"_posts/10.React 中常用 TS 类型.md","raw":"---\ntitle: React 中常用 TS 类型\nindex_img: /img/2022-03-20-1.webp\ntags: React TypeScript\ncategories: React\nabbrlink: '25e26362'\ndate: 2022-03-20 17:21:09\n---\n\n## 函数组件注解\n\n```ts\nconst Test = React.FC<Props>\n```\n\n## 类组件注解\n\n```ts\nclass Test extends React.Component<Props,States>\n```\n\n## 泛型 class 组件\n\n```ts\ninterface SelectProps<T> {\n  items: T[]\n}\n\nclass Select<T> extends React.Component<SelectProps<T>, {}> {\n  // ...\n}\n\nconst Form = () => <Select<string> items={['a', 'b']} />\n```\n","slug":"10-React-中常用-TS-类型","published":1,"updated":"2022-04-15T09:58:58.516Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k5bv76000q0h3l5h1t99e6","content":"<h2 id=\"函数组件注解\"><a href=\"#函数组件注解\" class=\"headerlink\" title=\"函数组件注解\"></a>函数组件注解</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> Test = React.FC&lt;Props&gt;</code></pre></div>\n\n<h2 id=\"类组件注解\"><a href=\"#类组件注解\" class=\"headerlink\" title=\"类组件注解\"></a>类组件注解</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">Props</span>,<span class=\"hljs-title\">States</span>&gt;</span></code></pre></div>\n\n<h2 id=\"泛型-class-组件\"><a href=\"#泛型-class-组件\" class=\"headerlink\" title=\"泛型 class 组件\"></a>泛型 class 组件</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> SelectProps&lt;T&gt; &#123;\n  <span class=\"hljs-attr\">items</span>: T[]\n&#125;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Select</span>&lt;<span class=\"hljs-title\">T</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">SelectProps</span>&lt;<span class=\"hljs-title\">T</span>&gt;, </span>&#123;&#125;&gt; &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n\n<span class=\"hljs-keyword\">const</span> Form = <span class=\"hljs-function\">() =&gt;</span> &lt;Select&lt;<span class=\"hljs-built_in\">string</span>&gt; items=&#123;[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>]&#125; /&gt;</code></pre></div>\n","site":{"data":{}},"wordcount":345,"excerpt":"","more":"<h2 id=\"函数组件注解\"><a href=\"#函数组件注解\" class=\"headerlink\" title=\"函数组件注解\"></a>函数组件注解</h2><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> Test = React.FC&lt;Props&gt;</code></pre>\n\n<h2 id=\"类组件注解\"><a href=\"#类组件注解\" class=\"headerlink\" title=\"类组件注解\"></a>类组件注解</h2><pre><code class=\"hljs ts\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">Props</span>,<span class=\"hljs-title\">States</span>&gt;</span></code></pre>\n\n<h2 id=\"泛型-class-组件\"><a href=\"#泛型-class-组件\" class=\"headerlink\" title=\"泛型 class 组件\"></a>泛型 class 组件</h2><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> SelectProps&lt;T&gt; &#123;\n  <span class=\"hljs-attr\">items</span>: T[]\n&#125;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Select</span>&lt;<span class=\"hljs-title\">T</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">SelectProps</span>&lt;<span class=\"hljs-title\">T</span>&gt;, </span>&#123;&#125;&gt; &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n\n<span class=\"hljs-keyword\">const</span> Form = <span class=\"hljs-function\">() =&gt;</span> &lt;Select&lt;<span class=\"hljs-built_in\">string</span>&gt; items=&#123;[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>]&#125; /&gt;</code></pre>\n"},{"title":"Antd 源码分析之 useMergedState.md","index_img":"/img/2022-04-29-2.jpeg","abbrlink":"e6886795","date":"2022-04-28T15:55:06.000Z","_content":"\n用法与 useState 类似，区别是 如果 props 提供 value 值，将会用 value 值来初始化 state 状态。\n\n## 用法\n\n```ts\nconst [innerChecked, setInnerChecked] = useMergedState<boolean>(false, {\n      value: checked,\n      defaultValue: defaultChecked,\n    });\n```\n\n## 源码分析\n\n```ts\nimport * as React, { useState } from 'react';\n\n/**\n* Similar to `useState` but will use props value if provided.\n */\nexport default function useMergedState<T, R = T>(\n  defaultStateValue: T | (() => T),\n  option?: {\n    defaultValue?: T | (() => T);\n    value?: T;\n    onChange?: (value: T, prevValue: T) => void;\n    postState?: (value: T) => T;\n  },\n): [R, (value: T, ignoreDestroy?: boolean) => void] {\n  const { defaultValue, value, onChange, postState } = option || {};\n  // 声明内部 value 值\n  const [innerValue, setInnerValue] = useState<T>(() => {\n    // value 存在，用 value 初始化 innerValue 的值\n    if (value !== undefined) {\n      return value;\n    }\n    // 同上\n    if (defaultValue !== undefined) {\n      return typeof defaultValue === 'function'\n        ? (defaultValue as any)()\n        : defaultValue;\n    }\n    // defaultStateValue 优先级最低\n    return typeof defaultStateValue === 'function'\n      ? (defaultStateValue as any)()\n      : defaultStateValue;\n  });\n\n  let mergedValue = value !== undefined ? value : innerValue;\n  if (postState) {\n    // 数据处理\n    mergedValue = postState(mergedValue);\n  }\n\n  // 封装内部的 setState\n  const onChangeRef = React.useRef(onChange);\n  onChangeRef.current = onChange;\n\n  const triggerChange = React.useCallback(\n    (newValue: T, ignoreDestroy?: boolean) => {\n      setInnerValue(newValue, ignoreDestroy);\n      if (mergedValue !== newValue && onChangeRef.current) {\n        onChangeRef.current(newValue, mergedValue);\n      }\n    },\n    [mergedValue, onChangeRef],\n  );\n\n  // Effect of reset value to `undefined`\n  const prevValueRef = React.useRef(value);\n  React.useEffect(() => {\n    if (value === undefined && value !== prevValueRef.current) {\n      setInnerValue(value);\n    }\n\n    prevValueRef.current = value;\n  }, [value]);\n\n  return [mergedValue as unknown as R, triggerChange];\n}\n\n```\n","source":"_posts/13.Antd 源码分析之 useMergedState.md","raw":"---\ntitle: Antd 源码分析之 useMergedState.md\nindex_img: /img/2022-04-29-2.jpeg\nabbrlink: e6886795\ndate: 2022-04-28 23:55:06\ntags: Hook\ncategories: React\n---\n\n用法与 useState 类似，区别是 如果 props 提供 value 值，将会用 value 值来初始化 state 状态。\n\n## 用法\n\n```ts\nconst [innerChecked, setInnerChecked] = useMergedState<boolean>(false, {\n      value: checked,\n      defaultValue: defaultChecked,\n    });\n```\n\n## 源码分析\n\n```ts\nimport * as React, { useState } from 'react';\n\n/**\n* Similar to `useState` but will use props value if provided.\n */\nexport default function useMergedState<T, R = T>(\n  defaultStateValue: T | (() => T),\n  option?: {\n    defaultValue?: T | (() => T);\n    value?: T;\n    onChange?: (value: T, prevValue: T) => void;\n    postState?: (value: T) => T;\n  },\n): [R, (value: T, ignoreDestroy?: boolean) => void] {\n  const { defaultValue, value, onChange, postState } = option || {};\n  // 声明内部 value 值\n  const [innerValue, setInnerValue] = useState<T>(() => {\n    // value 存在，用 value 初始化 innerValue 的值\n    if (value !== undefined) {\n      return value;\n    }\n    // 同上\n    if (defaultValue !== undefined) {\n      return typeof defaultValue === 'function'\n        ? (defaultValue as any)()\n        : defaultValue;\n    }\n    // defaultStateValue 优先级最低\n    return typeof defaultStateValue === 'function'\n      ? (defaultStateValue as any)()\n      : defaultStateValue;\n  });\n\n  let mergedValue = value !== undefined ? value : innerValue;\n  if (postState) {\n    // 数据处理\n    mergedValue = postState(mergedValue);\n  }\n\n  // 封装内部的 setState\n  const onChangeRef = React.useRef(onChange);\n  onChangeRef.current = onChange;\n\n  const triggerChange = React.useCallback(\n    (newValue: T, ignoreDestroy?: boolean) => {\n      setInnerValue(newValue, ignoreDestroy);\n      if (mergedValue !== newValue && onChangeRef.current) {\n        onChangeRef.current(newValue, mergedValue);\n      }\n    },\n    [mergedValue, onChangeRef],\n  );\n\n  // Effect of reset value to `undefined`\n  const prevValueRef = React.useRef(value);\n  React.useEffect(() => {\n    if (value === undefined && value !== prevValueRef.current) {\n      setInnerValue(value);\n    }\n\n    prevValueRef.current = value;\n  }, [value]);\n\n  return [mergedValue as unknown as R, triggerChange];\n}\n\n```\n","slug":"13-Antd-源码分析之-useMergedState","published":1,"updated":"2022-04-29T02:08:35.703Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k5bv77000v0h3l1nuddd7u","content":"<p>用法与 useState 类似，区别是 如果 props 提供 value 值，将会用 value 值来初始化 state 状态。</p>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> [innerChecked, setInnerChecked] = useMergedState&lt;<span class=\"hljs-built_in\">boolean</span>&gt;(<span class=\"hljs-literal\">false</span>, &#123;\n      <span class=\"hljs-attr\">value</span>: checked,\n      <span class=\"hljs-attr\">defaultValue</span>: defaultChecked,\n    &#125;);</code></pre></div>\n\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> React, &#123; useState &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n\n<span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">* Similar to `useState` but will use props value if provided.</span>\n<span class=\"hljs-comment\"> */</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useMergedState</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">R</span> = <span class=\"hljs-title\">T</span>&gt;(<span class=\"hljs-params\"></span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">  defaultStateValue: T | (() =&gt; T),</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">  option?: &#123;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    defaultValue?: T | (() =&gt; T);</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    value?: T;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    onChange?: (value: T, prevValue: T) =&gt; <span class=\"hljs-built_in\">void</span>;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    postState?: (value: T) =&gt; T;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">  &#125;,</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\"></span>): [<span class=\"hljs-title\">R</span>, (<span class=\"hljs-params\">value: T, ignoreDestroy?: <span class=\"hljs-built_in\">boolean</span></span>) =&gt; <span class=\"hljs-title\">void</span>] </span>&#123;\n  <span class=\"hljs-keyword\">const</span> &#123; defaultValue, value, onChange, postState &#125; = option || &#123;&#125;;\n  <span class=\"hljs-comment\">// 声明内部 value 值</span>\n  <span class=\"hljs-keyword\">const</span> [innerValue, setInnerValue] = useState&lt;T&gt;(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-comment\">// value 存在，用 value 初始化 innerValue 的值</span>\n    <span class=\"hljs-keyword\">if</span> (value !== <span class=\"hljs-literal\">undefined</span>) &#123;\n      <span class=\"hljs-keyword\">return</span> value;\n    &#125;\n    <span class=\"hljs-comment\">// 同上</span>\n    <span class=\"hljs-keyword\">if</span> (defaultValue !== <span class=\"hljs-literal\">undefined</span>) &#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> defaultValue === <span class=\"hljs-string\">&#x27;function&#x27;</span>\n        ? (defaultValue <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>)()\n        : defaultValue;\n    &#125;\n    <span class=\"hljs-comment\">// defaultStateValue 优先级最低</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> defaultStateValue === <span class=\"hljs-string\">&#x27;function&#x27;</span>\n      ? (defaultStateValue <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>)()\n      : defaultStateValue;\n  &#125;);\n\n  <span class=\"hljs-keyword\">let</span> mergedValue = value !== <span class=\"hljs-literal\">undefined</span> ? value : innerValue;\n  <span class=\"hljs-keyword\">if</span> (postState) &#123;\n    <span class=\"hljs-comment\">// 数据处理</span>\n    mergedValue = postState(mergedValue);\n  &#125;\n\n  <span class=\"hljs-comment\">// 封装内部的 setState</span>\n  <span class=\"hljs-keyword\">const</span> onChangeRef = React.useRef(onChange);\n  onChangeRef.current = onChange;\n\n  <span class=\"hljs-keyword\">const</span> triggerChange = React.useCallback(\n    <span class=\"hljs-function\">(<span class=\"hljs-params\">newValue: T, ignoreDestroy?: <span class=\"hljs-built_in\">boolean</span></span>) =&gt;</span> &#123;\n      setInnerValue(newValue, ignoreDestroy);\n      <span class=\"hljs-keyword\">if</span> (mergedValue !== newValue &amp;&amp; onChangeRef.current) &#123;\n        onChangeRef.current(newValue, mergedValue);\n      &#125;\n    &#125;,\n    [mergedValue, onChangeRef],\n  );\n\n  <span class=\"hljs-comment\">// Effect of reset value to `undefined`</span>\n  <span class=\"hljs-keyword\">const</span> prevValueRef = React.useRef(value);\n  React.useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">if</span> (value === <span class=\"hljs-literal\">undefined</span> &amp;&amp; value !== prevValueRef.current) &#123;\n      setInnerValue(value);\n    &#125;\n\n    prevValueRef.current = value;\n  &#125;, [value]);\n\n  <span class=\"hljs-keyword\">return</span> [mergedValue <span class=\"hljs-keyword\">as</span> unknown <span class=\"hljs-keyword\">as</span> R, triggerChange];\n&#125;\n</code></pre></div>\n","site":{"data":{}},"wordcount":1795,"excerpt":"","more":"<p>用法与 useState 类似，区别是 如果 props 提供 value 值，将会用 value 值来初始化 state 状态。</p>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> [innerChecked, setInnerChecked] = useMergedState&lt;<span class=\"hljs-built_in\">boolean</span>&gt;(<span class=\"hljs-literal\">false</span>, &#123;\n      <span class=\"hljs-attr\">value</span>: checked,\n      <span class=\"hljs-attr\">defaultValue</span>: defaultChecked,\n    &#125;);</code></pre>\n\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> React, &#123; useState &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n\n<span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">* Similar to `useState` but will use props value if provided.</span>\n<span class=\"hljs-comment\"> */</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useMergedState</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">R</span> = <span class=\"hljs-title\">T</span>&gt;(<span class=\"hljs-params\"></span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">  defaultStateValue: T | (() =&gt; T),</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">  option?: &#123;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    defaultValue?: T | (() =&gt; T);</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    value?: T;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    onChange?: (value: T, prevValue: T) =&gt; <span class=\"hljs-built_in\">void</span>;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    postState?: (value: T) =&gt; T;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">  &#125;,</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\"></span>): [<span class=\"hljs-title\">R</span>, (<span class=\"hljs-params\">value: T, ignoreDestroy?: <span class=\"hljs-built_in\">boolean</span></span>) =&gt; <span class=\"hljs-title\">void</span>] </span>&#123;\n  <span class=\"hljs-keyword\">const</span> &#123; defaultValue, value, onChange, postState &#125; = option || &#123;&#125;;\n  <span class=\"hljs-comment\">// 声明内部 value 值</span>\n  <span class=\"hljs-keyword\">const</span> [innerValue, setInnerValue] = useState&lt;T&gt;(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-comment\">// value 存在，用 value 初始化 innerValue 的值</span>\n    <span class=\"hljs-keyword\">if</span> (value !== <span class=\"hljs-literal\">undefined</span>) &#123;\n      <span class=\"hljs-keyword\">return</span> value;\n    &#125;\n    <span class=\"hljs-comment\">// 同上</span>\n    <span class=\"hljs-keyword\">if</span> (defaultValue !== <span class=\"hljs-literal\">undefined</span>) &#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> defaultValue === <span class=\"hljs-string\">&#x27;function&#x27;</span>\n        ? (defaultValue <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>)()\n        : defaultValue;\n    &#125;\n    <span class=\"hljs-comment\">// defaultStateValue 优先级最低</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> defaultStateValue === <span class=\"hljs-string\">&#x27;function&#x27;</span>\n      ? (defaultStateValue <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>)()\n      : defaultStateValue;\n  &#125;);\n\n  <span class=\"hljs-keyword\">let</span> mergedValue = value !== <span class=\"hljs-literal\">undefined</span> ? value : innerValue;\n  <span class=\"hljs-keyword\">if</span> (postState) &#123;\n    <span class=\"hljs-comment\">// 数据处理</span>\n    mergedValue = postState(mergedValue);\n  &#125;\n\n  <span class=\"hljs-comment\">// 封装内部的 setState</span>\n  <span class=\"hljs-keyword\">const</span> onChangeRef = React.useRef(onChange);\n  onChangeRef.current = onChange;\n\n  <span class=\"hljs-keyword\">const</span> triggerChange = React.useCallback(\n    <span class=\"hljs-function\">(<span class=\"hljs-params\">newValue: T, ignoreDestroy?: <span class=\"hljs-built_in\">boolean</span></span>) =&gt;</span> &#123;\n      setInnerValue(newValue, ignoreDestroy);\n      <span class=\"hljs-keyword\">if</span> (mergedValue !== newValue &amp;&amp; onChangeRef.current) &#123;\n        onChangeRef.current(newValue, mergedValue);\n      &#125;\n    &#125;,\n    [mergedValue, onChangeRef],\n  );\n\n  <span class=\"hljs-comment\">// Effect of reset value to `undefined`</span>\n  <span class=\"hljs-keyword\">const</span> prevValueRef = React.useRef(value);\n  React.useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">if</span> (value === <span class=\"hljs-literal\">undefined</span> &amp;&amp; value !== prevValueRef.current) &#123;\n      setInnerValue(value);\n    &#125;\n\n    prevValueRef.current = value;\n  &#125;, [value]);\n\n  <span class=\"hljs-keyword\">return</span> [mergedValue <span class=\"hljs-keyword\">as</span> unknown <span class=\"hljs-keyword\">as</span> R, triggerChange];\n&#125;\n</code></pre>\n"},{"title":"React Hooks 之 useCallback","index_img":"/img/2022-04-18-1.png","abbrlink":"b3515e96","date":"2022-04-18T02:44:18.000Z","_content":"\n## 类组件，父组件传方法给子组件\n\n父组件：\n\n```jsx\nclass Parent extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  handleChildren() {\n    console.log(\"clicked Children\");\n  }\n\n  handleParent() {\n    console.log(\"clicked Parent\");\n    this.setState((preCount) => ({ count: preCount + 1 }));\n  }\n\n  render() {\n    return (\n      <div>\n        <div\n          onClick={() => {\n            this.handleParent();\n          }}\n        >\n          Parent{\" \"}\n        </div>\n\n        <Children\n          handleChildren={() => {\n            this.handleChildren();\n          }}\n        />\n      </div>\n    );\n  }\n}\n\n```\n\n子组件：\n\n```jsx\nclass Children extends PureComponent {\n  render() {\n    const { handleChildren } = this.props;\n    console.log(\"render Children\");\n    return <div onClick={handleChildren}>Children </div>;\n  }\n}\n```\n\n每次点击 Parent，都会打印 `render Children`，子组件都会重新渲染，虽然子组件用了 PureComponent。\n\n因为父组件 setState 改变后，render() 会重新渲染，Children 组件的 handleChildren prop 采用的是(内联函数)匿名函数赋值，导致每次的引用地址不一样,PureComponent 优化无效。\n\n正确是写法如下：\n\n```jsx\n...\n <Children handleChildren={this.handleChildren}/>\n...\n```\n\n## 函数组件，useCallback 使用场景\n\nuseCallback 在依赖不变的时候，返回的回调函数保持同一个引用地址。useCallback 的真正目的是在于缓存每次渲染时内联函数的实例。\n\n```jsx\nconst Parent = () => {\n  const [count, setCount] = useState(0);\n\n  const handleParent = () => {\n    console.log(\"clicked Parent\");\n    setCount((preCount) => preCount + 1);\n  };\n\n  const handleChildren = useCallback(() => {\n    console.log(\"clicked Children\");\n  }, []);\n\n  return (\n    <div>\n      <div onClick={handleParent}>Parent (count:{count}) </div>\n      <Children handleChildren={handleChildren} />\n    </div>\n  );\n};\n\nconst Children = memo(({ handleChildren }) => {\n  console.log(\"Children rending\");\n  return <div onClick={handleChildren}>Children </div>;\n});\n```\n\n需要注意的是:\n\n- 单纯的 useCallback 包裹，并不能提升性能，反而会下降，useCallback 需要配合子组件优化（memo）成对使用，缺一性能都不升反降。\n\n    ```jsx\n    <!-- \n    不管是否使用useCallback，都无法避免重新创建内部函数\n    使用 useCallback，还增加了 useCallback 内部对依赖项变化的检测\n     -->\n    function A() {\n      // ...\n      const cb = () => {}/* 创建了 */;\n\n    }\n\n    function B() {\n      // ...\n      const cb = useCallback(() => {}/*还是创建了*/, [a, b]);\n    }\n    ```\n\n## [如何从 useCallback 读取一个经常变化的值？](https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback)\n\n有时候一个函数依赖于一个经常变化的 state ，内部函数必须经常重新创建，那缓存方法的作用就没什么意义。\n\n```jsx\nfunction Form() {\n  const [text, updateText] = useState(\"\");\n\n  const handleSubmit = useCallback(() => {\n    console.log(text);\n  }, [text]); // 每次 text 变化时 handleSubmit 都会变\n\n  return (\n    <>\n      <input value={text} onChange={(e) => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n\nfunction ExpensiveTree(props) {\n  return <div onClick={props.onSubmit}>Submit</div>;\n}\n```\n\n如果你想要记住的函数是一个事件处理器并且在渲染期间没有被用到，可以把 ref 当做实例变量来用，并手动把最后提交的值保存在它当中：\n\n```jsx\nfunction Form() {\n  const [text, updateText] = useState(\"\");\n  const textRef = useRef();\n\n  useEffect(() => {\n    textRef.current = text; // 把它写入 ref\n  });\n\n  const handleSubmit = useCallback(() => {\n    const currentText = textRef.current; // 从 ref 读取它\n    alert(currentText);\n  }, [textRef]); // 不要像 [text] 那样重新创建 handleSubmit\n\n  return (\n    <>\n      <input value={text} onChange={(e) => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n\nfunction ExpensiveTree(props) {\n  return <div onClick={props.onSubmit}>Submit</div>;\n}\n```\n\n上述方式可以用来达到优化的目的，但是更佳的方式是抽成自定义 Hook:\n\n```jsx\nfunction Form() {\n  const [text, updateText] = useState('');\n  // 即便 `text` 变了也会被记住:\n  const handleSubmit = useEventCallback(() => {\n    alert(text);\n  }, [text]);\n\n  return (\n    <>\n      <input value={text} onChange={e => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n\nfunction useEventCallback(fn, dependencies) {\n  const ref = useRef(() => {\n    throw new Error('Cannot call an event handler while rendering.');\n  });\n\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn, ...dependencies]);\n\n  return useCallback(() => {\n    const fn = ref.current;\n    return fn();\n  }, [ref]);\n}\n```\n\n## 最后，官方推荐在 context 中向下传递 dispatch 而非在 props 中使用独立的回调\n\n- [如何避免向下传递回调？](https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down)\n","source":"_posts/12.React Hooks 之 useCallback.md","raw":"---\ntitle: React Hooks 之 useCallback\nindex_img: /img/2022-04-18-1.png\nabbrlink: b3515e96\ndate: 2022-04-18 10:44:18\ntags: useCallback\ncategories:\n- [React Hook]\n- [React]\n---\n\n## 类组件，父组件传方法给子组件\n\n父组件：\n\n```jsx\nclass Parent extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  handleChildren() {\n    console.log(\"clicked Children\");\n  }\n\n  handleParent() {\n    console.log(\"clicked Parent\");\n    this.setState((preCount) => ({ count: preCount + 1 }));\n  }\n\n  render() {\n    return (\n      <div>\n        <div\n          onClick={() => {\n            this.handleParent();\n          }}\n        >\n          Parent{\" \"}\n        </div>\n\n        <Children\n          handleChildren={() => {\n            this.handleChildren();\n          }}\n        />\n      </div>\n    );\n  }\n}\n\n```\n\n子组件：\n\n```jsx\nclass Children extends PureComponent {\n  render() {\n    const { handleChildren } = this.props;\n    console.log(\"render Children\");\n    return <div onClick={handleChildren}>Children </div>;\n  }\n}\n```\n\n每次点击 Parent，都会打印 `render Children`，子组件都会重新渲染，虽然子组件用了 PureComponent。\n\n因为父组件 setState 改变后，render() 会重新渲染，Children 组件的 handleChildren prop 采用的是(内联函数)匿名函数赋值，导致每次的引用地址不一样,PureComponent 优化无效。\n\n正确是写法如下：\n\n```jsx\n...\n <Children handleChildren={this.handleChildren}/>\n...\n```\n\n## 函数组件，useCallback 使用场景\n\nuseCallback 在依赖不变的时候，返回的回调函数保持同一个引用地址。useCallback 的真正目的是在于缓存每次渲染时内联函数的实例。\n\n```jsx\nconst Parent = () => {\n  const [count, setCount] = useState(0);\n\n  const handleParent = () => {\n    console.log(\"clicked Parent\");\n    setCount((preCount) => preCount + 1);\n  };\n\n  const handleChildren = useCallback(() => {\n    console.log(\"clicked Children\");\n  }, []);\n\n  return (\n    <div>\n      <div onClick={handleParent}>Parent (count:{count}) </div>\n      <Children handleChildren={handleChildren} />\n    </div>\n  );\n};\n\nconst Children = memo(({ handleChildren }) => {\n  console.log(\"Children rending\");\n  return <div onClick={handleChildren}>Children </div>;\n});\n```\n\n需要注意的是:\n\n- 单纯的 useCallback 包裹，并不能提升性能，反而会下降，useCallback 需要配合子组件优化（memo）成对使用，缺一性能都不升反降。\n\n    ```jsx\n    <!-- \n    不管是否使用useCallback，都无法避免重新创建内部函数\n    使用 useCallback，还增加了 useCallback 内部对依赖项变化的检测\n     -->\n    function A() {\n      // ...\n      const cb = () => {}/* 创建了 */;\n\n    }\n\n    function B() {\n      // ...\n      const cb = useCallback(() => {}/*还是创建了*/, [a, b]);\n    }\n    ```\n\n## [如何从 useCallback 读取一个经常变化的值？](https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback)\n\n有时候一个函数依赖于一个经常变化的 state ，内部函数必须经常重新创建，那缓存方法的作用就没什么意义。\n\n```jsx\nfunction Form() {\n  const [text, updateText] = useState(\"\");\n\n  const handleSubmit = useCallback(() => {\n    console.log(text);\n  }, [text]); // 每次 text 变化时 handleSubmit 都会变\n\n  return (\n    <>\n      <input value={text} onChange={(e) => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n\nfunction ExpensiveTree(props) {\n  return <div onClick={props.onSubmit}>Submit</div>;\n}\n```\n\n如果你想要记住的函数是一个事件处理器并且在渲染期间没有被用到，可以把 ref 当做实例变量来用，并手动把最后提交的值保存在它当中：\n\n```jsx\nfunction Form() {\n  const [text, updateText] = useState(\"\");\n  const textRef = useRef();\n\n  useEffect(() => {\n    textRef.current = text; // 把它写入 ref\n  });\n\n  const handleSubmit = useCallback(() => {\n    const currentText = textRef.current; // 从 ref 读取它\n    alert(currentText);\n  }, [textRef]); // 不要像 [text] 那样重新创建 handleSubmit\n\n  return (\n    <>\n      <input value={text} onChange={(e) => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n\nfunction ExpensiveTree(props) {\n  return <div onClick={props.onSubmit}>Submit</div>;\n}\n```\n\n上述方式可以用来达到优化的目的，但是更佳的方式是抽成自定义 Hook:\n\n```jsx\nfunction Form() {\n  const [text, updateText] = useState('');\n  // 即便 `text` 变了也会被记住:\n  const handleSubmit = useEventCallback(() => {\n    alert(text);\n  }, [text]);\n\n  return (\n    <>\n      <input value={text} onChange={e => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n\nfunction useEventCallback(fn, dependencies) {\n  const ref = useRef(() => {\n    throw new Error('Cannot call an event handler while rendering.');\n  });\n\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn, ...dependencies]);\n\n  return useCallback(() => {\n    const fn = ref.current;\n    return fn();\n  }, [ref]);\n}\n```\n\n## 最后，官方推荐在 context 中向下传递 dispatch 而非在 props 中使用独立的回调\n\n- [如何避免向下传递回调？](https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down)\n","slug":"12-React-Hooks-之-useCallback","published":1,"updated":"2022-04-19T02:34:15.712Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k5bv78000y0h3l4mz21cti","content":"<h2 id=\"类组件，父组件传方法给子组件\"><a href=\"#类组件，父组件传方法给子组件\" class=\"headerlink\" title=\"类组件，父组件传方法给子组件\"></a>类组件，父组件传方法给子组件</h2><p>父组件：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Parent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;\n    <span class=\"hljs-built_in\">super</span>(props);\n    <span class=\"hljs-built_in\">this</span>.state = &#123;\n      <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span>\n    &#125;;\n  &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">handleChildren</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;clicked Children&quot;</span>);\n  &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">handleParent</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;clicked Parent&quot;</span>);\n    <span class=\"hljs-built_in\">this</span>.setState(<span class=\"hljs-function\">(<span class=\"hljs-params\">preCount</span>) =&gt;</span> (&#123; <span class=\"hljs-attr\">count</span>: preCount + <span class=\"hljs-number\">1</span> &#125;));\n  &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span></span></span>\n<span class=\"hljs-tag\"><span class=\"xml\">          <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span>\n<span class=\"xml\">            this.handleParent();</span>\n<span class=\"xml\">          &#125;&#125;</span>\n<span class=\"xml\">        &gt;</span>\n<span class=\"xml\">          Parent&#123;&quot; &quot;&#125;</span>\n<span class=\"xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\"></span>\n<span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Children</span></span></span>\n<span class=\"hljs-tag\"><span class=\"xml\">          <span class=\"hljs-attr\">handleChildren</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span>\n<span class=\"xml\">            this.handleChildren();</span>\n<span class=\"xml\">          &#125;&#125;</span>\n<span class=\"xml\">        /&gt;</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n    );\n  &#125;\n&#125;\n</code></pre></div>\n\n<p>子组件：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Children</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">PureComponent</span> </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">const</span> &#123; handleChildren &#125; = <span class=\"hljs-built_in\">this</span>.props;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;render Children&quot;</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;handleChildren&#125;</span>&gt;</span>Children <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n  &#125;\n&#125;</code></pre></div>\n\n<p>每次点击 Parent，都会打印 <code>render Children</code>，子组件都会重新渲染，虽然子组件用了 PureComponent。</p>\n<p>因为父组件 setState 改变后，render() 会重新渲染，Children 组件的 handleChildren prop 采用的是(内联函数)匿名函数赋值，导致每次的引用地址不一样,PureComponent 优化无效。</p>\n<p>正确是写法如下：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\">...\n &lt;Children handleChildren=&#123;<span class=\"hljs-built_in\">this</span>.handleChildren&#125;/&gt;\n...</code></pre></div>\n\n<h2 id=\"函数组件，useCallback-使用场景\"><a href=\"#函数组件，useCallback-使用场景\" class=\"headerlink\" title=\"函数组件，useCallback 使用场景\"></a>函数组件，useCallback 使用场景</h2><p>useCallback 在依赖不变的时候，返回的回调函数保持同一个引用地址。useCallback 的真正目的是在于缓存每次渲染时内联函数的实例。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Parent = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">const</span> handleParent = <span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;clicked Parent&quot;</span>);\n    setCount(<span class=\"hljs-function\">(<span class=\"hljs-params\">preCount</span>) =&gt;</span> preCount + <span class=\"hljs-number\">1</span>);\n  &#125;;\n\n  <span class=\"hljs-keyword\">const</span> handleChildren = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;clicked Children&quot;</span>);\n  &#125;, []);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;handleParent&#125;</span>&gt;</span>Parent (count:&#123;count&#125;) <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Children</span> <span class=\"hljs-attr\">handleChildren</span>=<span class=\"hljs-string\">&#123;handleChildren&#125;</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;;\n\n<span class=\"hljs-keyword\">const</span> Children = memo(<span class=\"hljs-function\">(<span class=\"hljs-params\">&#123; handleChildren &#125;</span>) =&gt;</span> &#123;\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;Children rending&quot;</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;handleChildren&#125;</span>&gt;</span>Children <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n&#125;);</code></pre></div>\n\n<p>需要注意的是:</p>\n<ul>\n<li><p>单纯的 useCallback 包裹，并不能提升性能，反而会下降，useCallback 需要配合子组件优化（memo）成对使用，缺一性能都不升反降。</p>\n  <div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\">&lt;!-- \n不管是否使用useCallback，都无法避免重新创建内部函数\n使用 useCallback，还增加了 useCallback 内部对依赖项变化的检测\n --&gt;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">A</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-keyword\">const</span> cb = <span class=\"hljs-function\">() =&gt;</span> &#123;&#125;<span class=\"hljs-comment\">/* 创建了 */</span>;\n\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">B</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-keyword\">const</span> cb = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;&#125;<span class=\"hljs-comment\">/*还是创建了*/</span>, [a, b]);\n&#125;</code></pre></div></li>\n</ul>\n<h2 id=\"如何从-useCallback-读取一个经常变化的值？\"><a href=\"#如何从-useCallback-读取一个经常变化的值？\" class=\"headerlink\" title=\"如何从 useCallback 读取一个经常变化的值？\"></a><a href=\"https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback\">如何从 useCallback 读取一个经常变化的值？</a></h2><p>有时候一个函数依赖于一个经常变化的 state ，内部函数必须经常重新创建，那缓存方法的作用就没什么意义。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Form</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [text, updateText] = useState(<span class=\"hljs-string\">&quot;&quot;</span>);\n\n  <span class=\"hljs-keyword\">const</span> handleSubmit = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(text);\n  &#125;, [text]); <span class=\"hljs-comment\">// 每次 text 变化时 handleSubmit 都会变</span>\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;text&#125;</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">&#123;(e)</span> =&gt;</span> updateText(e.target.value)&#125; /&gt;</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ExpensiveTree</span> <span class=\"hljs-attr\">onSubmit</span>=<span class=\"hljs-string\">&#123;handleSubmit&#125;</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ExpensiveTree</span>(<span class=\"hljs-params\">props</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;props.onSubmit&#125;</span>&gt;</span>Submit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n&#125;</code></pre></div>\n\n<p>如果你想要记住的函数是一个事件处理器并且在渲染期间没有被用到，可以把 ref 当做实例变量来用，并手动把最后提交的值保存在它当中：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Form</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [text, updateText] = useState(<span class=\"hljs-string\">&quot;&quot;</span>);\n  <span class=\"hljs-keyword\">const</span> textRef = useRef();\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    textRef.current = text; <span class=\"hljs-comment\">// 把它写入 ref</span>\n  &#125;);\n\n  <span class=\"hljs-keyword\">const</span> handleSubmit = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> currentText = textRef.current; <span class=\"hljs-comment\">// 从 ref 读取它</span>\n    alert(currentText);\n  &#125;, [textRef]); <span class=\"hljs-comment\">// 不要像 [text] 那样重新创建 handleSubmit</span>\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;text&#125;</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">&#123;(e)</span> =&gt;</span> updateText(e.target.value)&#125; /&gt;</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ExpensiveTree</span> <span class=\"hljs-attr\">onSubmit</span>=<span class=\"hljs-string\">&#123;handleSubmit&#125;</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ExpensiveTree</span>(<span class=\"hljs-params\">props</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;props.onSubmit&#125;</span>&gt;</span>Submit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n&#125;</code></pre></div>\n\n<p>上述方式可以用来达到优化的目的，但是更佳的方式是抽成自定义 Hook:</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Form</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [text, updateText] = useState(<span class=\"hljs-string\">&#x27;&#x27;</span>);\n  <span class=\"hljs-comment\">// 即便 `text` 变了也会被记住:</span>\n  <span class=\"hljs-keyword\">const</span> handleSubmit = useEventCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    alert(text);\n  &#125;, [text]);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;text&#125;</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">&#123;e</span> =&gt;</span> updateText(e.target.value)&#125; /&gt;</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ExpensiveTree</span> <span class=\"hljs-attr\">onSubmit</span>=<span class=\"hljs-string\">&#123;handleSubmit&#125;</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useEventCallback</span>(<span class=\"hljs-params\">fn, dependencies</span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> ref = useRef(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;Cannot call an event handler while rendering.&#x27;</span>);\n  &#125;);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    ref.current = fn;\n  &#125;, [fn, ...dependencies]);\n\n  <span class=\"hljs-keyword\">return</span> useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> fn = ref.current;\n    <span class=\"hljs-keyword\">return</span> fn();\n  &#125;, [ref]);\n&#125;</code></pre></div>\n\n<h2 id=\"最后，官方推荐在-context-中向下传递-dispatch-而非在-props-中使用独立的回调\"><a href=\"#最后，官方推荐在-context-中向下传递-dispatch-而非在-props-中使用独立的回调\" class=\"headerlink\" title=\"最后，官方推荐在 context 中向下传递 dispatch 而非在 props 中使用独立的回调\"></a>最后，官方推荐在 context 中向下传递 dispatch 而非在 props 中使用独立的回调</h2><ul>\n<li><a href=\"https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down\">如何避免向下传递回调？</a></li>\n</ul>\n","site":{"data":{}},"wordcount":3984,"excerpt":"","more":"<h2 id=\"类组件，父组件传方法给子组件\"><a href=\"#类组件，父组件传方法给子组件\" class=\"headerlink\" title=\"类组件，父组件传方法给子组件\"></a>类组件，父组件传方法给子组件</h2><p>父组件：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Parent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;\n    <span class=\"hljs-built_in\">super</span>(props);\n    <span class=\"hljs-built_in\">this</span>.state = &#123;\n      <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span>\n    &#125;;\n  &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">handleChildren</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;clicked Children&quot;</span>);\n  &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">handleParent</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;clicked Parent&quot;</span>);\n    <span class=\"hljs-built_in\">this</span>.setState(<span class=\"hljs-function\">(<span class=\"hljs-params\">preCount</span>) =&gt;</span> (&#123; <span class=\"hljs-attr\">count</span>: preCount + <span class=\"hljs-number\">1</span> &#125;));\n  &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span></span></span>\n<span class=\"hljs-tag\"><span class=\"xml\">          <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span>\n<span class=\"xml\">            this.handleParent();</span>\n<span class=\"xml\">          &#125;&#125;</span>\n<span class=\"xml\">        &gt;</span>\n<span class=\"xml\">          Parent&#123;&quot; &quot;&#125;</span>\n<span class=\"xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\"></span>\n<span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Children</span></span></span>\n<span class=\"hljs-tag\"><span class=\"xml\">          <span class=\"hljs-attr\">handleChildren</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span>\n<span class=\"xml\">            this.handleChildren();</span>\n<span class=\"xml\">          &#125;&#125;</span>\n<span class=\"xml\">        /&gt;</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n    );\n  &#125;\n&#125;\n</code></pre>\n\n<p>子组件：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Children</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">PureComponent</span> </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">const</span> &#123; handleChildren &#125; = <span class=\"hljs-built_in\">this</span>.props;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;render Children&quot;</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;handleChildren&#125;</span>&gt;</span>Children <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n  &#125;\n&#125;</code></pre>\n\n<p>每次点击 Parent，都会打印 <code>render Children</code>，子组件都会重新渲染，虽然子组件用了 PureComponent。</p>\n<p>因为父组件 setState 改变后，render() 会重新渲染，Children 组件的 handleChildren prop 采用的是(内联函数)匿名函数赋值，导致每次的引用地址不一样,PureComponent 优化无效。</p>\n<p>正确是写法如下：</p>\n<pre><code class=\"hljs jsx\">...\n &lt;Children handleChildren=&#123;<span class=\"hljs-built_in\">this</span>.handleChildren&#125;/&gt;\n...</code></pre>\n\n<h2 id=\"函数组件，useCallback-使用场景\"><a href=\"#函数组件，useCallback-使用场景\" class=\"headerlink\" title=\"函数组件，useCallback 使用场景\"></a>函数组件，useCallback 使用场景</h2><p>useCallback 在依赖不变的时候，返回的回调函数保持同一个引用地址。useCallback 的真正目的是在于缓存每次渲染时内联函数的实例。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Parent = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">const</span> handleParent = <span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;clicked Parent&quot;</span>);\n    setCount(<span class=\"hljs-function\">(<span class=\"hljs-params\">preCount</span>) =&gt;</span> preCount + <span class=\"hljs-number\">1</span>);\n  &#125;;\n\n  <span class=\"hljs-keyword\">const</span> handleChildren = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;clicked Children&quot;</span>);\n  &#125;, []);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;handleParent&#125;</span>&gt;</span>Parent (count:&#123;count&#125;) <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Children</span> <span class=\"hljs-attr\">handleChildren</span>=<span class=\"hljs-string\">&#123;handleChildren&#125;</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;;\n\n<span class=\"hljs-keyword\">const</span> Children = memo(<span class=\"hljs-function\">(<span class=\"hljs-params\">&#123; handleChildren &#125;</span>) =&gt;</span> &#123;\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;Children rending&quot;</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;handleChildren&#125;</span>&gt;</span>Children <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n&#125;);</code></pre>\n\n<p>需要注意的是:</p>\n<ul>\n<li><p>单纯的 useCallback 包裹，并不能提升性能，反而会下降，useCallback 需要配合子组件优化（memo）成对使用，缺一性能都不升反降。</p>\n  <pre><code class=\"hljs jsx\">&lt;!-- \n不管是否使用useCallback，都无法避免重新创建内部函数\n使用 useCallback，还增加了 useCallback 内部对依赖项变化的检测\n --&gt;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">A</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-keyword\">const</span> cb = <span class=\"hljs-function\">() =&gt;</span> &#123;&#125;<span class=\"hljs-comment\">/* 创建了 */</span>;\n\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">B</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-keyword\">const</span> cb = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;&#125;<span class=\"hljs-comment\">/*还是创建了*/</span>, [a, b]);\n&#125;</code></pre></li>\n</ul>\n<h2 id=\"如何从-useCallback-读取一个经常变化的值？\"><a href=\"#如何从-useCallback-读取一个经常变化的值？\" class=\"headerlink\" title=\"如何从 useCallback 读取一个经常变化的值？\"></a><a href=\"https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback\">如何从 useCallback 读取一个经常变化的值？</a></h2><p>有时候一个函数依赖于一个经常变化的 state ，内部函数必须经常重新创建，那缓存方法的作用就没什么意义。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Form</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [text, updateText] = useState(<span class=\"hljs-string\">&quot;&quot;</span>);\n\n  <span class=\"hljs-keyword\">const</span> handleSubmit = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(text);\n  &#125;, [text]); <span class=\"hljs-comment\">// 每次 text 变化时 handleSubmit 都会变</span>\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;text&#125;</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">&#123;(e)</span> =&gt;</span> updateText(e.target.value)&#125; /&gt;</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ExpensiveTree</span> <span class=\"hljs-attr\">onSubmit</span>=<span class=\"hljs-string\">&#123;handleSubmit&#125;</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ExpensiveTree</span>(<span class=\"hljs-params\">props</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;props.onSubmit&#125;</span>&gt;</span>Submit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n&#125;</code></pre>\n\n<p>如果你想要记住的函数是一个事件处理器并且在渲染期间没有被用到，可以把 ref 当做实例变量来用，并手动把最后提交的值保存在它当中：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Form</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [text, updateText] = useState(<span class=\"hljs-string\">&quot;&quot;</span>);\n  <span class=\"hljs-keyword\">const</span> textRef = useRef();\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    textRef.current = text; <span class=\"hljs-comment\">// 把它写入 ref</span>\n  &#125;);\n\n  <span class=\"hljs-keyword\">const</span> handleSubmit = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> currentText = textRef.current; <span class=\"hljs-comment\">// 从 ref 读取它</span>\n    alert(currentText);\n  &#125;, [textRef]); <span class=\"hljs-comment\">// 不要像 [text] 那样重新创建 handleSubmit</span>\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;text&#125;</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">&#123;(e)</span> =&gt;</span> updateText(e.target.value)&#125; /&gt;</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ExpensiveTree</span> <span class=\"hljs-attr\">onSubmit</span>=<span class=\"hljs-string\">&#123;handleSubmit&#125;</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ExpensiveTree</span>(<span class=\"hljs-params\">props</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;props.onSubmit&#125;</span>&gt;</span>Submit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n&#125;</code></pre>\n\n<p>上述方式可以用来达到优化的目的，但是更佳的方式是抽成自定义 Hook:</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Form</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [text, updateText] = useState(<span class=\"hljs-string\">&#x27;&#x27;</span>);\n  <span class=\"hljs-comment\">// 即便 `text` 变了也会被记住:</span>\n  <span class=\"hljs-keyword\">const</span> handleSubmit = useEventCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    alert(text);\n  &#125;, [text]);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;text&#125;</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">&#123;e</span> =&gt;</span> updateText(e.target.value)&#125; /&gt;</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ExpensiveTree</span> <span class=\"hljs-attr\">onSubmit</span>=<span class=\"hljs-string\">&#123;handleSubmit&#125;</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useEventCallback</span>(<span class=\"hljs-params\">fn, dependencies</span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> ref = useRef(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;Cannot call an event handler while rendering.&#x27;</span>);\n  &#125;);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    ref.current = fn;\n  &#125;, [fn, ...dependencies]);\n\n  <span class=\"hljs-keyword\">return</span> useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> fn = ref.current;\n    <span class=\"hljs-keyword\">return</span> fn();\n  &#125;, [ref]);\n&#125;</code></pre>\n\n<h2 id=\"最后，官方推荐在-context-中向下传递-dispatch-而非在-props-中使用独立的回调\"><a href=\"#最后，官方推荐在-context-中向下传递-dispatch-而非在-props-中使用独立的回调\" class=\"headerlink\" title=\"最后，官方推荐在 context 中向下传递 dispatch 而非在 props 中使用独立的回调\"></a>最后，官方推荐在 context 中向下传递 dispatch 而非在 props 中使用独立的回调</h2><ul>\n<li><a href=\"https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down\">如何避免向下传递回调？</a></li>\n</ul>\n"},{"title":"Antd 源码分析之 useMountMergeState.md","index_img":"/img/2022-04-29-3.jpeg","abbrlink":"f806f23d","date":"2022-04-28T16:51:59.000Z","_content":"\n接上篇 `useMergeState`, `useMountMergeState` 是组件挂载后再声明 state。\n\n## 用法\n\n```ts\n  const [list, setList] = useMountMergeState<any[] | undefined>(defaultData, {\n    value: options?.dataSource,\n    onChange: options?.onDataSourceChange,\n  });\n```\n\n## 源码分析\n\n```ts\nimport useMergedState from './useMergedState';\nimport { useEffect, useRef } from 'react';\n\ntype Dispatch<A> = (value: A) => void;\n\nexport default function useMountMergeState<S>(\n  initialState: S | (() => S),\n  option?: {\n    defaultValue?: S;\n    value?: S;\n    onChange?: (value: S, prevValue: S) => void;\n    postState?: (value: S) => S;\n  },\n): [S, Dispatch<S>] {\n  const mountRef = useRef<boolean>(false);\n  const frame = useRef<number | undefined>(undefined);\n\n  useEffect(() => {\n    mountRef.current = true;\n    return () => {\n      clearTimeout(frame.current);\n      mountRef.current = false;\n    };\n  }, []);\n\n  const [state, setState] = useMergedState<S>(initialState, option);\n  const mountSetState: Dispatch<S> = (prevState: S) => {\n    clearTimeout(frame.current);\n    frame.current = window.setTimeout(() => {\n      if (mountRef.current) {\n        setState(prevState);\n      }\n    }, 16);\n  };\n  return [state, mountSetState];\n}\n```\n","source":"_posts/14.Antd 源码分析之 useMountMergeState.md","raw":"---\ntitle: Antd 源码分析之 useMountMergeState.md\nindex_img: /img/2022-04-29-3.jpeg\nabbrlink: f806f23d\ndate: 2022-04-29 00:51:59\ntags: Hook\ncategories: React\n---\n\n接上篇 `useMergeState`, `useMountMergeState` 是组件挂载后再声明 state。\n\n## 用法\n\n```ts\n  const [list, setList] = useMountMergeState<any[] | undefined>(defaultData, {\n    value: options?.dataSource,\n    onChange: options?.onDataSourceChange,\n  });\n```\n\n## 源码分析\n\n```ts\nimport useMergedState from './useMergedState';\nimport { useEffect, useRef } from 'react';\n\ntype Dispatch<A> = (value: A) => void;\n\nexport default function useMountMergeState<S>(\n  initialState: S | (() => S),\n  option?: {\n    defaultValue?: S;\n    value?: S;\n    onChange?: (value: S, prevValue: S) => void;\n    postState?: (value: S) => S;\n  },\n): [S, Dispatch<S>] {\n  const mountRef = useRef<boolean>(false);\n  const frame = useRef<number | undefined>(undefined);\n\n  useEffect(() => {\n    mountRef.current = true;\n    return () => {\n      clearTimeout(frame.current);\n      mountRef.current = false;\n    };\n  }, []);\n\n  const [state, setState] = useMergedState<S>(initialState, option);\n  const mountSetState: Dispatch<S> = (prevState: S) => {\n    clearTimeout(frame.current);\n    frame.current = window.setTimeout(() => {\n      if (mountRef.current) {\n        setState(prevState);\n      }\n    }, 16);\n  };\n  return [state, mountSetState];\n}\n```\n","slug":"14-Antd-源码分析之-useMountMergeState","published":1,"updated":"2022-04-29T02:08:45.170Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k5bv7800110h3l06e23e2l","content":"<p>接上篇 <code>useMergeState</code>, <code>useMountMergeState</code> 是组件挂载后再声明 state。</p>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> [list, setList] = useMountMergeState&lt;<span class=\"hljs-built_in\">any</span>[] | <span class=\"hljs-literal\">undefined</span>&gt;(defaultData, &#123;\n  <span class=\"hljs-attr\">value</span>: options?.dataSource,\n  <span class=\"hljs-attr\">onChange</span>: options?.onDataSourceChange,\n&#125;);</code></pre></div>\n\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> useMergedState <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./useMergedState&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> &#123; useEffect, useRef &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n\n<span class=\"hljs-keyword\">type</span> Dispatch&lt;A&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">value: A</span>) =&gt;</span> <span class=\"hljs-built_in\">void</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useMountMergeState</span>&lt;<span class=\"hljs-title\">S</span>&gt;(<span class=\"hljs-params\"></span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">  initialState: S | (() =&gt; S),</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">  option?: &#123;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    defaultValue?: S;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    value?: S;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    onChange?: (value: S, prevValue: S) =&gt; <span class=\"hljs-built_in\">void</span>;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    postState?: (value: S) =&gt; S;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">  &#125;,</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\"></span>): [<span class=\"hljs-title\">S</span>, <span class=\"hljs-title\">Dispatch</span>&lt;<span class=\"hljs-title\">S</span>&gt;] </span>&#123;\n  <span class=\"hljs-keyword\">const</span> mountRef = useRef&lt;<span class=\"hljs-built_in\">boolean</span>&gt;(<span class=\"hljs-literal\">false</span>);\n  <span class=\"hljs-keyword\">const</span> frame = useRef&lt;<span class=\"hljs-built_in\">number</span> | <span class=\"hljs-literal\">undefined</span>&gt;(<span class=\"hljs-literal\">undefined</span>);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    mountRef.current = <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">clearTimeout</span>(frame.current);\n      mountRef.current = <span class=\"hljs-literal\">false</span>;\n    &#125;;\n  &#125;, []);\n\n  <span class=\"hljs-keyword\">const</span> [state, setState] = useMergedState&lt;S&gt;(initialState, option);\n  <span class=\"hljs-keyword\">const</span> mountSetState: Dispatch&lt;S&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">prevState: S</span>) =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">clearTimeout</span>(frame.current);\n    frame.current = <span class=\"hljs-built_in\">window</span>.setTimeout(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-keyword\">if</span> (mountRef.current) &#123;\n        setState(prevState);\n      &#125;\n    &#125;, <span class=\"hljs-number\">16</span>);\n  &#125;;\n  <span class=\"hljs-keyword\">return</span> [state, mountSetState];\n&#125;</code></pre></div>\n","site":{"data":{}},"wordcount":1109,"excerpt":"","more":"<p>接上篇 <code>useMergeState</code>, <code>useMountMergeState</code> 是组件挂载后再声明 state。</p>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> [list, setList] = useMountMergeState&lt;<span class=\"hljs-built_in\">any</span>[] | <span class=\"hljs-literal\">undefined</span>&gt;(defaultData, &#123;\n  <span class=\"hljs-attr\">value</span>: options?.dataSource,\n  <span class=\"hljs-attr\">onChange</span>: options?.onDataSourceChange,\n&#125;);</code></pre>\n\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> useMergedState <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./useMergedState&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> &#123; useEffect, useRef &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n\n<span class=\"hljs-keyword\">type</span> Dispatch&lt;A&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">value: A</span>) =&gt;</span> <span class=\"hljs-built_in\">void</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useMountMergeState</span>&lt;<span class=\"hljs-title\">S</span>&gt;(<span class=\"hljs-params\"></span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">  initialState: S | (() =&gt; S),</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">  option?: &#123;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    defaultValue?: S;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    value?: S;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    onChange?: (value: S, prevValue: S) =&gt; <span class=\"hljs-built_in\">void</span>;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    postState?: (value: S) =&gt; S;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">  &#125;,</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\"></span>): [<span class=\"hljs-title\">S</span>, <span class=\"hljs-title\">Dispatch</span>&lt;<span class=\"hljs-title\">S</span>&gt;] </span>&#123;\n  <span class=\"hljs-keyword\">const</span> mountRef = useRef&lt;<span class=\"hljs-built_in\">boolean</span>&gt;(<span class=\"hljs-literal\">false</span>);\n  <span class=\"hljs-keyword\">const</span> frame = useRef&lt;<span class=\"hljs-built_in\">number</span> | <span class=\"hljs-literal\">undefined</span>&gt;(<span class=\"hljs-literal\">undefined</span>);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    mountRef.current = <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">clearTimeout</span>(frame.current);\n      mountRef.current = <span class=\"hljs-literal\">false</span>;\n    &#125;;\n  &#125;, []);\n\n  <span class=\"hljs-keyword\">const</span> [state, setState] = useMergedState&lt;S&gt;(initialState, option);\n  <span class=\"hljs-keyword\">const</span> mountSetState: Dispatch&lt;S&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">prevState: S</span>) =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">clearTimeout</span>(frame.current);\n    frame.current = <span class=\"hljs-built_in\">window</span>.setTimeout(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-keyword\">if</span> (mountRef.current) &#123;\n        setState(prevState);\n      &#125;\n    &#125;, <span class=\"hljs-number\">16</span>);\n  &#125;;\n  <span class=\"hljs-keyword\">return</span> [state, mountSetState];\n&#125;</code></pre>\n"},{"title":"使用 useRef 跨生命周期保存变量","index_img":"/img/2022-01-13-1.png","abbrlink":"bb88c12","date":"2022-01-13T07:23:54.000Z","_content":"\nref 这一种访问 DOM 的主要方式。然而，useRef() 比 ref 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式.\n\n当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。\n\n## 场景 1：只在更新时运行 useEffect\n\n使用一个可变的 ref 手动存储一个布尔值来表示是首次渲染还是后续渲染.\n\n```jsx\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  const prevCountRef = useRef(false);\n  useEffect(() => {\n    if (prevCountRef.current) {\n      console.log(\"只在更新时候执行\");\n    } else {\n      console.log(\"首次渲染执行\");\n      prevCountRef.current = true;\n    }\n  });\n\n  return (\n    <div>\n      <div>{count}</div>\n      <button\n        onClick={() => {\n          setCount(count + 1);\n        }}\n      >\n        +\n      </button>\n    </div>\n  );\n}\n```\n\n抽成自定义 hook：\n\n```jsx\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  const update = useUpdate();\n  console.log(update, \"是否更新\");\n\n  return (\n    <div>\n      <div>{count}</div>\n      <button\n        onClick={() => {\n          setCount(count + 1);\n        }}\n      >\n        +\n      </button>\n    </div>\n  );\n}\n\nfunction useUpdate() {\n  const ref = useRef(false);\n  useEffect(() => {\n    ref.current = true;\n  });\n  return ref.current;\n}\n```\n\n## 场景 2：获取上一轮的 props 或 state\n\n为什么 ref.current 拿到是上次的值？原因：\n\n1. useEffect 很重要的一点是：它是在每次渲染之后才会触发的，是延迟执行的。\n2. return 语句是同步的，所以 return 的时候，ref.current 还是旧值。\n3. 以下代码的执行顺序是 1 3 2\n\n```jsx\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  const prevCountRef = useRef();\n\n  console.log(\"1\", count);\n  useEffect(() => {\n    console.log(\"2.\", count);\n    prevCountRef.current = count;\n  });\n\n  const prevCount = prevCountRef.current;\n\n  console.log(`3.之前的状态: ${prevCount};现在状态: ${count}`);\n  return (\n    <div>\n      <div>{count}</div>\n      <button\n        onClick={() => {\n          setCount(count + 1);\n        }}\n      >\n        +\n      </button>\n    </div>\n  );\n}\n```\n\n抽取成自定义 Hook:\n\n```jsx\nexport default function usePrevious(value) {\n  const ref = useRef();\n\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref.current;\n}\n```\n\n## 场景 3：解决 hooks 时，由于异步闭包无法获取最新 state 的问题\n\n```jsx\nimport React, { useState, useEffect, useRef } from \"react\";\n\nconst RefComponent = () => {\n  // 使用 useState 存放和改变展示的 number\n  const [number, setNumber] = useState(0);\n  // 使用 useRef 生成一个独立的 ref 对象\n  // 在它的 current 属性单独存放一个展示的 number, 初始值为 0\n  const numRef = useRef(0);\n\n  function incrementAndDelayLogging() {\n    // 点击按钮 number + 1\n    setNumber(number + 1);\n    // 同时 ref 对象的 current 属性值也 + 1\n    numRef.current++;\n    // 定时器函数中产生了闭包, 这里 number 的是组件更新前的 number 对象, 所以值一直会滞后 1\n    setTimeout(() => alert(`state: ${number} | ref: ${numRef.current}`), 1000);\n  }\n\n  // 直接渲染的组件是正常情况, 可以获取到最新的 state,\n  // 所以 ref.current 和 state 存储的值显示一致\n  return (\n    <div>\n      <h1>solving closure by useRef</h1>\n      <button onClick={incrementAndDelayLogging}>alert in setTimeout</button>\n      <h4>state: {number}</h4>\n      <h4>ref: {numRef.current}</h4>\n    </div>\n  );\n};\n```\n","source":"_posts/3.使用 useRef 跨生命周期保存变量.md","raw":"---\ntitle: 使用 useRef 跨生命周期保存变量\ntags:\n  - React\n  - HooK\nindex_img: /img/2022-01-13-1.png\ncategories: React\nabbrlink: bb88c12\ndate: 2022-01-13 15:23:54\n---\n\nref 这一种访问 DOM 的主要方式。然而，useRef() 比 ref 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式.\n\n当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。\n\n## 场景 1：只在更新时运行 useEffect\n\n使用一个可变的 ref 手动存储一个布尔值来表示是首次渲染还是后续渲染.\n\n```jsx\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  const prevCountRef = useRef(false);\n  useEffect(() => {\n    if (prevCountRef.current) {\n      console.log(\"只在更新时候执行\");\n    } else {\n      console.log(\"首次渲染执行\");\n      prevCountRef.current = true;\n    }\n  });\n\n  return (\n    <div>\n      <div>{count}</div>\n      <button\n        onClick={() => {\n          setCount(count + 1);\n        }}\n      >\n        +\n      </button>\n    </div>\n  );\n}\n```\n\n抽成自定义 hook：\n\n```jsx\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  const update = useUpdate();\n  console.log(update, \"是否更新\");\n\n  return (\n    <div>\n      <div>{count}</div>\n      <button\n        onClick={() => {\n          setCount(count + 1);\n        }}\n      >\n        +\n      </button>\n    </div>\n  );\n}\n\nfunction useUpdate() {\n  const ref = useRef(false);\n  useEffect(() => {\n    ref.current = true;\n  });\n  return ref.current;\n}\n```\n\n## 场景 2：获取上一轮的 props 或 state\n\n为什么 ref.current 拿到是上次的值？原因：\n\n1. useEffect 很重要的一点是：它是在每次渲染之后才会触发的，是延迟执行的。\n2. return 语句是同步的，所以 return 的时候，ref.current 还是旧值。\n3. 以下代码的执行顺序是 1 3 2\n\n```jsx\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  const prevCountRef = useRef();\n\n  console.log(\"1\", count);\n  useEffect(() => {\n    console.log(\"2.\", count);\n    prevCountRef.current = count;\n  });\n\n  const prevCount = prevCountRef.current;\n\n  console.log(`3.之前的状态: ${prevCount};现在状态: ${count}`);\n  return (\n    <div>\n      <div>{count}</div>\n      <button\n        onClick={() => {\n          setCount(count + 1);\n        }}\n      >\n        +\n      </button>\n    </div>\n  );\n}\n```\n\n抽取成自定义 Hook:\n\n```jsx\nexport default function usePrevious(value) {\n  const ref = useRef();\n\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref.current;\n}\n```\n\n## 场景 3：解决 hooks 时，由于异步闭包无法获取最新 state 的问题\n\n```jsx\nimport React, { useState, useEffect, useRef } from \"react\";\n\nconst RefComponent = () => {\n  // 使用 useState 存放和改变展示的 number\n  const [number, setNumber] = useState(0);\n  // 使用 useRef 生成一个独立的 ref 对象\n  // 在它的 current 属性单独存放一个展示的 number, 初始值为 0\n  const numRef = useRef(0);\n\n  function incrementAndDelayLogging() {\n    // 点击按钮 number + 1\n    setNumber(number + 1);\n    // 同时 ref 对象的 current 属性值也 + 1\n    numRef.current++;\n    // 定时器函数中产生了闭包, 这里 number 的是组件更新前的 number 对象, 所以值一直会滞后 1\n    setTimeout(() => alert(`state: ${number} | ref: ${numRef.current}`), 1000);\n  }\n\n  // 直接渲染的组件是正常情况, 可以获取到最新的 state,\n  // 所以 ref.current 和 state 存储的值显示一致\n  return (\n    <div>\n      <h1>solving closure by useRef</h1>\n      <button onClick={incrementAndDelayLogging}>alert in setTimeout</button>\n      <h4>state: {number}</h4>\n      <h4>ref: {numRef.current}</h4>\n    </div>\n  );\n};\n```\n","slug":"3-使用-useRef-跨生命周期保存变量","published":1,"updated":"2022-03-01T02:56:12.117Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k5bv7900140h3l9jhsbawi","content":"<p>ref 这一种访问 DOM 的主要方式。然而，useRef() 比 ref 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式.</p>\n<p>当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。</p>\n<h2 id=\"场景-1：只在更新时运行-useEffect\"><a href=\"#场景-1：只在更新时运行-useEffect\" class=\"headerlink\" title=\"场景 1：只在更新时运行 useEffect\"></a>场景 1：只在更新时运行 useEffect</h2><p>使用一个可变的 ref 手动存储一个布尔值来表示是首次渲染还是后续渲染.</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">const</span> prevCountRef = useRef(<span class=\"hljs-literal\">false</span>);\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">if</span> (prevCountRef.current) &#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;只在更新时候执行&quot;</span>);\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;首次渲染执行&quot;</span>);\n      prevCountRef.current = <span class=\"hljs-literal\">true</span>;\n    &#125;\n  &#125;);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span></span></span>\n<span class=\"hljs-tag\"><span class=\"xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span>\n<span class=\"xml\">          setCount(count + 1);</span>\n<span class=\"xml\">        &#125;&#125;</span>\n<span class=\"xml\">      &gt;</span>\n<span class=\"xml\">        +</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;</code></pre></div>\n\n<p>抽成自定义 hook：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">const</span> update = useUpdate();\n  <span class=\"hljs-built_in\">console</span>.log(update, <span class=\"hljs-string\">&quot;是否更新&quot;</span>);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span></span></span>\n<span class=\"hljs-tag\"><span class=\"xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span>\n<span class=\"xml\">          setCount(count + 1);</span>\n<span class=\"xml\">        &#125;&#125;</span>\n<span class=\"xml\">      &gt;</span>\n<span class=\"xml\">        +</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useUpdate</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> ref = useRef(<span class=\"hljs-literal\">false</span>);\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    ref.current = <span class=\"hljs-literal\">true</span>;\n  &#125;);\n  <span class=\"hljs-keyword\">return</span> ref.current;\n&#125;</code></pre></div>\n\n<h2 id=\"场景-2：获取上一轮的-props-或-state\"><a href=\"#场景-2：获取上一轮的-props-或-state\" class=\"headerlink\" title=\"场景 2：获取上一轮的 props 或 state\"></a>场景 2：获取上一轮的 props 或 state</h2><p>为什么 ref.current 拿到是上次的值？原因：</p>\n<ol>\n<li>useEffect 很重要的一点是：它是在每次渲染之后才会触发的，是延迟执行的。</li>\n<li>return 语句是同步的，所以 return 的时候，ref.current 还是旧值。</li>\n<li>以下代码的执行顺序是 1 3 2</li>\n</ol>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">const</span> prevCountRef = useRef();\n\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;1&quot;</span>, count);\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;2.&quot;</span>, count);\n    prevCountRef.current = count;\n  &#125;);\n\n  <span class=\"hljs-keyword\">const</span> prevCount = prevCountRef.current;\n\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`3.之前的状态: <span class=\"hljs-subst\">$&#123;prevCount&#125;</span>;现在状态: <span class=\"hljs-subst\">$&#123;count&#125;</span>`</span>);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span></span></span>\n<span class=\"hljs-tag\"><span class=\"xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span>\n<span class=\"xml\">          setCount(count + 1);</span>\n<span class=\"xml\">        &#125;&#125;</span>\n<span class=\"xml\">      &gt;</span>\n<span class=\"xml\">        +</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;</code></pre></div>\n\n<p>抽取成自定义 Hook:</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">usePrevious</span>(<span class=\"hljs-params\">value</span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> ref = useRef();\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    ref.current = value;\n  &#125;, [value]);\n\n  <span class=\"hljs-keyword\">return</span> ref.current;\n&#125;</code></pre></div>\n\n<h2 id=\"场景-3：解决-hooks-时，由于异步闭包无法获取最新-state-的问题\"><a href=\"#场景-3：解决-hooks-时，由于异步闭包无法获取最新-state-的问题\" class=\"headerlink\" title=\"场景 3：解决 hooks 时，由于异步闭包无法获取最新 state 的问题\"></a>场景 3：解决 hooks 时，由于异步闭包无法获取最新 state 的问题</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React, &#123; useState, useEffect, useRef &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> RefComponent = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-comment\">// 使用 useState 存放和改变展示的 number</span>\n  <span class=\"hljs-keyword\">const</span> [number, setNumber] = useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-comment\">// 使用 useRef 生成一个独立的 ref 对象</span>\n  <span class=\"hljs-comment\">// 在它的 current 属性单独存放一个展示的 number, 初始值为 0</span>\n  <span class=\"hljs-keyword\">const</span> numRef = useRef(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">incrementAndDelayLogging</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// 点击按钮 number + 1</span>\n    setNumber(number + <span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-comment\">// 同时 ref 对象的 current 属性值也 + 1</span>\n    numRef.current++;\n    <span class=\"hljs-comment\">// 定时器函数中产生了闭包, 这里 number 的是组件更新前的 number 对象, 所以值一直会滞后 1</span>\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> alert(<span class=\"hljs-string\">`state: <span class=\"hljs-subst\">$&#123;number&#125;</span> | ref: <span class=\"hljs-subst\">$&#123;numRef.current&#125;</span>`</span>), <span class=\"hljs-number\">1000</span>);\n  &#125;\n\n  <span class=\"hljs-comment\">// 直接渲染的组件是正常情况, 可以获取到最新的 state,</span>\n  <span class=\"hljs-comment\">// 所以 ref.current 和 state 存储的值显示一致</span>\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>solving closure by useRef<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;incrementAndDelayLogging&#125;</span>&gt;</span>alert in setTimeout<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h4</span>&gt;</span>state: &#123;number&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h4</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h4</span>&gt;</span>ref: &#123;numRef.current&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h4</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;;</code></pre></div>\n","site":{"data":{}},"wordcount":2697,"excerpt":"","more":"<p>ref 这一种访问 DOM 的主要方式。然而，useRef() 比 ref 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式.</p>\n<p>当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。</p>\n<h2 id=\"场景-1：只在更新时运行-useEffect\"><a href=\"#场景-1：只在更新时运行-useEffect\" class=\"headerlink\" title=\"场景 1：只在更新时运行 useEffect\"></a>场景 1：只在更新时运行 useEffect</h2><p>使用一个可变的 ref 手动存储一个布尔值来表示是首次渲染还是后续渲染.</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">const</span> prevCountRef = useRef(<span class=\"hljs-literal\">false</span>);\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">if</span> (prevCountRef.current) &#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;只在更新时候执行&quot;</span>);\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;首次渲染执行&quot;</span>);\n      prevCountRef.current = <span class=\"hljs-literal\">true</span>;\n    &#125;\n  &#125;);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span></span></span>\n<span class=\"hljs-tag\"><span class=\"xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span>\n<span class=\"xml\">          setCount(count + 1);</span>\n<span class=\"xml\">        &#125;&#125;</span>\n<span class=\"xml\">      &gt;</span>\n<span class=\"xml\">        +</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;</code></pre>\n\n<p>抽成自定义 hook：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">const</span> update = useUpdate();\n  <span class=\"hljs-built_in\">console</span>.log(update, <span class=\"hljs-string\">&quot;是否更新&quot;</span>);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span></span></span>\n<span class=\"hljs-tag\"><span class=\"xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span>\n<span class=\"xml\">          setCount(count + 1);</span>\n<span class=\"xml\">        &#125;&#125;</span>\n<span class=\"xml\">      &gt;</span>\n<span class=\"xml\">        +</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useUpdate</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> ref = useRef(<span class=\"hljs-literal\">false</span>);\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    ref.current = <span class=\"hljs-literal\">true</span>;\n  &#125;);\n  <span class=\"hljs-keyword\">return</span> ref.current;\n&#125;</code></pre>\n\n<h2 id=\"场景-2：获取上一轮的-props-或-state\"><a href=\"#场景-2：获取上一轮的-props-或-state\" class=\"headerlink\" title=\"场景 2：获取上一轮的 props 或 state\"></a>场景 2：获取上一轮的 props 或 state</h2><p>为什么 ref.current 拿到是上次的值？原因：</p>\n<ol>\n<li>useEffect 很重要的一点是：它是在每次渲染之后才会触发的，是延迟执行的。</li>\n<li>return 语句是同步的，所以 return 的时候，ref.current 还是旧值。</li>\n<li>以下代码的执行顺序是 1 3 2</li>\n</ol>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">const</span> prevCountRef = useRef();\n\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;1&quot;</span>, count);\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;2.&quot;</span>, count);\n    prevCountRef.current = count;\n  &#125;);\n\n  <span class=\"hljs-keyword\">const</span> prevCount = prevCountRef.current;\n\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`3.之前的状态: <span class=\"hljs-subst\">$&#123;prevCount&#125;</span>;现在状态: <span class=\"hljs-subst\">$&#123;count&#125;</span>`</span>);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span></span></span>\n<span class=\"hljs-tag\"><span class=\"xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span>\n<span class=\"xml\">          setCount(count + 1);</span>\n<span class=\"xml\">        &#125;&#125;</span>\n<span class=\"xml\">      &gt;</span>\n<span class=\"xml\">        +</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;</code></pre>\n\n<p>抽取成自定义 Hook:</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">usePrevious</span>(<span class=\"hljs-params\">value</span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> ref = useRef();\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    ref.current = value;\n  &#125;, [value]);\n\n  <span class=\"hljs-keyword\">return</span> ref.current;\n&#125;</code></pre>\n\n<h2 id=\"场景-3：解决-hooks-时，由于异步闭包无法获取最新-state-的问题\"><a href=\"#场景-3：解决-hooks-时，由于异步闭包无法获取最新-state-的问题\" class=\"headerlink\" title=\"场景 3：解决 hooks 时，由于异步闭包无法获取最新 state 的问题\"></a>场景 3：解决 hooks 时，由于异步闭包无法获取最新 state 的问题</h2><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React, &#123; useState, useEffect, useRef &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> RefComponent = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-comment\">// 使用 useState 存放和改变展示的 number</span>\n  <span class=\"hljs-keyword\">const</span> [number, setNumber] = useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-comment\">// 使用 useRef 生成一个独立的 ref 对象</span>\n  <span class=\"hljs-comment\">// 在它的 current 属性单独存放一个展示的 number, 初始值为 0</span>\n  <span class=\"hljs-keyword\">const</span> numRef = useRef(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">incrementAndDelayLogging</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// 点击按钮 number + 1</span>\n    setNumber(number + <span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-comment\">// 同时 ref 对象的 current 属性值也 + 1</span>\n    numRef.current++;\n    <span class=\"hljs-comment\">// 定时器函数中产生了闭包, 这里 number 的是组件更新前的 number 对象, 所以值一直会滞后 1</span>\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> alert(<span class=\"hljs-string\">`state: <span class=\"hljs-subst\">$&#123;number&#125;</span> | ref: <span class=\"hljs-subst\">$&#123;numRef.current&#125;</span>`</span>), <span class=\"hljs-number\">1000</span>);\n  &#125;\n\n  <span class=\"hljs-comment\">// 直接渲染的组件是正常情况, 可以获取到最新的 state,</span>\n  <span class=\"hljs-comment\">// 所以 ref.current 和 state 存储的值显示一致</span>\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>solving closure by useRef<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;incrementAndDelayLogging&#125;</span>&gt;</span>alert in setTimeout<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h4</span>&gt;</span>state: &#123;number&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h4</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h4</span>&gt;</span>ref: &#123;numRef.current&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h4</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;;</code></pre>\n"},{"title":"Antd 源码分析之常用 hooks","index_img":"/img/2022-04-29-1.jpeg","abbrlink":"e509b107","date":"2022-04-28T17:01:04.000Z","_content":"\n## usePrevious\n\n```ts\nimport { useEffect, useRef } from 'react';\n\nconst usePrevious = <T>(state: T): T | undefined => {\n  const ref = useRef<T>();\n\n  useEffect(() => {\n    ref.current = state;\n  });\n\n  return ref.current;\n};\n\nexport default usePrevious;\n\n```\n","source":"_posts/15.Antd 源码分析之常用 hooks.md","raw":"---\ntitle: Antd 源码分析之常用 hooks\nindex_img: /img/2022-04-29-1.jpeg\nabbrlink: e509b107\ndate: 2022-04-29 01:01:04\ntags: Hook\ncategories: React\n---\n\n## usePrevious\n\n```ts\nimport { useEffect, useRef } from 'react';\n\nconst usePrevious = <T>(state: T): T | undefined => {\n  const ref = useRef<T>();\n\n  useEffect(() => {\n    ref.current = state;\n  });\n\n  return ref.current;\n};\n\nexport default usePrevious;\n\n```\n","slug":"15-Antd-源码分析之常用-hooks","published":1,"updated":"2022-04-29T02:07:35.808Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k5bv7900160h3l8txg2nb3","content":"<h2 id=\"usePrevious\"><a href=\"#usePrevious\" class=\"headerlink\" title=\"usePrevious\"></a>usePrevious</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> &#123; useEffect, useRef &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> usePrevious = &lt;T&gt;(state: T): T | <span class=\"hljs-function\"><span class=\"hljs-params\">undefined</span> =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> ref = useRef&lt;T&gt;();\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    ref.current = state;\n  &#125;);\n\n  <span class=\"hljs-keyword\">return</span> ref.current;\n&#125;;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> usePrevious;\n</code></pre></div>\n","site":{"data":{}},"wordcount":251,"excerpt":"","more":"<h2 id=\"usePrevious\"><a href=\"#usePrevious\" class=\"headerlink\" title=\"usePrevious\"></a>usePrevious</h2><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> &#123; useEffect, useRef &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> usePrevious = &lt;T&gt;(state: T): T | <span class=\"hljs-function\"><span class=\"hljs-params\">undefined</span> =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> ref = useRef&lt;T&gt;();\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    ref.current = state;\n  &#125;);\n\n  <span class=\"hljs-keyword\">return</span> ref.current;\n&#125;;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> usePrevious;\n</code></pre>\n"},{"title":"如何在 class 组件中使用 hooks","index_img":"/img/2022-01-14-2.png","abbrlink":"ee7a9294","date":"2022-01-14T03:03:28.000Z","_content":"\n解决办法\n\n以一个简单的 `useScreenWidthhook` 函数为例，它的目的是获取全屏的宽度，并且去监听浏览器窗口的变化，更新宽度：\n\n```jsx\nimport { useEffect, useState } from \"react\";\n\nexport function useScreenWidth(): number {\n  const [width, setWidth] = useState(window.innerWidth);\n\n  useEffect(() => {\n    const handler = (event: any) => {\n      setWidth(event.target.innerWidth);\n    };\n    // 监听浏览器窗口变化\n    window.addEventListener(\"resize\", handler);\n    // 组件unmount时要解除监听\n    return () => {\n      window.removeEventListener(\"resize\", handler);\n    };\n  }, []);\n\n  return width;\n}\n```\n\n## 方法 1：将 Hook 包装成 HOC\n\nHOC 是 React 中复用组件的高级用法，它的本质是一个函数，它的输入参数是一个组件，返回相同的组件以及一些额外的 props。在我们的例子里，可以让 hook 函数作为 props 传递到目标组件中:\n\n```jsx\nimport React from \"react\";\nimport { useScreenWidth } from \"../hooks/useScreenWidth\";\n\nexport const withHooksHOC = (Component: any) => {\n  return (props: any) => {\n    const screenWidth = useScreenWidth();\n\n    return <Component width={screenWidth} {...props} />;\n  };\n};\n```\n\n将我们的目标组件用上述的 withHooksHOC 包装起来\n\n```jsx\nimport React from \"react\";\nimport { withHooksHOC } from \"./withHooksHOC\";\n\ninterface IHooksHOCProps {\n  width: number;\n}\n\nclass HooksHOC extends React.Component<IHooksHOCProps> {\n  render() {\n    return <p>width: {this.props.width}</p>;\n  }\n}\n\nexport default withHooksHOC(HooksHOC);\n```\n\n## 方法 2：将 Hook 包装成函数组件\n\n将 hook 变成函数组件，它接收一个参数为 width 的 children 函数，然后将 width 作为 render prop 传递：\n\n```jsx\nimport { FunctionComponent } from \"react\";\nimport { useScreenWidth } from \"../hooks/useScreenWidth\";\n\ntype ScreenWidthChildren = (screenWidth: number) => React.ReactNode;\n\ninterface IScreenWidthProps {\n  children: ScreenWidthChildren;\n}\n\nexport const ScreenWidth: FunctionComponent<IScreenWidthProps> = ({ children }) => {\n  const screenWidth: number = useScreenWidth();\n\n  return children(screenWidth);\n};\n```\n\n使用：\n\n```jsx\nimport React from \"react\";\nimport { ScreenWidth } from \"./ScreenWidth\";\n\nexport class HooksRenderProps extends React.Component {\n  render() {\n    return <ScreenWidth>{(width) => <p style={{ fontSize: \"48px\" }}>width: {width}</p>}</ScreenWidth>;\n  }\n}\n```\n","source":"_posts/5.如何在 class 组件中使用 hooks.md","raw":"---\ntitle: 如何在 class 组件中使用 hooks\nindex_img: /img/2022-01-14-2.png\ntags: HooK\ncategories: React\nabbrlink: ee7a9294\ndate: 2022-01-14 11:03:28\n---\n\n解决办法\n\n以一个简单的 `useScreenWidthhook` 函数为例，它的目的是获取全屏的宽度，并且去监听浏览器窗口的变化，更新宽度：\n\n```jsx\nimport { useEffect, useState } from \"react\";\n\nexport function useScreenWidth(): number {\n  const [width, setWidth] = useState(window.innerWidth);\n\n  useEffect(() => {\n    const handler = (event: any) => {\n      setWidth(event.target.innerWidth);\n    };\n    // 监听浏览器窗口变化\n    window.addEventListener(\"resize\", handler);\n    // 组件unmount时要解除监听\n    return () => {\n      window.removeEventListener(\"resize\", handler);\n    };\n  }, []);\n\n  return width;\n}\n```\n\n## 方法 1：将 Hook 包装成 HOC\n\nHOC 是 React 中复用组件的高级用法，它的本质是一个函数，它的输入参数是一个组件，返回相同的组件以及一些额外的 props。在我们的例子里，可以让 hook 函数作为 props 传递到目标组件中:\n\n```jsx\nimport React from \"react\";\nimport { useScreenWidth } from \"../hooks/useScreenWidth\";\n\nexport const withHooksHOC = (Component: any) => {\n  return (props: any) => {\n    const screenWidth = useScreenWidth();\n\n    return <Component width={screenWidth} {...props} />;\n  };\n};\n```\n\n将我们的目标组件用上述的 withHooksHOC 包装起来\n\n```jsx\nimport React from \"react\";\nimport { withHooksHOC } from \"./withHooksHOC\";\n\ninterface IHooksHOCProps {\n  width: number;\n}\n\nclass HooksHOC extends React.Component<IHooksHOCProps> {\n  render() {\n    return <p>width: {this.props.width}</p>;\n  }\n}\n\nexport default withHooksHOC(HooksHOC);\n```\n\n## 方法 2：将 Hook 包装成函数组件\n\n将 hook 变成函数组件，它接收一个参数为 width 的 children 函数，然后将 width 作为 render prop 传递：\n\n```jsx\nimport { FunctionComponent } from \"react\";\nimport { useScreenWidth } from \"../hooks/useScreenWidth\";\n\ntype ScreenWidthChildren = (screenWidth: number) => React.ReactNode;\n\ninterface IScreenWidthProps {\n  children: ScreenWidthChildren;\n}\n\nexport const ScreenWidth: FunctionComponent<IScreenWidthProps> = ({ children }) => {\n  const screenWidth: number = useScreenWidth();\n\n  return children(screenWidth);\n};\n```\n\n使用：\n\n```jsx\nimport React from \"react\";\nimport { ScreenWidth } from \"./ScreenWidth\";\n\nexport class HooksRenderProps extends React.Component {\n  render() {\n    return <ScreenWidth>{(width) => <p style={{ fontSize: \"48px\" }}>width: {width}</p>}</ScreenWidth>;\n  }\n}\n```\n","slug":"5-如何在-class-组件中使用-hooks","published":1,"updated":"2022-03-01T02:56:12.119Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k5bv7a00190h3l3mra3aoz","content":"<p>解决办法</p>\n<p>以一个简单的 <code>useScreenWidthhook</code> 函数为例，它的目的是获取全屏的宽度，并且去监听浏览器窗口的变化，更新宽度：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; useEffect, useState &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useScreenWidth</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">number</span> </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [width, setWidth] = useState(<span class=\"hljs-built_in\">window</span>.innerWidth);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> handler = <span class=\"hljs-function\">(<span class=\"hljs-params\">event: any</span>) =&gt;</span> &#123;\n      setWidth(event.target.innerWidth);\n    &#125;;\n    <span class=\"hljs-comment\">// 监听浏览器窗口变化</span>\n    <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">&quot;resize&quot;</span>, handler);\n    <span class=\"hljs-comment\">// 组件unmount时要解除监听</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">window</span>.removeEventListener(<span class=\"hljs-string\">&quot;resize&quot;</span>, handler);\n    &#125;;\n  &#125;, []);\n\n  <span class=\"hljs-keyword\">return</span> width;\n&#125;</code></pre></div>\n\n<h2 id=\"方法-1：将-Hook-包装成-HOC\"><a href=\"#方法-1：将-Hook-包装成-HOC\" class=\"headerlink\" title=\"方法 1：将 Hook 包装成 HOC\"></a>方法 1：将 Hook 包装成 HOC</h2><p>HOC 是 React 中复用组件的高级用法，它的本质是一个函数，它的输入参数是一个组件，返回相同的组件以及一些额外的 props。在我们的例子里，可以让 hook 函数作为 props 传递到目标组件中:</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> &#123; useScreenWidth &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../hooks/useScreenWidth&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> withHooksHOC = <span class=\"hljs-function\">(<span class=\"hljs-params\">Component: any</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">props: any</span>) =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> screenWidth = useScreenWidth();\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Component</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&#123;screenWidth&#125;</span> &#123;<span class=\"hljs-attr\">...props</span>&#125; /&gt;</span></span>;\n  &#125;;\n&#125;;</code></pre></div>\n\n<p>将我们的目标组件用上述的 withHooksHOC 包装起来</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> &#123; withHooksHOC &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./withHooksHOC&quot;</span>;\n\ninterface IHooksHOCProps &#123;\n  <span class=\"hljs-attr\">width</span>: number;\n&#125;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HooksHOC</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">IHooksHOCProps</span>&gt; </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>width: &#123;this.props.width&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>;\n  &#125;\n&#125;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> withHooksHOC(HooksHOC);</code></pre></div>\n\n<h2 id=\"方法-2：将-Hook-包装成函数组件\"><a href=\"#方法-2：将-Hook-包装成函数组件\" class=\"headerlink\" title=\"方法 2：将 Hook 包装成函数组件\"></a>方法 2：将 Hook 包装成函数组件</h2><p>将 hook 变成函数组件，它接收一个参数为 width 的 children 函数，然后将 width 作为 render prop 传递：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; FunctionComponent &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> &#123; useScreenWidth &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../hooks/useScreenWidth&quot;</span>;\n\ntype ScreenWidthChildren = <span class=\"hljs-function\">(<span class=\"hljs-params\">screenWidth: number</span>) =&gt;</span> React.ReactNode;\n\ninterface IScreenWidthProps &#123;\n  <span class=\"hljs-attr\">children</span>: ScreenWidthChildren;\n&#125;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> ScreenWidth: FunctionComponent&lt;IScreenWidthProps&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">&#123; children &#125;</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> screenWidth: number = useScreenWidth();\n\n  <span class=\"hljs-keyword\">return</span> children(screenWidth);\n&#125;;</code></pre></div>\n\n<p>使用：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> &#123; ScreenWidth &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./ScreenWidth&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HooksRenderProps</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ScreenWidth</span>&gt;</span>&#123;(width) =&gt; <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&#123;&#123;</span> <span class=\"hljs-attr\">fontSize:</span> &quot;<span class=\"hljs-attr\">48px</span>&quot; &#125;&#125;&gt;</span>width: &#123;width&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ScreenWidth</span>&gt;</span></span>;\n  &#125;\n&#125;</code></pre></div>\n","site":{"data":{}},"wordcount":2130,"excerpt":"","more":"<p>解决办法</p>\n<p>以一个简单的 <code>useScreenWidthhook</code> 函数为例，它的目的是获取全屏的宽度，并且去监听浏览器窗口的变化，更新宽度：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; useEffect, useState &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useScreenWidth</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">number</span> </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [width, setWidth] = useState(<span class=\"hljs-built_in\">window</span>.innerWidth);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> handler = <span class=\"hljs-function\">(<span class=\"hljs-params\">event: any</span>) =&gt;</span> &#123;\n      setWidth(event.target.innerWidth);\n    &#125;;\n    <span class=\"hljs-comment\">// 监听浏览器窗口变化</span>\n    <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">&quot;resize&quot;</span>, handler);\n    <span class=\"hljs-comment\">// 组件unmount时要解除监听</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">window</span>.removeEventListener(<span class=\"hljs-string\">&quot;resize&quot;</span>, handler);\n    &#125;;\n  &#125;, []);\n\n  <span class=\"hljs-keyword\">return</span> width;\n&#125;</code></pre>\n\n<h2 id=\"方法-1：将-Hook-包装成-HOC\"><a href=\"#方法-1：将-Hook-包装成-HOC\" class=\"headerlink\" title=\"方法 1：将 Hook 包装成 HOC\"></a>方法 1：将 Hook 包装成 HOC</h2><p>HOC 是 React 中复用组件的高级用法，它的本质是一个函数，它的输入参数是一个组件，返回相同的组件以及一些额外的 props。在我们的例子里，可以让 hook 函数作为 props 传递到目标组件中:</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> &#123; useScreenWidth &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../hooks/useScreenWidth&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> withHooksHOC = <span class=\"hljs-function\">(<span class=\"hljs-params\">Component: any</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">props: any</span>) =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> screenWidth = useScreenWidth();\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Component</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&#123;screenWidth&#125;</span> &#123;<span class=\"hljs-attr\">...props</span>&#125; /&gt;</span></span>;\n  &#125;;\n&#125;;</code></pre>\n\n<p>将我们的目标组件用上述的 withHooksHOC 包装起来</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> &#123; withHooksHOC &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./withHooksHOC&quot;</span>;\n\ninterface IHooksHOCProps &#123;\n  <span class=\"hljs-attr\">width</span>: number;\n&#125;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HooksHOC</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">IHooksHOCProps</span>&gt; </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>width: &#123;this.props.width&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>;\n  &#125;\n&#125;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> withHooksHOC(HooksHOC);</code></pre>\n\n<h2 id=\"方法-2：将-Hook-包装成函数组件\"><a href=\"#方法-2：将-Hook-包装成函数组件\" class=\"headerlink\" title=\"方法 2：将 Hook 包装成函数组件\"></a>方法 2：将 Hook 包装成函数组件</h2><p>将 hook 变成函数组件，它接收一个参数为 width 的 children 函数，然后将 width 作为 render prop 传递：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; FunctionComponent &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> &#123; useScreenWidth &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../hooks/useScreenWidth&quot;</span>;\n\ntype ScreenWidthChildren = <span class=\"hljs-function\">(<span class=\"hljs-params\">screenWidth: number</span>) =&gt;</span> React.ReactNode;\n\ninterface IScreenWidthProps &#123;\n  <span class=\"hljs-attr\">children</span>: ScreenWidthChildren;\n&#125;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> ScreenWidth: FunctionComponent&lt;IScreenWidthProps&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">&#123; children &#125;</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> screenWidth: number = useScreenWidth();\n\n  <span class=\"hljs-keyword\">return</span> children(screenWidth);\n&#125;;</code></pre>\n\n<p>使用：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> &#123; ScreenWidth &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./ScreenWidth&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HooksRenderProps</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ScreenWidth</span>&gt;</span>&#123;(width) =&gt; <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&#123;&#123;</span> <span class=\"hljs-attr\">fontSize:</span> &quot;<span class=\"hljs-attr\">48px</span>&quot; &#125;&#125;&gt;</span>width: &#123;width&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ScreenWidth</span>&gt;</span></span>;\n  &#125;\n&#125;</code></pre>\n"},{"title":"Vue3 学习笔记","index_img":"/img/2022-01-22-1.jpeg","abbrlink":"e372be48","date":"2022-01-22T02:46:00.000Z","_content":"\n## Vue 和 React 数据驱动原理对比\n\nVue1 解决方案是使用响应式，初始化的时候，watcher 监听数据的每个属性，数据发生变化的时候，就能够知道数据的哪个 key 变了，去修改对应的 DOM。\n\nReact 是虚拟 DOM 方案，用 JS 对象描述 DOM 树，这个对象就像数据和实际 DOM 的一个缓存层，通过管理这个对象的变化，来减少对实际 DOM 的操作。\n\n描述实际 DOM 的虚拟 DOM 对象如下：\n\nDOM:\n\n```html\n<div id=\"app\">\n  <p class=\"item\">Item1</p>\n  <div class=\"item\">Item2</div>\n</div>\n```\n\n虚拟 DOM：\n\n```js\n\n{\n  tag: \"div\",\n  attrs: {\n    id: \"app\"\n  },\n  children: [\n    {\n      tag: \"p\",\n      attrs: { className: \"item\" },\n      children: [\"Item1\"]\n    },\n    {\n      tag: \"div\",\n      attrs: { className: \"item\" },\n      children: [\"Item2\"]\n    }\n  ]\n}\n```\n\n数据变化的时候生成一个新的虚拟 DOM 数据，对比之前的虚拟 DOM 进行 diff 计算，算出要修改的 DOM，再对页面进行操作。\n\n通知页面更新的方式不同：\n\n- vue 中，数据变化，框架主动告诉你修改了哪些数据；\n- react 中，变化变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化\n\n性能问题：\n\n- vue 的响应式，在项目大了之后，每个数据都有一个 watcher 会影响性能\n- 如果 react 虚拟 dom 过于庞大，使得 diff 计算时间大于 16.6 ms(屏幕刷新率 60HZ, 1/60)，可能造成性能卡顿。\n\n为了解决性能问题， Vue 和 react 走了不同的道路。\n\n- react 借鉴操作系统时间分片概念，引入 Fiber 架构。把整个虚拟 DOM 树 微观化，变成链表，然后利用浏览器的空闲时间计算 diff。\n- vue1 的问题在于响应式数据过多，会带来内存占用过多的问题。vue2 引入虚拟 DOM 来解决响应式数据过多问题。\n\n响应式数据是主动推送变化，虚拟 DOM 是被动计算数据的 diff。vue2 将两者结合在一起，在组件级别来划分。\n\n组件间的变化，通过响应式来通知更新。组件内部的数据变化，通过虚拟 DOM 去更新页面。最终，把响应式监听器控制在组件级别，而虚拟 DOM 的量级控制在组件的大小。\n\n在模板书写上，vue 和 react 分别走了 template 和 jsx 两个路线。\n\n- react 世界只有 jsx，最终 jsx 都会在 Compiler 那层，即工程化那里编译成 js 来执行。\n- vue 默认 template。vue3 优秀的其中一点是在虚拟 DOM 的静态标记上做到了极致，让静态的部分越过虚拟 DOM 的计算，真正做到按需更新，很好的提高了性能。\n\n## Vue3 的新特性\n\n### 响应式系统\n\nVue 2 的响应式机制是基于 Object.defineProperty() 这个 API 实现的.Vue3 是基于 proxy。两者区别是 defineProperty 是拦截具体某个属性， Proxy 是全部拦截，是代理。\n\ndefineProperty 示例如下：\n\n```js\nObject.defineProperty(obj, \"title\", {\n  get() {},\n  set() {}\n});\n```\n\n当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。\n\n但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的 $set。\n\nProxy API 是真正的代理，示例如下：\n\n```js\nnew Proxy(obj, {\n  get() {},\n  set() {}\n});\n```\n\nProxy 拦截 obj 这个数据，不关心 obj 里面属性，统一拦截。\n\n### 自定义渲染器\n\nvue2 内部所有模块是揉在一起，导致不好扩展。vue3 采用 monorepo 方式进行拆包，响应式、编译和运行时全部独立。独立出来的响应式，甚至可以在 react、node 中使用。\n\n![vue 架构](/img/2022-01-24-1.png)\n\n渲染逻辑拆成 **平台无关渲染逻辑** 和 **浏览器渲染 API**。\n\n### 全部模块使用 TS 重构\n\nVue2 使用 Flow.js 做类型检测；Flow.js 已被抛弃，vue3 选择 TS。\n\n### Composition API 组合语法\n\nvue2 中示例：\n\n```js\nlet App = {\n  data() {\n    return { count: 1 };\n  },\n  methods: {\n    add() {\n      this.count++;\n    }\n  },\n  computed: {\n    double() {\n      return this.count * 2;\n    }\n  }\n};\n```\n\nvue2 中 Options API 存在以下问题：\n\n- 所有数据都挂载在 this 上，Options API 写法对 TS 类型推导不友好。\n- 新增的功能基本都要修改 data、method 等，代码行数多了以后，会经常需要上下反复横跳。\n- 代码不好复用，vue2 的组件很难抽离通用逻辑，只能使用 mixin，还会导致命名冲突问题。\n\nvue3 中采用新增的 setup 写法：\n\n```js\nconst { reactive, computed } = Vue;\nlet App = {\n  setup() {\n    const state = reactive({ count: 1 });\n    function add() {\n      state.count++;\n    }\n    const double = computed(() => state.count * 2);\n    return { state, add, double };\n  }\n};\n```\n\nComposition API 好处如下：\n\n- 所有 API 都是 import 引入。对 Tree-shaking 很友好，没用到功能，打包的时候会被清理掉 ，减小包的大小\n- 一个功能模块的 methods、data 放一起书写，避免上下反复横跳。\n- 代码复用方便，一个功能的所有 methods、data 封装在一个独立的函数里。\n- Composotion API 新增的 return 等语句，在实际项目中使用。\n\n![Composition API](/img/2022-01-24-2.png)\n\n### 新的组件\n\nVue 3 还内置了 Fragment、Teleport 和 Suspense 三个新组件。\n\n- Fragment: Vue 3 组件不再要求有一个唯一的根节点，清除了很多无用的占位 div。\n- Teleport: 允许组件渲染在别的元素内，主要开发弹窗组件的时候特别有用。\n- Suspense: 异步组件，更方便开发有异步请求的组件。\n\n### 新一代工程化工具 Vite\n\nwebpack 工程化的原理是 根据 import 依赖逻辑形成一个依赖图，然后调用对应的处理工具，把整个项目打包后，放在内存中再启动调试。因为要预打包，复杂项目开发时，启动开发环境和热更新时间都比较长，Vite 就是为了解决这个问题而出现的。\n\n现代浏览器已经默认支持 ES6 的 import 语法，Vite 就是基于这个原理实现的。\n\n在开发环境下，不需要全部预打包，只要把首页依赖的文件，依次通过网络请求去获取，开发体验得到巨大提升，做到复杂项目时，也能做到秒级调试和热更新。\n\nwebpack 工作原理如下，需要把所有路由依赖打包后，才能开始调试。\n\n![webpack 工作原理](/img/2022-01-24-3.png)\n\nVite 工作原理，根据首页的依赖模块，再去获取路由 1 的模块，按需加载。\n\n![Vite 工作原理](/img/2022-01-24-4.png)\n\n## Vue3 响应式机制\n\n响应式原理：Vue 中用过三种响应式解决方案，分别是 defineProperty、Proxy 和 value setter。\n\n---\n\ntodo: 07\n\n## Vue3 实践常见问题汇总\n\n1. vetur 报错， xx has no export.\n\n   使用 Vue3 `script setup` 语法糖时,VsCode 插件 Vetur 会报该错误，原因是 Vetur(v0.35.0) 暂不支持 ts。\n\n   解决办法： 卸载 Vetur， 用 Volar(尤大推荐) 以取代 Vetur。\n\n---\n\n上述笔记源于学习极客时间-大圣的 [玩转 Vue3 全家桶](http://gk.link/a/115Qp) 课程笔记整理。\n\n---\n","source":"_posts/7.Vue3 学习笔记.md","raw":"---\ntitle: Vue3 学习笔记\nindex_img: /img/2022-01-22-1.jpeg\ntags: Vue3\ncategories: Vue\nabbrlink: e372be48\ndate: 2022-01-22 10:46:00\n---\n\n## Vue 和 React 数据驱动原理对比\n\nVue1 解决方案是使用响应式，初始化的时候，watcher 监听数据的每个属性，数据发生变化的时候，就能够知道数据的哪个 key 变了，去修改对应的 DOM。\n\nReact 是虚拟 DOM 方案，用 JS 对象描述 DOM 树，这个对象就像数据和实际 DOM 的一个缓存层，通过管理这个对象的变化，来减少对实际 DOM 的操作。\n\n描述实际 DOM 的虚拟 DOM 对象如下：\n\nDOM:\n\n```html\n<div id=\"app\">\n  <p class=\"item\">Item1</p>\n  <div class=\"item\">Item2</div>\n</div>\n```\n\n虚拟 DOM：\n\n```js\n\n{\n  tag: \"div\",\n  attrs: {\n    id: \"app\"\n  },\n  children: [\n    {\n      tag: \"p\",\n      attrs: { className: \"item\" },\n      children: [\"Item1\"]\n    },\n    {\n      tag: \"div\",\n      attrs: { className: \"item\" },\n      children: [\"Item2\"]\n    }\n  ]\n}\n```\n\n数据变化的时候生成一个新的虚拟 DOM 数据，对比之前的虚拟 DOM 进行 diff 计算，算出要修改的 DOM，再对页面进行操作。\n\n通知页面更新的方式不同：\n\n- vue 中，数据变化，框架主动告诉你修改了哪些数据；\n- react 中，变化变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化\n\n性能问题：\n\n- vue 的响应式，在项目大了之后，每个数据都有一个 watcher 会影响性能\n- 如果 react 虚拟 dom 过于庞大，使得 diff 计算时间大于 16.6 ms(屏幕刷新率 60HZ, 1/60)，可能造成性能卡顿。\n\n为了解决性能问题， Vue 和 react 走了不同的道路。\n\n- react 借鉴操作系统时间分片概念，引入 Fiber 架构。把整个虚拟 DOM 树 微观化，变成链表，然后利用浏览器的空闲时间计算 diff。\n- vue1 的问题在于响应式数据过多，会带来内存占用过多的问题。vue2 引入虚拟 DOM 来解决响应式数据过多问题。\n\n响应式数据是主动推送变化，虚拟 DOM 是被动计算数据的 diff。vue2 将两者结合在一起，在组件级别来划分。\n\n组件间的变化，通过响应式来通知更新。组件内部的数据变化，通过虚拟 DOM 去更新页面。最终，把响应式监听器控制在组件级别，而虚拟 DOM 的量级控制在组件的大小。\n\n在模板书写上，vue 和 react 分别走了 template 和 jsx 两个路线。\n\n- react 世界只有 jsx，最终 jsx 都会在 Compiler 那层，即工程化那里编译成 js 来执行。\n- vue 默认 template。vue3 优秀的其中一点是在虚拟 DOM 的静态标记上做到了极致，让静态的部分越过虚拟 DOM 的计算，真正做到按需更新，很好的提高了性能。\n\n## Vue3 的新特性\n\n### 响应式系统\n\nVue 2 的响应式机制是基于 Object.defineProperty() 这个 API 实现的.Vue3 是基于 proxy。两者区别是 defineProperty 是拦截具体某个属性， Proxy 是全部拦截，是代理。\n\ndefineProperty 示例如下：\n\n```js\nObject.defineProperty(obj, \"title\", {\n  get() {},\n  set() {}\n});\n```\n\n当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。\n\n但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的 $set。\n\nProxy API 是真正的代理，示例如下：\n\n```js\nnew Proxy(obj, {\n  get() {},\n  set() {}\n});\n```\n\nProxy 拦截 obj 这个数据，不关心 obj 里面属性，统一拦截。\n\n### 自定义渲染器\n\nvue2 内部所有模块是揉在一起，导致不好扩展。vue3 采用 monorepo 方式进行拆包，响应式、编译和运行时全部独立。独立出来的响应式，甚至可以在 react、node 中使用。\n\n![vue 架构](/img/2022-01-24-1.png)\n\n渲染逻辑拆成 **平台无关渲染逻辑** 和 **浏览器渲染 API**。\n\n### 全部模块使用 TS 重构\n\nVue2 使用 Flow.js 做类型检测；Flow.js 已被抛弃，vue3 选择 TS。\n\n### Composition API 组合语法\n\nvue2 中示例：\n\n```js\nlet App = {\n  data() {\n    return { count: 1 };\n  },\n  methods: {\n    add() {\n      this.count++;\n    }\n  },\n  computed: {\n    double() {\n      return this.count * 2;\n    }\n  }\n};\n```\n\nvue2 中 Options API 存在以下问题：\n\n- 所有数据都挂载在 this 上，Options API 写法对 TS 类型推导不友好。\n- 新增的功能基本都要修改 data、method 等，代码行数多了以后，会经常需要上下反复横跳。\n- 代码不好复用，vue2 的组件很难抽离通用逻辑，只能使用 mixin，还会导致命名冲突问题。\n\nvue3 中采用新增的 setup 写法：\n\n```js\nconst { reactive, computed } = Vue;\nlet App = {\n  setup() {\n    const state = reactive({ count: 1 });\n    function add() {\n      state.count++;\n    }\n    const double = computed(() => state.count * 2);\n    return { state, add, double };\n  }\n};\n```\n\nComposition API 好处如下：\n\n- 所有 API 都是 import 引入。对 Tree-shaking 很友好，没用到功能，打包的时候会被清理掉 ，减小包的大小\n- 一个功能模块的 methods、data 放一起书写，避免上下反复横跳。\n- 代码复用方便，一个功能的所有 methods、data 封装在一个独立的函数里。\n- Composotion API 新增的 return 等语句，在实际项目中使用。\n\n![Composition API](/img/2022-01-24-2.png)\n\n### 新的组件\n\nVue 3 还内置了 Fragment、Teleport 和 Suspense 三个新组件。\n\n- Fragment: Vue 3 组件不再要求有一个唯一的根节点，清除了很多无用的占位 div。\n- Teleport: 允许组件渲染在别的元素内，主要开发弹窗组件的时候特别有用。\n- Suspense: 异步组件，更方便开发有异步请求的组件。\n\n### 新一代工程化工具 Vite\n\nwebpack 工程化的原理是 根据 import 依赖逻辑形成一个依赖图，然后调用对应的处理工具，把整个项目打包后，放在内存中再启动调试。因为要预打包，复杂项目开发时，启动开发环境和热更新时间都比较长，Vite 就是为了解决这个问题而出现的。\n\n现代浏览器已经默认支持 ES6 的 import 语法，Vite 就是基于这个原理实现的。\n\n在开发环境下，不需要全部预打包，只要把首页依赖的文件，依次通过网络请求去获取，开发体验得到巨大提升，做到复杂项目时，也能做到秒级调试和热更新。\n\nwebpack 工作原理如下，需要把所有路由依赖打包后，才能开始调试。\n\n![webpack 工作原理](/img/2022-01-24-3.png)\n\nVite 工作原理，根据首页的依赖模块，再去获取路由 1 的模块，按需加载。\n\n![Vite 工作原理](/img/2022-01-24-4.png)\n\n## Vue3 响应式机制\n\n响应式原理：Vue 中用过三种响应式解决方案，分别是 defineProperty、Proxy 和 value setter。\n\n---\n\ntodo: 07\n\n## Vue3 实践常见问题汇总\n\n1. vetur 报错， xx has no export.\n\n   使用 Vue3 `script setup` 语法糖时,VsCode 插件 Vetur 会报该错误，原因是 Vetur(v0.35.0) 暂不支持 ts。\n\n   解决办法： 卸载 Vetur， 用 Volar(尤大推荐) 以取代 Vetur。\n\n---\n\n上述笔记源于学习极客时间-大圣的 [玩转 Vue3 全家桶](http://gk.link/a/115Qp) 课程笔记整理。\n\n---\n","slug":"7-Vue3-学习笔记","published":1,"updated":"2022-03-01T02:56:12.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k5bv7a001b0h3lfngh372f","content":"<h2 id=\"Vue-和-React-数据驱动原理对比\"><a href=\"#Vue-和-React-数据驱动原理对比\" class=\"headerlink\" title=\"Vue 和 React 数据驱动原理对比\"></a>Vue 和 React 数据驱动原理对比</h2><p>Vue1 解决方案是使用响应式，初始化的时候，watcher 监听数据的每个属性，数据发生变化的时候，就能够知道数据的哪个 key 变了，去修改对应的 DOM。</p>\n<p>React 是虚拟 DOM 方案，用 JS 对象描述 DOM 树，这个对象就像数据和实际 DOM 的一个缓存层，通过管理这个对象的变化，来减少对实际 DOM 的操作。</p>\n<p>描述实际 DOM 的虚拟 DOM 对象如下：</p>\n<p>DOM:</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>Item1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>Item2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre></div>\n\n<p>虚拟 DOM：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\">\n&#123;\n  <span class=\"hljs-attr\">tag</span>: <span class=\"hljs-string\">&quot;div&quot;</span>,\n  <span class=\"hljs-attr\">attrs</span>: &#123;\n    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">&quot;app&quot;</span>\n  &#125;,\n  <span class=\"hljs-attr\">children</span>: [\n    &#123;\n      <span class=\"hljs-attr\">tag</span>: <span class=\"hljs-string\">&quot;p&quot;</span>,\n      <span class=\"hljs-attr\">attrs</span>: &#123; <span class=\"hljs-attr\">className</span>: <span class=\"hljs-string\">&quot;item&quot;</span> &#125;,\n      <span class=\"hljs-attr\">children</span>: [<span class=\"hljs-string\">&quot;Item1&quot;</span>]\n    &#125;,\n    &#123;\n      <span class=\"hljs-attr\">tag</span>: <span class=\"hljs-string\">&quot;div&quot;</span>,\n      <span class=\"hljs-attr\">attrs</span>: &#123; <span class=\"hljs-attr\">className</span>: <span class=\"hljs-string\">&quot;item&quot;</span> &#125;,\n      <span class=\"hljs-attr\">children</span>: [<span class=\"hljs-string\">&quot;Item2&quot;</span>]\n    &#125;\n  ]\n&#125;</code></pre></div>\n\n<p>数据变化的时候生成一个新的虚拟 DOM 数据，对比之前的虚拟 DOM 进行 diff 计算，算出要修改的 DOM，再对页面进行操作。</p>\n<p>通知页面更新的方式不同：</p>\n<ul>\n<li>vue 中，数据变化，框架主动告诉你修改了哪些数据；</li>\n<li>react 中，变化变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化</li>\n</ul>\n<p>性能问题：</p>\n<ul>\n<li>vue 的响应式，在项目大了之后，每个数据都有一个 watcher 会影响性能</li>\n<li>如果 react 虚拟 dom 过于庞大，使得 diff 计算时间大于 16.6 ms(屏幕刷新率 60HZ, 1/60)，可能造成性能卡顿。</li>\n</ul>\n<p>为了解决性能问题， Vue 和 react 走了不同的道路。</p>\n<ul>\n<li>react 借鉴操作系统时间分片概念，引入 Fiber 架构。把整个虚拟 DOM 树 微观化，变成链表，然后利用浏览器的空闲时间计算 diff。</li>\n<li>vue1 的问题在于响应式数据过多，会带来内存占用过多的问题。vue2 引入虚拟 DOM 来解决响应式数据过多问题。</li>\n</ul>\n<p>响应式数据是主动推送变化，虚拟 DOM 是被动计算数据的 diff。vue2 将两者结合在一起，在组件级别来划分。</p>\n<p>组件间的变化，通过响应式来通知更新。组件内部的数据变化，通过虚拟 DOM 去更新页面。最终，把响应式监听器控制在组件级别，而虚拟 DOM 的量级控制在组件的大小。</p>\n<p>在模板书写上，vue 和 react 分别走了 template 和 jsx 两个路线。</p>\n<ul>\n<li>react 世界只有 jsx，最终 jsx 都会在 Compiler 那层，即工程化那里编译成 js 来执行。</li>\n<li>vue 默认 template。vue3 优秀的其中一点是在虚拟 DOM 的静态标记上做到了极致，让静态的部分越过虚拟 DOM 的计算，真正做到按需更新，很好的提高了性能。</li>\n</ul>\n<h2 id=\"Vue3-的新特性\"><a href=\"#Vue3-的新特性\" class=\"headerlink\" title=\"Vue3 的新特性\"></a>Vue3 的新特性</h2><h3 id=\"响应式系统\"><a href=\"#响应式系统\" class=\"headerlink\" title=\"响应式系统\"></a>响应式系统</h3><p>Vue 2 的响应式机制是基于 Object.defineProperty() 这个 API 实现的.Vue3 是基于 proxy。两者区别是 defineProperty 是拦截具体某个属性， Proxy 是全部拦截，是代理。</p>\n<p>defineProperty 示例如下：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">Object</span>.defineProperty(obj, <span class=\"hljs-string\">&quot;title&quot;</span>, &#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;,\n  <span class=\"hljs-function\"><span class=\"hljs-title\">set</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;\n&#125;);</code></pre></div>\n\n<p>当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。</p>\n<p>但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的 $set。</p>\n<p>Proxy API 是真正的代理，示例如下：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>(obj, &#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;,\n  <span class=\"hljs-function\"><span class=\"hljs-title\">set</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;\n&#125;);</code></pre></div>\n\n<p>Proxy 拦截 obj 这个数据，不关心 obj 里面属性，统一拦截。</p>\n<h3 id=\"自定义渲染器\"><a href=\"#自定义渲染器\" class=\"headerlink\" title=\"自定义渲染器\"></a>自定义渲染器</h3><p>vue2 内部所有模块是揉在一起，导致不好扩展。vue3 采用 monorepo 方式进行拆包，响应式、编译和运行时全部独立。独立出来的响应式，甚至可以在 react、node 中使用。</p>\n<p><img src=\"/img/2022-01-24-1.png\" alt=\"vue 架构\"></p>\n<p>渲染逻辑拆成 <strong>平台无关渲染逻辑</strong> 和 <strong>浏览器渲染 API</strong>。</p>\n<h3 id=\"全部模块使用-TS-重构\"><a href=\"#全部模块使用-TS-重构\" class=\"headerlink\" title=\"全部模块使用 TS 重构\"></a>全部模块使用 TS 重构</h3><p>Vue2 使用 Flow.js 做类型检测；Flow.js 已被抛弃，vue3 选择 TS。</p>\n<h3 id=\"Composition-API-组合语法\"><a href=\"#Composition-API-组合语法\" class=\"headerlink\" title=\"Composition API 组合语法\"></a>Composition API 组合语法</h3><p>vue2 中示例：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> App = &#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">1</span> &#125;;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-function\"><span class=\"hljs-title\">add</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n      <span class=\"hljs-built_in\">this</span>.count++;\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">computed</span>: &#123;\n    <span class=\"hljs-function\"><span class=\"hljs-title\">double</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.count * <span class=\"hljs-number\">2</span>;\n    &#125;\n  &#125;\n&#125;;</code></pre></div>\n\n<p>vue2 中 Options API 存在以下问题：</p>\n<ul>\n<li>所有数据都挂载在 this 上，Options API 写法对 TS 类型推导不友好。</li>\n<li>新增的功能基本都要修改 data、method 等，代码行数多了以后，会经常需要上下反复横跳。</li>\n<li>代码不好复用，vue2 的组件很难抽离通用逻辑，只能使用 mixin，还会导致命名冲突问题。</li>\n</ul>\n<p>vue3 中采用新增的 setup 写法：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> &#123; reactive, computed &#125; = Vue;\n<span class=\"hljs-keyword\">let</span> App = &#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">setup</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">const</span> state = reactive(&#123; <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">1</span> &#125;);\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n      state.count++;\n    &#125;\n    <span class=\"hljs-keyword\">const</span> double = computed(<span class=\"hljs-function\">() =&gt;</span> state.count * <span class=\"hljs-number\">2</span>);\n    <span class=\"hljs-keyword\">return</span> &#123; state, add, double &#125;;\n  &#125;\n&#125;;</code></pre></div>\n\n<p>Composition API 好处如下：</p>\n<ul>\n<li>所有 API 都是 import 引入。对 Tree-shaking 很友好，没用到功能，打包的时候会被清理掉 ，减小包的大小</li>\n<li>一个功能模块的 methods、data 放一起书写，避免上下反复横跳。</li>\n<li>代码复用方便，一个功能的所有 methods、data 封装在一个独立的函数里。</li>\n<li>Composotion API 新增的 return 等语句，在实际项目中使用。</li>\n</ul>\n<p><img src=\"/img/2022-01-24-2.png\" alt=\"Composition API\"></p>\n<h3 id=\"新的组件\"><a href=\"#新的组件\" class=\"headerlink\" title=\"新的组件\"></a>新的组件</h3><p>Vue 3 还内置了 Fragment、Teleport 和 Suspense 三个新组件。</p>\n<ul>\n<li>Fragment: Vue 3 组件不再要求有一个唯一的根节点，清除了很多无用的占位 div。</li>\n<li>Teleport: 允许组件渲染在别的元素内，主要开发弹窗组件的时候特别有用。</li>\n<li>Suspense: 异步组件，更方便开发有异步请求的组件。</li>\n</ul>\n<h3 id=\"新一代工程化工具-Vite\"><a href=\"#新一代工程化工具-Vite\" class=\"headerlink\" title=\"新一代工程化工具 Vite\"></a>新一代工程化工具 Vite</h3><p>webpack 工程化的原理是 根据 import 依赖逻辑形成一个依赖图，然后调用对应的处理工具，把整个项目打包后，放在内存中再启动调试。因为要预打包，复杂项目开发时，启动开发环境和热更新时间都比较长，Vite 就是为了解决这个问题而出现的。</p>\n<p>现代浏览器已经默认支持 ES6 的 import 语法，Vite 就是基于这个原理实现的。</p>\n<p>在开发环境下，不需要全部预打包，只要把首页依赖的文件，依次通过网络请求去获取，开发体验得到巨大提升，做到复杂项目时，也能做到秒级调试和热更新。</p>\n<p>webpack 工作原理如下，需要把所有路由依赖打包后，才能开始调试。</p>\n<p><img src=\"/img/2022-01-24-3.png\" alt=\"webpack 工作原理\"></p>\n<p>Vite 工作原理，根据首页的依赖模块，再去获取路由 1 的模块，按需加载。</p>\n<p><img src=\"/img/2022-01-24-4.png\" alt=\"Vite 工作原理\"></p>\n<h2 id=\"Vue3-响应式机制\"><a href=\"#Vue3-响应式机制\" class=\"headerlink\" title=\"Vue3 响应式机制\"></a>Vue3 响应式机制</h2><p>响应式原理：Vue 中用过三种响应式解决方案，分别是 defineProperty、Proxy 和 value setter。</p>\n<hr>\n<p>todo: 07</p>\n<h2 id=\"Vue3-实践常见问题汇总\"><a href=\"#Vue3-实践常见问题汇总\" class=\"headerlink\" title=\"Vue3 实践常见问题汇总\"></a>Vue3 实践常见问题汇总</h2><ol>\n<li><p>vetur 报错， xx has no export.</p>\n<p>使用 Vue3 <code>script setup</code> 语法糖时,VsCode 插件 Vetur 会报该错误，原因是 Vetur(v0.35.0) 暂不支持 ts。</p>\n<p>解决办法： 卸载 Vetur， 用 Volar(尤大推荐) 以取代 Vetur。</p>\n</li>\n</ol>\n<hr>\n<p>上述笔记源于学习极客时间-大圣的 <a href=\"http://gk.link/a/115Qp\">玩转 Vue3 全家桶</a> 课程笔记整理。</p>\n<hr>\n","site":{"data":{}},"wordcount":3477,"excerpt":"","more":"<h2 id=\"Vue-和-React-数据驱动原理对比\"><a href=\"#Vue-和-React-数据驱动原理对比\" class=\"headerlink\" title=\"Vue 和 React 数据驱动原理对比\"></a>Vue 和 React 数据驱动原理对比</h2><p>Vue1 解决方案是使用响应式，初始化的时候，watcher 监听数据的每个属性，数据发生变化的时候，就能够知道数据的哪个 key 变了，去修改对应的 DOM。</p>\n<p>React 是虚拟 DOM 方案，用 JS 对象描述 DOM 树，这个对象就像数据和实际 DOM 的一个缓存层，通过管理这个对象的变化，来减少对实际 DOM 的操作。</p>\n<p>描述实际 DOM 的虚拟 DOM 对象如下：</p>\n<p>DOM:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>Item1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>Item2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n\n<p>虚拟 DOM：</p>\n<pre><code class=\"hljs js\">\n&#123;\n  <span class=\"hljs-attr\">tag</span>: <span class=\"hljs-string\">&quot;div&quot;</span>,\n  <span class=\"hljs-attr\">attrs</span>: &#123;\n    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">&quot;app&quot;</span>\n  &#125;,\n  <span class=\"hljs-attr\">children</span>: [\n    &#123;\n      <span class=\"hljs-attr\">tag</span>: <span class=\"hljs-string\">&quot;p&quot;</span>,\n      <span class=\"hljs-attr\">attrs</span>: &#123; <span class=\"hljs-attr\">className</span>: <span class=\"hljs-string\">&quot;item&quot;</span> &#125;,\n      <span class=\"hljs-attr\">children</span>: [<span class=\"hljs-string\">&quot;Item1&quot;</span>]\n    &#125;,\n    &#123;\n      <span class=\"hljs-attr\">tag</span>: <span class=\"hljs-string\">&quot;div&quot;</span>,\n      <span class=\"hljs-attr\">attrs</span>: &#123; <span class=\"hljs-attr\">className</span>: <span class=\"hljs-string\">&quot;item&quot;</span> &#125;,\n      <span class=\"hljs-attr\">children</span>: [<span class=\"hljs-string\">&quot;Item2&quot;</span>]\n    &#125;\n  ]\n&#125;</code></pre>\n\n<p>数据变化的时候生成一个新的虚拟 DOM 数据，对比之前的虚拟 DOM 进行 diff 计算，算出要修改的 DOM，再对页面进行操作。</p>\n<p>通知页面更新的方式不同：</p>\n<ul>\n<li>vue 中，数据变化，框架主动告诉你修改了哪些数据；</li>\n<li>react 中，变化变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化</li>\n</ul>\n<p>性能问题：</p>\n<ul>\n<li>vue 的响应式，在项目大了之后，每个数据都有一个 watcher 会影响性能</li>\n<li>如果 react 虚拟 dom 过于庞大，使得 diff 计算时间大于 16.6 ms(屏幕刷新率 60HZ, 1/60)，可能造成性能卡顿。</li>\n</ul>\n<p>为了解决性能问题， Vue 和 react 走了不同的道路。</p>\n<ul>\n<li>react 借鉴操作系统时间分片概念，引入 Fiber 架构。把整个虚拟 DOM 树 微观化，变成链表，然后利用浏览器的空闲时间计算 diff。</li>\n<li>vue1 的问题在于响应式数据过多，会带来内存占用过多的问题。vue2 引入虚拟 DOM 来解决响应式数据过多问题。</li>\n</ul>\n<p>响应式数据是主动推送变化，虚拟 DOM 是被动计算数据的 diff。vue2 将两者结合在一起，在组件级别来划分。</p>\n<p>组件间的变化，通过响应式来通知更新。组件内部的数据变化，通过虚拟 DOM 去更新页面。最终，把响应式监听器控制在组件级别，而虚拟 DOM 的量级控制在组件的大小。</p>\n<p>在模板书写上，vue 和 react 分别走了 template 和 jsx 两个路线。</p>\n<ul>\n<li>react 世界只有 jsx，最终 jsx 都会在 Compiler 那层，即工程化那里编译成 js 来执行。</li>\n<li>vue 默认 template。vue3 优秀的其中一点是在虚拟 DOM 的静态标记上做到了极致，让静态的部分越过虚拟 DOM 的计算，真正做到按需更新，很好的提高了性能。</li>\n</ul>\n<h2 id=\"Vue3-的新特性\"><a href=\"#Vue3-的新特性\" class=\"headerlink\" title=\"Vue3 的新特性\"></a>Vue3 的新特性</h2><h3 id=\"响应式系统\"><a href=\"#响应式系统\" class=\"headerlink\" title=\"响应式系统\"></a>响应式系统</h3><p>Vue 2 的响应式机制是基于 Object.defineProperty() 这个 API 实现的.Vue3 是基于 proxy。两者区别是 defineProperty 是拦截具体某个属性， Proxy 是全部拦截，是代理。</p>\n<p>defineProperty 示例如下：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-built_in\">Object</span>.defineProperty(obj, <span class=\"hljs-string\">&quot;title&quot;</span>, &#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;,\n  <span class=\"hljs-function\"><span class=\"hljs-title\">set</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;\n&#125;);</code></pre>\n\n<p>当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。</p>\n<p>但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的 $set。</p>\n<p>Proxy API 是真正的代理，示例如下：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>(obj, &#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;,\n  <span class=\"hljs-function\"><span class=\"hljs-title\">set</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;\n&#125;);</code></pre>\n\n<p>Proxy 拦截 obj 这个数据，不关心 obj 里面属性，统一拦截。</p>\n<h3 id=\"自定义渲染器\"><a href=\"#自定义渲染器\" class=\"headerlink\" title=\"自定义渲染器\"></a>自定义渲染器</h3><p>vue2 内部所有模块是揉在一起，导致不好扩展。vue3 采用 monorepo 方式进行拆包，响应式、编译和运行时全部独立。独立出来的响应式，甚至可以在 react、node 中使用。</p>\n<p><img src=\"/img/2022-01-24-1.png\" alt=\"vue 架构\"></p>\n<p>渲染逻辑拆成 <strong>平台无关渲染逻辑</strong> 和 <strong>浏览器渲染 API</strong>。</p>\n<h3 id=\"全部模块使用-TS-重构\"><a href=\"#全部模块使用-TS-重构\" class=\"headerlink\" title=\"全部模块使用 TS 重构\"></a>全部模块使用 TS 重构</h3><p>Vue2 使用 Flow.js 做类型检测；Flow.js 已被抛弃，vue3 选择 TS。</p>\n<h3 id=\"Composition-API-组合语法\"><a href=\"#Composition-API-组合语法\" class=\"headerlink\" title=\"Composition API 组合语法\"></a>Composition API 组合语法</h3><p>vue2 中示例：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> App = &#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">1</span> &#125;;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-function\"><span class=\"hljs-title\">add</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n      <span class=\"hljs-built_in\">this</span>.count++;\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">computed</span>: &#123;\n    <span class=\"hljs-function\"><span class=\"hljs-title\">double</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.count * <span class=\"hljs-number\">2</span>;\n    &#125;\n  &#125;\n&#125;;</code></pre>\n\n<p>vue2 中 Options API 存在以下问题：</p>\n<ul>\n<li>所有数据都挂载在 this 上，Options API 写法对 TS 类型推导不友好。</li>\n<li>新增的功能基本都要修改 data、method 等，代码行数多了以后，会经常需要上下反复横跳。</li>\n<li>代码不好复用，vue2 的组件很难抽离通用逻辑，只能使用 mixin，还会导致命名冲突问题。</li>\n</ul>\n<p>vue3 中采用新增的 setup 写法：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> &#123; reactive, computed &#125; = Vue;\n<span class=\"hljs-keyword\">let</span> App = &#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">setup</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">const</span> state = reactive(&#123; <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">1</span> &#125;);\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n      state.count++;\n    &#125;\n    <span class=\"hljs-keyword\">const</span> double = computed(<span class=\"hljs-function\">() =&gt;</span> state.count * <span class=\"hljs-number\">2</span>);\n    <span class=\"hljs-keyword\">return</span> &#123; state, add, double &#125;;\n  &#125;\n&#125;;</code></pre>\n\n<p>Composition API 好处如下：</p>\n<ul>\n<li>所有 API 都是 import 引入。对 Tree-shaking 很友好，没用到功能，打包的时候会被清理掉 ，减小包的大小</li>\n<li>一个功能模块的 methods、data 放一起书写，避免上下反复横跳。</li>\n<li>代码复用方便，一个功能的所有 methods、data 封装在一个独立的函数里。</li>\n<li>Composotion API 新增的 return 等语句，在实际项目中使用。</li>\n</ul>\n<p><img src=\"/img/2022-01-24-2.png\" alt=\"Composition API\"></p>\n<h3 id=\"新的组件\"><a href=\"#新的组件\" class=\"headerlink\" title=\"新的组件\"></a>新的组件</h3><p>Vue 3 还内置了 Fragment、Teleport 和 Suspense 三个新组件。</p>\n<ul>\n<li>Fragment: Vue 3 组件不再要求有一个唯一的根节点，清除了很多无用的占位 div。</li>\n<li>Teleport: 允许组件渲染在别的元素内，主要开发弹窗组件的时候特别有用。</li>\n<li>Suspense: 异步组件，更方便开发有异步请求的组件。</li>\n</ul>\n<h3 id=\"新一代工程化工具-Vite\"><a href=\"#新一代工程化工具-Vite\" class=\"headerlink\" title=\"新一代工程化工具 Vite\"></a>新一代工程化工具 Vite</h3><p>webpack 工程化的原理是 根据 import 依赖逻辑形成一个依赖图，然后调用对应的处理工具，把整个项目打包后，放在内存中再启动调试。因为要预打包，复杂项目开发时，启动开发环境和热更新时间都比较长，Vite 就是为了解决这个问题而出现的。</p>\n<p>现代浏览器已经默认支持 ES6 的 import 语法，Vite 就是基于这个原理实现的。</p>\n<p>在开发环境下，不需要全部预打包，只要把首页依赖的文件，依次通过网络请求去获取，开发体验得到巨大提升，做到复杂项目时，也能做到秒级调试和热更新。</p>\n<p>webpack 工作原理如下，需要把所有路由依赖打包后，才能开始调试。</p>\n<p><img src=\"/img/2022-01-24-3.png\" alt=\"webpack 工作原理\"></p>\n<p>Vite 工作原理，根据首页的依赖模块，再去获取路由 1 的模块，按需加载。</p>\n<p><img src=\"/img/2022-01-24-4.png\" alt=\"Vite 工作原理\"></p>\n<h2 id=\"Vue3-响应式机制\"><a href=\"#Vue3-响应式机制\" class=\"headerlink\" title=\"Vue3 响应式机制\"></a>Vue3 响应式机制</h2><p>响应式原理：Vue 中用过三种响应式解决方案，分别是 defineProperty、Proxy 和 value setter。</p>\n<hr>\n<p>todo: 07</p>\n<h2 id=\"Vue3-实践常见问题汇总\"><a href=\"#Vue3-实践常见问题汇总\" class=\"headerlink\" title=\"Vue3 实践常见问题汇总\"></a>Vue3 实践常见问题汇总</h2><ol>\n<li><p>vetur 报错， xx has no export.</p>\n<p>使用 Vue3 <code>script setup</code> 语法糖时,VsCode 插件 Vetur 会报该错误，原因是 Vetur(v0.35.0) 暂不支持 ts。</p>\n<p>解决办法： 卸载 Vetur， 用 Volar(尤大推荐) 以取代 Vetur。</p>\n</li>\n</ol>\n<hr>\n<p>上述笔记源于学习极客时间-大圣的 <a href=\"http://gk.link/a/115Qp\">玩转 Vue3 全家桶</a> 课程笔记整理。</p>\n<hr>\n"},{"title":"VS Code 配置","index_img":"/img/2022-02-06-1.png","abbrlink":"1ad5be0d","date":"2022-02-06T15:30:46.000Z","_content":"\n## console.log 快捷输入\n\n打开 `文件 --> 首选项 --> 用户片段`\n\n在输入框中输入markdown，可以找到markdown.json的代码片段配置 放开 example 注释\n\n```js\n \"Print to console\": {\n  \"prefix\": \"log\",\n  \"body\": [\n   \"console.log('$1');\",\n   \"$2\"\n  ],\n  \"description\": \"Log output to console\"\n },\n```\n\n## markdown 代码段快捷输入\n\n同上 在 markdown.json 中继续配置如下\n\n```js\n \"Print to ```js\": {\n  \"prefix\": \"```js\",\n  \"body\": [\n   \"```js\",\n   \"$1\",\n   \"```\",\n  ],\n  \"description\": \"js代码片段\"\n },\n \"Print to ```jsx\": {\n  \"prefix\": \"```jsx\",\n  \"body\": [\n   \"```jsx\",\n   \"$1\",\n   \"```\",\n  ],\n  \"description\": \"jsx代码片段\"\n },\n```\n\n配置添加后，markdown 中输入 ```js 并没有快捷提示 还需要在 setting.json 中添加如下配置\n\nsetting.json 打开位置：打开vs code的设置，文件 --> 首选项 --> 设置 --> 打开设置（在设置的右上角）\n\n```js\n\"[markdown]\":{\n    \"editor.quickSuggestions\": true\n}\n```\n","source":"_posts/8.VS Code 配置.md","raw":"---\ntitle: VS Code 配置\nindex_img: /img/2022-02-06-1.png\nabbrlink: 1ad5be0d\ndate: 2022-02-06 23:30:46\ntags: vscode\ncategories: vscode\n---\n\n## console.log 快捷输入\n\n打开 `文件 --> 首选项 --> 用户片段`\n\n在输入框中输入markdown，可以找到markdown.json的代码片段配置 放开 example 注释\n\n```js\n \"Print to console\": {\n  \"prefix\": \"log\",\n  \"body\": [\n   \"console.log('$1');\",\n   \"$2\"\n  ],\n  \"description\": \"Log output to console\"\n },\n```\n\n## markdown 代码段快捷输入\n\n同上 在 markdown.json 中继续配置如下\n\n```js\n \"Print to ```js\": {\n  \"prefix\": \"```js\",\n  \"body\": [\n   \"```js\",\n   \"$1\",\n   \"```\",\n  ],\n  \"description\": \"js代码片段\"\n },\n \"Print to ```jsx\": {\n  \"prefix\": \"```jsx\",\n  \"body\": [\n   \"```jsx\",\n   \"$1\",\n   \"```\",\n  ],\n  \"description\": \"jsx代码片段\"\n },\n```\n\n配置添加后，markdown 中输入 ```js 并没有快捷提示 还需要在 setting.json 中添加如下配置\n\nsetting.json 打开位置：打开vs code的设置，文件 --> 首选项 --> 设置 --> 打开设置（在设置的右上角）\n\n```js\n\"[markdown]\":{\n    \"editor.quickSuggestions\": true\n}\n```\n","slug":"8-VS-Code-配置","published":1,"updated":"2022-04-15T09:58:53.884Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k5bv7b001f0h3l76mgg3fm","content":"<h2 id=\"console-log-快捷输入\"><a href=\"#console-log-快捷输入\" class=\"headerlink\" title=\"console.log 快捷输入\"></a>console.log 快捷输入</h2><p>打开 <code>文件 --&gt; 首选项 --&gt; 用户片段</code></p>\n<p>在输入框中输入markdown，可以找到markdown.json的代码片段配置 放开 example 注释</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-string\">&quot;Print to console&quot;</span>: &#123;\n <span class=\"hljs-string\">&quot;prefix&quot;</span>: <span class=\"hljs-string\">&quot;log&quot;</span>,\n <span class=\"hljs-string\">&quot;body&quot;</span>: [\n  <span class=\"hljs-string\">&quot;console.log(&#x27;$1&#x27;);&quot;</span>,\n  <span class=\"hljs-string\">&quot;$2&quot;</span>\n ],\n <span class=\"hljs-string\">&quot;description&quot;</span>: <span class=\"hljs-string\">&quot;Log output to console&quot;</span>\n&#125;,</code></pre></div>\n\n<h2 id=\"markdown-代码段快捷输入\"><a href=\"#markdown-代码段快捷输入\" class=\"headerlink\" title=\"markdown 代码段快捷输入\"></a>markdown 代码段快捷输入</h2><p>同上 在 markdown.json 中继续配置如下</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-string\">&quot;Print to ```js&quot;</span>: &#123;\n <span class=\"hljs-string\">&quot;prefix&quot;</span>: <span class=\"hljs-string\">&quot;```js&quot;</span>,\n <span class=\"hljs-string\">&quot;body&quot;</span>: [\n  <span class=\"hljs-string\">&quot;```js&quot;</span>,\n  <span class=\"hljs-string\">&quot;$1&quot;</span>,\n  <span class=\"hljs-string\">&quot;```&quot;</span>,\n ],\n <span class=\"hljs-string\">&quot;description&quot;</span>: <span class=\"hljs-string\">&quot;js代码片段&quot;</span>\n&#125;,\n<span class=\"hljs-string\">&quot;Print to ```jsx&quot;</span>: &#123;\n <span class=\"hljs-string\">&quot;prefix&quot;</span>: <span class=\"hljs-string\">&quot;```jsx&quot;</span>,\n <span class=\"hljs-string\">&quot;body&quot;</span>: [\n  <span class=\"hljs-string\">&quot;```jsx&quot;</span>,\n  <span class=\"hljs-string\">&quot;$1&quot;</span>,\n  <span class=\"hljs-string\">&quot;```&quot;</span>,\n ],\n <span class=\"hljs-string\">&quot;description&quot;</span>: <span class=\"hljs-string\">&quot;jsx代码片段&quot;</span>\n&#125;,</code></pre></div>\n\n<p>配置添加后，markdown 中输入 ```js 并没有快捷提示 还需要在 setting.json 中添加如下配置</p>\n<p>setting.json 打开位置：打开vs code的设置，文件 –&gt; 首选项 –&gt; 设置 –&gt; 打开设置（在设置的右上角）</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-string\">&quot;[markdown]&quot;</span>:&#123;\n    <span class=\"hljs-string\">&quot;editor.quickSuggestions&quot;</span>: <span class=\"hljs-literal\">true</span>\n&#125;</code></pre></div>\n","site":{"data":{}},"wordcount":898,"excerpt":"","more":"<h2 id=\"console-log-快捷输入\"><a href=\"#console-log-快捷输入\" class=\"headerlink\" title=\"console.log 快捷输入\"></a>console.log 快捷输入</h2><p>打开 <code>文件 --&gt; 首选项 --&gt; 用户片段</code></p>\n<p>在输入框中输入markdown，可以找到markdown.json的代码片段配置 放开 example 注释</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-string\">&quot;Print to console&quot;</span>: &#123;\n <span class=\"hljs-string\">&quot;prefix&quot;</span>: <span class=\"hljs-string\">&quot;log&quot;</span>,\n <span class=\"hljs-string\">&quot;body&quot;</span>: [\n  <span class=\"hljs-string\">&quot;console.log(&#x27;$1&#x27;);&quot;</span>,\n  <span class=\"hljs-string\">&quot;$2&quot;</span>\n ],\n <span class=\"hljs-string\">&quot;description&quot;</span>: <span class=\"hljs-string\">&quot;Log output to console&quot;</span>\n&#125;,</code></pre>\n\n<h2 id=\"markdown-代码段快捷输入\"><a href=\"#markdown-代码段快捷输入\" class=\"headerlink\" title=\"markdown 代码段快捷输入\"></a>markdown 代码段快捷输入</h2><p>同上 在 markdown.json 中继续配置如下</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-string\">&quot;Print to ```js&quot;</span>: &#123;\n <span class=\"hljs-string\">&quot;prefix&quot;</span>: <span class=\"hljs-string\">&quot;```js&quot;</span>,\n <span class=\"hljs-string\">&quot;body&quot;</span>: [\n  <span class=\"hljs-string\">&quot;```js&quot;</span>,\n  <span class=\"hljs-string\">&quot;$1&quot;</span>,\n  <span class=\"hljs-string\">&quot;```&quot;</span>,\n ],\n <span class=\"hljs-string\">&quot;description&quot;</span>: <span class=\"hljs-string\">&quot;js代码片段&quot;</span>\n&#125;,\n<span class=\"hljs-string\">&quot;Print to ```jsx&quot;</span>: &#123;\n <span class=\"hljs-string\">&quot;prefix&quot;</span>: <span class=\"hljs-string\">&quot;```jsx&quot;</span>,\n <span class=\"hljs-string\">&quot;body&quot;</span>: [\n  <span class=\"hljs-string\">&quot;```jsx&quot;</span>,\n  <span class=\"hljs-string\">&quot;$1&quot;</span>,\n  <span class=\"hljs-string\">&quot;```&quot;</span>,\n ],\n <span class=\"hljs-string\">&quot;description&quot;</span>: <span class=\"hljs-string\">&quot;jsx代码片段&quot;</span>\n&#125;,</code></pre>\n\n<p>配置添加后，markdown 中输入 ```js 并没有快捷提示 还需要在 setting.json 中添加如下配置</p>\n<p>setting.json 打开位置：打开vs code的设置，文件 –&gt; 首选项 –&gt; 设置 –&gt; 打开设置（在设置的右上角）</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-string\">&quot;[markdown]&quot;</span>:&#123;\n    <span class=\"hljs-string\">&quot;editor.quickSuggestions&quot;</span>: <span class=\"hljs-literal\">true</span>\n&#125;</code></pre>\n"},{"title":"日常使用的容器镜像操作命令","index_img":"/img/2021-12-01-1.png","abbrlink":"25d325e2","date":"2021-12-01T02:25:42.000Z","_content":"\n构建镜像\n\n```sh\ndocker build -t user-manage:v1.0 .\n```\n\n运行容器镜像\n\n```sh\ndocker run --rm -d -p 8089:80 --name k8s-installer-test -v ~/gitlab/k8s-installer-ui/dist:/usr/share/nginx/html -v ~/default.conf:/etc/nginx/conf.d/default.conf nginx\n\n# --rm container 停止后删除 container\n# -d 后台运行容器\n# -p 80:80 前者本地端口，后者是 dockerfile 暴露端口\n# --name 指定容器名称\n# -v 挂载替换容器内指定文件\n```\n\n将镜像打成 tar 包\n\n```sh\ndocker save user-manage:latest > ~/Downloads/usermanage.tar\n```\n\n上传 tar 包到指定服务器\n\n```sh\nscp ~/Downloads/usermanage.tar root@172.16.60.99:/tmp/\n```\n\n从服务器下载 tar 包到本地\n\n```sh\nscp -r caas-aio:~/tmp/origin-web-console.tar ~/Downloads/test/\n```\n\n从 tar 包加载镜像\n\n```sh\ndocker load < /tmp/usermanage.tar\n# 可以查看到\ndocker images \n```\n\n给镜像重新打 tag\n\n```sh\ndocker tag user-manage:latest docker.io/user-manage:latest\n```\n\n进入容器内部\n\n```sh\n# 镜像 id\ndocker exec -it 73bee1a2a355 /bin/bash\n# 或者 /bin/sh\n```\n\n查看镜像元数据，常用来查看 commit-id\n\n```sh\ndocker inspect <image-id>\n```\n\n","source":"_posts/2.日常使用的容器镜像操作命令.md","raw":"---\ntitle: 日常使用的容器镜像操作命令\nindex_img: /img/2021-12-01-1.png\nabbrlink: 25d325e2\ndate: 2021-12-01 10:25:42\ntags:\ncategories:\n---\n\n构建镜像\n\n```sh\ndocker build -t user-manage:v1.0 .\n```\n\n运行容器镜像\n\n```sh\ndocker run --rm -d -p 8089:80 --name k8s-installer-test -v ~/gitlab/k8s-installer-ui/dist:/usr/share/nginx/html -v ~/default.conf:/etc/nginx/conf.d/default.conf nginx\n\n# --rm container 停止后删除 container\n# -d 后台运行容器\n# -p 80:80 前者本地端口，后者是 dockerfile 暴露端口\n# --name 指定容器名称\n# -v 挂载替换容器内指定文件\n```\n\n将镜像打成 tar 包\n\n```sh\ndocker save user-manage:latest > ~/Downloads/usermanage.tar\n```\n\n上传 tar 包到指定服务器\n\n```sh\nscp ~/Downloads/usermanage.tar root@172.16.60.99:/tmp/\n```\n\n从服务器下载 tar 包到本地\n\n```sh\nscp -r caas-aio:~/tmp/origin-web-console.tar ~/Downloads/test/\n```\n\n从 tar 包加载镜像\n\n```sh\ndocker load < /tmp/usermanage.tar\n# 可以查看到\ndocker images \n```\n\n给镜像重新打 tag\n\n```sh\ndocker tag user-manage:latest docker.io/user-manage:latest\n```\n\n进入容器内部\n\n```sh\n# 镜像 id\ndocker exec -it 73bee1a2a355 /bin/bash\n# 或者 /bin/sh\n```\n\n查看镜像元数据，常用来查看 commit-id\n\n```sh\ndocker inspect <image-id>\n```\n\n","slug":"2-日常使用的容器镜像操作命令","published":1,"updated":"2022-03-01T02:56:12.118Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k5bv7c001h0h3l2wrs2gkp","content":"<p>构建镜像</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">docker build -t user-manage:v1.0 .</code></pre></div>\n\n<p>运行容器镜像</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">docker run --rm -d -p 8089:80 --name k8s-installer-test -v ~/gitlab/k8s-installer-ui/dist:/usr/share/nginx/html -v ~/default.conf:/etc/nginx/conf.d/default.conf nginx\n\n<span class=\"hljs-comment\"># --rm container 停止后删除 container</span>\n<span class=\"hljs-comment\"># -d 后台运行容器</span>\n<span class=\"hljs-comment\"># -p 80:80 前者本地端口，后者是 dockerfile 暴露端口</span>\n<span class=\"hljs-comment\"># --name 指定容器名称</span>\n<span class=\"hljs-comment\"># -v 挂载替换容器内指定文件</span></code></pre></div>\n\n<p>将镜像打成 tar 包</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">docker save user-manage:latest &gt; ~/Downloads/usermanage.tar</code></pre></div>\n\n<p>上传 tar 包到指定服务器</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">scp ~/Downloads/usermanage.tar root@172.16.60.99:/tmp/</code></pre></div>\n\n<p>从服务器下载 tar 包到本地</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">scp -r caas-aio:~/tmp/origin-web-console.tar ~/Downloads/<span class=\"hljs-built_in\">test</span>/</code></pre></div>\n\n<p>从 tar 包加载镜像</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">docker load &lt; /tmp/usermanage.tar\n<span class=\"hljs-comment\"># 可以查看到</span>\ndocker images</code></pre></div>\n\n<p>给镜像重新打 tag</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">docker tag user-manage:latest docker.io/user-manage:latest</code></pre></div>\n\n<p>进入容器内部</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># 镜像 id</span>\ndocker <span class=\"hljs-built_in\">exec</span> -it 73bee1a2a355 /bin/bash\n<span class=\"hljs-comment\"># 或者 /bin/sh</span></code></pre></div>\n\n<p>查看镜像元数据，常用来查看 commit-id</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">docker inspect &lt;image-id&gt;</code></pre></div>\n\n","site":{"data":{}},"wordcount":723,"excerpt":"","more":"<p>构建镜像</p>\n<pre><code class=\"hljs sh\">docker build -t user-manage:v1.0 .</code></pre>\n\n<p>运行容器镜像</p>\n<pre><code class=\"hljs sh\">docker run --rm -d -p 8089:80 --name k8s-installer-test -v ~/gitlab/k8s-installer-ui/dist:/usr/share/nginx/html -v ~/default.conf:/etc/nginx/conf.d/default.conf nginx\n\n<span class=\"hljs-comment\"># --rm container 停止后删除 container</span>\n<span class=\"hljs-comment\"># -d 后台运行容器</span>\n<span class=\"hljs-comment\"># -p 80:80 前者本地端口，后者是 dockerfile 暴露端口</span>\n<span class=\"hljs-comment\"># --name 指定容器名称</span>\n<span class=\"hljs-comment\"># -v 挂载替换容器内指定文件</span></code></pre>\n\n<p>将镜像打成 tar 包</p>\n<pre><code class=\"hljs sh\">docker save user-manage:latest &gt; ~/Downloads/usermanage.tar</code></pre>\n\n<p>上传 tar 包到指定服务器</p>\n<pre><code class=\"hljs sh\">scp ~/Downloads/usermanage.tar root@172.16.60.99:/tmp/</code></pre>\n\n<p>从服务器下载 tar 包到本地</p>\n<pre><code class=\"hljs sh\">scp -r caas-aio:~/tmp/origin-web-console.tar ~/Downloads/<span class=\"hljs-built_in\">test</span>/</code></pre>\n\n<p>从 tar 包加载镜像</p>\n<pre><code class=\"hljs sh\">docker load &lt; /tmp/usermanage.tar\n<span class=\"hljs-comment\"># 可以查看到</span>\ndocker images</code></pre>\n\n<p>给镜像重新打 tag</p>\n<pre><code class=\"hljs sh\">docker tag user-manage:latest docker.io/user-manage:latest</code></pre>\n\n<p>进入容器内部</p>\n<pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># 镜像 id</span>\ndocker <span class=\"hljs-built_in\">exec</span> -it 73bee1a2a355 /bin/bash\n<span class=\"hljs-comment\"># 或者 /bin/sh</span></code></pre>\n\n<p>查看镜像元数据，常用来查看 commit-id</p>\n<pre><code class=\"hljs sh\">docker inspect &lt;image-id&gt;</code></pre>\n\n"},{"title":"useState 引用类型数据更新不触发重新渲染问题","index_img":"/img/2022-01-14-1.png","abbrlink":"b195fb80","date":"2022-01-14T02:24:50.000Z","_content":"\n## useState 函数式更新\n\n与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。\n\n```jsx\nconst [state, setState] = useState({});\nsetState((prevState) => {\n  // 也可以使用 Object.assign\n  return { ...prevState, ...updatedValues };\n});\n```\n\n## 引用类型 state 更新\n\n经常 state 数据不是简单数据类型(值类型)，而是数组、对象之类(引用类型).而 React 组件的更新机制对 state 只进行浅对比，也就是更新某个复杂类型数据时只要它的引用地址没变，那就不会重新渲染组件。\n\n尤其当被更新的引用类型数据需要依赖之前的数据时，容易踩坑,不触发更新。更新复杂 state 的时候必须传给它一个全新的对象，而不是复制了它引用地址再修改的对象。\n\n两种解决办法：\n\n1. 结合展开运算符返回一个新对象\n\n   ```jsx\n   function nextValue(preValue) {\n     let ipValue = Number.parseInt(newVal, 10);\n\n     if (Number.isNaN(ipValue)) {\n       ipValue = undefined;\n     }\n     if (ipValue < 0) {\n       ipValue = 0;\n     }\n     if (ipValue > 255) {\n       ipValue = 255;\n     }\n     preValue[index] = ipValue; //这里数据引用地址的值同样被修改\n     return [...preValue]; // 数据最外层的引用地址不同即可触发组件更新\n   }\n\n   setValue((preValue) => nextValue(preValue));\n   ```\n\n1. 深拷贝对象，用全新的副本更新数据。\n\n   ```jsx\n   function nextValue(preValue) {\n     const newValue = _.cloneDeep(preValue);\n     let ipValue = Number.parseInt(newVal, 10);\n\n     if (Number.isNaN(ipValue)) {\n       ipValue = undefined;\n     }\n     if (ipValue < 0) {\n       ipValue = 0;\n     }\n     if (ipValue > 255) {\n       ipValue = 255;\n     }\n     newValue[index] = ipValue; //这里数据引用地址的值同样被修改\n     return newValue; // 数据最外层的引用地址不同即可触发组件更新\n   }\n\n   setValue((preValue) => nextValue(preValue));\n   ```\n","source":"_posts/4.useState 引用类型数据更新不触发重新渲染问题.md","raw":"---\ntitle: useState 引用类型数据更新不触发重新渲染问题\ntags: HooK\nindex_img: /img/2022-01-14-1.png\ncategories: React\nabbrlink: b195fb80\ndate: 2022-01-14 10:24:50\n---\n\n## useState 函数式更新\n\n与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。\n\n```jsx\nconst [state, setState] = useState({});\nsetState((prevState) => {\n  // 也可以使用 Object.assign\n  return { ...prevState, ...updatedValues };\n});\n```\n\n## 引用类型 state 更新\n\n经常 state 数据不是简单数据类型(值类型)，而是数组、对象之类(引用类型).而 React 组件的更新机制对 state 只进行浅对比，也就是更新某个复杂类型数据时只要它的引用地址没变，那就不会重新渲染组件。\n\n尤其当被更新的引用类型数据需要依赖之前的数据时，容易踩坑,不触发更新。更新复杂 state 的时候必须传给它一个全新的对象，而不是复制了它引用地址再修改的对象。\n\n两种解决办法：\n\n1. 结合展开运算符返回一个新对象\n\n   ```jsx\n   function nextValue(preValue) {\n     let ipValue = Number.parseInt(newVal, 10);\n\n     if (Number.isNaN(ipValue)) {\n       ipValue = undefined;\n     }\n     if (ipValue < 0) {\n       ipValue = 0;\n     }\n     if (ipValue > 255) {\n       ipValue = 255;\n     }\n     preValue[index] = ipValue; //这里数据引用地址的值同样被修改\n     return [...preValue]; // 数据最外层的引用地址不同即可触发组件更新\n   }\n\n   setValue((preValue) => nextValue(preValue));\n   ```\n\n1. 深拷贝对象，用全新的副本更新数据。\n\n   ```jsx\n   function nextValue(preValue) {\n     const newValue = _.cloneDeep(preValue);\n     let ipValue = Number.parseInt(newVal, 10);\n\n     if (Number.isNaN(ipValue)) {\n       ipValue = undefined;\n     }\n     if (ipValue < 0) {\n       ipValue = 0;\n     }\n     if (ipValue > 255) {\n       ipValue = 255;\n     }\n     newValue[index] = ipValue; //这里数据引用地址的值同样被修改\n     return newValue; // 数据最外层的引用地址不同即可触发组件更新\n   }\n\n   setValue((preValue) => nextValue(preValue));\n   ```\n","slug":"4-useState-引用类型数据更新不触发重新渲染问题","published":1,"updated":"2022-03-01T02:56:12.115Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k5bv7c001k0h3l3ywkbvao","content":"<h2 id=\"useState-函数式更新\"><a href=\"#useState-函数式更新\" class=\"headerlink\" title=\"useState 函数式更新\"></a>useState 函数式更新</h2><p>与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> [state, setState] = useState(&#123;&#125;);\nsetState(<span class=\"hljs-function\">(<span class=\"hljs-params\">prevState</span>) =&gt;</span> &#123;\n  <span class=\"hljs-comment\">// 也可以使用 Object.assign</span>\n  <span class=\"hljs-keyword\">return</span> &#123; ...prevState, ...updatedValues &#125;;\n&#125;);</code></pre></div>\n\n<h2 id=\"引用类型-state-更新\"><a href=\"#引用类型-state-更新\" class=\"headerlink\" title=\"引用类型 state 更新\"></a>引用类型 state 更新</h2><p>经常 state 数据不是简单数据类型(值类型)，而是数组、对象之类(引用类型).而 React 组件的更新机制对 state 只进行浅对比，也就是更新某个复杂类型数据时只要它的引用地址没变，那就不会重新渲染组件。</p>\n<p>尤其当被更新的引用类型数据需要依赖之前的数据时，容易踩坑,不触发更新。更新复杂 state 的时候必须传给它一个全新的对象，而不是复制了它引用地址再修改的对象。</p>\n<p>两种解决办法：</p>\n<ol>\n<li><p>结合展开运算符返回一个新对象</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">nextValue</span>(<span class=\"hljs-params\">preValue</span>) </span>&#123;\n  <span class=\"hljs-keyword\">let</span> ipValue = <span class=\"hljs-built_in\">Number</span>.parseInt(newVal, <span class=\"hljs-number\">10</span>);\n\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Number</span>.isNaN(ipValue)) &#123;\n    ipValue = <span class=\"hljs-literal\">undefined</span>;\n  &#125;\n  <span class=\"hljs-keyword\">if</span> (ipValue &lt; <span class=\"hljs-number\">0</span>) &#123;\n    ipValue = <span class=\"hljs-number\">0</span>;\n  &#125;\n  <span class=\"hljs-keyword\">if</span> (ipValue &gt; <span class=\"hljs-number\">255</span>) &#123;\n    ipValue = <span class=\"hljs-number\">255</span>;\n  &#125;\n  preValue[index] = ipValue; <span class=\"hljs-comment\">//这里数据引用地址的值同样被修改</span>\n  <span class=\"hljs-keyword\">return</span> [...preValue]; <span class=\"hljs-comment\">// 数据最外层的引用地址不同即可触发组件更新</span>\n&#125;\n\nsetValue(<span class=\"hljs-function\">(<span class=\"hljs-params\">preValue</span>) =&gt;</span> nextValue(preValue));</code></pre></div></li>\n<li><p>深拷贝对象，用全新的副本更新数据。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">nextValue</span>(<span class=\"hljs-params\">preValue</span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> newValue = _.cloneDeep(preValue);\n  <span class=\"hljs-keyword\">let</span> ipValue = <span class=\"hljs-built_in\">Number</span>.parseInt(newVal, <span class=\"hljs-number\">10</span>);\n\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Number</span>.isNaN(ipValue)) &#123;\n    ipValue = <span class=\"hljs-literal\">undefined</span>;\n  &#125;\n  <span class=\"hljs-keyword\">if</span> (ipValue &lt; <span class=\"hljs-number\">0</span>) &#123;\n    ipValue = <span class=\"hljs-number\">0</span>;\n  &#125;\n  <span class=\"hljs-keyword\">if</span> (ipValue &gt; <span class=\"hljs-number\">255</span>) &#123;\n    ipValue = <span class=\"hljs-number\">255</span>;\n  &#125;\n  newValue[index] = ipValue; <span class=\"hljs-comment\">//这里数据引用地址的值同样被修改</span>\n  <span class=\"hljs-keyword\">return</span> newValue; <span class=\"hljs-comment\">// 数据最外层的引用地址不同即可触发组件更新</span>\n&#125;\n\nsetValue(<span class=\"hljs-function\">(<span class=\"hljs-params\">preValue</span>) =&gt;</span> nextValue(preValue));</code></pre></div></li>\n</ol>\n","site":{"data":{}},"wordcount":1182,"excerpt":"","more":"<h2 id=\"useState-函数式更新\"><a href=\"#useState-函数式更新\" class=\"headerlink\" title=\"useState 函数式更新\"></a>useState 函数式更新</h2><p>与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> [state, setState] = useState(&#123;&#125;);\nsetState(<span class=\"hljs-function\">(<span class=\"hljs-params\">prevState</span>) =&gt;</span> &#123;\n  <span class=\"hljs-comment\">// 也可以使用 Object.assign</span>\n  <span class=\"hljs-keyword\">return</span> &#123; ...prevState, ...updatedValues &#125;;\n&#125;);</code></pre>\n\n<h2 id=\"引用类型-state-更新\"><a href=\"#引用类型-state-更新\" class=\"headerlink\" title=\"引用类型 state 更新\"></a>引用类型 state 更新</h2><p>经常 state 数据不是简单数据类型(值类型)，而是数组、对象之类(引用类型).而 React 组件的更新机制对 state 只进行浅对比，也就是更新某个复杂类型数据时只要它的引用地址没变，那就不会重新渲染组件。</p>\n<p>尤其当被更新的引用类型数据需要依赖之前的数据时，容易踩坑,不触发更新。更新复杂 state 的时候必须传给它一个全新的对象，而不是复制了它引用地址再修改的对象。</p>\n<p>两种解决办法：</p>\n<ol>\n<li><p>结合展开运算符返回一个新对象</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">nextValue</span>(<span class=\"hljs-params\">preValue</span>) </span>&#123;\n  <span class=\"hljs-keyword\">let</span> ipValue = <span class=\"hljs-built_in\">Number</span>.parseInt(newVal, <span class=\"hljs-number\">10</span>);\n\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Number</span>.isNaN(ipValue)) &#123;\n    ipValue = <span class=\"hljs-literal\">undefined</span>;\n  &#125;\n  <span class=\"hljs-keyword\">if</span> (ipValue &lt; <span class=\"hljs-number\">0</span>) &#123;\n    ipValue = <span class=\"hljs-number\">0</span>;\n  &#125;\n  <span class=\"hljs-keyword\">if</span> (ipValue &gt; <span class=\"hljs-number\">255</span>) &#123;\n    ipValue = <span class=\"hljs-number\">255</span>;\n  &#125;\n  preValue[index] = ipValue; <span class=\"hljs-comment\">//这里数据引用地址的值同样被修改</span>\n  <span class=\"hljs-keyword\">return</span> [...preValue]; <span class=\"hljs-comment\">// 数据最外层的引用地址不同即可触发组件更新</span>\n&#125;\n\nsetValue(<span class=\"hljs-function\">(<span class=\"hljs-params\">preValue</span>) =&gt;</span> nextValue(preValue));</code></pre></li>\n<li><p>深拷贝对象，用全新的副本更新数据。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">nextValue</span>(<span class=\"hljs-params\">preValue</span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> newValue = _.cloneDeep(preValue);\n  <span class=\"hljs-keyword\">let</span> ipValue = <span class=\"hljs-built_in\">Number</span>.parseInt(newVal, <span class=\"hljs-number\">10</span>);\n\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Number</span>.isNaN(ipValue)) &#123;\n    ipValue = <span class=\"hljs-literal\">undefined</span>;\n  &#125;\n  <span class=\"hljs-keyword\">if</span> (ipValue &lt; <span class=\"hljs-number\">0</span>) &#123;\n    ipValue = <span class=\"hljs-number\">0</span>;\n  &#125;\n  <span class=\"hljs-keyword\">if</span> (ipValue &gt; <span class=\"hljs-number\">255</span>) &#123;\n    ipValue = <span class=\"hljs-number\">255</span>;\n  &#125;\n  newValue[index] = ipValue; <span class=\"hljs-comment\">//这里数据引用地址的值同样被修改</span>\n  <span class=\"hljs-keyword\">return</span> newValue; <span class=\"hljs-comment\">// 数据最外层的引用地址不同即可触发组件更新</span>\n&#125;\n\nsetValue(<span class=\"hljs-function\">(<span class=\"hljs-params\">preValue</span>) =&gt;</span> nextValue(preValue));</code></pre></li>\n</ol>\n"},{"title":"map 到底改不改变原数组","index_img":"/img/2022-01-14-3.png","abbrlink":"d177e434","date":"2022-01-14T05:53:44.000Z","_content":"\n\n一般认为 map 不会对原数组进行修改，但事实并不是如此。\n\n## 数组内为基础类型数据时,原数组不变\n\n```js\nlet array = [1, 2, 3, 4, 5];\nlet newArray = array.map((item) => item * 2);\nconsole.log(array); // [1,2,3,4,5]\nconsole.log(newArray); //[2, 4, 6, 8, 10]\n```\n\n## 数据内是引用类型数据时，注意写法\n\n1. item 上直接修改，改变原数组\n\n   ```js\n   let array = [\n     { name: \"Anna\", age: 16 },\n     { name: \"James\", age: 18 }\n   ];\n   let newArray = array.map((item) => {\n     item.like = \"eat\";\n     return item;\n   });\n   console.log(array); // [{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}]\n   console.log(newArray); //[{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}]\n   ```\n\n1. 开辟新的引用地址, 不改变原数组\n\n   ```js\n   let array = [\n     { name: \"Anna\", age: 16 },\n     { name: \"James\", age: 18 }\n   ];\n   let newArray = array.map((item) => {\n     const obj = { ...item, like: \"eat\" };\n     return obj;\n   });\n   console.log(array); // [{ name: 'Anna', age: 16},{ name: 'James', age: 18}]\n   console.log(newArray); //[{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}]\n   ```\n","source":"_posts/6.map 到底改不改变原数组.md","raw":"---\ntitle: map 到底改不改变原数组\nindex_img: /img/2022-01-14-3.png\ntags: map\ncategories: JS\nabbrlink: d177e434\ndate: 2022-01-14 13:53:44\n---\n\n\n一般认为 map 不会对原数组进行修改，但事实并不是如此。\n\n## 数组内为基础类型数据时,原数组不变\n\n```js\nlet array = [1, 2, 3, 4, 5];\nlet newArray = array.map((item) => item * 2);\nconsole.log(array); // [1,2,3,4,5]\nconsole.log(newArray); //[2, 4, 6, 8, 10]\n```\n\n## 数据内是引用类型数据时，注意写法\n\n1. item 上直接修改，改变原数组\n\n   ```js\n   let array = [\n     { name: \"Anna\", age: 16 },\n     { name: \"James\", age: 18 }\n   ];\n   let newArray = array.map((item) => {\n     item.like = \"eat\";\n     return item;\n   });\n   console.log(array); // [{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}]\n   console.log(newArray); //[{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}]\n   ```\n\n1. 开辟新的引用地址, 不改变原数组\n\n   ```js\n   let array = [\n     { name: \"Anna\", age: 16 },\n     { name: \"James\", age: 18 }\n   ];\n   let newArray = array.map((item) => {\n     const obj = { ...item, like: \"eat\" };\n     return obj;\n   });\n   console.log(array); // [{ name: 'Anna', age: 16},{ name: 'James', age: 18}]\n   console.log(newArray); //[{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}]\n   ```\n","slug":"6-map-到底改不改变原数组","published":1,"updated":"2022-03-01T02:56:12.119Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k5bv7d001m0h3lg87d6g45","content":"<p>一般认为 map 不会对原数组进行修改，但事实并不是如此。</p>\n<h2 id=\"数组内为基础类型数据时-原数组不变\"><a href=\"#数组内为基础类型数据时-原数组不变\" class=\"headerlink\" title=\"数组内为基础类型数据时,原数组不变\"></a>数组内为基础类型数据时,原数组不变</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> array = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];\n<span class=\"hljs-keyword\">let</span> newArray = array.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> item * <span class=\"hljs-number\">2</span>);\n<span class=\"hljs-built_in\">console</span>.log(array); <span class=\"hljs-comment\">// [1,2,3,4,5]</span>\n<span class=\"hljs-built_in\">console</span>.log(newArray); <span class=\"hljs-comment\">//[2, 4, 6, 8, 10]</span></code></pre></div>\n\n<h2 id=\"数据内是引用类型数据时，注意写法\"><a href=\"#数据内是引用类型数据时，注意写法\" class=\"headerlink\" title=\"数据内是引用类型数据时，注意写法\"></a>数据内是引用类型数据时，注意写法</h2><ol>\n<li><p>item 上直接修改，改变原数组</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> array = [\n  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Anna&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">16</span> &#125;,\n  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;James&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span> &#125;\n];\n<span class=\"hljs-keyword\">let</span> newArray = array.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> &#123;\n  item.like = <span class=\"hljs-string\">&quot;eat&quot;</span>;\n  <span class=\"hljs-keyword\">return</span> item;\n&#125;);\n<span class=\"hljs-built_in\">console</span>.log(array); <span class=\"hljs-comment\">// [&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span>\n<span class=\"hljs-built_in\">console</span>.log(newArray); <span class=\"hljs-comment\">//[&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span></code></pre></div></li>\n<li><p>开辟新的引用地址, 不改变原数组</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> array = [\n  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Anna&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">16</span> &#125;,\n  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;James&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span> &#125;\n];\n<span class=\"hljs-keyword\">let</span> newArray = array.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> obj = &#123; ...item, <span class=\"hljs-attr\">like</span>: <span class=\"hljs-string\">&quot;eat&quot;</span> &#125;;\n  <span class=\"hljs-keyword\">return</span> obj;\n&#125;);\n<span class=\"hljs-built_in\">console</span>.log(array); <span class=\"hljs-comment\">// [&#123; name: &#x27;Anna&#x27;, age: 16&#125;,&#123; name: &#x27;James&#x27;, age: 18&#125;]</span>\n<span class=\"hljs-built_in\">console</span>.log(newArray); <span class=\"hljs-comment\">//[&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span></code></pre></div></li>\n</ol>\n","site":{"data":{}},"wordcount":1151,"excerpt":"","more":"<p>一般认为 map 不会对原数组进行修改，但事实并不是如此。</p>\n<h2 id=\"数组内为基础类型数据时-原数组不变\"><a href=\"#数组内为基础类型数据时-原数组不变\" class=\"headerlink\" title=\"数组内为基础类型数据时,原数组不变\"></a>数组内为基础类型数据时,原数组不变</h2><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> array = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];\n<span class=\"hljs-keyword\">let</span> newArray = array.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> item * <span class=\"hljs-number\">2</span>);\n<span class=\"hljs-built_in\">console</span>.log(array); <span class=\"hljs-comment\">// [1,2,3,4,5]</span>\n<span class=\"hljs-built_in\">console</span>.log(newArray); <span class=\"hljs-comment\">//[2, 4, 6, 8, 10]</span></code></pre>\n\n<h2 id=\"数据内是引用类型数据时，注意写法\"><a href=\"#数据内是引用类型数据时，注意写法\" class=\"headerlink\" title=\"数据内是引用类型数据时，注意写法\"></a>数据内是引用类型数据时，注意写法</h2><ol>\n<li><p>item 上直接修改，改变原数组</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> array = [\n  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Anna&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">16</span> &#125;,\n  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;James&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span> &#125;\n];\n<span class=\"hljs-keyword\">let</span> newArray = array.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> &#123;\n  item.like = <span class=\"hljs-string\">&quot;eat&quot;</span>;\n  <span class=\"hljs-keyword\">return</span> item;\n&#125;);\n<span class=\"hljs-built_in\">console</span>.log(array); <span class=\"hljs-comment\">// [&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span>\n<span class=\"hljs-built_in\">console</span>.log(newArray); <span class=\"hljs-comment\">//[&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span></code></pre></li>\n<li><p>开辟新的引用地址, 不改变原数组</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> array = [\n  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Anna&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">16</span> &#125;,\n  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;James&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span> &#125;\n];\n<span class=\"hljs-keyword\">let</span> newArray = array.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> obj = &#123; ...item, <span class=\"hljs-attr\">like</span>: <span class=\"hljs-string\">&quot;eat&quot;</span> &#125;;\n  <span class=\"hljs-keyword\">return</span> obj;\n&#125;);\n<span class=\"hljs-built_in\">console</span>.log(array); <span class=\"hljs-comment\">// [&#123; name: &#x27;Anna&#x27;, age: 16&#125;,&#123; name: &#x27;James&#x27;, age: 18&#125;]</span>\n<span class=\"hljs-built_in\">console</span>.log(newArray); <span class=\"hljs-comment\">//[&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span></code></pre></li>\n</ol>\n"},{"title":"前端工程师面试题","index_img":"/img/2022-02-16-1.jpeg","abbrlink":"a18c0ac9","date":"2022-02-15T02:39:21.000Z","_content":"\n## JS\n\n1、请你讲一下闭包?\n\n> 简单：闭包是有权限访问其他函数作用域内的变量的一个函数。\n>\n> 完整：由于在JS中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之回收，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数——也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后作用域内的值也不会被销毁。\n\n- 闭包解决了什么？\n\n> 由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。以平时使用的Ajax成功回调为例，这里其实就是个闭包，由于上述的特性，回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。开发者不用去写钩子函数来操作上级函数作用域内部的变量了。\n\n- 闭包有哪些应用场景?\n\n> 闭包随处可见，一个Ajax请求的成功回调，一个事件绑定的回调方法，一个setTimeout的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。\n\n- react hooks 中的 闭包陷阱问题如何解决？\n\n不管在这个组件中的其他地方使用 setCount 将 count 设置为任何值，还是设置多少次，打印的都是1\n\n```jsx\nfunction App(){\n    const [count, setCount] = useState(1);\n    useEffect(()=>{\n        setInterval(()=>{\n            console.log(count)\n        }, 1000)\n    }, [])\n}\n```\n\nuseRef\n\nuseState 更新值时传入回调函数\n\n2、介绍一下 JS 里面的原型？\n\n> 每个对象都有一个 prototype 属性，就是原型，是一个对象，叫原型对象。\n\n- 原型的作用是什么？\n\n > 共享方法\n\n- 原型中this的指向是什么？\n\n> 原型中this的指向是实例。\n\n- 说一下平时开发使用到 prototype 的例子？\n\n3、如何理解 es6 class 中 constructor 方法？ 和 super的作用？\n\n> constructor 方法是类的构造函数。\n通过 new 命令创建对象实例时，自动调用该方法。\nconstructor 内定义的方法是 实例方法；class 内直接定义的方法是原型方法。\n\n- super 的作用？\n\n子类是没有自己的 this 对象的，它只能继承自父类的 this 对象，然后对其进行加工，而super( )就是将父类中的this对象继承给子类的。没有 super，子类就得不到 this 对象。\n\n- 为什么要传入 props？\n\n```jsx\nclass Component {\n  constructor(props) {\n    this.props = props;\n    // ...\n  }\n}\n```\n\n确保了 this.props 在构造函数执行完毕之前已被赋值。\n\n4、eventloop\n\n浏览器或node 端 js 单线程运行时不会阻塞的一种机制。\n\n任务分为宏任务和微任务；\n\n宏任务：script全部代码、setTimeout、setInterval、I/O、UI Rendering。\n微任务：Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver\n\n- 浏览器中的 event loop\n\nJS 中有一个主线程和一个调用栈（执行栈），所有的任务都会被放到调用栈中等待主线程执行。\n\nJS 调用栈后进先出原则，当函数执行的时候，会被添加到栈顶部，当执行完后，会被从栈顶移出，直到栈内被清空。\n\nJS 任务分为同步任务和异步任务。同步任务在调用栈中按照顺序等待主线程依次执行。异步任务会在异步任务有结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），读取到栈内等待主线程执行。\n\n任务队列：先进先出\n\n顺序：同步任务 =》微任务 =》 宏任务\n\n- 执行栈在执行完同步任务后，查看执行栈是否为空\n- 如果执行栈为空，就会去检查微任务(microTask)队列, 执行完微任务，再执行宏任务\n- 每个宏任务执行完后，都会再检查微任务队列是否为空，不为空，就按先进先出执行完微任务，设置微任务为 null，再执行宏任务。\n\nNode 中 event loop(待补充)\n\n## React\n\n1、介绍一下react diff 算法 的工作原理？\n\n- react 状态变化渲染页面时，不会马上对DOM节点进行操作，是先通过diff算法计算后，再对有变化的DOM节点进行操作。\n- diff算法就是更高效地通过对比新旧Virtual DOM来找出真正的Dom变化之处.\n- react中diff算法主要遵循三个层级的策略:tree层级、conponent 层级、element 层级\n- tree层级: DOM节点跨层级的操作不做优化，只会对相同层级的节点进行比较.只有删除、创建操作.新树中，R节点下没有了A，那么直接删除A，在D节点下创建A以及下属节点。\n- conponent层级:是同一个组件，则会继续往下diff运算，如果不是一个类的组件，那么直接删除这个组件下的所有子节点，创建新的\n- element层级:对于比较同一层级的节点们，每个节点在对应的层级用唯一的key作为标识.\n\n  - 3 种节点操作，分别为 INSERT_MARKUP(插入)、MOVE_EXISTING (移动)和 REMOVE_NODE (删除)\n  - 通过key可以准确地发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置\n  - 如果当前节点在新集合中的位置比老集合中的位置靠前的话，是不会影响后续节点操作的，这里这时候被动字节不用动\n  - 当ABCD节点比较完成后，diff过程还没完，还会整体遍历老集合中节点，看有没有没用到的节点，有的话，就删除\n\n由于dom节点的移动操作开销是比较昂贵的，没有key的情况下要比有key的性能更好\n\n```HTML\n1.加key\n<div key='1'>1</div>             <div key='1'>1</div>     \n<div key='2'>2</div>             <div key='3'>3</div>  \n<div key='3'>3</div>  ========>  <div key='2'>2</div>  \n<div key='4'>4</div>             <div key='5'>5</div>  \n<div key='5'>5</div>             <div key='6'>6</div>  \n操作：节点2移动至下标为2的位置，新增节点6至下标为4的位置，删除节点4。\n\n2.不加key\n<div>1</div>             <div>1</div>     \n<div>2</div>             <div>3</div>  \n<div>3</div>  ========>  <div>2</div>  \n<div>4</div>             <div>5</div>  \n<div>5</div>             <div>6</div> \n操作：修改第1个到第5个节点的innerText\n```\n\nVirtual DOM 工作过程有：\n\n    1. state 变化，生成新的 Virtual Dom\n    2. 比较 Virtual Dom 与之前 Virtual Dom 的异同\n    3. 生成差异对象\n    4. 遍历差异对象并更新真实 DOM\n\n- React diff 算法 和 vue diff 的相同点和不同点有哪些？\n\n不同点：\n\n- vue的列表比对，采用从两端到中间的比对方式，而react则采用从左到右依次比对的方式。当一个集合，只是把最后一个节点移动到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移动到第一个\n- vue比对节点，当节点元素类型相同，但是className不同，认为是不同类型元素，删除重建，而react会认为是同类型节点，只是修改节点属性\n\nVue Diff使用双向链表，边对比，边更新DOM。React主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。\n\n相同点：\n\n- 虚拟DOM在比较时只比较同一层级节点，复杂度都为 O(n)，降低了算法复杂度；\n- 都使用key比较是否是相同节点，都是为了尽可能的复用节点\n- 都是操作虚拟DOM，最小化操作真实DOM，提高性能（其实虚拟DOM的优势 并不是在于它操作DOM快）\n- 都是不要用 index作为 key\n\n2、react 里什么是高阶组件？使用高阶组件的场景？\n\n> 高阶组件(HOC)是接受一个组件并返回一个新组件的函数。\n\n2、React setState 怎么获取到更新后的值?异步函数中为什么 setState 会立即更新?\n\n3、useState 为什么不能放到条件语句里面?\n\nReact通过单链表来管理Hooks。\nupdate 阶段，每次调用 useState，链表就会执行 next 向后移动一步。如果将 useState 写在条件判断中，假设条件判断不成立，没有执行里面的 useState 方法，会导致接下来所有的 useState 的取值出现偏移，从而导致异常发生。\n\n4、说一下 useRef 有哪些用法？\n\n> useRef 除了获取 dom，另一个用法：\n保存数据，不造成 rerender\n想要保存数据，又不想触发函数的更新，该数据的更新不会造成组件 rerender\n\n5、什么情况下使用 useCallback ？\n子组件接收一个方法，避免子组件重复渲染\n\n- react 中只要父组件的 render 了，那么默认情况下就会触发子组的 render，react 提供了来避免这种重渲染的性能开销的一些方法：React.PureComponent、React.memo ，shouldComponentUpdate()\n- 使用 React.memo 避免子组件做没必要的渲染。\n- Reace.memo 只会对 props 做浅比较，也就是父组件重新 render 之后会传入 不同引用的方法 getList，浅比较之后不相等，导致子组件还是依然会渲染。\n- useCallback 缓存一个函数，当依赖没有改变的时候，会一直返回同一个引用\n\n6、useCallback 与 useMemo 作用用来缓存，两者的区别是什么？\n\n> useMemo 缓存值；useCallback 缓存函数\n\n注意不要滥用：\n\n经常用在以下两种场景（要保持引用相等；对于组件内部用到的 object、array、函数等，如果用在了其他 Hook 的依赖数组中，或者作为 props 传递给了下游组件，应该使用 useMemo/useCallback）\n\n7、react ssr 实现原理？react ssr 是在什么场景下做的？\n\nserver端接收到客户端的请求路由后，查找对应的数据，以props、context、store的形式注入组件中。然后基于react提供的API：renderToString将组件转换为html字符串输出到客户端。客户端使用该数据进行渲染，保证数据的一致性。\n\nReact SSR之所以能够实现，本质是虚拟 DOM的存在。判断环境是服务器环境，可以操作 JavaScript 对象，把虚拟 DOM 映射成字符串输出。判断环境是客户端环境，可以操作 JavaScript 对象，将虚拟 DOM 映射成真实 DOM ，完成页面挂载。\n\n8、 react 项目里做过哪些性能优化？\n\n代码层面：\n\n- 使用return null而不是CSS的display:none来控制节点的显示隐藏。保证同一时间页面的DOM节点尽可能的少。\n- props和state的数据尽可能简单明了，扁平化。\n- 不要使用数组下标作为key\n- 利用 shouldComponentUpdate 和 PureComponent 避免过多 render function\n- render里面尽量减少新建变量和bind函数，传递参数是尽量减少传递参数的数量。\n- 尽量将 props 和 state 扁平化，只传递 component 需要的 props（传得太多，或者层次传得太深，都会加重shouldComponentUpdate里面的数据比较负担），慎将 component 当作 props 传入\n\n代码体积优化:\n\n- 使用 babel-plugin-import 优化业务组件的引入，实现按需加载\n- 使用 生产版本\n- 使用 SplitChunksPlugin 拆分公共代码\n- 分析 CSS 和 JS 代码覆盖率\n- 优化 Webpack 中的库\n- 使用动态 import，懒加载 React 组件\n- 使用 webpack-bundle-analyzer 可视化 webpack 输出文件的大小\n- 使用动态 import，懒加载 React 组件\n- 使用 Tree Shaking & 教程 & Tree Shaking 优化\n\n9、有 用 过 lerna 吗 ？ 多 个 项 目 之 间 共 用 的 东 西 怎 么 共 享 ？\n\n10、使用 react 中，有没有遇到觉得比较难的点？是什么？\n\n11、使用 hooks 中遇到过哪些坑？为什么？\n\n- 不要在循环，条件或嵌套函数中调用Hook，必须始终在React函数的顶层使用Hook。这是因为React需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子函数。一旦在循环或条件分支语句中调用Hook，就容易导致调用顺序的不一致性。\n- 使用useState时候，使用push，pop，splice等直接更改数组对象的坑，应该采用析构方式.\n- 必包带来的坑,因为每次 render 都有一份新的状态，因此上述代码中的 setTimeout 使用产生了一个闭包，捕获了每次 render 后的 state，也就导致了输出了 0、1、2。如果你希望输出的内容是最新的 state 的话，可以通过 useRef 来保存 state。前文讲过 ref 在组件中只存在一份，无论何时使用它的引用都不会产生变化，因此可以来解决闭包引发的问题。\n\n## Vue\n\n1、Vue如何监听数组的变化？\n\n- 对象数据是怎么被监听的?\n\nvue2.x版本中，数据监听用 Object.defineProperty. 通过Object.defineProperty来劫持对象属性的setter和getter操作，并创建一个监听器，当数据发生变化的时候发出通知\n\n- 数组数据是怎么被监听的?\n\nVue.js是基于Object.defineProperty对对象实现“响应式化”，而对于数组，Vue.js提供的方法是重写push、pop、shift、unshift、splice、sort、reverse这七个数组方法.\n\n如果需要用数组下标修改数组并实现响应式数据变化，Vue.js提供了$set()及$remove()方法。\n\n1、Vue 组件 data 为什么必须是函数？\n\n> 因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染。\n所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。\n\n2、直接给一个数组项赋值，Vue 能检测到变化吗？\n\n由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。\n\n- Vue 不能检测到以下数组的变动:\n\n1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue\n\n```js\n// 解决办法\nvm.$set(vm.items, indexOfItem, newValue)\n```\n\n2.当你修改数组的长度时，例如：vm.items.length = newLength\n\n```js\n/ 解决办法\nvm.items.splice(newLength)\n```\n\n- 检测不到的原因是什么？\n\n当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。\n\n但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的 $set。\n\n3、vue2 中响应式（双向绑定）的原理？vue3 的原理？\nProxy 与 Object.defineProperty 的优劣对比?\n为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？\n\n> Proxy的优势如下:\nProxy 可以直接监听对象而非属性\nProxy 可以直接监听数组的变化\nProxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的\nProxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改\nProxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利\n>\n> Object.defineProperty 的优势如下:\n>\n> 兼容性好,支持 IE9\n\n4、vuex 的工作流程是怎么样？\n\n> Vuex有5个重要的属性，分别是 State、Getter、Mutation、Action、Module，由 view 层发起一个 Action 给 Mutation，在 Mutation 中修改状态，返回新的状态，通过 Getter暴露给 view层的组件或者页面，页面监测到状态改变于是更新页面。\n\n4、Vue 的初始化过程（new Vue(options)）都做了什么？\n\n处理组件配置项\n\n初始化根组件时进行了选项合并操作，将全局配置合并到根组件的局部配置上\n\n初始化每个子组件时做了一些性能优化，将组件配置对象上的一些深层次属性放到 vm.$options 选项中，以提高代码的执行效率\n\n初始化组件实例的关系属性，比如 $parent、$children、$root、$refs 等\n\n处理自定义事件\n\n调用 beforeCreate 钩子函数\n\n初始化组件的 inject 配置项，得到 ret[key] = val 形式的配置对象，然后对该配置对象进行响应式处理，并代理每个 key 到 vm 实例上\n\n数据响应式，处理 props、methods、data、computed、watch 等选项\n\n解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上，如果 provide 是函数就用 call(vm) 方法 返回 provide 里面定义的对象\n\n调用 created 钩子函数\n\n如果发现配置项上有 el 选项，则自动调用 $mount 方法，也就是说有了 el 选项，就不需要再手动调用 $mount 方法，反之，没提供 el 选项则必须调用 $mount\n\n接下来则进入挂载阶段\n\n4、beforeCreate 期间能拿到数据吗？\n\n```\n不能，因为数据初始化阶段是在 beforeCreate 之后执行\n```\n\n4、Vue nextTick使用场景及实现原理\n\n它主要是处理我们再变更完数据以后，无法立刻拿到最新的DOM节点对象的问题。\n\nvue执行完渲染后会执行this.nextTick()里面的callback函数。\n\n将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。\n\nnextTick流程总结：\n1、将回调放到callbacks里等待执行；\n2、将执行函数（flushCallbacks）放到微任务或宏任务里；原码里按照是否原生支持Promise.then、MutationObserver和setImmediate的顺序决策，都不支持则使用setTimeout\n3、等到事件循环执行到微任务或者宏任务时，执行函数依次执行callbacks里的回调；\n\n5、Vue的nextTick具体是微任务还是宏任务?\n\n|  宏任务   | 微任务  |\n|  ----  | ----  |\n| setTimeout  | process.nextTick |\n| setInterval  | MutationObserver |\n| setImmediate  | Promise.then |\n| requestAnimationFrame  |  |\n| MessageChannel  |  |\n\n5、 Vue3 有哪些新的新特性？\n\n- 响应式系统\n- 自定义渲染器\n- 全部模块使用 TS 重构\n- Composition API 组合语法\n- 新一代工程化工具 Vite\n\n6、Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？\n\nvue2 问题：\n\n- 代码的可读性随着组件变大而变差\n- 每一种代码复用的方式，都存在缺点\n- TypeScript支持有限\n- 逻辑组织\n\n  - 大型组件, 需要不断跳转代码块\n  - 逻辑关注点相关的代码全都放在一个函数里\n\n- 逻辑复用\n\n  - vue2 用 mixin去复用相同的逻辑, 我们一个组件混入大量不同的 mixins 的时候,命名冲突,数据来源不清\n  - vue3 写 hook 函数\n\n6、父组件可以监听到子组件的生命周期吗？\n\n比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理。\n\n方法一：手动通过 $emit 触发父组件的事件\n\n```js\n// Parent.vue\n<Child @mounted=\"doSomething\"/>\n    \n// Child.vue\nmounted() {\n  this.$emit(\"mounted\");\n}\n```\n\n方法二：父组件引用子组件时通过 @hook 来监听\n\n```js\n//  Parent.vue\n<Child @hook:mounted=\"doSomething\" ></Child>\n    \n//  Child.vue\nmounted(){\n   console.log('子组件触发 mounted 钩子函数 ...');\n},       \n```\n\n@hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。\n\n7、比较 Vue 和 React 两个框架，你觉得有哪些区别？\n\n- 监听数据变化的实现原理不同:\n\n    Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化.\n    react 中，数据变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化。\n- 数据流的不同:\n- 模板渲染方式的不同:\n\n8、什么是异步组件？\n\n在声明或注册组件时，Vue 接受提供 Promise 的工厂函数。然后可以在调用该组件时对其进行“解析”。\n\n```js\nnew Vue({\n    components: {\n        ‘tweet-box’: () => import(‘./components/async/TweetBox’)\n    }\n}); \n```\n\n## http\n\n1、HTTP有哪些请求方法？PUT 和 PATCH 有什么区别？\n\n- GET, POST 和 HEAD方法；OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT\n- PUT和PATCH都是更新资源，而PATCH用来对资源进行局部更新。\n\n2、http 状态码 403 是什么错误？\n\n- 403 forbidden，表示对请求资源的访问被服务器拒绝\n\n3、知道哪些 http 的缓存策略 ？控制缓存的请求头有哪些？\n\n- HTTP缓存机制分为强制缓存和协商缓存两类。\n- 强制缓存的意思就是不要问了(不发起请求)，直接用缓存吧。\n- 强制缓存常见技术有Expires和Cache-Control。\n- Expires的值是一个时间，表示这个时间前缓存都有效，都不需要发起请求。\n- Cache-Control有很多属性值，常用属性max-age设置了缓存有效的时间长度，单位为秒，这个时间没到，都不用发起请求。\n- immutable也是Cache-Control的一个属性，表示这个资源这辈子都不用再请求了，但是他兼容性不好，Cache-Control其他属性可以参考MDN的文档。\n- Cache-Control的max-age优先级比Expires高。\n- 协商缓存是为了知道有没有更新，必须跟服务端沟通过才知道的。常见技术有ETag和Last-Modified。\n- ETag其实就是给资源算一个hash值或者版本号，对应的常用request header为If-None-Match。\n- Last-Modified其实就是加上资源修改的时间，对应的常用request header为If-Modified-Since，精度为秒。\n- ETag每次修改都会改变，而Last-Modified的精度只到秒，所以ETag更准确，优先级更高，但是需要计算，所以服务端开销更大。\n- 强制缓存和协商缓存都存在的情况下，先判断强制缓存是否生效，如果生效，不用发起请求，直接用缓存。如果强制缓存不生效再发起请求判断协商缓存。\n\n> Cache-Control，ETag，Last-Modified\n\n## 其他\n\n1. 什 么 是 TS 泛 型 ？\n1. webpack 构 建 流 程 是 怎 样 的 ？\n1. webpack loade r 和 plugin 的 原 理 和 区 别 ？\n1. webpack 热 更 新 原 理 ？\n1. 有没有读过哪些源码？\n1. 最近开发的项目具体业务是怎么样的？介绍一下？\n\n## Devops 相关\n\n## Git\n\n1、什么情况下使用 git rebase, 而不用 git merge\n\n### nginx\n\n1. 谈谈一下对 nginx 的理解，项目中用到 nginx 的哪些功能？\n\n- Nginx ，是一个 Web 服务器和反向代理服务器用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。\n- 主要功能如下：\n    正向、反向代理 2、负载均衡、分流 3、虚拟主机（绑定host）\n\n2、正向代理和反向代理区别是什么？\n\n- 正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定原始服务器，然后代理向原始服务器转交请求并将获得的内容返回给客户端。代理服务器和客户端处于同一个局域网内。\n- 比如说fanqiang。我知道我要访问谷歌，于是我就告诉代理服务器让它帮我转发。\n- 反向代理实际运行方式是代理服务器接受网络上的连接请求。它将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给网络上请求连接的客户端 。代理服务器和原始服务器处于同一个局域网内。\n- 比如说我要访问taobao，对我来说不知道图片、json、css 是不是同一个服务器返回回来的，但是我不关心，是反向代理 处理的，我不知道原始服务器。\n\n3、nginx 如何来实现负载均衡？\n\n负载均衡的5种策略:\n\n```sh\n\n 1.轮询（默认）\n 每个请求按时间顺序逐一分配到不同的后端服务器\n\n upstream backserver {\n    server 192.168.0.14;\n    server 192.168.0.15;\n}\n\n2.weight\n指定轮询几率，weight和访问概率成正比\n\nupstream backserver {\n    server 192.168.0.14 weight=3;\n    server 192.168.0.15 weight=7;\n}\n\n3.ip_hash\n已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的.ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。\n\nupstream backserver {\n    ip_hash;\n    server 192.168.0.14:88;\n    server 192.168.0.15:80;\n}\n\n4.fair\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n\nupstream backserver {\n    server server1;\n    server server2;\n    fair;\n}\n\n5.url_hash\n按访问url的hash结果来分配请求，使每个url定向到同一个（对应的）后端服务器，后端服务器为缓存时比较有效。\n\nupstream backserver {\n    server squid1:3128;\n    server squid2:3128;\n    hash $request_uri;\n    hash_method crc32;\n}\n```\n\n### docker\n\n1、什么是 Docker？\n\n- Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。\n\n2、Dockerfile中最常见的指令是什么？\n\n- FROM：指定基础镜像；LABEL：功能是为镜像指定标签；RUN：运行指定的命令；CMD：容器启动时要运行的命令。\n\n3、docker 构建镜像多大，如何优化？\n\n- 使用轻量级基础镜像,如 Alpine\n- 多阶段构建\n\n4、 CI 中前端镜像每次构建都很慢，甚至有时候失败，如何解决？\n\n- 合理分层，利用构建镜像缓存机制\n- 失败，检查是否安装依赖超时，修改 npm timeout\n\n### k8s\n\n1、k8s是什么？请说出你的了解？\n\n- Kubernetes 是一个针对容器应用，进行自动部署，弹性伸缩和管理的开源系统。主要功能是生产环境中的容器编排。\n\n2、k8s 集群里面最小的单位是什么？\n\n- pod 是最小单位。每个pod里边可以运行一个或多个container（容器）\n\n3、Service这种资源对象的作用是什么？\n\n- 用来给相同的多个pod对象提供一个固定的统一访问接口，常用于服务发现和服务访问。\n\n### openstack\n\n1、openstack 里 KeyStone 组件是用于提供什么服务的？Nova 组件是做什么用？\n\n- 认证服务（KeyStone）\nNova – 用于在计算级别管理虚拟机，并在计算或管理程序级别执行其他计算任务。\n","source":"_posts/0.前端工程师面试题.md","raw":"---\ntitle: 前端工程师面试题\nindex_img: /img/2022-02-16-1.jpeg\ntags: 前端\ncategories: 面试\nabbrlink: a18c0ac9\ndate: 2022-02-15 10:39:21\n---\n\n## JS\n\n1、请你讲一下闭包?\n\n> 简单：闭包是有权限访问其他函数作用域内的变量的一个函数。\n>\n> 完整：由于在JS中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之回收，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数——也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后作用域内的值也不会被销毁。\n\n- 闭包解决了什么？\n\n> 由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。以平时使用的Ajax成功回调为例，这里其实就是个闭包，由于上述的特性，回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。开发者不用去写钩子函数来操作上级函数作用域内部的变量了。\n\n- 闭包有哪些应用场景?\n\n> 闭包随处可见，一个Ajax请求的成功回调，一个事件绑定的回调方法，一个setTimeout的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。\n\n- react hooks 中的 闭包陷阱问题如何解决？\n\n不管在这个组件中的其他地方使用 setCount 将 count 设置为任何值，还是设置多少次，打印的都是1\n\n```jsx\nfunction App(){\n    const [count, setCount] = useState(1);\n    useEffect(()=>{\n        setInterval(()=>{\n            console.log(count)\n        }, 1000)\n    }, [])\n}\n```\n\nuseRef\n\nuseState 更新值时传入回调函数\n\n2、介绍一下 JS 里面的原型？\n\n> 每个对象都有一个 prototype 属性，就是原型，是一个对象，叫原型对象。\n\n- 原型的作用是什么？\n\n > 共享方法\n\n- 原型中this的指向是什么？\n\n> 原型中this的指向是实例。\n\n- 说一下平时开发使用到 prototype 的例子？\n\n3、如何理解 es6 class 中 constructor 方法？ 和 super的作用？\n\n> constructor 方法是类的构造函数。\n通过 new 命令创建对象实例时，自动调用该方法。\nconstructor 内定义的方法是 实例方法；class 内直接定义的方法是原型方法。\n\n- super 的作用？\n\n子类是没有自己的 this 对象的，它只能继承自父类的 this 对象，然后对其进行加工，而super( )就是将父类中的this对象继承给子类的。没有 super，子类就得不到 this 对象。\n\n- 为什么要传入 props？\n\n```jsx\nclass Component {\n  constructor(props) {\n    this.props = props;\n    // ...\n  }\n}\n```\n\n确保了 this.props 在构造函数执行完毕之前已被赋值。\n\n4、eventloop\n\n浏览器或node 端 js 单线程运行时不会阻塞的一种机制。\n\n任务分为宏任务和微任务；\n\n宏任务：script全部代码、setTimeout、setInterval、I/O、UI Rendering。\n微任务：Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver\n\n- 浏览器中的 event loop\n\nJS 中有一个主线程和一个调用栈（执行栈），所有的任务都会被放到调用栈中等待主线程执行。\n\nJS 调用栈后进先出原则，当函数执行的时候，会被添加到栈顶部，当执行完后，会被从栈顶移出，直到栈内被清空。\n\nJS 任务分为同步任务和异步任务。同步任务在调用栈中按照顺序等待主线程依次执行。异步任务会在异步任务有结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），读取到栈内等待主线程执行。\n\n任务队列：先进先出\n\n顺序：同步任务 =》微任务 =》 宏任务\n\n- 执行栈在执行完同步任务后，查看执行栈是否为空\n- 如果执行栈为空，就会去检查微任务(microTask)队列, 执行完微任务，再执行宏任务\n- 每个宏任务执行完后，都会再检查微任务队列是否为空，不为空，就按先进先出执行完微任务，设置微任务为 null，再执行宏任务。\n\nNode 中 event loop(待补充)\n\n## React\n\n1、介绍一下react diff 算法 的工作原理？\n\n- react 状态变化渲染页面时，不会马上对DOM节点进行操作，是先通过diff算法计算后，再对有变化的DOM节点进行操作。\n- diff算法就是更高效地通过对比新旧Virtual DOM来找出真正的Dom变化之处.\n- react中diff算法主要遵循三个层级的策略:tree层级、conponent 层级、element 层级\n- tree层级: DOM节点跨层级的操作不做优化，只会对相同层级的节点进行比较.只有删除、创建操作.新树中，R节点下没有了A，那么直接删除A，在D节点下创建A以及下属节点。\n- conponent层级:是同一个组件，则会继续往下diff运算，如果不是一个类的组件，那么直接删除这个组件下的所有子节点，创建新的\n- element层级:对于比较同一层级的节点们，每个节点在对应的层级用唯一的key作为标识.\n\n  - 3 种节点操作，分别为 INSERT_MARKUP(插入)、MOVE_EXISTING (移动)和 REMOVE_NODE (删除)\n  - 通过key可以准确地发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置\n  - 如果当前节点在新集合中的位置比老集合中的位置靠前的话，是不会影响后续节点操作的，这里这时候被动字节不用动\n  - 当ABCD节点比较完成后，diff过程还没完，还会整体遍历老集合中节点，看有没有没用到的节点，有的话，就删除\n\n由于dom节点的移动操作开销是比较昂贵的，没有key的情况下要比有key的性能更好\n\n```HTML\n1.加key\n<div key='1'>1</div>             <div key='1'>1</div>     \n<div key='2'>2</div>             <div key='3'>3</div>  \n<div key='3'>3</div>  ========>  <div key='2'>2</div>  \n<div key='4'>4</div>             <div key='5'>5</div>  \n<div key='5'>5</div>             <div key='6'>6</div>  \n操作：节点2移动至下标为2的位置，新增节点6至下标为4的位置，删除节点4。\n\n2.不加key\n<div>1</div>             <div>1</div>     \n<div>2</div>             <div>3</div>  \n<div>3</div>  ========>  <div>2</div>  \n<div>4</div>             <div>5</div>  \n<div>5</div>             <div>6</div> \n操作：修改第1个到第5个节点的innerText\n```\n\nVirtual DOM 工作过程有：\n\n    1. state 变化，生成新的 Virtual Dom\n    2. 比较 Virtual Dom 与之前 Virtual Dom 的异同\n    3. 生成差异对象\n    4. 遍历差异对象并更新真实 DOM\n\n- React diff 算法 和 vue diff 的相同点和不同点有哪些？\n\n不同点：\n\n- vue的列表比对，采用从两端到中间的比对方式，而react则采用从左到右依次比对的方式。当一个集合，只是把最后一个节点移动到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移动到第一个\n- vue比对节点，当节点元素类型相同，但是className不同，认为是不同类型元素，删除重建，而react会认为是同类型节点，只是修改节点属性\n\nVue Diff使用双向链表，边对比，边更新DOM。React主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。\n\n相同点：\n\n- 虚拟DOM在比较时只比较同一层级节点，复杂度都为 O(n)，降低了算法复杂度；\n- 都使用key比较是否是相同节点，都是为了尽可能的复用节点\n- 都是操作虚拟DOM，最小化操作真实DOM，提高性能（其实虚拟DOM的优势 并不是在于它操作DOM快）\n- 都是不要用 index作为 key\n\n2、react 里什么是高阶组件？使用高阶组件的场景？\n\n> 高阶组件(HOC)是接受一个组件并返回一个新组件的函数。\n\n2、React setState 怎么获取到更新后的值?异步函数中为什么 setState 会立即更新?\n\n3、useState 为什么不能放到条件语句里面?\n\nReact通过单链表来管理Hooks。\nupdate 阶段，每次调用 useState，链表就会执行 next 向后移动一步。如果将 useState 写在条件判断中，假设条件判断不成立，没有执行里面的 useState 方法，会导致接下来所有的 useState 的取值出现偏移，从而导致异常发生。\n\n4、说一下 useRef 有哪些用法？\n\n> useRef 除了获取 dom，另一个用法：\n保存数据，不造成 rerender\n想要保存数据，又不想触发函数的更新，该数据的更新不会造成组件 rerender\n\n5、什么情况下使用 useCallback ？\n子组件接收一个方法，避免子组件重复渲染\n\n- react 中只要父组件的 render 了，那么默认情况下就会触发子组的 render，react 提供了来避免这种重渲染的性能开销的一些方法：React.PureComponent、React.memo ，shouldComponentUpdate()\n- 使用 React.memo 避免子组件做没必要的渲染。\n- Reace.memo 只会对 props 做浅比较，也就是父组件重新 render 之后会传入 不同引用的方法 getList，浅比较之后不相等，导致子组件还是依然会渲染。\n- useCallback 缓存一个函数，当依赖没有改变的时候，会一直返回同一个引用\n\n6、useCallback 与 useMemo 作用用来缓存，两者的区别是什么？\n\n> useMemo 缓存值；useCallback 缓存函数\n\n注意不要滥用：\n\n经常用在以下两种场景（要保持引用相等；对于组件内部用到的 object、array、函数等，如果用在了其他 Hook 的依赖数组中，或者作为 props 传递给了下游组件，应该使用 useMemo/useCallback）\n\n7、react ssr 实现原理？react ssr 是在什么场景下做的？\n\nserver端接收到客户端的请求路由后，查找对应的数据，以props、context、store的形式注入组件中。然后基于react提供的API：renderToString将组件转换为html字符串输出到客户端。客户端使用该数据进行渲染，保证数据的一致性。\n\nReact SSR之所以能够实现，本质是虚拟 DOM的存在。判断环境是服务器环境，可以操作 JavaScript 对象，把虚拟 DOM 映射成字符串输出。判断环境是客户端环境，可以操作 JavaScript 对象，将虚拟 DOM 映射成真实 DOM ，完成页面挂载。\n\n8、 react 项目里做过哪些性能优化？\n\n代码层面：\n\n- 使用return null而不是CSS的display:none来控制节点的显示隐藏。保证同一时间页面的DOM节点尽可能的少。\n- props和state的数据尽可能简单明了，扁平化。\n- 不要使用数组下标作为key\n- 利用 shouldComponentUpdate 和 PureComponent 避免过多 render function\n- render里面尽量减少新建变量和bind函数，传递参数是尽量减少传递参数的数量。\n- 尽量将 props 和 state 扁平化，只传递 component 需要的 props（传得太多，或者层次传得太深，都会加重shouldComponentUpdate里面的数据比较负担），慎将 component 当作 props 传入\n\n代码体积优化:\n\n- 使用 babel-plugin-import 优化业务组件的引入，实现按需加载\n- 使用 生产版本\n- 使用 SplitChunksPlugin 拆分公共代码\n- 分析 CSS 和 JS 代码覆盖率\n- 优化 Webpack 中的库\n- 使用动态 import，懒加载 React 组件\n- 使用 webpack-bundle-analyzer 可视化 webpack 输出文件的大小\n- 使用动态 import，懒加载 React 组件\n- 使用 Tree Shaking & 教程 & Tree Shaking 优化\n\n9、有 用 过 lerna 吗 ？ 多 个 项 目 之 间 共 用 的 东 西 怎 么 共 享 ？\n\n10、使用 react 中，有没有遇到觉得比较难的点？是什么？\n\n11、使用 hooks 中遇到过哪些坑？为什么？\n\n- 不要在循环，条件或嵌套函数中调用Hook，必须始终在React函数的顶层使用Hook。这是因为React需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子函数。一旦在循环或条件分支语句中调用Hook，就容易导致调用顺序的不一致性。\n- 使用useState时候，使用push，pop，splice等直接更改数组对象的坑，应该采用析构方式.\n- 必包带来的坑,因为每次 render 都有一份新的状态，因此上述代码中的 setTimeout 使用产生了一个闭包，捕获了每次 render 后的 state，也就导致了输出了 0、1、2。如果你希望输出的内容是最新的 state 的话，可以通过 useRef 来保存 state。前文讲过 ref 在组件中只存在一份，无论何时使用它的引用都不会产生变化，因此可以来解决闭包引发的问题。\n\n## Vue\n\n1、Vue如何监听数组的变化？\n\n- 对象数据是怎么被监听的?\n\nvue2.x版本中，数据监听用 Object.defineProperty. 通过Object.defineProperty来劫持对象属性的setter和getter操作，并创建一个监听器，当数据发生变化的时候发出通知\n\n- 数组数据是怎么被监听的?\n\nVue.js是基于Object.defineProperty对对象实现“响应式化”，而对于数组，Vue.js提供的方法是重写push、pop、shift、unshift、splice、sort、reverse这七个数组方法.\n\n如果需要用数组下标修改数组并实现响应式数据变化，Vue.js提供了$set()及$remove()方法。\n\n1、Vue 组件 data 为什么必须是函数？\n\n> 因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染。\n所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。\n\n2、直接给一个数组项赋值，Vue 能检测到变化吗？\n\n由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。\n\n- Vue 不能检测到以下数组的变动:\n\n1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue\n\n```js\n// 解决办法\nvm.$set(vm.items, indexOfItem, newValue)\n```\n\n2.当你修改数组的长度时，例如：vm.items.length = newLength\n\n```js\n/ 解决办法\nvm.items.splice(newLength)\n```\n\n- 检测不到的原因是什么？\n\n当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。\n\n但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的 $set。\n\n3、vue2 中响应式（双向绑定）的原理？vue3 的原理？\nProxy 与 Object.defineProperty 的优劣对比?\n为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？\n\n> Proxy的优势如下:\nProxy 可以直接监听对象而非属性\nProxy 可以直接监听数组的变化\nProxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的\nProxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改\nProxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利\n>\n> Object.defineProperty 的优势如下:\n>\n> 兼容性好,支持 IE9\n\n4、vuex 的工作流程是怎么样？\n\n> Vuex有5个重要的属性，分别是 State、Getter、Mutation、Action、Module，由 view 层发起一个 Action 给 Mutation，在 Mutation 中修改状态，返回新的状态，通过 Getter暴露给 view层的组件或者页面，页面监测到状态改变于是更新页面。\n\n4、Vue 的初始化过程（new Vue(options)）都做了什么？\n\n处理组件配置项\n\n初始化根组件时进行了选项合并操作，将全局配置合并到根组件的局部配置上\n\n初始化每个子组件时做了一些性能优化，将组件配置对象上的一些深层次属性放到 vm.$options 选项中，以提高代码的执行效率\n\n初始化组件实例的关系属性，比如 $parent、$children、$root、$refs 等\n\n处理自定义事件\n\n调用 beforeCreate 钩子函数\n\n初始化组件的 inject 配置项，得到 ret[key] = val 形式的配置对象，然后对该配置对象进行响应式处理，并代理每个 key 到 vm 实例上\n\n数据响应式，处理 props、methods、data、computed、watch 等选项\n\n解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上，如果 provide 是函数就用 call(vm) 方法 返回 provide 里面定义的对象\n\n调用 created 钩子函数\n\n如果发现配置项上有 el 选项，则自动调用 $mount 方法，也就是说有了 el 选项，就不需要再手动调用 $mount 方法，反之，没提供 el 选项则必须调用 $mount\n\n接下来则进入挂载阶段\n\n4、beforeCreate 期间能拿到数据吗？\n\n```\n不能，因为数据初始化阶段是在 beforeCreate 之后执行\n```\n\n4、Vue nextTick使用场景及实现原理\n\n它主要是处理我们再变更完数据以后，无法立刻拿到最新的DOM节点对象的问题。\n\nvue执行完渲染后会执行this.nextTick()里面的callback函数。\n\n将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。\n\nnextTick流程总结：\n1、将回调放到callbacks里等待执行；\n2、将执行函数（flushCallbacks）放到微任务或宏任务里；原码里按照是否原生支持Promise.then、MutationObserver和setImmediate的顺序决策，都不支持则使用setTimeout\n3、等到事件循环执行到微任务或者宏任务时，执行函数依次执行callbacks里的回调；\n\n5、Vue的nextTick具体是微任务还是宏任务?\n\n|  宏任务   | 微任务  |\n|  ----  | ----  |\n| setTimeout  | process.nextTick |\n| setInterval  | MutationObserver |\n| setImmediate  | Promise.then |\n| requestAnimationFrame  |  |\n| MessageChannel  |  |\n\n5、 Vue3 有哪些新的新特性？\n\n- 响应式系统\n- 自定义渲染器\n- 全部模块使用 TS 重构\n- Composition API 组合语法\n- 新一代工程化工具 Vite\n\n6、Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？\n\nvue2 问题：\n\n- 代码的可读性随着组件变大而变差\n- 每一种代码复用的方式，都存在缺点\n- TypeScript支持有限\n- 逻辑组织\n\n  - 大型组件, 需要不断跳转代码块\n  - 逻辑关注点相关的代码全都放在一个函数里\n\n- 逻辑复用\n\n  - vue2 用 mixin去复用相同的逻辑, 我们一个组件混入大量不同的 mixins 的时候,命名冲突,数据来源不清\n  - vue3 写 hook 函数\n\n6、父组件可以监听到子组件的生命周期吗？\n\n比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理。\n\n方法一：手动通过 $emit 触发父组件的事件\n\n```js\n// Parent.vue\n<Child @mounted=\"doSomething\"/>\n    \n// Child.vue\nmounted() {\n  this.$emit(\"mounted\");\n}\n```\n\n方法二：父组件引用子组件时通过 @hook 来监听\n\n```js\n//  Parent.vue\n<Child @hook:mounted=\"doSomething\" ></Child>\n    \n//  Child.vue\nmounted(){\n   console.log('子组件触发 mounted 钩子函数 ...');\n},       \n```\n\n@hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。\n\n7、比较 Vue 和 React 两个框架，你觉得有哪些区别？\n\n- 监听数据变化的实现原理不同:\n\n    Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化.\n    react 中，数据变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化。\n- 数据流的不同:\n- 模板渲染方式的不同:\n\n8、什么是异步组件？\n\n在声明或注册组件时，Vue 接受提供 Promise 的工厂函数。然后可以在调用该组件时对其进行“解析”。\n\n```js\nnew Vue({\n    components: {\n        ‘tweet-box’: () => import(‘./components/async/TweetBox’)\n    }\n}); \n```\n\n## http\n\n1、HTTP有哪些请求方法？PUT 和 PATCH 有什么区别？\n\n- GET, POST 和 HEAD方法；OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT\n- PUT和PATCH都是更新资源，而PATCH用来对资源进行局部更新。\n\n2、http 状态码 403 是什么错误？\n\n- 403 forbidden，表示对请求资源的访问被服务器拒绝\n\n3、知道哪些 http 的缓存策略 ？控制缓存的请求头有哪些？\n\n- HTTP缓存机制分为强制缓存和协商缓存两类。\n- 强制缓存的意思就是不要问了(不发起请求)，直接用缓存吧。\n- 强制缓存常见技术有Expires和Cache-Control。\n- Expires的值是一个时间，表示这个时间前缓存都有效，都不需要发起请求。\n- Cache-Control有很多属性值，常用属性max-age设置了缓存有效的时间长度，单位为秒，这个时间没到，都不用发起请求。\n- immutable也是Cache-Control的一个属性，表示这个资源这辈子都不用再请求了，但是他兼容性不好，Cache-Control其他属性可以参考MDN的文档。\n- Cache-Control的max-age优先级比Expires高。\n- 协商缓存是为了知道有没有更新，必须跟服务端沟通过才知道的。常见技术有ETag和Last-Modified。\n- ETag其实就是给资源算一个hash值或者版本号，对应的常用request header为If-None-Match。\n- Last-Modified其实就是加上资源修改的时间，对应的常用request header为If-Modified-Since，精度为秒。\n- ETag每次修改都会改变，而Last-Modified的精度只到秒，所以ETag更准确，优先级更高，但是需要计算，所以服务端开销更大。\n- 强制缓存和协商缓存都存在的情况下，先判断强制缓存是否生效，如果生效，不用发起请求，直接用缓存。如果强制缓存不生效再发起请求判断协商缓存。\n\n> Cache-Control，ETag，Last-Modified\n\n## 其他\n\n1. 什 么 是 TS 泛 型 ？\n1. webpack 构 建 流 程 是 怎 样 的 ？\n1. webpack loade r 和 plugin 的 原 理 和 区 别 ？\n1. webpack 热 更 新 原 理 ？\n1. 有没有读过哪些源码？\n1. 最近开发的项目具体业务是怎么样的？介绍一下？\n\n## Devops 相关\n\n## Git\n\n1、什么情况下使用 git rebase, 而不用 git merge\n\n### nginx\n\n1. 谈谈一下对 nginx 的理解，项目中用到 nginx 的哪些功能？\n\n- Nginx ，是一个 Web 服务器和反向代理服务器用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。\n- 主要功能如下：\n    正向、反向代理 2、负载均衡、分流 3、虚拟主机（绑定host）\n\n2、正向代理和反向代理区别是什么？\n\n- 正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定原始服务器，然后代理向原始服务器转交请求并将获得的内容返回给客户端。代理服务器和客户端处于同一个局域网内。\n- 比如说fanqiang。我知道我要访问谷歌，于是我就告诉代理服务器让它帮我转发。\n- 反向代理实际运行方式是代理服务器接受网络上的连接请求。它将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给网络上请求连接的客户端 。代理服务器和原始服务器处于同一个局域网内。\n- 比如说我要访问taobao，对我来说不知道图片、json、css 是不是同一个服务器返回回来的，但是我不关心，是反向代理 处理的，我不知道原始服务器。\n\n3、nginx 如何来实现负载均衡？\n\n负载均衡的5种策略:\n\n```sh\n\n 1.轮询（默认）\n 每个请求按时间顺序逐一分配到不同的后端服务器\n\n upstream backserver {\n    server 192.168.0.14;\n    server 192.168.0.15;\n}\n\n2.weight\n指定轮询几率，weight和访问概率成正比\n\nupstream backserver {\n    server 192.168.0.14 weight=3;\n    server 192.168.0.15 weight=7;\n}\n\n3.ip_hash\n已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的.ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。\n\nupstream backserver {\n    ip_hash;\n    server 192.168.0.14:88;\n    server 192.168.0.15:80;\n}\n\n4.fair\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n\nupstream backserver {\n    server server1;\n    server server2;\n    fair;\n}\n\n5.url_hash\n按访问url的hash结果来分配请求，使每个url定向到同一个（对应的）后端服务器，后端服务器为缓存时比较有效。\n\nupstream backserver {\n    server squid1:3128;\n    server squid2:3128;\n    hash $request_uri;\n    hash_method crc32;\n}\n```\n\n### docker\n\n1、什么是 Docker？\n\n- Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。\n\n2、Dockerfile中最常见的指令是什么？\n\n- FROM：指定基础镜像；LABEL：功能是为镜像指定标签；RUN：运行指定的命令；CMD：容器启动时要运行的命令。\n\n3、docker 构建镜像多大，如何优化？\n\n- 使用轻量级基础镜像,如 Alpine\n- 多阶段构建\n\n4、 CI 中前端镜像每次构建都很慢，甚至有时候失败，如何解决？\n\n- 合理分层，利用构建镜像缓存机制\n- 失败，检查是否安装依赖超时，修改 npm timeout\n\n### k8s\n\n1、k8s是什么？请说出你的了解？\n\n- Kubernetes 是一个针对容器应用，进行自动部署，弹性伸缩和管理的开源系统。主要功能是生产环境中的容器编排。\n\n2、k8s 集群里面最小的单位是什么？\n\n- pod 是最小单位。每个pod里边可以运行一个或多个container（容器）\n\n3、Service这种资源对象的作用是什么？\n\n- 用来给相同的多个pod对象提供一个固定的统一访问接口，常用于服务发现和服务访问。\n\n### openstack\n\n1、openstack 里 KeyStone 组件是用于提供什么服务的？Nova 组件是做什么用？\n\n- 认证服务（KeyStone）\nNova – 用于在计算级别管理虚拟机，并在计算或管理程序级别执行其他计算任务。\n","slug":"0-前端工程师面试题","published":1,"updated":"2022-04-15T09:59:06.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k5bv7m002t0h3l9x881c1g","content":"<h2 id=\"JS\"><a href=\"#JS\" class=\"headerlink\" title=\"JS\"></a>JS</h2><p>1、请你讲一下闭包?</p>\n<blockquote>\n<p>简单：闭包是有权限访问其他函数作用域内的变量的一个函数。</p>\n<p>完整：由于在JS中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之回收，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数——也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后作用域内的值也不会被销毁。</p>\n</blockquote>\n<ul>\n<li>闭包解决了什么？</li>\n</ul>\n<blockquote>\n<p>由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。以平时使用的Ajax成功回调为例，这里其实就是个闭包，由于上述的特性，回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。开发者不用去写钩子函数来操作上级函数作用域内部的变量了。</p>\n</blockquote>\n<ul>\n<li>闭包有哪些应用场景?</li>\n</ul>\n<blockquote>\n<p>闭包随处可见，一个Ajax请求的成功回调，一个事件绑定的回调方法，一个setTimeout的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。</p>\n</blockquote>\n<ul>\n<li>react hooks 中的 闭包陷阱问题如何解决？</li>\n</ul>\n<p>不管在这个组件中的其他地方使用 setCount 将 count 设置为任何值，还是设置多少次，打印的都是1</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>)</span>&#123;\n    <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">1</span>);\n    useEffect(<span class=\"hljs-function\">()=&gt;</span>&#123;\n        <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">()=&gt;</span>&#123;\n            <span class=\"hljs-built_in\">console</span>.log(count)\n        &#125;, <span class=\"hljs-number\">1000</span>)\n    &#125;, [])\n&#125;</code></pre></div>\n\n<p>useRef</p>\n<p>useState 更新值时传入回调函数</p>\n<p>2、介绍一下 JS 里面的原型？</p>\n<blockquote>\n<p>每个对象都有一个 prototype 属性，就是原型，是一个对象，叫原型对象。</p>\n</blockquote>\n<ul>\n<li>原型的作用是什么？</li>\n</ul>\n<blockquote>\n<p>共享方法</p>\n</blockquote>\n<ul>\n<li>原型中this的指向是什么？</li>\n</ul>\n<blockquote>\n<p>原型中this的指向是实例。</p>\n</blockquote>\n<ul>\n<li>说一下平时开发使用到 prototype 的例子？</li>\n</ul>\n<p>3、如何理解 es6 class 中 constructor 方法？ 和 super的作用？</p>\n<blockquote>\n<p>constructor 方法是类的构造函数。<br>通过 new 命令创建对象实例时，自动调用该方法。<br>constructor 内定义的方法是 实例方法；class 内直接定义的方法是原型方法。</p>\n</blockquote>\n<ul>\n<li>super 的作用？</li>\n</ul>\n<p>子类是没有自己的 this 对象的，它只能继承自父类的 this 对象，然后对其进行加工，而super( )就是将父类中的this对象继承给子类的。没有 super，子类就得不到 this 对象。</p>\n<ul>\n<li>为什么要传入 props？</li>\n</ul>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Component</span> </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;\n    <span class=\"hljs-built_in\">this</span>.props = props;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;\n&#125;</code></pre></div>\n\n<p>确保了 this.props 在构造函数执行完毕之前已被赋值。</p>\n<p>4、eventloop</p>\n<p>浏览器或node 端 js 单线程运行时不会阻塞的一种机制。</p>\n<p>任务分为宏任务和微任务；</p>\n<p>宏任务：script全部代码、setTimeout、setInterval、I/O、UI Rendering。<br>微任务：Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver</p>\n<ul>\n<li>浏览器中的 event loop</li>\n</ul>\n<p>JS 中有一个主线程和一个调用栈（执行栈），所有的任务都会被放到调用栈中等待主线程执行。</p>\n<p>JS 调用栈后进先出原则，当函数执行的时候，会被添加到栈顶部，当执行完后，会被从栈顶移出，直到栈内被清空。</p>\n<p>JS 任务分为同步任务和异步任务。同步任务在调用栈中按照顺序等待主线程依次执行。异步任务会在异步任务有结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），读取到栈内等待主线程执行。</p>\n<p>任务队列：先进先出</p>\n<p>顺序：同步任务 =》微任务 =》 宏任务</p>\n<ul>\n<li>执行栈在执行完同步任务后，查看执行栈是否为空</li>\n<li>如果执行栈为空，就会去检查微任务(microTask)队列, 执行完微任务，再执行宏任务</li>\n<li>每个宏任务执行完后，都会再检查微任务队列是否为空，不为空，就按先进先出执行完微任务，设置微任务为 null，再执行宏任务。</li>\n</ul>\n<p>Node 中 event loop(待补充)</p>\n<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><p>1、介绍一下react diff 算法 的工作原理？</p>\n<ul>\n<li><p>react 状态变化渲染页面时，不会马上对DOM节点进行操作，是先通过diff算法计算后，再对有变化的DOM节点进行操作。</p>\n</li>\n<li><p>diff算法就是更高效地通过对比新旧Virtual DOM来找出真正的Dom变化之处.</p>\n</li>\n<li><p>react中diff算法主要遵循三个层级的策略:tree层级、conponent 层级、element 层级</p>\n</li>\n<li><p>tree层级: DOM节点跨层级的操作不做优化，只会对相同层级的节点进行比较.只有删除、创建操作.新树中，R节点下没有了A，那么直接删除A，在D节点下创建A以及下属节点。</p>\n</li>\n<li><p>conponent层级:是同一个组件，则会继续往下diff运算，如果不是一个类的组件，那么直接删除这个组件下的所有子节点，创建新的</p>\n</li>\n<li><p>element层级:对于比较同一层级的节点们，每个节点在对应的层级用唯一的key作为标识.</p>\n<ul>\n<li>3 种节点操作，分别为 INSERT_MARKUP(插入)、MOVE_EXISTING (移动)和 REMOVE_NODE (删除)</li>\n<li>通过key可以准确地发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置</li>\n<li>如果当前节点在新集合中的位置比老集合中的位置靠前的话，是不会影响后续节点操作的，这里这时候被动字节不用动</li>\n<li>当ABCD节点比较完成后，diff过程还没完，还会整体遍历老集合中节点，看有没有没用到的节点，有的话，就删除</li>\n</ul>\n</li>\n</ul>\n<p>由于dom节点的移动操作开销是比较昂贵的，没有key的情况下要比有key的性能更好</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs HTML\">1.加key\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;1&#x27;</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;1&#x27;</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>     \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;2&#x27;</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;3&#x27;</span>&gt;</span>3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;3&#x27;</span>&gt;</span>3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  ========&gt;  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;2&#x27;</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;4&#x27;</span>&gt;</span>4<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;5&#x27;</span>&gt;</span>5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;5&#x27;</span>&gt;</span>5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;6&#x27;</span>&gt;</span>6<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n操作：节点2移动至下标为2的位置，新增节点6至下标为4的位置，删除节点4。\n\n2.不加key\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>     \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  ========&gt;  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>4<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>6<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span> \n操作：修改第1个到第5个节点的innerText</code></pre></div>\n\n<p>Virtual DOM 工作过程有：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs\">1. state 变化，生成新的 Virtual Dom\n2. 比较 Virtual Dom 与之前 Virtual Dom 的异同\n3. 生成差异对象\n4. 遍历差异对象并更新真实 DOM\n</code></pre></div>\n<ul>\n<li>React diff 算法 和 vue diff 的相同点和不同点有哪些？</li>\n</ul>\n<p>不同点：</p>\n<ul>\n<li>vue的列表比对，采用从两端到中间的比对方式，而react则采用从左到右依次比对的方式。当一个集合，只是把最后一个节点移动到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移动到第一个</li>\n<li>vue比对节点，当节点元素类型相同，但是className不同，认为是不同类型元素，删除重建，而react会认为是同类型节点，只是修改节点属性</li>\n</ul>\n<p>Vue Diff使用双向链表，边对比，边更新DOM。React主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。</p>\n<p>相同点：</p>\n<ul>\n<li>虚拟DOM在比较时只比较同一层级节点，复杂度都为 O(n)，降低了算法复杂度；</li>\n<li>都使用key比较是否是相同节点，都是为了尽可能的复用节点</li>\n<li>都是操作虚拟DOM，最小化操作真实DOM，提高性能（其实虚拟DOM的优势 并不是在于它操作DOM快）</li>\n<li>都是不要用 index作为 key</li>\n</ul>\n<p>2、react 里什么是高阶组件？使用高阶组件的场景？</p>\n<blockquote>\n<p>高阶组件(HOC)是接受一个组件并返回一个新组件的函数。</p>\n</blockquote>\n<p>2、React setState 怎么获取到更新后的值?异步函数中为什么 setState 会立即更新?</p>\n<p>3、useState 为什么不能放到条件语句里面?</p>\n<p>React通过单链表来管理Hooks。<br>update 阶段，每次调用 useState，链表就会执行 next 向后移动一步。如果将 useState 写在条件判断中，假设条件判断不成立，没有执行里面的 useState 方法，会导致接下来所有的 useState 的取值出现偏移，从而导致异常发生。</p>\n<p>4、说一下 useRef 有哪些用法？</p>\n<blockquote>\n<p>useRef 除了获取 dom，另一个用法：<br>保存数据，不造成 rerender<br>想要保存数据，又不想触发函数的更新，该数据的更新不会造成组件 rerender</p>\n</blockquote>\n<p>5、什么情况下使用 useCallback ？<br>子组件接收一个方法，避免子组件重复渲染</p>\n<ul>\n<li>react 中只要父组件的 render 了，那么默认情况下就会触发子组的 render，react 提供了来避免这种重渲染的性能开销的一些方法：React.PureComponent、React.memo ，shouldComponentUpdate()</li>\n<li>使用 React.memo 避免子组件做没必要的渲染。</li>\n<li>Reace.memo 只会对 props 做浅比较，也就是父组件重新 render 之后会传入 不同引用的方法 getList，浅比较之后不相等，导致子组件还是依然会渲染。</li>\n<li>useCallback 缓存一个函数，当依赖没有改变的时候，会一直返回同一个引用</li>\n</ul>\n<p>6、useCallback 与 useMemo 作用用来缓存，两者的区别是什么？</p>\n<blockquote>\n<p>useMemo 缓存值；useCallback 缓存函数</p>\n</blockquote>\n<p>注意不要滥用：</p>\n<p>经常用在以下两种场景（要保持引用相等；对于组件内部用到的 object、array、函数等，如果用在了其他 Hook 的依赖数组中，或者作为 props 传递给了下游组件，应该使用 useMemo/useCallback）</p>\n<p>7、react ssr 实现原理？react ssr 是在什么场景下做的？</p>\n<p>server端接收到客户端的请求路由后，查找对应的数据，以props、context、store的形式注入组件中。然后基于react提供的API：renderToString将组件转换为html字符串输出到客户端。客户端使用该数据进行渲染，保证数据的一致性。</p>\n<p>React SSR之所以能够实现，本质是虚拟 DOM的存在。判断环境是服务器环境，可以操作 JavaScript 对象，把虚拟 DOM 映射成字符串输出。判断环境是客户端环境，可以操作 JavaScript 对象，将虚拟 DOM 映射成真实 DOM ，完成页面挂载。</p>\n<p>8、 react 项目里做过哪些性能优化？</p>\n<p>代码层面：</p>\n<ul>\n<li>使用return null而不是CSS的display:none来控制节点的显示隐藏。保证同一时间页面的DOM节点尽可能的少。</li>\n<li>props和state的数据尽可能简单明了，扁平化。</li>\n<li>不要使用数组下标作为key</li>\n<li>利用 shouldComponentUpdate 和 PureComponent 避免过多 render function</li>\n<li>render里面尽量减少新建变量和bind函数，传递参数是尽量减少传递参数的数量。</li>\n<li>尽量将 props 和 state 扁平化，只传递 component 需要的 props（传得太多，或者层次传得太深，都会加重shouldComponentUpdate里面的数据比较负担），慎将 component 当作 props 传入</li>\n</ul>\n<p>代码体积优化:</p>\n<ul>\n<li>使用 babel-plugin-import 优化业务组件的引入，实现按需加载</li>\n<li>使用 生产版本</li>\n<li>使用 SplitChunksPlugin 拆分公共代码</li>\n<li>分析 CSS 和 JS 代码覆盖率</li>\n<li>优化 Webpack 中的库</li>\n<li>使用动态 import，懒加载 React 组件</li>\n<li>使用 webpack-bundle-analyzer 可视化 webpack 输出文件的大小</li>\n<li>使用动态 import，懒加载 React 组件</li>\n<li>使用 Tree Shaking &amp; 教程 &amp; Tree Shaking 优化</li>\n</ul>\n<p>9、有 用 过 lerna 吗 ？ 多 个 项 目 之 间 共 用 的 东 西 怎 么 共 享 ？</p>\n<p>10、使用 react 中，有没有遇到觉得比较难的点？是什么？</p>\n<p>11、使用 hooks 中遇到过哪些坑？为什么？</p>\n<ul>\n<li>不要在循环，条件或嵌套函数中调用Hook，必须始终在React函数的顶层使用Hook。这是因为React需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子函数。一旦在循环或条件分支语句中调用Hook，就容易导致调用顺序的不一致性。</li>\n<li>使用useState时候，使用push，pop，splice等直接更改数组对象的坑，应该采用析构方式.</li>\n<li>必包带来的坑,因为每次 render 都有一份新的状态，因此上述代码中的 setTimeout 使用产生了一个闭包，捕获了每次 render 后的 state，也就导致了输出了 0、1、2。如果你希望输出的内容是最新的 state 的话，可以通过 useRef 来保存 state。前文讲过 ref 在组件中只存在一份，无论何时使用它的引用都不会产生变化，因此可以来解决闭包引发的问题。</li>\n</ul>\n<h2 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h2><p>1、Vue如何监听数组的变化？</p>\n<ul>\n<li>对象数据是怎么被监听的?</li>\n</ul>\n<p>vue2.x版本中，数据监听用 Object.defineProperty. 通过Object.defineProperty来劫持对象属性的setter和getter操作，并创建一个监听器，当数据发生变化的时候发出通知</p>\n<ul>\n<li>数组数据是怎么被监听的?</li>\n</ul>\n<p>Vue.js是基于Object.defineProperty对对象实现“响应式化”，而对于数组，Vue.js提供的方法是重写push、pop、shift、unshift、splice、sort、reverse这七个数组方法.</p>\n<p>如果需要用数组下标修改数组并实现响应式数据变化，Vue.js提供了$set()及$remove()方法。</p>\n<p>1、Vue 组件 data 为什么必须是函数？</p>\n<blockquote>\n<p>因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染。<br>所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。</p>\n</blockquote>\n<p>2、直接给一个数组项赋值，Vue 能检测到变化吗？</p>\n<p>由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。</p>\n<ul>\n<li>Vue 不能检测到以下数组的变动:</li>\n</ul>\n<p>1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 解决办法</span>\nvm.$set(vm.items, indexOfItem, newValue)</code></pre></div>\n\n<p>2.当你修改数组的长度时，例如：vm.items.length = newLength</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\">/ 解决办法\nvm.items.splice(newLength)</code></pre></div>\n\n<ul>\n<li>检测不到的原因是什么？</li>\n</ul>\n<p>当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。</p>\n<p>但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的 $set。</p>\n<p>3、vue2 中响应式（双向绑定）的原理？vue3 的原理？<br>Proxy 与 Object.defineProperty 的优劣对比?<br>为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？</p>\n<blockquote>\n<p>Proxy的优势如下:<br>Proxy 可以直接监听对象而非属性<br>Proxy 可以直接监听数组的变化<br>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的<br>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改<br>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利</p>\n<p>Object.defineProperty 的优势如下:</p>\n<p>兼容性好,支持 IE9</p>\n</blockquote>\n<p>4、vuex 的工作流程是怎么样？</p>\n<blockquote>\n<p>Vuex有5个重要的属性，分别是 State、Getter、Mutation、Action、Module，由 view 层发起一个 Action 给 Mutation，在 Mutation 中修改状态，返回新的状态，通过 Getter暴露给 view层的组件或者页面，页面监测到状态改变于是更新页面。</p>\n</blockquote>\n<p>4、Vue 的初始化过程（new Vue(options)）都做了什么？</p>\n<p>处理组件配置项</p>\n<p>初始化根组件时进行了选项合并操作，将全局配置合并到根组件的局部配置上</p>\n<p>初始化每个子组件时做了一些性能优化，将组件配置对象上的一些深层次属性放到 vm.$options 选项中，以提高代码的执行效率</p>\n<p>初始化组件实例的关系属性，比如 $parent、$children、$root、$refs 等</p>\n<p>处理自定义事件</p>\n<p>调用 beforeCreate 钩子函数</p>\n<p>初始化组件的 inject 配置项，得到 ret[key] = val 形式的配置对象，然后对该配置对象进行响应式处理，并代理每个 key 到 vm 实例上</p>\n<p>数据响应式，处理 props、methods、data、computed、watch 等选项</p>\n<p>解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上，如果 provide 是函数就用 call(vm) 方法 返回 provide 里面定义的对象</p>\n<p>调用 created 钩子函数</p>\n<p>如果发现配置项上有 el 选项，则自动调用 $mount 方法，也就是说有了 el 选项，就不需要再手动调用 $mount 方法，反之，没提供 el 选项则必须调用 $mount</p>\n<p>接下来则进入挂载阶段</p>\n<p>4、beforeCreate 期间能拿到数据吗？</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs mipsasm\">不能，因为数据初始化阶段是在 <span class=\"hljs-keyword\">beforeCreate </span>之后执行</code></pre></div>\n\n<p>4、Vue nextTick使用场景及实现原理</p>\n<p>它主要是处理我们再变更完数据以后，无法立刻拿到最新的DOM节点对象的问题。</p>\n<p>vue执行完渲染后会执行this.nextTick()里面的callback函数。</p>\n<p>将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。</p>\n<p>nextTick流程总结：<br>1、将回调放到callbacks里等待执行；<br>2、将执行函数（flushCallbacks）放到微任务或宏任务里；原码里按照是否原生支持Promise.then、MutationObserver和setImmediate的顺序决策，都不支持则使用setTimeout<br>3、等到事件循环执行到微任务或者宏任务时，执行函数依次执行callbacks里的回调；</p>\n<p>5、Vue的nextTick具体是微任务还是宏任务?</p>\n<table>\n<thead>\n<tr>\n<th>宏任务</th>\n<th>微任务</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>setTimeout</td>\n<td>process.nextTick</td>\n</tr>\n<tr>\n<td>setInterval</td>\n<td>MutationObserver</td>\n</tr>\n<tr>\n<td>setImmediate</td>\n<td>Promise.then</td>\n</tr>\n<tr>\n<td>requestAnimationFrame</td>\n<td></td>\n</tr>\n<tr>\n<td>MessageChannel</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>5、 Vue3 有哪些新的新特性？</p>\n<ul>\n<li>响应式系统</li>\n<li>自定义渲染器</li>\n<li>全部模块使用 TS 重构</li>\n<li>Composition API 组合语法</li>\n<li>新一代工程化工具 Vite</li>\n</ul>\n<p>6、Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</p>\n<p>vue2 问题：</p>\n<ul>\n<li><p>代码的可读性随着组件变大而变差</p>\n</li>\n<li><p>每一种代码复用的方式，都存在缺点</p>\n</li>\n<li><p>TypeScript支持有限</p>\n</li>\n<li><p>逻辑组织</p>\n<ul>\n<li>大型组件, 需要不断跳转代码块</li>\n<li>逻辑关注点相关的代码全都放在一个函数里</li>\n</ul>\n</li>\n<li><p>逻辑复用</p>\n<ul>\n<li>vue2 用 mixin去复用相同的逻辑, 我们一个组件混入大量不同的 mixins 的时候,命名冲突,数据来源不清</li>\n<li>vue3 写 hook 函数</li>\n</ul>\n</li>\n</ul>\n<p>6、父组件可以监听到子组件的生命周期吗？</p>\n<p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理。</p>\n<p>方法一：手动通过 $emit 触发父组件的事件</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Parent.vue</span>\n&lt;Child @mounted=<span class=\"hljs-string\">&quot;doSomething&quot;</span>/&gt;\n    \n<span class=\"hljs-comment\">// Child.vue</span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">mounted</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n  <span class=\"hljs-built_in\">this</span>.$emit(<span class=\"hljs-string\">&quot;mounted&quot;</span>);\n&#125;</code></pre></div>\n\n<p>方法二：父组件引用子组件时通过 @hook 来监听</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//  Parent.vue</span>\n&lt;Child @hook:mounted=<span class=\"hljs-string\">&quot;doSomething&quot;</span> &gt;&lt;/Child&gt;\n    \n<span class=\"hljs-comment\">//  Child.vue</span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">mounted</span>(<span class=\"hljs-params\"></span>)</span>&#123;\n   <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;子组件触发 mounted 钩子函数 ...&#x27;</span>);\n&#125;,</code></pre></div>\n\n<p>@hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p>\n<p>7、比较 Vue 和 React 两个框架，你觉得有哪些区别？</p>\n<ul>\n<li><p>监听数据变化的实现原理不同:</p>\n<p>  Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化.<br>  react 中，数据变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化。</p>\n</li>\n<li><p>数据流的不同:</p>\n</li>\n<li><p>模板渲染方式的不同:</p>\n</li>\n</ul>\n<p>8、什么是异步组件？</p>\n<p>在声明或注册组件时，Vue 接受提供 Promise 的工厂函数。然后可以在调用该组件时对其进行“解析”。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n    <span class=\"hljs-attr\">components</span>: &#123;\n        ‘tweet-box’: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">import</span>(‘./components/<span class=\"hljs-keyword\">async</span>/TweetBox’)\n    &#125;\n&#125;);</code></pre></div>\n\n<h2 id=\"http\"><a href=\"#http\" class=\"headerlink\" title=\"http\"></a>http</h2><p>1、HTTP有哪些请求方法？PUT 和 PATCH 有什么区别？</p>\n<ul>\n<li>GET, POST 和 HEAD方法；OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT</li>\n<li>PUT和PATCH都是更新资源，而PATCH用来对资源进行局部更新。</li>\n</ul>\n<p>2、http 状态码 403 是什么错误？</p>\n<ul>\n<li>403 forbidden，表示对请求资源的访问被服务器拒绝</li>\n</ul>\n<p>3、知道哪些 http 的缓存策略 ？控制缓存的请求头有哪些？</p>\n<ul>\n<li>HTTP缓存机制分为强制缓存和协商缓存两类。</li>\n<li>强制缓存的意思就是不要问了(不发起请求)，直接用缓存吧。</li>\n<li>强制缓存常见技术有Expires和Cache-Control。</li>\n<li>Expires的值是一个时间，表示这个时间前缓存都有效，都不需要发起请求。</li>\n<li>Cache-Control有很多属性值，常用属性max-age设置了缓存有效的时间长度，单位为秒，这个时间没到，都不用发起请求。</li>\n<li>immutable也是Cache-Control的一个属性，表示这个资源这辈子都不用再请求了，但是他兼容性不好，Cache-Control其他属性可以参考MDN的文档。</li>\n<li>Cache-Control的max-age优先级比Expires高。</li>\n<li>协商缓存是为了知道有没有更新，必须跟服务端沟通过才知道的。常见技术有ETag和Last-Modified。</li>\n<li>ETag其实就是给资源算一个hash值或者版本号，对应的常用request header为If-None-Match。</li>\n<li>Last-Modified其实就是加上资源修改的时间，对应的常用request header为If-Modified-Since，精度为秒。</li>\n<li>ETag每次修改都会改变，而Last-Modified的精度只到秒，所以ETag更准确，优先级更高，但是需要计算，所以服务端开销更大。</li>\n<li>强制缓存和协商缓存都存在的情况下，先判断强制缓存是否生效，如果生效，不用发起请求，直接用缓存。如果强制缓存不生效再发起请求判断协商缓存。</li>\n</ul>\n<blockquote>\n<p>Cache-Control，ETag，Last-Modified</p>\n</blockquote>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ol>\n<li>什 么 是 TS 泛 型 ？</li>\n<li>webpack 构 建 流 程 是 怎 样 的 ？</li>\n<li>webpack loade r 和 plugin 的 原 理 和 区 别 ？</li>\n<li>webpack 热 更 新 原 理 ？</li>\n<li>有没有读过哪些源码？</li>\n<li>最近开发的项目具体业务是怎么样的？介绍一下？</li>\n</ol>\n<h2 id=\"Devops-相关\"><a href=\"#Devops-相关\" class=\"headerlink\" title=\"Devops 相关\"></a>Devops 相关</h2><h2 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h2><p>1、什么情况下使用 git rebase, 而不用 git merge</p>\n<h3 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h3><ol>\n<li>谈谈一下对 nginx 的理解，项目中用到 nginx 的哪些功能？</li>\n</ol>\n<ul>\n<li>Nginx ，是一个 Web 服务器和反向代理服务器用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。</li>\n<li>主要功能如下：<br>  正向、反向代理 2、负载均衡、分流 3、虚拟主机（绑定host）</li>\n</ul>\n<p>2、正向代理和反向代理区别是什么？</p>\n<ul>\n<li>正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定原始服务器，然后代理向原始服务器转交请求并将获得的内容返回给客户端。代理服务器和客户端处于同一个局域网内。</li>\n<li>比如说fanqiang。我知道我要访问谷歌，于是我就告诉代理服务器让它帮我转发。</li>\n<li>反向代理实际运行方式是代理服务器接受网络上的连接请求。它将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给网络上请求连接的客户端 。代理服务器和原始服务器处于同一个局域网内。</li>\n<li>比如说我要访问taobao，对我来说不知道图片、json、css 是不是同一个服务器返回回来的，但是我不关心，是反向代理 处理的，我不知道原始服务器。</li>\n</ul>\n<p>3、nginx 如何来实现负载均衡？</p>\n<p>负载均衡的5种策略:</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">\n 1.轮询（默认）\n 每个请求按时间顺序逐一分配到不同的后端服务器\n\n upstream backserver &#123;\n    server 192.168.0.14;\n    server 192.168.0.15;\n&#125;\n\n2.weight\n指定轮询几率，weight和访问概率成正比\n\nupstream backserver &#123;\n    server 192.168.0.14 weight=3;\n    server 192.168.0.15 weight=7;\n&#125;\n\n3.ip_hash\n已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的.ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。\n\nupstream backserver &#123;\n    ip_hash;\n    server 192.168.0.14:88;\n    server 192.168.0.15:80;\n&#125;\n\n4.fair\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n\nupstream backserver &#123;\n    server server1;\n    server server2;\n    fair;\n&#125;\n\n5.url_hash\n按访问url的<span class=\"hljs-built_in\">hash</span>结果来分配请求，使每个url定向到同一个（对应的）后端服务器，后端服务器为缓存时比较有效。\n\nupstream backserver &#123;\n    server squid1:3128;\n    server squid2:3128;\n    <span class=\"hljs-built_in\">hash</span> <span class=\"hljs-variable\">$request_uri</span>;\n    hash_method crc32;\n&#125;</code></pre></div>\n\n<h3 id=\"docker\"><a href=\"#docker\" class=\"headerlink\" title=\"docker\"></a>docker</h3><p>1、什么是 Docker？</p>\n<ul>\n<li>Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。</li>\n</ul>\n<p>2、Dockerfile中最常见的指令是什么？</p>\n<ul>\n<li>FROM：指定基础镜像；LABEL：功能是为镜像指定标签；RUN：运行指定的命令；CMD：容器启动时要运行的命令。</li>\n</ul>\n<p>3、docker 构建镜像多大，如何优化？</p>\n<ul>\n<li>使用轻量级基础镜像,如 Alpine</li>\n<li>多阶段构建</li>\n</ul>\n<p>4、 CI 中前端镜像每次构建都很慢，甚至有时候失败，如何解决？</p>\n<ul>\n<li>合理分层，利用构建镜像缓存机制</li>\n<li>失败，检查是否安装依赖超时，修改 npm timeout</li>\n</ul>\n<h3 id=\"k8s\"><a href=\"#k8s\" class=\"headerlink\" title=\"k8s\"></a>k8s</h3><p>1、k8s是什么？请说出你的了解？</p>\n<ul>\n<li>Kubernetes 是一个针对容器应用，进行自动部署，弹性伸缩和管理的开源系统。主要功能是生产环境中的容器编排。</li>\n</ul>\n<p>2、k8s 集群里面最小的单位是什么？</p>\n<ul>\n<li>pod 是最小单位。每个pod里边可以运行一个或多个container（容器）</li>\n</ul>\n<p>3、Service这种资源对象的作用是什么？</p>\n<ul>\n<li>用来给相同的多个pod对象提供一个固定的统一访问接口，常用于服务发现和服务访问。</li>\n</ul>\n<h3 id=\"openstack\"><a href=\"#openstack\" class=\"headerlink\" title=\"openstack\"></a>openstack</h3><p>1、openstack 里 KeyStone 组件是用于提供什么服务的？Nova 组件是做什么用？</p>\n<ul>\n<li>认证服务（KeyStone）<br>Nova – 用于在计算级别管理虚拟机，并在计算或管理程序级别执行其他计算任务。</li>\n</ul>\n","site":{"data":{}},"wordcount":11941,"excerpt":"","more":"<h2 id=\"JS\"><a href=\"#JS\" class=\"headerlink\" title=\"JS\"></a>JS</h2><p>1、请你讲一下闭包?</p>\n<blockquote>\n<p>简单：闭包是有权限访问其他函数作用域内的变量的一个函数。</p>\n<p>完整：由于在JS中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之回收，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数——也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后作用域内的值也不会被销毁。</p>\n</blockquote>\n<ul>\n<li>闭包解决了什么？</li>\n</ul>\n<blockquote>\n<p>由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。以平时使用的Ajax成功回调为例，这里其实就是个闭包，由于上述的特性，回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。开发者不用去写钩子函数来操作上级函数作用域内部的变量了。</p>\n</blockquote>\n<ul>\n<li>闭包有哪些应用场景?</li>\n</ul>\n<blockquote>\n<p>闭包随处可见，一个Ajax请求的成功回调，一个事件绑定的回调方法，一个setTimeout的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。</p>\n</blockquote>\n<ul>\n<li>react hooks 中的 闭包陷阱问题如何解决？</li>\n</ul>\n<p>不管在这个组件中的其他地方使用 setCount 将 count 设置为任何值，还是设置多少次，打印的都是1</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>)</span>&#123;\n    <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">1</span>);\n    useEffect(<span class=\"hljs-function\">()=&gt;</span>&#123;\n        <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">()=&gt;</span>&#123;\n            <span class=\"hljs-built_in\">console</span>.log(count)\n        &#125;, <span class=\"hljs-number\">1000</span>)\n    &#125;, [])\n&#125;</code></pre>\n\n<p>useRef</p>\n<p>useState 更新值时传入回调函数</p>\n<p>2、介绍一下 JS 里面的原型？</p>\n<blockquote>\n<p>每个对象都有一个 prototype 属性，就是原型，是一个对象，叫原型对象。</p>\n</blockquote>\n<ul>\n<li>原型的作用是什么？</li>\n</ul>\n<blockquote>\n<p>共享方法</p>\n</blockquote>\n<ul>\n<li>原型中this的指向是什么？</li>\n</ul>\n<blockquote>\n<p>原型中this的指向是实例。</p>\n</blockquote>\n<ul>\n<li>说一下平时开发使用到 prototype 的例子？</li>\n</ul>\n<p>3、如何理解 es6 class 中 constructor 方法？ 和 super的作用？</p>\n<blockquote>\n<p>constructor 方法是类的构造函数。<br>通过 new 命令创建对象实例时，自动调用该方法。<br>constructor 内定义的方法是 实例方法；class 内直接定义的方法是原型方法。</p>\n</blockquote>\n<ul>\n<li>super 的作用？</li>\n</ul>\n<p>子类是没有自己的 this 对象的，它只能继承自父类的 this 对象，然后对其进行加工，而super( )就是将父类中的this对象继承给子类的。没有 super，子类就得不到 this 对象。</p>\n<ul>\n<li>为什么要传入 props？</li>\n</ul>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Component</span> </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;\n    <span class=\"hljs-built_in\">this</span>.props = props;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;\n&#125;</code></pre>\n\n<p>确保了 this.props 在构造函数执行完毕之前已被赋值。</p>\n<p>4、eventloop</p>\n<p>浏览器或node 端 js 单线程运行时不会阻塞的一种机制。</p>\n<p>任务分为宏任务和微任务；</p>\n<p>宏任务：script全部代码、setTimeout、setInterval、I/O、UI Rendering。<br>微任务：Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver</p>\n<ul>\n<li>浏览器中的 event loop</li>\n</ul>\n<p>JS 中有一个主线程和一个调用栈（执行栈），所有的任务都会被放到调用栈中等待主线程执行。</p>\n<p>JS 调用栈后进先出原则，当函数执行的时候，会被添加到栈顶部，当执行完后，会被从栈顶移出，直到栈内被清空。</p>\n<p>JS 任务分为同步任务和异步任务。同步任务在调用栈中按照顺序等待主线程依次执行。异步任务会在异步任务有结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），读取到栈内等待主线程执行。</p>\n<p>任务队列：先进先出</p>\n<p>顺序：同步任务 =》微任务 =》 宏任务</p>\n<ul>\n<li>执行栈在执行完同步任务后，查看执行栈是否为空</li>\n<li>如果执行栈为空，就会去检查微任务(microTask)队列, 执行完微任务，再执行宏任务</li>\n<li>每个宏任务执行完后，都会再检查微任务队列是否为空，不为空，就按先进先出执行完微任务，设置微任务为 null，再执行宏任务。</li>\n</ul>\n<p>Node 中 event loop(待补充)</p>\n<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><p>1、介绍一下react diff 算法 的工作原理？</p>\n<ul>\n<li><p>react 状态变化渲染页面时，不会马上对DOM节点进行操作，是先通过diff算法计算后，再对有变化的DOM节点进行操作。</p>\n</li>\n<li><p>diff算法就是更高效地通过对比新旧Virtual DOM来找出真正的Dom变化之处.</p>\n</li>\n<li><p>react中diff算法主要遵循三个层级的策略:tree层级、conponent 层级、element 层级</p>\n</li>\n<li><p>tree层级: DOM节点跨层级的操作不做优化，只会对相同层级的节点进行比较.只有删除、创建操作.新树中，R节点下没有了A，那么直接删除A，在D节点下创建A以及下属节点。</p>\n</li>\n<li><p>conponent层级:是同一个组件，则会继续往下diff运算，如果不是一个类的组件，那么直接删除这个组件下的所有子节点，创建新的</p>\n</li>\n<li><p>element层级:对于比较同一层级的节点们，每个节点在对应的层级用唯一的key作为标识.</p>\n<ul>\n<li>3 种节点操作，分别为 INSERT_MARKUP(插入)、MOVE_EXISTING (移动)和 REMOVE_NODE (删除)</li>\n<li>通过key可以准确地发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置</li>\n<li>如果当前节点在新集合中的位置比老集合中的位置靠前的话，是不会影响后续节点操作的，这里这时候被动字节不用动</li>\n<li>当ABCD节点比较完成后，diff过程还没完，还会整体遍历老集合中节点，看有没有没用到的节点，有的话，就删除</li>\n</ul>\n</li>\n</ul>\n<p>由于dom节点的移动操作开销是比较昂贵的，没有key的情况下要比有key的性能更好</p>\n<pre><code class=\"hljs HTML\">1.加key\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;1&#x27;</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;1&#x27;</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>     \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;2&#x27;</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;3&#x27;</span>&gt;</span>3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;3&#x27;</span>&gt;</span>3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  ========&gt;  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;2&#x27;</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;4&#x27;</span>&gt;</span>4<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;5&#x27;</span>&gt;</span>5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;5&#x27;</span>&gt;</span>5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;6&#x27;</span>&gt;</span>6<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n操作：节点2移动至下标为2的位置，新增节点6至下标为4的位置，删除节点4。\n\n2.不加key\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>     \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  ========&gt;  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>4<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>6<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span> \n操作：修改第1个到第5个节点的innerText</code></pre>\n\n<p>Virtual DOM 工作过程有：</p>\n<pre><code>1. state 变化，生成新的 Virtual Dom\n2. 比较 Virtual Dom 与之前 Virtual Dom 的异同\n3. 生成差异对象\n4. 遍历差异对象并更新真实 DOM\n</code></pre>\n<ul>\n<li>React diff 算法 和 vue diff 的相同点和不同点有哪些？</li>\n</ul>\n<p>不同点：</p>\n<ul>\n<li>vue的列表比对，采用从两端到中间的比对方式，而react则采用从左到右依次比对的方式。当一个集合，只是把最后一个节点移动到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移动到第一个</li>\n<li>vue比对节点，当节点元素类型相同，但是className不同，认为是不同类型元素，删除重建，而react会认为是同类型节点，只是修改节点属性</li>\n</ul>\n<p>Vue Diff使用双向链表，边对比，边更新DOM。React主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。</p>\n<p>相同点：</p>\n<ul>\n<li>虚拟DOM在比较时只比较同一层级节点，复杂度都为 O(n)，降低了算法复杂度；</li>\n<li>都使用key比较是否是相同节点，都是为了尽可能的复用节点</li>\n<li>都是操作虚拟DOM，最小化操作真实DOM，提高性能（其实虚拟DOM的优势 并不是在于它操作DOM快）</li>\n<li>都是不要用 index作为 key</li>\n</ul>\n<p>2、react 里什么是高阶组件？使用高阶组件的场景？</p>\n<blockquote>\n<p>高阶组件(HOC)是接受一个组件并返回一个新组件的函数。</p>\n</blockquote>\n<p>2、React setState 怎么获取到更新后的值?异步函数中为什么 setState 会立即更新?</p>\n<p>3、useState 为什么不能放到条件语句里面?</p>\n<p>React通过单链表来管理Hooks。<br>update 阶段，每次调用 useState，链表就会执行 next 向后移动一步。如果将 useState 写在条件判断中，假设条件判断不成立，没有执行里面的 useState 方法，会导致接下来所有的 useState 的取值出现偏移，从而导致异常发生。</p>\n<p>4、说一下 useRef 有哪些用法？</p>\n<blockquote>\n<p>useRef 除了获取 dom，另一个用法：<br>保存数据，不造成 rerender<br>想要保存数据，又不想触发函数的更新，该数据的更新不会造成组件 rerender</p>\n</blockquote>\n<p>5、什么情况下使用 useCallback ？<br>子组件接收一个方法，避免子组件重复渲染</p>\n<ul>\n<li>react 中只要父组件的 render 了，那么默认情况下就会触发子组的 render，react 提供了来避免这种重渲染的性能开销的一些方法：React.PureComponent、React.memo ，shouldComponentUpdate()</li>\n<li>使用 React.memo 避免子组件做没必要的渲染。</li>\n<li>Reace.memo 只会对 props 做浅比较，也就是父组件重新 render 之后会传入 不同引用的方法 getList，浅比较之后不相等，导致子组件还是依然会渲染。</li>\n<li>useCallback 缓存一个函数，当依赖没有改变的时候，会一直返回同一个引用</li>\n</ul>\n<p>6、useCallback 与 useMemo 作用用来缓存，两者的区别是什么？</p>\n<blockquote>\n<p>useMemo 缓存值；useCallback 缓存函数</p>\n</blockquote>\n<p>注意不要滥用：</p>\n<p>经常用在以下两种场景（要保持引用相等；对于组件内部用到的 object、array、函数等，如果用在了其他 Hook 的依赖数组中，或者作为 props 传递给了下游组件，应该使用 useMemo/useCallback）</p>\n<p>7、react ssr 实现原理？react ssr 是在什么场景下做的？</p>\n<p>server端接收到客户端的请求路由后，查找对应的数据，以props、context、store的形式注入组件中。然后基于react提供的API：renderToString将组件转换为html字符串输出到客户端。客户端使用该数据进行渲染，保证数据的一致性。</p>\n<p>React SSR之所以能够实现，本质是虚拟 DOM的存在。判断环境是服务器环境，可以操作 JavaScript 对象，把虚拟 DOM 映射成字符串输出。判断环境是客户端环境，可以操作 JavaScript 对象，将虚拟 DOM 映射成真实 DOM ，完成页面挂载。</p>\n<p>8、 react 项目里做过哪些性能优化？</p>\n<p>代码层面：</p>\n<ul>\n<li>使用return null而不是CSS的display:none来控制节点的显示隐藏。保证同一时间页面的DOM节点尽可能的少。</li>\n<li>props和state的数据尽可能简单明了，扁平化。</li>\n<li>不要使用数组下标作为key</li>\n<li>利用 shouldComponentUpdate 和 PureComponent 避免过多 render function</li>\n<li>render里面尽量减少新建变量和bind函数，传递参数是尽量减少传递参数的数量。</li>\n<li>尽量将 props 和 state 扁平化，只传递 component 需要的 props（传得太多，或者层次传得太深，都会加重shouldComponentUpdate里面的数据比较负担），慎将 component 当作 props 传入</li>\n</ul>\n<p>代码体积优化:</p>\n<ul>\n<li>使用 babel-plugin-import 优化业务组件的引入，实现按需加载</li>\n<li>使用 生产版本</li>\n<li>使用 SplitChunksPlugin 拆分公共代码</li>\n<li>分析 CSS 和 JS 代码覆盖率</li>\n<li>优化 Webpack 中的库</li>\n<li>使用动态 import，懒加载 React 组件</li>\n<li>使用 webpack-bundle-analyzer 可视化 webpack 输出文件的大小</li>\n<li>使用动态 import，懒加载 React 组件</li>\n<li>使用 Tree Shaking &amp; 教程 &amp; Tree Shaking 优化</li>\n</ul>\n<p>9、有 用 过 lerna 吗 ？ 多 个 项 目 之 间 共 用 的 东 西 怎 么 共 享 ？</p>\n<p>10、使用 react 中，有没有遇到觉得比较难的点？是什么？</p>\n<p>11、使用 hooks 中遇到过哪些坑？为什么？</p>\n<ul>\n<li>不要在循环，条件或嵌套函数中调用Hook，必须始终在React函数的顶层使用Hook。这是因为React需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子函数。一旦在循环或条件分支语句中调用Hook，就容易导致调用顺序的不一致性。</li>\n<li>使用useState时候，使用push，pop，splice等直接更改数组对象的坑，应该采用析构方式.</li>\n<li>必包带来的坑,因为每次 render 都有一份新的状态，因此上述代码中的 setTimeout 使用产生了一个闭包，捕获了每次 render 后的 state，也就导致了输出了 0、1、2。如果你希望输出的内容是最新的 state 的话，可以通过 useRef 来保存 state。前文讲过 ref 在组件中只存在一份，无论何时使用它的引用都不会产生变化，因此可以来解决闭包引发的问题。</li>\n</ul>\n<h2 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h2><p>1、Vue如何监听数组的变化？</p>\n<ul>\n<li>对象数据是怎么被监听的?</li>\n</ul>\n<p>vue2.x版本中，数据监听用 Object.defineProperty. 通过Object.defineProperty来劫持对象属性的setter和getter操作，并创建一个监听器，当数据发生变化的时候发出通知</p>\n<ul>\n<li>数组数据是怎么被监听的?</li>\n</ul>\n<p>Vue.js是基于Object.defineProperty对对象实现“响应式化”，而对于数组，Vue.js提供的方法是重写push、pop、shift、unshift、splice、sort、reverse这七个数组方法.</p>\n<p>如果需要用数组下标修改数组并实现响应式数据变化，Vue.js提供了$set()及$remove()方法。</p>\n<p>1、Vue 组件 data 为什么必须是函数？</p>\n<blockquote>\n<p>因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染。<br>所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。</p>\n</blockquote>\n<p>2、直接给一个数组项赋值，Vue 能检测到变化吗？</p>\n<p>由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。</p>\n<ul>\n<li>Vue 不能检测到以下数组的变动:</li>\n</ul>\n<p>1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 解决办法</span>\nvm.$set(vm.items, indexOfItem, newValue)</code></pre>\n\n<p>2.当你修改数组的长度时，例如：vm.items.length = newLength</p>\n<pre><code class=\"hljs js\">/ 解决办法\nvm.items.splice(newLength)</code></pre>\n\n<ul>\n<li>检测不到的原因是什么？</li>\n</ul>\n<p>当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。</p>\n<p>但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的 $set。</p>\n<p>3、vue2 中响应式（双向绑定）的原理？vue3 的原理？<br>Proxy 与 Object.defineProperty 的优劣对比?<br>为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？</p>\n<blockquote>\n<p>Proxy的优势如下:<br>Proxy 可以直接监听对象而非属性<br>Proxy 可以直接监听数组的变化<br>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的<br>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改<br>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利</p>\n<p>Object.defineProperty 的优势如下:</p>\n<p>兼容性好,支持 IE9</p>\n</blockquote>\n<p>4、vuex 的工作流程是怎么样？</p>\n<blockquote>\n<p>Vuex有5个重要的属性，分别是 State、Getter、Mutation、Action、Module，由 view 层发起一个 Action 给 Mutation，在 Mutation 中修改状态，返回新的状态，通过 Getter暴露给 view层的组件或者页面，页面监测到状态改变于是更新页面。</p>\n</blockquote>\n<p>4、Vue 的初始化过程（new Vue(options)）都做了什么？</p>\n<p>处理组件配置项</p>\n<p>初始化根组件时进行了选项合并操作，将全局配置合并到根组件的局部配置上</p>\n<p>初始化每个子组件时做了一些性能优化，将组件配置对象上的一些深层次属性放到 vm.$options 选项中，以提高代码的执行效率</p>\n<p>初始化组件实例的关系属性，比如 $parent、$children、$root、$refs 等</p>\n<p>处理自定义事件</p>\n<p>调用 beforeCreate 钩子函数</p>\n<p>初始化组件的 inject 配置项，得到 ret[key] = val 形式的配置对象，然后对该配置对象进行响应式处理，并代理每个 key 到 vm 实例上</p>\n<p>数据响应式，处理 props、methods、data、computed、watch 等选项</p>\n<p>解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上，如果 provide 是函数就用 call(vm) 方法 返回 provide 里面定义的对象</p>\n<p>调用 created 钩子函数</p>\n<p>如果发现配置项上有 el 选项，则自动调用 $mount 方法，也就是说有了 el 选项，就不需要再手动调用 $mount 方法，反之，没提供 el 选项则必须调用 $mount</p>\n<p>接下来则进入挂载阶段</p>\n<p>4、beforeCreate 期间能拿到数据吗？</p>\n<pre><code class=\"hljs mipsasm\">不能，因为数据初始化阶段是在 <span class=\"hljs-keyword\">beforeCreate </span>之后执行</code></pre>\n\n<p>4、Vue nextTick使用场景及实现原理</p>\n<p>它主要是处理我们再变更完数据以后，无法立刻拿到最新的DOM节点对象的问题。</p>\n<p>vue执行完渲染后会执行this.nextTick()里面的callback函数。</p>\n<p>将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。</p>\n<p>nextTick流程总结：<br>1、将回调放到callbacks里等待执行；<br>2、将执行函数（flushCallbacks）放到微任务或宏任务里；原码里按照是否原生支持Promise.then、MutationObserver和setImmediate的顺序决策，都不支持则使用setTimeout<br>3、等到事件循环执行到微任务或者宏任务时，执行函数依次执行callbacks里的回调；</p>\n<p>5、Vue的nextTick具体是微任务还是宏任务?</p>\n<table>\n<thead>\n<tr>\n<th>宏任务</th>\n<th>微任务</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>setTimeout</td>\n<td>process.nextTick</td>\n</tr>\n<tr>\n<td>setInterval</td>\n<td>MutationObserver</td>\n</tr>\n<tr>\n<td>setImmediate</td>\n<td>Promise.then</td>\n</tr>\n<tr>\n<td>requestAnimationFrame</td>\n<td></td>\n</tr>\n<tr>\n<td>MessageChannel</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>5、 Vue3 有哪些新的新特性？</p>\n<ul>\n<li>响应式系统</li>\n<li>自定义渲染器</li>\n<li>全部模块使用 TS 重构</li>\n<li>Composition API 组合语法</li>\n<li>新一代工程化工具 Vite</li>\n</ul>\n<p>6、Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</p>\n<p>vue2 问题：</p>\n<ul>\n<li><p>代码的可读性随着组件变大而变差</p>\n</li>\n<li><p>每一种代码复用的方式，都存在缺点</p>\n</li>\n<li><p>TypeScript支持有限</p>\n</li>\n<li><p>逻辑组织</p>\n<ul>\n<li>大型组件, 需要不断跳转代码块</li>\n<li>逻辑关注点相关的代码全都放在一个函数里</li>\n</ul>\n</li>\n<li><p>逻辑复用</p>\n<ul>\n<li>vue2 用 mixin去复用相同的逻辑, 我们一个组件混入大量不同的 mixins 的时候,命名冲突,数据来源不清</li>\n<li>vue3 写 hook 函数</li>\n</ul>\n</li>\n</ul>\n<p>6、父组件可以监听到子组件的生命周期吗？</p>\n<p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理。</p>\n<p>方法一：手动通过 $emit 触发父组件的事件</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Parent.vue</span>\n&lt;Child @mounted=<span class=\"hljs-string\">&quot;doSomething&quot;</span>/&gt;\n    \n<span class=\"hljs-comment\">// Child.vue</span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">mounted</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n  <span class=\"hljs-built_in\">this</span>.$emit(<span class=\"hljs-string\">&quot;mounted&quot;</span>);\n&#125;</code></pre>\n\n<p>方法二：父组件引用子组件时通过 @hook 来监听</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">//  Parent.vue</span>\n&lt;Child @hook:mounted=<span class=\"hljs-string\">&quot;doSomething&quot;</span> &gt;&lt;/Child&gt;\n    \n<span class=\"hljs-comment\">//  Child.vue</span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">mounted</span>(<span class=\"hljs-params\"></span>)</span>&#123;\n   <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;子组件触发 mounted 钩子函数 ...&#x27;</span>);\n&#125;,</code></pre>\n\n<p>@hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p>\n<p>7、比较 Vue 和 React 两个框架，你觉得有哪些区别？</p>\n<ul>\n<li><p>监听数据变化的实现原理不同:</p>\n<p>  Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化.<br>  react 中，数据变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化。</p>\n</li>\n<li><p>数据流的不同:</p>\n</li>\n<li><p>模板渲染方式的不同:</p>\n</li>\n</ul>\n<p>8、什么是异步组件？</p>\n<p>在声明或注册组件时，Vue 接受提供 Promise 的工厂函数。然后可以在调用该组件时对其进行“解析”。</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n    <span class=\"hljs-attr\">components</span>: &#123;\n        ‘tweet-box’: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">import</span>(‘./components/<span class=\"hljs-keyword\">async</span>/TweetBox’)\n    &#125;\n&#125;);</code></pre>\n\n<h2 id=\"http\"><a href=\"#http\" class=\"headerlink\" title=\"http\"></a>http</h2><p>1、HTTP有哪些请求方法？PUT 和 PATCH 有什么区别？</p>\n<ul>\n<li>GET, POST 和 HEAD方法；OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT</li>\n<li>PUT和PATCH都是更新资源，而PATCH用来对资源进行局部更新。</li>\n</ul>\n<p>2、http 状态码 403 是什么错误？</p>\n<ul>\n<li>403 forbidden，表示对请求资源的访问被服务器拒绝</li>\n</ul>\n<p>3、知道哪些 http 的缓存策略 ？控制缓存的请求头有哪些？</p>\n<ul>\n<li>HTTP缓存机制分为强制缓存和协商缓存两类。</li>\n<li>强制缓存的意思就是不要问了(不发起请求)，直接用缓存吧。</li>\n<li>强制缓存常见技术有Expires和Cache-Control。</li>\n<li>Expires的值是一个时间，表示这个时间前缓存都有效，都不需要发起请求。</li>\n<li>Cache-Control有很多属性值，常用属性max-age设置了缓存有效的时间长度，单位为秒，这个时间没到，都不用发起请求。</li>\n<li>immutable也是Cache-Control的一个属性，表示这个资源这辈子都不用再请求了，但是他兼容性不好，Cache-Control其他属性可以参考MDN的文档。</li>\n<li>Cache-Control的max-age优先级比Expires高。</li>\n<li>协商缓存是为了知道有没有更新，必须跟服务端沟通过才知道的。常见技术有ETag和Last-Modified。</li>\n<li>ETag其实就是给资源算一个hash值或者版本号，对应的常用request header为If-None-Match。</li>\n<li>Last-Modified其实就是加上资源修改的时间，对应的常用request header为If-Modified-Since，精度为秒。</li>\n<li>ETag每次修改都会改变，而Last-Modified的精度只到秒，所以ETag更准确，优先级更高，但是需要计算，所以服务端开销更大。</li>\n<li>强制缓存和协商缓存都存在的情况下，先判断强制缓存是否生效，如果生效，不用发起请求，直接用缓存。如果强制缓存不生效再发起请求判断协商缓存。</li>\n</ul>\n<blockquote>\n<p>Cache-Control，ETag，Last-Modified</p>\n</blockquote>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ol>\n<li>什 么 是 TS 泛 型 ？</li>\n<li>webpack 构 建 流 程 是 怎 样 的 ？</li>\n<li>webpack loade r 和 plugin 的 原 理 和 区 别 ？</li>\n<li>webpack 热 更 新 原 理 ？</li>\n<li>有没有读过哪些源码？</li>\n<li>最近开发的项目具体业务是怎么样的？介绍一下？</li>\n</ol>\n<h2 id=\"Devops-相关\"><a href=\"#Devops-相关\" class=\"headerlink\" title=\"Devops 相关\"></a>Devops 相关</h2><h2 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h2><p>1、什么情况下使用 git rebase, 而不用 git merge</p>\n<h3 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h3><ol>\n<li>谈谈一下对 nginx 的理解，项目中用到 nginx 的哪些功能？</li>\n</ol>\n<ul>\n<li>Nginx ，是一个 Web 服务器和反向代理服务器用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。</li>\n<li>主要功能如下：<br>  正向、反向代理 2、负载均衡、分流 3、虚拟主机（绑定host）</li>\n</ul>\n<p>2、正向代理和反向代理区别是什么？</p>\n<ul>\n<li>正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定原始服务器，然后代理向原始服务器转交请求并将获得的内容返回给客户端。代理服务器和客户端处于同一个局域网内。</li>\n<li>比如说fanqiang。我知道我要访问谷歌，于是我就告诉代理服务器让它帮我转发。</li>\n<li>反向代理实际运行方式是代理服务器接受网络上的连接请求。它将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给网络上请求连接的客户端 。代理服务器和原始服务器处于同一个局域网内。</li>\n<li>比如说我要访问taobao，对我来说不知道图片、json、css 是不是同一个服务器返回回来的，但是我不关心，是反向代理 处理的，我不知道原始服务器。</li>\n</ul>\n<p>3、nginx 如何来实现负载均衡？</p>\n<p>负载均衡的5种策略:</p>\n<pre><code class=\"hljs sh\">\n 1.轮询（默认）\n 每个请求按时间顺序逐一分配到不同的后端服务器\n\n upstream backserver &#123;\n    server 192.168.0.14;\n    server 192.168.0.15;\n&#125;\n\n2.weight\n指定轮询几率，weight和访问概率成正比\n\nupstream backserver &#123;\n    server 192.168.0.14 weight=3;\n    server 192.168.0.15 weight=7;\n&#125;\n\n3.ip_hash\n已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的.ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。\n\nupstream backserver &#123;\n    ip_hash;\n    server 192.168.0.14:88;\n    server 192.168.0.15:80;\n&#125;\n\n4.fair\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n\nupstream backserver &#123;\n    server server1;\n    server server2;\n    fair;\n&#125;\n\n5.url_hash\n按访问url的<span class=\"hljs-built_in\">hash</span>结果来分配请求，使每个url定向到同一个（对应的）后端服务器，后端服务器为缓存时比较有效。\n\nupstream backserver &#123;\n    server squid1:3128;\n    server squid2:3128;\n    <span class=\"hljs-built_in\">hash</span> <span class=\"hljs-variable\">$request_uri</span>;\n    hash_method crc32;\n&#125;</code></pre>\n\n<h3 id=\"docker\"><a href=\"#docker\" class=\"headerlink\" title=\"docker\"></a>docker</h3><p>1、什么是 Docker？</p>\n<ul>\n<li>Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。</li>\n</ul>\n<p>2、Dockerfile中最常见的指令是什么？</p>\n<ul>\n<li>FROM：指定基础镜像；LABEL：功能是为镜像指定标签；RUN：运行指定的命令；CMD：容器启动时要运行的命令。</li>\n</ul>\n<p>3、docker 构建镜像多大，如何优化？</p>\n<ul>\n<li>使用轻量级基础镜像,如 Alpine</li>\n<li>多阶段构建</li>\n</ul>\n<p>4、 CI 中前端镜像每次构建都很慢，甚至有时候失败，如何解决？</p>\n<ul>\n<li>合理分层，利用构建镜像缓存机制</li>\n<li>失败，检查是否安装依赖超时，修改 npm timeout</li>\n</ul>\n<h3 id=\"k8s\"><a href=\"#k8s\" class=\"headerlink\" title=\"k8s\"></a>k8s</h3><p>1、k8s是什么？请说出你的了解？</p>\n<ul>\n<li>Kubernetes 是一个针对容器应用，进行自动部署，弹性伸缩和管理的开源系统。主要功能是生产环境中的容器编排。</li>\n</ul>\n<p>2、k8s 集群里面最小的单位是什么？</p>\n<ul>\n<li>pod 是最小单位。每个pod里边可以运行一个或多个container（容器）</li>\n</ul>\n<p>3、Service这种资源对象的作用是什么？</p>\n<ul>\n<li>用来给相同的多个pod对象提供一个固定的统一访问接口，常用于服务发现和服务访问。</li>\n</ul>\n<h3 id=\"openstack\"><a href=\"#openstack\" class=\"headerlink\" title=\"openstack\"></a>openstack</h3><p>1、openstack 里 KeyStone 组件是用于提供什么服务的？Nova 组件是做什么用？</p>\n<ul>\n<li>认证服务（KeyStone）<br>Nova – 用于在计算级别管理虚拟机，并在计算或管理程序级别执行其他计算任务。</li>\n</ul>\n"},{"title":"每日 3+1","index_img":"/img/index-img.png","date":"2022-01-01T00:28:12.000Z","_content":"\n\n\n\n\n\n- [你有使用过loadable组件吗？它帮我们解决了什么问题？](https://github.com/haizlin/fe-interview/issues/897)\n- [你有使用过suspense组件吗？它帮我们解决了什么问题？](https://github.com/haizlin/fe-interview/issues/896)\n- [怎样动态导入组件？](https://github.com/haizlin/fe-interview/issues/895)\n- [如何给非控组件设置默认的值？](https://github.com/haizlin/fe-interview/issues/894)\n- [怎么在React中引入其它的UI库，例如Bootstrap](https://github.com/haizlin/fe-interview/issues/893)\n- [怎样将事件传递给子组件？](https://github.com/haizlin/fe-interview/issues/892)\n- [怎样使用Hooks获取服务端数据？](https://github.com/haizlin/fe-interview/issues/891)\n- [使用Hooks要遵守哪些原则？](https://github.com/haizlin/fe-interview/issues/890)\n- [render方法的原理你有了解吗？它返回的数据类型是什么？](https://github.com/haizlin/fe-interview/issues/889)\n- [useEffect和useLayoutEffect有什么区别？](https://github.com/haizlin/fe-interview/issues/888)\n- [在React项目中你用过哪些动画的包？](https://github.com/haizlin/fe-interview/issues/887)\n- [React必须使用JSX吗？](https://github.com/haizlin/fe-interview/issues/886)\n- [自定义组件时render是可选的吗？为什么？](https://github.com/haizlin/fe-interview/issues/885)\n- [需要把keys设置为全局唯一吗？](https://github.com/haizlin/fe-interview/issues/884)\n- [怎么定时更新一个组件？](https://github.com/haizlin/fe-interview/issues/883)\n- [React根据不同的环境打包不同的域名？](https://github.com/haizlin/fe-interview/issues/882)\n- [使用webpack打包React项目，怎么减小生成的js大小？](https://github.com/haizlin/fe-interview/issues/881)\n- [在React中怎么使用async/await？](https://github.com/haizlin/fe-interview/issues/880)\n- [你阅读了几遍React的源码？都有哪些收获？你是怎么阅读的？](https://github.com/haizlin/fe-interview/issues/879)\n- [什么是React.forwardRef？它有什么作用？](https://github.com/haizlin/fe-interview/issues/878)\n- [写个例子说明什么是JSX的内联条件渲染](https://github.com/haizlin/fe-interview/issues/877)\n- [在React中怎么将参数传递给事件？](https://github.com/haizlin/fe-interview/issues/876)\n- [React的事件和普通的HTML事件有什么不同？](https://github.com/haizlin/fe-interview/issues/875)\n- [在React中怎么阻止事件的默认行为？](https://github.com/haizlin/fe-interview/issues/874)\n- [你最喜欢React的哪一个特性（说一个就好）？](https://github.com/haizlin/fe-interview/issues/873)\n- [在React中什么时候使用箭头函数更方便呢？](https://github.com/haizlin/fe-interview/issues/872)\n- [你最不喜欢React的哪一个特性（说一个就好）？](https://github.com/haizlin/fe-interview/issues/871)\n- [说说你对React的reconciliation（一致化算法）的理解](https://github.com/haizlin/fe-interview/issues/870)\n- [使用PropTypes和Flow有什么区别？](https://github.com/haizlin/fe-interview/issues/869)\n- [怎样有条件地渲染组件？](https://github.com/haizlin/fe-interview/issues/868)\n- [在JSX中如何写注释？](https://github.com/haizlin/fe-interview/issues/867)\n- [constructor和getInitialState有不同？](https://github.com/haizlin/fe-interview/issues/866)\n- [写例子说明React如何在JSX中实现for循环](https://github.com/haizlin/fe-interview/issues/865)\n- [为什么建议Fragment包裹元素？它的简写是什么？](https://github.com/haizlin/fe-interview/issues/864)\n- [你有用过React.Fragment吗？说说它有什么用途？](https://github.com/haizlin/fe-interview/issues/863)\n- [在React中你有遇到过安全问题吗？怎么解决？](https://github.com/haizlin/fe-interview/issues/862)\n- [React中如何监听state的变化？](https://github.com/haizlin/fe-interview/issues/861)\n- [React什么是有状态组件？](https://github.com/haizlin/fe-interview/issues/860)\n- [React v15中怎么处理错误边界？](https://github.com/haizlin/fe-interview/issues/859)\n- [React Fiber它的目的是解决什么问题？](https://github.com/haizlin/fe-interview/issues/858)\n- [React为什么不要直接修改state？如果想修改怎么做？](https://github.com/haizlin/fe-interview/issues/857)\n- [create-react-app有什么好处？](https://github.com/haizlin/fe-interview/issues/856)\n- [装饰器(Decorator)在React中有什么应用？](https://github.com/haizlin/fe-interview/issues/855)\n- [使用高阶组件(HOC)实现一个loading组件](https://github.com/haizlin/fe-interview/issues/854)\n- [如何用React实现滚动动画？](https://github.com/haizlin/fe-interview/issues/853)\n- [说出几点你认为的React最佳实践](https://github.com/haizlin/fe-interview/issues/852)\n- [你是如何划分React组件的？](https://github.com/haizlin/fe-interview/issues/851)\n- [举例说明如何在React创建一个事件](https://github.com/haizlin/fe-interview/issues/850)\n- [如何更新组件的状态？](https://github.com/haizlin/fe-interview/issues/849)\n- [怎样将多个组件嵌入到一个组件中？](https://github.com/haizlin/fe-interview/issues/848)\n- [React的render中可以写{if else}这样的判断吗？](https://github.com/haizlin/fe-interview/issues/847)\n- [React为什么要搞一个Hooks？](https://github.com/haizlin/fe-interview/issues/846)\n- [React Hooks帮我们解决了哪些问题？](https://github.com/haizlin/fe-interview/issues/845)\n- [使用React的memo和forwardRef包装的组件为什么提示children类型不对？](https://github.com/haizlin/fe-interview/issues/844)\n- [有在项目中使用过Antd吗？说说它的好处](https://github.com/haizlin/fe-interview/issues/843)\n- [在React中如果去除生产环境上的sourcemap？](https://github.com/haizlin/fe-interview/issues/842)\n- [在React中怎么引用sass或less？](https://github.com/haizlin/fe-interview/issues/841)\n- [组件卸载前，加在DOM元素的监听事件和定时器要不要手动清除？为什么？](https://github.com/haizlin/fe-interview/issues/840)\n- [为什么标签里的for要写成htmlFor呢？](https://github.com/haizlin/fe-interview/issues/839)\n- [状态管理器解决了什么问题？什么时候用状态管理器？](https://github.com/haizlin/fe-interview/issues/838)\n- [状态管理器它精髓是什么？](https://github.com/haizlin/fe-interview/issues/837)\n- [函数式组件有没有生命周期？为什么？](https://github.com/haizlin/fe-interview/issues/836)\n- [在React中怎么引用第三方插件？比如说jQuery等](https://github.com/haizlin/fe-interview/issues/835)\n- [React的触摸事件有哪几种？](https://github.com/haizlin/fe-interview/issues/834)\n- [路由切换时同一组件无法重新渲染的有什么方法可以解决？](https://github.com/haizlin/fe-interview/issues/833)\n- [React16新特性有哪些？](https://github.com/haizlin/fe-interview/issues/832)\n- [你有用过哪些React的UI库？它们的优缺点分别是什么？](https://github.com/haizlin/fe-interview/issues/831)\n- [`<div onClick={handlerClick}>单击</div>`和`<div onClick={handlerClick(1)}>单击</div>`有什么区别？](https://github.com/haizlin/fe-interview/issues/830)\n- [在React中如何引入图片？哪种方式更好？](https://github.com/haizlin/fe-interview/issues/829)\n- [在React中怎么使用字体图标？](https://github.com/haizlin/fe-interview/issues/828)\n- [React的应用如何打包发布？它的步骤是什么？](https://github.com/haizlin/fe-interview/issues/827)\n- [ES6的语法'...'在React中有哪些应用？](https://github.com/haizlin/fe-interview/issues/826)\n- [如何封装一个React的全局公共组件？](https://github.com/haizlin/fe-interview/issues/825)\n- [在React中组件的props改变时更新组件的有哪些方法？](https://github.com/haizlin/fe-interview/issues/824)\n- [immutable的原理是什么？](https://github.com/haizlin/fe-interview/issues/823)\n- [你对immutable有了解吗？它有什么作用？](https://github.com/haizlin/fe-interview/issues/822)\n- [如何提高组件的渲染效率呢？](https://github.com/haizlin/fe-interview/issues/821)\n- [在React中如何避免不必要的render？](https://github.com/haizlin/fe-interview/issues/820)\n- [render在什么时候会被触发？](https://github.com/haizlin/fe-interview/issues/819)\n- [写出React动态改变class切换组件样式](https://github.com/haizlin/fe-interview/issues/818)\n- [React中怎么操作虚拟DOM的Class属性？](https://github.com/haizlin/fe-interview/issues/817)\n- [为什么属性使用className而不是class呢？](https://github.com/haizlin/fe-interview/issues/816)\n- [请说下react组件更新的机制是什么？](https://github.com/haizlin/fe-interview/issues/815)\n- [怎么在JSX里属性可以被覆盖吗？覆盖的原则是什么？](https://github.com/haizlin/fe-interview/issues/814)\n- [怎么在JSX里使用自定义属性？](https://github.com/haizlin/fe-interview/issues/813)\n- [怎么防止HTML被转义？](https://github.com/haizlin/fe-interview/issues/812)\n- [经常用React，你知道React的核心思想是什么吗？](https://github.com/haizlin/fe-interview/issues/811)\n- [在React中我们怎么做静态类型检测？都有哪些方法可以做到？](https://github.com/haizlin/fe-interview/issues/810)\n- [在React中组件的state和setState有什么区别？](https://github.com/haizlin/fe-interview/issues/809)\n- [React怎样跳过重新渲染？](https://github.com/haizlin/fe-interview/issues/808)\n- [React怎么判断什么时候重新渲染组件呢？](https://github.com/haizlin/fe-interview/issues/807)\n- [什么是React的实例？函数式组件有没有实例？](https://github.com/haizlin/fe-interview/issues/806)\n- [在React中如何判断点击元素属于哪一个组件？](https://github.com/haizlin/fe-interview/issues/805)\n- [在React中组件和元素有什么区别？](https://github.com/haizlin/fe-interview/issues/804)\n- [在React中声明组件时组件名的第一个字母必须是大写吗？为什么？](https://github.com/haizlin/fe-interview/issues/803)\n- [举例说明什么是高阶组件(HOC)的反向继承？](https://github.com/haizlin/fe-interview/issues/802)\n- [有用过React Devtools吗？说说它的优缺点分别是什么？](https://github.com/haizlin/fe-interview/issues/801)\n- [举例说明什么是高阶组件(HOC)的属性代理？](https://github.com/haizlin/fe-interview/issues/800)\n- [React的isMounted有什么作用？](https://github.com/haizlin/fe-interview/issues/799)\n- [React组件命名推荐的方式是哪个？为什么不推荐使用displayName？](https://github.com/haizlin/fe-interview/issues/798)\n- [React的displayName有什么作用？](https://github.com/haizlin/fe-interview/issues/797)\n- [说说你对React的组件命名规范的理解](https://github.com/haizlin/fe-interview/issues/796)\n- [说说你对React的项目结构的理解](https://github.com/haizlin/fe-interview/issues/795)\n- [React16废弃了哪些生命周期？为什么？](https://github.com/haizlin/fe-interview/issues/794)\n- [怎样在React中开启生产模式？](https://github.com/haizlin/fe-interview/issues/793)\n- [React中getInitialState方法的作用是什么？](https://github.com/haizlin/fe-interview/issues/792)\n- [React中你知道creatClass的原理吗？](https://github.com/haizlin/fe-interview/issues/791)\n- [React中验证props的目的是什么？](https://github.com/haizlin/fe-interview/issues/790)\n- [React中你有使用过getDefaultProps吗？它有什么作用？](https://github.com/haizlin/fe-interview/issues/789)\n- [React中你有使用过propType吗？它有什么作用？](https://github.com/haizlin/fe-interview/issues/788)\n- [React中怎么检验props？](https://github.com/haizlin/fe-interview/issues/787)\n- [React.createClass和extends Component的区别有哪些？](https://github.com/haizlin/fe-interview/issues/786)\n- [高阶组件(HOC)有哪些优点和缺点？](https://github.com/haizlin/fe-interview/issues/785)\n- [给组件设置很多属性时不想一个个去设置有什么办法可以解决这问题呢？](https://github.com/haizlin/fe-interview/issues/784)\n- [React16跟之前的版本生命周期有哪些变化？](https://github.com/haizlin/fe-interview/issues/756)\n- [怎样实现React组件的记忆？原理是什么？](https://github.com/haizlin/fe-interview/issues/755)\n- [创建React动画有哪些方式？](https://github.com/haizlin/fe-interview/issues/754)\n- [为什么建议不要过渡使用Refs？](https://github.com/haizlin/fe-interview/issues/753)\n- [在React使用高阶组件(HOC)有遇到过哪些问题？如何解决？](https://github.com/haizlin/fe-interview/issues/752)\n- [在使用React过程中什么时候用高阶组件(HOC)？](https://github.com/haizlin/fe-interview/issues/751)\n- [说说React diff的原理是什么？](https://github.com/haizlin/fe-interview/issues/724)\n- [React怎么提高列表渲染的性能？](https://github.com/haizlin/fe-interview/issues/723)\n- [使用ES6的class定义的组件不支持mixins了，那用什么可以替代呢？](https://github.com/haizlin/fe-interview/issues/722)\n- [为何说虚拟DOM会提高性能？](https://github.com/haizlin/fe-interview/issues/720)\n- [React的性能优化在哪个生命周期？它优化的原理是什么？](https://github.com/haizlin/fe-interview/issues/719)\n- [你知道的React性能优化有哪些方法？](https://github.com/haizlin/fe-interview/issues/718)\n- [举例说明在React中怎么使用样式？](https://github.com/haizlin/fe-interview/issues/717)\n- [React有哪几种方法来处理表单输入？](https://github.com/haizlin/fe-interview/issues/716)\n- [什么是浅层渲染？](https://github.com/haizlin/fe-interview/issues/715)\n- [你有做过React的单元测试吗？如果有，用的是哪些工具？怎么做的？](https://github.com/haizlin/fe-interview/issues/714)\n- [在React中什么是合成事件？有什么用？](https://github.com/haizlin/fe-interview/issues/713)\n- [使用React写一个todo应用，说说你的思路](https://github.com/haizlin/fe-interview/issues/712)\n- [React16的reconciliation和commit分别是什么？](https://github.com/haizlin/fe-interview/issues/711)\n- [React的函数式组件有没有生命周期？](https://github.com/haizlin/fe-interview/issues/710)\n- [useState和this.state的区别是什么？](https://github.com/haizlin/fe-interview/issues/709)\n- [请说说什么是useImperativeHandle？](https://github.com/haizlin/fe-interview/issues/708)\n- [请说说什么是useReducer？](https://github.com/haizlin/fe-interview/issues/707)\n- [请说说什么是useRef？](https://github.com/haizlin/fe-interview/issues/706)\n- [请说说什么是useEffect？](https://github.com/haizlin/fe-interview/issues/705)\n- [举例说明useState](https://github.com/haizlin/fe-interview/issues/704)\n- [请说说什么是useState？为什么要使用useState？](https://github.com/haizlin/fe-interview/issues/703)\n- [请描述下你对React的新特性Hooks的理解？它有哪些应用场景？](https://github.com/haizlin/fe-interview/issues/702)\n- [说说你对Error Boundaries的理解](https://github.com/haizlin/fe-interview/issues/701)\n- [说说你对Fiber架构的理解](https://github.com/haizlin/fe-interview/issues/700)\n- [说说你是怎么理解React的业务组件和技术组件的？](https://github.com/haizlin/fe-interview/issues/699)\n- [为什么建议setState的第一个参数是callback而不是一个对象呢？](https://github.com/haizlin/fe-interview/issues/698)\n- [展示组件和容器组件有什么区别？](https://github.com/haizlin/fe-interview/issues/697)\n- [Mern和Yeoman脚手架有什么区别？](https://github.com/haizlin/fe-interview/issues/696)\n- [你有在项目中使用过Yeoman脚手架吗？](https://github.com/haizlin/fe-interview/issues/695)\n- [你有在项目中使用过Mern脚手架吗？](https://github.com/haizlin/fe-interview/issues/694)\n- [shouldComponentUpdate方法是做什么的？](https://github.com/haizlin/fe-interview/issues/693)\n- [怎样在React中使用innerHTML？](https://github.com/haizlin/fe-interview/issues/692)\n- [你有写过React的中间件插件吗？](https://github.com/haizlin/fe-interview/issues/691)\n- [React的中间件机制是怎么样的？这种机制有什么作用？](https://github.com/haizlin/fe-interview/issues/690)\n- [React中你用过哪些第三方的中间件？](https://github.com/haizlin/fe-interview/issues/689)\n- [不用脚手架，你会手动搭建React项目吗？](https://github.com/haizlin/fe-interview/issues/688)\n- [请说说React中Portal是什么？](https://github.com/haizlin/fe-interview/issues/687)\n- [React中修改prop引发的生命周期有哪几个？](https://github.com/haizlin/fe-interview/issues/686)\n- [React多个setState调用的原理是什么？](https://github.com/haizlin/fe-interview/issues/685)\n- [React中调用setState会更新的生命周期有哪几个？](https://github.com/haizlin/fe-interview/issues/684)\n- [React中setState的第二个参数作用是什么呢？](https://github.com/haizlin/fe-interview/issues/683)\n- [React中的setState是同步还是异步的呢？为什么state并不一定会同步更新？](https://github.com/haizlin/fe-interview/issues/682)\n- [React中的setState批量更新的过程是什么？](https://github.com/haizlin/fe-interview/issues/681)\n- [React中的setState执行机制是什么呢？](https://github.com/haizlin/fe-interview/issues/680)\n- [在React中遍历的方法有哪些？它们有什么区别呢？](https://github.com/haizlin/fe-interview/issues/679)\n- [请说说你对React的render方法的理解](https://github.com/haizlin/fe-interview/issues/678)\n- [props.children.map和js的map有什么区别？为什么优先选择React的？](https://github.com/haizlin/fe-interview/issues/677)\n- [有用过React的严格模式吗？](https://github.com/haizlin/fe-interview/issues/676)\n- [React中的setState和replaceState的区别是什么？](https://github.com/haizlin/fe-interview/issues/675)\n- [React中的setState缺点是什么呢？](https://github.com/haizlin/fe-interview/issues/674)\n- [有用过React的Fragment吗？它的运用场景是什么？](https://github.com/haizlin/fe-interview/issues/673)\n- [React组件间共享数据方法有哪些？](https://github.com/haizlin/fe-interview/issues/672)\n- [React的状态提升是什么？使用场景有哪些？](https://github.com/haizlin/fe-interview/issues/671)\n- [简单描述下你有做过哪些React项目？](https://github.com/haizlin/fe-interview/issues/670)\n- [在构造函数中调用super(props)的目的是什么？](https://github.com/haizlin/fe-interview/issues/669)\n- [你是如何学习React的？](https://github.com/haizlin/fe-interview/issues/668)\n- [从旧版本的React升级到新版本的React有做过吗？有遇到过什么坑？](https://github.com/haizlin/fe-interview/issues/667)\n- [你用过React版本有哪些？](https://github.com/haizlin/fe-interview/issues/666)\n- [有用过React的服务端渲染吗？怎么做的？](https://github.com/haizlin/fe-interview/issues/665)\n- [React的mixins有什么作用？适用于什么场景？](https://github.com/haizlin/fe-interview/issues/664)\n- [React怎么拿到组件对应的DOM元素？](https://github.com/haizlin/fe-interview/issues/663)\n- [请描述下事件在React中的处理方式是什么？](https://github.com/haizlin/fe-interview/issues/662)\n- [JSX和HTML有什么区别？](https://github.com/haizlin/fe-interview/issues/661)\n- [React的书写规范有哪些？](https://github.com/haizlin/fe-interview/issues/660)\n- [create-react-app创建新运用怎么解决卡的问题？](https://github.com/haizlin/fe-interview/issues/659)\n- [使用React的方式有哪几种？](https://github.com/haizlin/fe-interview/issues/658)\n- [说说你对reader的context的理解](https://github.com/haizlin/fe-interview/issues/657)\n- [同时引用这三个库React.js、React-dom.js和babel.js它们都有什么作用？](https://github.com/haizlin/fe-interview/issues/656)\n- [你知道Virtual DOM的工作原理吗？](https://github.com/haizlin/fe-interview/issues/655)\n- [你阅读过React的源码吗？简要说下它的执行流程](https://github.com/haizlin/fe-interview/issues/654)\n- [React中怎样阻止组件渲染？](https://github.com/haizlin/fe-interview/issues/653)\n- [React非兄弟组件如何通信？](https://github.com/haizlin/fe-interview/issues/652)\n- [React兄弟组件如何通信？](https://github.com/haizlin/fe-interview/issues/651)\n- [React非父子组件如何通信？](https://github.com/haizlin/fe-interview/issues/650)\n- [React父子组件如何通信？](https://github.com/haizlin/fe-interview/issues/649)\n- [React组件间的通信有哪些？](https://github.com/haizlin/fe-interview/issues/648)\n- [类组件和函数式组件有什么区别？](https://github.com/haizlin/fe-interview/issues/647)\n- [React自定义组件你写过吗？说说看都写过哪些？](https://github.com/haizlin/fe-interview/issues/646)\n- [React组件的state和props两者有什么区别？](https://github.com/haizlin/fe-interview/issues/645)\n- [React有几种构建组件的方式？可以写出来吗？](https://github.com/haizlin/fe-interview/issues/644)\n- [React中遍历时为什么不用索引作为唯一的key值？](https://github.com/haizlin/fe-interview/issues/643)\n- [React中的key有什么作用？](https://github.com/haizlin/fe-interview/issues/642)\n- [React中除了在构造函数中绑定this,还有别的方式吗？](https://github.com/haizlin/fe-interview/issues/641)\n- [在React中页面重新加载时怎样保留数据？](https://github.com/haizlin/fe-interview/issues/640)\n- [请描述下React的事件机制](https://github.com/haizlin/fe-interview/issues/639)\n- [怎样在React中创建一个事件？](https://github.com/haizlin/fe-interview/issues/638)\n- [在React中无状态组件有什么运用场景？](https://github.com/haizlin/fe-interview/issues/637)\n- [描述下在React中无状态组件和有状态组件的区别是什么？](https://github.com/haizlin/fe-interview/issues/636)\n- [写一个React的高阶组件(HOC)并说明你对它的理解](https://github.com/haizlin/fe-interview/issues/635)\n- [React中可以在render访问refs吗？为什么？](https://github.com/haizlin/fe-interview/issues/634)\n- [React中refs的作用是什么？有哪些应用场景？](https://github.com/haizlin/fe-interview/issues/633)\n- [请描述你对纯函数的理解？](https://github.com/haizlin/fe-interview/issues/632)\n- [受控组件和非受控组件有什么区别？](https://github.com/haizlin/fe-interview/issues/631)\n- [React中什么是非控组件？](https://github.com/haizlin/fe-interview/issues/630)\n- [React中什么是受控组件？](https://github.com/haizlin/fe-interview/issues/629)\n- [React中发起网络请求应该在哪个生命周期中进行？为什么？](https://github.com/haizlin/fe-interview/issues/628)\n- [说说React的生命周期有哪些？](https://github.com/haizlin/fe-interview/issues/627)\n- [说说你对“在React中，一切都是组件”的理解](https://github.com/haizlin/fe-interview/issues/626)\n- [写React你是用es6还是es5的语法？有什么区别？](https://github.com/haizlin/fe-interview/issues/625)\n- [浏览器为什么无法直接JSX？怎么解决呢？](https://github.com/haizlin/fe-interview/issues/624)\n- [在使用React过程中你都踩过哪些坑？你是怎么填坑的？](https://github.com/haizlin/fe-interview/issues/623)\n- [说说你喜欢React的原因是什么？它有什么优缺点？](https://github.com/haizlin/fe-interview/issues/622)\n- [如何解决引用类型在pureComponent下修改值的时候，页面不渲染的问题？](https://github.com/haizlin/fe-interview/issues/621)\n- [createElement与cloneElement两者有什么区别？](https://github.com/haizlin/fe-interview/issues/620)\n- [解释下React中Element 和Component两者的区别是什么？](https://github.com/haizlin/fe-interview/issues/619)\n- [解释下React中component和pureComponent两者的区别是什么？](https://github.com/haizlin/fe-interview/issues/618)\n- [React的虚拟DOM和vue的虚拟DOM有什么区别？](https://github.com/haizlin/fe-interview/issues/617)\n- [你觉得React上手快不快？它有哪些限制？](https://github.com/haizlin/fe-interview/issues/616)\n- [说说你对声明式编程的理解？](https://github.com/haizlin/fe-interview/issues/615)\n- [React与angular、vue有什么区别？](https://github.com/haizlin/fe-interview/issues/614)\n- [React是哪个公司开发的？](https://github.com/haizlin/fe-interview/issues/613)\n- [React是什么？它的主要特点是什么？](https://github.com/haizlin/fe-interview/issues/612)\n- [简要描述下你知道的React工作原理是什么？](https://github.com/haizlin/fe-interview/issues/611)\n- [在React中怎样改变组件状态，以及状态改变的过程是什么？](https://github.com/haizlin/fe-interview/issues/606)\n- [在React中你是怎么进行状态管理的？](https://github.com/haizlin/fe-interview/issues/605)\n- [React声明组件有哪几种方法，各有什么不同？](https://github.com/haizlin/fe-interview/issues/604)\n\n### ReactNative\n- [如何在React Native中设置环境变量？]()\n- [请描述下Code Push的原理是什么？](https://github.com/haizlin/fe-interview/issues/783)\n- [React Native怎样查看日记？](https://github.com/haizlin/fe-interview/issues/782)\n- [React Native怎样测试？](https://github.com/haizlin/fe-interview/issues/781)\n- [React Native怎样调试？](https://github.com/haizlin/fe-interview/issues/780)\n- [React Native和React有什么区别？](https://github.com/haizlin/fe-interview/issues/779)\n- [有做过React Native项目吗？](https://github.com/haizlin/fe-interview/issues/725)\n\n### React-Router\n- [React-Router怎么获取历史对象？](https://github.com/haizlin/fe-interview/issues/922)\n- [React-Router怎么获取URL的参数？](https://github.com/haizlin/fe-interview/issues/921)\n- [在history模式中push和replace有什么区别？](https://github.com/haizlin/fe-interview/issues/778)\n- [React-Router怎么设置重定向？](https://github.com/haizlin/fe-interview/issues/777)\n- [React-Router 4中`<Router>`组件有几种类型？](https://github.com/haizlin/fe-interview/issues/776)\n- [React-Router 3和React-Router 4有什么变化？添加了什么好的特性？](https://github.com/haizlin/fe-interview/issues/775)\n- [React-Router的实现原理是什么？](https://github.com/haizlin/fe-interview/issues/774)\n- [React-Router 4的switch有什么用？](https://github.com/haizlin/fe-interview/issues/773)\n- [React-Router的路由有几种模式？](https://github.com/haizlin/fe-interview/issues/772)\n- [React-Router 4怎样在路由变化时重新渲染同一个组件？](https://github.com/haizlin/fe-interview/issues/771)\n- [React-Router的`<Link>`标签和`<a>`标签有什么区别？](https://github.com/haizlin/fe-interview/issues/770)\n- [React的路由和普通路由有什么区别？](https://github.com/haizlin/fe-interview/issues/728)\n- [请你说说React的路由的优缺点？](https://github.com/haizlin/fe-interview/issues/727)\n- [请你说说React的路由是什么？](https://github.com/haizlin/fe-interview/issues/726)\n\n### Redux/Mobx\n- [你有了解Rxjs是什么吗？它是做什么的？](https://github.com/haizlin/fe-interview/issues/920)\n- [在Redux中怎么发起网络请求？](https://github.com/haizlin/fe-interview/issues/919)\n- [Redux怎样重置状态？](https://github.com/haizlin/fe-interview/issues/918)\n- [Redux怎样设置初始状态？](https://github.com/haizlin/fe-interview/issues/917)\n- [Context api可以取代Redux吗？为什么？](https://github.com/haizlin/fe-interview/issues/916)\n- [推荐在reducer中触发Action吗？为什么？](https://github.com/haizlin/fe-interview/issues/915)\n- [Redux怎么添加新的中间件？](https://github.com/haizlin/fe-interview/issues/914)\n- [redux-saga和redux-thunk有什么本质的区别？](https://github.com/haizlin/fe-interview/issues/913)\n- [在React中你是怎么对异步方案进行选型的？](https://github.com/haizlin/fe-interview/issues/912)\n- [你知道redux-saga的原理吗？](https://github.com/haizlin/fe-interview/issues/911)\n- [你有使用过redux-saga中间件吗？它是干什么的？](https://github.com/haizlin/fe-interview/issues/910)\n- [Redux中异步action和同步action最大的区别是什么？](https://github.com/haizlin/fe-interview/issues/769)\n- [Redux和vuex有什么区别？](https://github.com/haizlin/fe-interview/issues/768)\n- [Redux的中间件是什么？你有用过哪些Redux的中间件？](https://github.com/haizlin/fe-interview/issues/767)\n- [说说Redux的实现流程](https://github.com/haizlin/fe-interview/issues/766)\n- [Mobx的设计思想是什么？](https://github.com/haizlin/fe-interview/issues/765)\n- [Redux由哪些组件构成？](https://github.com/haizlin/fe-interview/issues/764)\n- [Mobx和Redux有什么区别？](https://github.com/haizlin/fe-interview/issues/763)\n- [在React项目中你是如何选择Redux和Mobx的？说说你的理解](https://github.com/haizlin/fe-interview/issues/762)\n- [你有在React中使用过Mobx吗？它的运用场景有哪些？](https://github.com/haizlin/fe-interview/issues/761)\n- [Redux的thunk作用是什么？](https://github.com/haizlin/fe-interview/issues/740)\n- [Redux的数据存储和本地储存有什么区别？](https://github.com/haizlin/fe-interview/issues/739)\n- [在Redux中，什么是reducer？它有什么作用？](https://github.com/haizlin/fe-interview/issues/738)\n- [举例说明怎么在Redux中定义action？](https://github.com/haizlin/fe-interview/issues/737)\n- [在Redux中，什么是action？](https://github.com/haizlin/fe-interview/issues/736)\n- [在Redux中，什么是store？](https://github.com/haizlin/fe-interview/issues/735)\n- [为什么Redux能做到局部渲染呢？](https://github.com/haizlin/fe-interview/issues/734)\n- [说说Redux的优缺点分别是什么？](https://github.com/haizlin/fe-interview/issues/733)\n- [Redux和Flux的区别是什么？](https://github.com/haizlin/fe-interview/issues/732)\n- [Redux它的三个原则是什么？](https://github.com/haizlin/fe-interview/issues/731)\n- [什么是单一数据源？](https://github.com/haizlin/fe-interview/issues/730)\n- [什么是Redux？说说你对Redux的理解？有哪些运用场景？](https://github.com/haizlin/fe-interview/issues/729)\n\n### Flux\n- [请说说点击按钮触发到状态更改，数据的流向？](https://github.com/haizlin/fe-interview/issues/742)\n- [请描述下Flux的思想](https://github.com/haizlin/fe-interview/issues/742)\n- [什么是Flux？说说你对Flux的理解？有哪些运用场景？](https://github.com/haizlin/fe-interview/issues/741)\n\n## Reference\n\n- <https://github.com/qiu-deqing/FE-interview>\n- <https://github.com/haizlin/fe-interview>\n","source":"_drafts/2.每日 3+1.md","raw":"---\ntitle: 每日 3+1\nindex_img: /img/index-img.png\ndate: 2022-01-01 08:28:12\ntags:\ncategories:\n---\n\n\n\n\n\n\n- [你有使用过loadable组件吗？它帮我们解决了什么问题？](https://github.com/haizlin/fe-interview/issues/897)\n- [你有使用过suspense组件吗？它帮我们解决了什么问题？](https://github.com/haizlin/fe-interview/issues/896)\n- [怎样动态导入组件？](https://github.com/haizlin/fe-interview/issues/895)\n- [如何给非控组件设置默认的值？](https://github.com/haizlin/fe-interview/issues/894)\n- [怎么在React中引入其它的UI库，例如Bootstrap](https://github.com/haizlin/fe-interview/issues/893)\n- [怎样将事件传递给子组件？](https://github.com/haizlin/fe-interview/issues/892)\n- [怎样使用Hooks获取服务端数据？](https://github.com/haizlin/fe-interview/issues/891)\n- [使用Hooks要遵守哪些原则？](https://github.com/haizlin/fe-interview/issues/890)\n- [render方法的原理你有了解吗？它返回的数据类型是什么？](https://github.com/haizlin/fe-interview/issues/889)\n- [useEffect和useLayoutEffect有什么区别？](https://github.com/haizlin/fe-interview/issues/888)\n- [在React项目中你用过哪些动画的包？](https://github.com/haizlin/fe-interview/issues/887)\n- [React必须使用JSX吗？](https://github.com/haizlin/fe-interview/issues/886)\n- [自定义组件时render是可选的吗？为什么？](https://github.com/haizlin/fe-interview/issues/885)\n- [需要把keys设置为全局唯一吗？](https://github.com/haizlin/fe-interview/issues/884)\n- [怎么定时更新一个组件？](https://github.com/haizlin/fe-interview/issues/883)\n- [React根据不同的环境打包不同的域名？](https://github.com/haizlin/fe-interview/issues/882)\n- [使用webpack打包React项目，怎么减小生成的js大小？](https://github.com/haizlin/fe-interview/issues/881)\n- [在React中怎么使用async/await？](https://github.com/haizlin/fe-interview/issues/880)\n- [你阅读了几遍React的源码？都有哪些收获？你是怎么阅读的？](https://github.com/haizlin/fe-interview/issues/879)\n- [什么是React.forwardRef？它有什么作用？](https://github.com/haizlin/fe-interview/issues/878)\n- [写个例子说明什么是JSX的内联条件渲染](https://github.com/haizlin/fe-interview/issues/877)\n- [在React中怎么将参数传递给事件？](https://github.com/haizlin/fe-interview/issues/876)\n- [React的事件和普通的HTML事件有什么不同？](https://github.com/haizlin/fe-interview/issues/875)\n- [在React中怎么阻止事件的默认行为？](https://github.com/haizlin/fe-interview/issues/874)\n- [你最喜欢React的哪一个特性（说一个就好）？](https://github.com/haizlin/fe-interview/issues/873)\n- [在React中什么时候使用箭头函数更方便呢？](https://github.com/haizlin/fe-interview/issues/872)\n- [你最不喜欢React的哪一个特性（说一个就好）？](https://github.com/haizlin/fe-interview/issues/871)\n- [说说你对React的reconciliation（一致化算法）的理解](https://github.com/haizlin/fe-interview/issues/870)\n- [使用PropTypes和Flow有什么区别？](https://github.com/haizlin/fe-interview/issues/869)\n- [怎样有条件地渲染组件？](https://github.com/haizlin/fe-interview/issues/868)\n- [在JSX中如何写注释？](https://github.com/haizlin/fe-interview/issues/867)\n- [constructor和getInitialState有不同？](https://github.com/haizlin/fe-interview/issues/866)\n- [写例子说明React如何在JSX中实现for循环](https://github.com/haizlin/fe-interview/issues/865)\n- [为什么建议Fragment包裹元素？它的简写是什么？](https://github.com/haizlin/fe-interview/issues/864)\n- [你有用过React.Fragment吗？说说它有什么用途？](https://github.com/haizlin/fe-interview/issues/863)\n- [在React中你有遇到过安全问题吗？怎么解决？](https://github.com/haizlin/fe-interview/issues/862)\n- [React中如何监听state的变化？](https://github.com/haizlin/fe-interview/issues/861)\n- [React什么是有状态组件？](https://github.com/haizlin/fe-interview/issues/860)\n- [React v15中怎么处理错误边界？](https://github.com/haizlin/fe-interview/issues/859)\n- [React Fiber它的目的是解决什么问题？](https://github.com/haizlin/fe-interview/issues/858)\n- [React为什么不要直接修改state？如果想修改怎么做？](https://github.com/haizlin/fe-interview/issues/857)\n- [create-react-app有什么好处？](https://github.com/haizlin/fe-interview/issues/856)\n- [装饰器(Decorator)在React中有什么应用？](https://github.com/haizlin/fe-interview/issues/855)\n- [使用高阶组件(HOC)实现一个loading组件](https://github.com/haizlin/fe-interview/issues/854)\n- [如何用React实现滚动动画？](https://github.com/haizlin/fe-interview/issues/853)\n- [说出几点你认为的React最佳实践](https://github.com/haizlin/fe-interview/issues/852)\n- [你是如何划分React组件的？](https://github.com/haizlin/fe-interview/issues/851)\n- [举例说明如何在React创建一个事件](https://github.com/haizlin/fe-interview/issues/850)\n- [如何更新组件的状态？](https://github.com/haizlin/fe-interview/issues/849)\n- [怎样将多个组件嵌入到一个组件中？](https://github.com/haizlin/fe-interview/issues/848)\n- [React的render中可以写{if else}这样的判断吗？](https://github.com/haizlin/fe-interview/issues/847)\n- [React为什么要搞一个Hooks？](https://github.com/haizlin/fe-interview/issues/846)\n- [React Hooks帮我们解决了哪些问题？](https://github.com/haizlin/fe-interview/issues/845)\n- [使用React的memo和forwardRef包装的组件为什么提示children类型不对？](https://github.com/haizlin/fe-interview/issues/844)\n- [有在项目中使用过Antd吗？说说它的好处](https://github.com/haizlin/fe-interview/issues/843)\n- [在React中如果去除生产环境上的sourcemap？](https://github.com/haizlin/fe-interview/issues/842)\n- [在React中怎么引用sass或less？](https://github.com/haizlin/fe-interview/issues/841)\n- [组件卸载前，加在DOM元素的监听事件和定时器要不要手动清除？为什么？](https://github.com/haizlin/fe-interview/issues/840)\n- [为什么标签里的for要写成htmlFor呢？](https://github.com/haizlin/fe-interview/issues/839)\n- [状态管理器解决了什么问题？什么时候用状态管理器？](https://github.com/haizlin/fe-interview/issues/838)\n- [状态管理器它精髓是什么？](https://github.com/haizlin/fe-interview/issues/837)\n- [函数式组件有没有生命周期？为什么？](https://github.com/haizlin/fe-interview/issues/836)\n- [在React中怎么引用第三方插件？比如说jQuery等](https://github.com/haizlin/fe-interview/issues/835)\n- [React的触摸事件有哪几种？](https://github.com/haizlin/fe-interview/issues/834)\n- [路由切换时同一组件无法重新渲染的有什么方法可以解决？](https://github.com/haizlin/fe-interview/issues/833)\n- [React16新特性有哪些？](https://github.com/haizlin/fe-interview/issues/832)\n- [你有用过哪些React的UI库？它们的优缺点分别是什么？](https://github.com/haizlin/fe-interview/issues/831)\n- [`<div onClick={handlerClick}>单击</div>`和`<div onClick={handlerClick(1)}>单击</div>`有什么区别？](https://github.com/haizlin/fe-interview/issues/830)\n- [在React中如何引入图片？哪种方式更好？](https://github.com/haizlin/fe-interview/issues/829)\n- [在React中怎么使用字体图标？](https://github.com/haizlin/fe-interview/issues/828)\n- [React的应用如何打包发布？它的步骤是什么？](https://github.com/haizlin/fe-interview/issues/827)\n- [ES6的语法'...'在React中有哪些应用？](https://github.com/haizlin/fe-interview/issues/826)\n- [如何封装一个React的全局公共组件？](https://github.com/haizlin/fe-interview/issues/825)\n- [在React中组件的props改变时更新组件的有哪些方法？](https://github.com/haizlin/fe-interview/issues/824)\n- [immutable的原理是什么？](https://github.com/haizlin/fe-interview/issues/823)\n- [你对immutable有了解吗？它有什么作用？](https://github.com/haizlin/fe-interview/issues/822)\n- [如何提高组件的渲染效率呢？](https://github.com/haizlin/fe-interview/issues/821)\n- [在React中如何避免不必要的render？](https://github.com/haizlin/fe-interview/issues/820)\n- [render在什么时候会被触发？](https://github.com/haizlin/fe-interview/issues/819)\n- [写出React动态改变class切换组件样式](https://github.com/haizlin/fe-interview/issues/818)\n- [React中怎么操作虚拟DOM的Class属性？](https://github.com/haizlin/fe-interview/issues/817)\n- [为什么属性使用className而不是class呢？](https://github.com/haizlin/fe-interview/issues/816)\n- [请说下react组件更新的机制是什么？](https://github.com/haizlin/fe-interview/issues/815)\n- [怎么在JSX里属性可以被覆盖吗？覆盖的原则是什么？](https://github.com/haizlin/fe-interview/issues/814)\n- [怎么在JSX里使用自定义属性？](https://github.com/haizlin/fe-interview/issues/813)\n- [怎么防止HTML被转义？](https://github.com/haizlin/fe-interview/issues/812)\n- [经常用React，你知道React的核心思想是什么吗？](https://github.com/haizlin/fe-interview/issues/811)\n- [在React中我们怎么做静态类型检测？都有哪些方法可以做到？](https://github.com/haizlin/fe-interview/issues/810)\n- [在React中组件的state和setState有什么区别？](https://github.com/haizlin/fe-interview/issues/809)\n- [React怎样跳过重新渲染？](https://github.com/haizlin/fe-interview/issues/808)\n- [React怎么判断什么时候重新渲染组件呢？](https://github.com/haizlin/fe-interview/issues/807)\n- [什么是React的实例？函数式组件有没有实例？](https://github.com/haizlin/fe-interview/issues/806)\n- [在React中如何判断点击元素属于哪一个组件？](https://github.com/haizlin/fe-interview/issues/805)\n- [在React中组件和元素有什么区别？](https://github.com/haizlin/fe-interview/issues/804)\n- [在React中声明组件时组件名的第一个字母必须是大写吗？为什么？](https://github.com/haizlin/fe-interview/issues/803)\n- [举例说明什么是高阶组件(HOC)的反向继承？](https://github.com/haizlin/fe-interview/issues/802)\n- [有用过React Devtools吗？说说它的优缺点分别是什么？](https://github.com/haizlin/fe-interview/issues/801)\n- [举例说明什么是高阶组件(HOC)的属性代理？](https://github.com/haizlin/fe-interview/issues/800)\n- [React的isMounted有什么作用？](https://github.com/haizlin/fe-interview/issues/799)\n- [React组件命名推荐的方式是哪个？为什么不推荐使用displayName？](https://github.com/haizlin/fe-interview/issues/798)\n- [React的displayName有什么作用？](https://github.com/haizlin/fe-interview/issues/797)\n- [说说你对React的组件命名规范的理解](https://github.com/haizlin/fe-interview/issues/796)\n- [说说你对React的项目结构的理解](https://github.com/haizlin/fe-interview/issues/795)\n- [React16废弃了哪些生命周期？为什么？](https://github.com/haizlin/fe-interview/issues/794)\n- [怎样在React中开启生产模式？](https://github.com/haizlin/fe-interview/issues/793)\n- [React中getInitialState方法的作用是什么？](https://github.com/haizlin/fe-interview/issues/792)\n- [React中你知道creatClass的原理吗？](https://github.com/haizlin/fe-interview/issues/791)\n- [React中验证props的目的是什么？](https://github.com/haizlin/fe-interview/issues/790)\n- [React中你有使用过getDefaultProps吗？它有什么作用？](https://github.com/haizlin/fe-interview/issues/789)\n- [React中你有使用过propType吗？它有什么作用？](https://github.com/haizlin/fe-interview/issues/788)\n- [React中怎么检验props？](https://github.com/haizlin/fe-interview/issues/787)\n- [React.createClass和extends Component的区别有哪些？](https://github.com/haizlin/fe-interview/issues/786)\n- [高阶组件(HOC)有哪些优点和缺点？](https://github.com/haizlin/fe-interview/issues/785)\n- [给组件设置很多属性时不想一个个去设置有什么办法可以解决这问题呢？](https://github.com/haizlin/fe-interview/issues/784)\n- [React16跟之前的版本生命周期有哪些变化？](https://github.com/haizlin/fe-interview/issues/756)\n- [怎样实现React组件的记忆？原理是什么？](https://github.com/haizlin/fe-interview/issues/755)\n- [创建React动画有哪些方式？](https://github.com/haizlin/fe-interview/issues/754)\n- [为什么建议不要过渡使用Refs？](https://github.com/haizlin/fe-interview/issues/753)\n- [在React使用高阶组件(HOC)有遇到过哪些问题？如何解决？](https://github.com/haizlin/fe-interview/issues/752)\n- [在使用React过程中什么时候用高阶组件(HOC)？](https://github.com/haizlin/fe-interview/issues/751)\n- [说说React diff的原理是什么？](https://github.com/haizlin/fe-interview/issues/724)\n- [React怎么提高列表渲染的性能？](https://github.com/haizlin/fe-interview/issues/723)\n- [使用ES6的class定义的组件不支持mixins了，那用什么可以替代呢？](https://github.com/haizlin/fe-interview/issues/722)\n- [为何说虚拟DOM会提高性能？](https://github.com/haizlin/fe-interview/issues/720)\n- [React的性能优化在哪个生命周期？它优化的原理是什么？](https://github.com/haizlin/fe-interview/issues/719)\n- [你知道的React性能优化有哪些方法？](https://github.com/haizlin/fe-interview/issues/718)\n- [举例说明在React中怎么使用样式？](https://github.com/haizlin/fe-interview/issues/717)\n- [React有哪几种方法来处理表单输入？](https://github.com/haizlin/fe-interview/issues/716)\n- [什么是浅层渲染？](https://github.com/haizlin/fe-interview/issues/715)\n- [你有做过React的单元测试吗？如果有，用的是哪些工具？怎么做的？](https://github.com/haizlin/fe-interview/issues/714)\n- [在React中什么是合成事件？有什么用？](https://github.com/haizlin/fe-interview/issues/713)\n- [使用React写一个todo应用，说说你的思路](https://github.com/haizlin/fe-interview/issues/712)\n- [React16的reconciliation和commit分别是什么？](https://github.com/haizlin/fe-interview/issues/711)\n- [React的函数式组件有没有生命周期？](https://github.com/haizlin/fe-interview/issues/710)\n- [useState和this.state的区别是什么？](https://github.com/haizlin/fe-interview/issues/709)\n- [请说说什么是useImperativeHandle？](https://github.com/haizlin/fe-interview/issues/708)\n- [请说说什么是useReducer？](https://github.com/haizlin/fe-interview/issues/707)\n- [请说说什么是useRef？](https://github.com/haizlin/fe-interview/issues/706)\n- [请说说什么是useEffect？](https://github.com/haizlin/fe-interview/issues/705)\n- [举例说明useState](https://github.com/haizlin/fe-interview/issues/704)\n- [请说说什么是useState？为什么要使用useState？](https://github.com/haizlin/fe-interview/issues/703)\n- [请描述下你对React的新特性Hooks的理解？它有哪些应用场景？](https://github.com/haizlin/fe-interview/issues/702)\n- [说说你对Error Boundaries的理解](https://github.com/haizlin/fe-interview/issues/701)\n- [说说你对Fiber架构的理解](https://github.com/haizlin/fe-interview/issues/700)\n- [说说你是怎么理解React的业务组件和技术组件的？](https://github.com/haizlin/fe-interview/issues/699)\n- [为什么建议setState的第一个参数是callback而不是一个对象呢？](https://github.com/haizlin/fe-interview/issues/698)\n- [展示组件和容器组件有什么区别？](https://github.com/haizlin/fe-interview/issues/697)\n- [Mern和Yeoman脚手架有什么区别？](https://github.com/haizlin/fe-interview/issues/696)\n- [你有在项目中使用过Yeoman脚手架吗？](https://github.com/haizlin/fe-interview/issues/695)\n- [你有在项目中使用过Mern脚手架吗？](https://github.com/haizlin/fe-interview/issues/694)\n- [shouldComponentUpdate方法是做什么的？](https://github.com/haizlin/fe-interview/issues/693)\n- [怎样在React中使用innerHTML？](https://github.com/haizlin/fe-interview/issues/692)\n- [你有写过React的中间件插件吗？](https://github.com/haizlin/fe-interview/issues/691)\n- [React的中间件机制是怎么样的？这种机制有什么作用？](https://github.com/haizlin/fe-interview/issues/690)\n- [React中你用过哪些第三方的中间件？](https://github.com/haizlin/fe-interview/issues/689)\n- [不用脚手架，你会手动搭建React项目吗？](https://github.com/haizlin/fe-interview/issues/688)\n- [请说说React中Portal是什么？](https://github.com/haizlin/fe-interview/issues/687)\n- [React中修改prop引发的生命周期有哪几个？](https://github.com/haizlin/fe-interview/issues/686)\n- [React多个setState调用的原理是什么？](https://github.com/haizlin/fe-interview/issues/685)\n- [React中调用setState会更新的生命周期有哪几个？](https://github.com/haizlin/fe-interview/issues/684)\n- [React中setState的第二个参数作用是什么呢？](https://github.com/haizlin/fe-interview/issues/683)\n- [React中的setState是同步还是异步的呢？为什么state并不一定会同步更新？](https://github.com/haizlin/fe-interview/issues/682)\n- [React中的setState批量更新的过程是什么？](https://github.com/haizlin/fe-interview/issues/681)\n- [React中的setState执行机制是什么呢？](https://github.com/haizlin/fe-interview/issues/680)\n- [在React中遍历的方法有哪些？它们有什么区别呢？](https://github.com/haizlin/fe-interview/issues/679)\n- [请说说你对React的render方法的理解](https://github.com/haizlin/fe-interview/issues/678)\n- [props.children.map和js的map有什么区别？为什么优先选择React的？](https://github.com/haizlin/fe-interview/issues/677)\n- [有用过React的严格模式吗？](https://github.com/haizlin/fe-interview/issues/676)\n- [React中的setState和replaceState的区别是什么？](https://github.com/haizlin/fe-interview/issues/675)\n- [React中的setState缺点是什么呢？](https://github.com/haizlin/fe-interview/issues/674)\n- [有用过React的Fragment吗？它的运用场景是什么？](https://github.com/haizlin/fe-interview/issues/673)\n- [React组件间共享数据方法有哪些？](https://github.com/haizlin/fe-interview/issues/672)\n- [React的状态提升是什么？使用场景有哪些？](https://github.com/haizlin/fe-interview/issues/671)\n- [简单描述下你有做过哪些React项目？](https://github.com/haizlin/fe-interview/issues/670)\n- [在构造函数中调用super(props)的目的是什么？](https://github.com/haizlin/fe-interview/issues/669)\n- [你是如何学习React的？](https://github.com/haizlin/fe-interview/issues/668)\n- [从旧版本的React升级到新版本的React有做过吗？有遇到过什么坑？](https://github.com/haizlin/fe-interview/issues/667)\n- [你用过React版本有哪些？](https://github.com/haizlin/fe-interview/issues/666)\n- [有用过React的服务端渲染吗？怎么做的？](https://github.com/haizlin/fe-interview/issues/665)\n- [React的mixins有什么作用？适用于什么场景？](https://github.com/haizlin/fe-interview/issues/664)\n- [React怎么拿到组件对应的DOM元素？](https://github.com/haizlin/fe-interview/issues/663)\n- [请描述下事件在React中的处理方式是什么？](https://github.com/haizlin/fe-interview/issues/662)\n- [JSX和HTML有什么区别？](https://github.com/haizlin/fe-interview/issues/661)\n- [React的书写规范有哪些？](https://github.com/haizlin/fe-interview/issues/660)\n- [create-react-app创建新运用怎么解决卡的问题？](https://github.com/haizlin/fe-interview/issues/659)\n- [使用React的方式有哪几种？](https://github.com/haizlin/fe-interview/issues/658)\n- [说说你对reader的context的理解](https://github.com/haizlin/fe-interview/issues/657)\n- [同时引用这三个库React.js、React-dom.js和babel.js它们都有什么作用？](https://github.com/haizlin/fe-interview/issues/656)\n- [你知道Virtual DOM的工作原理吗？](https://github.com/haizlin/fe-interview/issues/655)\n- [你阅读过React的源码吗？简要说下它的执行流程](https://github.com/haizlin/fe-interview/issues/654)\n- [React中怎样阻止组件渲染？](https://github.com/haizlin/fe-interview/issues/653)\n- [React非兄弟组件如何通信？](https://github.com/haizlin/fe-interview/issues/652)\n- [React兄弟组件如何通信？](https://github.com/haizlin/fe-interview/issues/651)\n- [React非父子组件如何通信？](https://github.com/haizlin/fe-interview/issues/650)\n- [React父子组件如何通信？](https://github.com/haizlin/fe-interview/issues/649)\n- [React组件间的通信有哪些？](https://github.com/haizlin/fe-interview/issues/648)\n- [类组件和函数式组件有什么区别？](https://github.com/haizlin/fe-interview/issues/647)\n- [React自定义组件你写过吗？说说看都写过哪些？](https://github.com/haizlin/fe-interview/issues/646)\n- [React组件的state和props两者有什么区别？](https://github.com/haizlin/fe-interview/issues/645)\n- [React有几种构建组件的方式？可以写出来吗？](https://github.com/haizlin/fe-interview/issues/644)\n- [React中遍历时为什么不用索引作为唯一的key值？](https://github.com/haizlin/fe-interview/issues/643)\n- [React中的key有什么作用？](https://github.com/haizlin/fe-interview/issues/642)\n- [React中除了在构造函数中绑定this,还有别的方式吗？](https://github.com/haizlin/fe-interview/issues/641)\n- [在React中页面重新加载时怎样保留数据？](https://github.com/haizlin/fe-interview/issues/640)\n- [请描述下React的事件机制](https://github.com/haizlin/fe-interview/issues/639)\n- [怎样在React中创建一个事件？](https://github.com/haizlin/fe-interview/issues/638)\n- [在React中无状态组件有什么运用场景？](https://github.com/haizlin/fe-interview/issues/637)\n- [描述下在React中无状态组件和有状态组件的区别是什么？](https://github.com/haizlin/fe-interview/issues/636)\n- [写一个React的高阶组件(HOC)并说明你对它的理解](https://github.com/haizlin/fe-interview/issues/635)\n- [React中可以在render访问refs吗？为什么？](https://github.com/haizlin/fe-interview/issues/634)\n- [React中refs的作用是什么？有哪些应用场景？](https://github.com/haizlin/fe-interview/issues/633)\n- [请描述你对纯函数的理解？](https://github.com/haizlin/fe-interview/issues/632)\n- [受控组件和非受控组件有什么区别？](https://github.com/haizlin/fe-interview/issues/631)\n- [React中什么是非控组件？](https://github.com/haizlin/fe-interview/issues/630)\n- [React中什么是受控组件？](https://github.com/haizlin/fe-interview/issues/629)\n- [React中发起网络请求应该在哪个生命周期中进行？为什么？](https://github.com/haizlin/fe-interview/issues/628)\n- [说说React的生命周期有哪些？](https://github.com/haizlin/fe-interview/issues/627)\n- [说说你对“在React中，一切都是组件”的理解](https://github.com/haizlin/fe-interview/issues/626)\n- [写React你是用es6还是es5的语法？有什么区别？](https://github.com/haizlin/fe-interview/issues/625)\n- [浏览器为什么无法直接JSX？怎么解决呢？](https://github.com/haizlin/fe-interview/issues/624)\n- [在使用React过程中你都踩过哪些坑？你是怎么填坑的？](https://github.com/haizlin/fe-interview/issues/623)\n- [说说你喜欢React的原因是什么？它有什么优缺点？](https://github.com/haizlin/fe-interview/issues/622)\n- [如何解决引用类型在pureComponent下修改值的时候，页面不渲染的问题？](https://github.com/haizlin/fe-interview/issues/621)\n- [createElement与cloneElement两者有什么区别？](https://github.com/haizlin/fe-interview/issues/620)\n- [解释下React中Element 和Component两者的区别是什么？](https://github.com/haizlin/fe-interview/issues/619)\n- [解释下React中component和pureComponent两者的区别是什么？](https://github.com/haizlin/fe-interview/issues/618)\n- [React的虚拟DOM和vue的虚拟DOM有什么区别？](https://github.com/haizlin/fe-interview/issues/617)\n- [你觉得React上手快不快？它有哪些限制？](https://github.com/haizlin/fe-interview/issues/616)\n- [说说你对声明式编程的理解？](https://github.com/haizlin/fe-interview/issues/615)\n- [React与angular、vue有什么区别？](https://github.com/haizlin/fe-interview/issues/614)\n- [React是哪个公司开发的？](https://github.com/haizlin/fe-interview/issues/613)\n- [React是什么？它的主要特点是什么？](https://github.com/haizlin/fe-interview/issues/612)\n- [简要描述下你知道的React工作原理是什么？](https://github.com/haizlin/fe-interview/issues/611)\n- [在React中怎样改变组件状态，以及状态改变的过程是什么？](https://github.com/haizlin/fe-interview/issues/606)\n- [在React中你是怎么进行状态管理的？](https://github.com/haizlin/fe-interview/issues/605)\n- [React声明组件有哪几种方法，各有什么不同？](https://github.com/haizlin/fe-interview/issues/604)\n\n### ReactNative\n- [如何在React Native中设置环境变量？]()\n- [请描述下Code Push的原理是什么？](https://github.com/haizlin/fe-interview/issues/783)\n- [React Native怎样查看日记？](https://github.com/haizlin/fe-interview/issues/782)\n- [React Native怎样测试？](https://github.com/haizlin/fe-interview/issues/781)\n- [React Native怎样调试？](https://github.com/haizlin/fe-interview/issues/780)\n- [React Native和React有什么区别？](https://github.com/haizlin/fe-interview/issues/779)\n- [有做过React Native项目吗？](https://github.com/haizlin/fe-interview/issues/725)\n\n### React-Router\n- [React-Router怎么获取历史对象？](https://github.com/haizlin/fe-interview/issues/922)\n- [React-Router怎么获取URL的参数？](https://github.com/haizlin/fe-interview/issues/921)\n- [在history模式中push和replace有什么区别？](https://github.com/haizlin/fe-interview/issues/778)\n- [React-Router怎么设置重定向？](https://github.com/haizlin/fe-interview/issues/777)\n- [React-Router 4中`<Router>`组件有几种类型？](https://github.com/haizlin/fe-interview/issues/776)\n- [React-Router 3和React-Router 4有什么变化？添加了什么好的特性？](https://github.com/haizlin/fe-interview/issues/775)\n- [React-Router的实现原理是什么？](https://github.com/haizlin/fe-interview/issues/774)\n- [React-Router 4的switch有什么用？](https://github.com/haizlin/fe-interview/issues/773)\n- [React-Router的路由有几种模式？](https://github.com/haizlin/fe-interview/issues/772)\n- [React-Router 4怎样在路由变化时重新渲染同一个组件？](https://github.com/haizlin/fe-interview/issues/771)\n- [React-Router的`<Link>`标签和`<a>`标签有什么区别？](https://github.com/haizlin/fe-interview/issues/770)\n- [React的路由和普通路由有什么区别？](https://github.com/haizlin/fe-interview/issues/728)\n- [请你说说React的路由的优缺点？](https://github.com/haizlin/fe-interview/issues/727)\n- [请你说说React的路由是什么？](https://github.com/haizlin/fe-interview/issues/726)\n\n### Redux/Mobx\n- [你有了解Rxjs是什么吗？它是做什么的？](https://github.com/haizlin/fe-interview/issues/920)\n- [在Redux中怎么发起网络请求？](https://github.com/haizlin/fe-interview/issues/919)\n- [Redux怎样重置状态？](https://github.com/haizlin/fe-interview/issues/918)\n- [Redux怎样设置初始状态？](https://github.com/haizlin/fe-interview/issues/917)\n- [Context api可以取代Redux吗？为什么？](https://github.com/haizlin/fe-interview/issues/916)\n- [推荐在reducer中触发Action吗？为什么？](https://github.com/haizlin/fe-interview/issues/915)\n- [Redux怎么添加新的中间件？](https://github.com/haizlin/fe-interview/issues/914)\n- [redux-saga和redux-thunk有什么本质的区别？](https://github.com/haizlin/fe-interview/issues/913)\n- [在React中你是怎么对异步方案进行选型的？](https://github.com/haizlin/fe-interview/issues/912)\n- [你知道redux-saga的原理吗？](https://github.com/haizlin/fe-interview/issues/911)\n- [你有使用过redux-saga中间件吗？它是干什么的？](https://github.com/haizlin/fe-interview/issues/910)\n- [Redux中异步action和同步action最大的区别是什么？](https://github.com/haizlin/fe-interview/issues/769)\n- [Redux和vuex有什么区别？](https://github.com/haizlin/fe-interview/issues/768)\n- [Redux的中间件是什么？你有用过哪些Redux的中间件？](https://github.com/haizlin/fe-interview/issues/767)\n- [说说Redux的实现流程](https://github.com/haizlin/fe-interview/issues/766)\n- [Mobx的设计思想是什么？](https://github.com/haizlin/fe-interview/issues/765)\n- [Redux由哪些组件构成？](https://github.com/haizlin/fe-interview/issues/764)\n- [Mobx和Redux有什么区别？](https://github.com/haizlin/fe-interview/issues/763)\n- [在React项目中你是如何选择Redux和Mobx的？说说你的理解](https://github.com/haizlin/fe-interview/issues/762)\n- [你有在React中使用过Mobx吗？它的运用场景有哪些？](https://github.com/haizlin/fe-interview/issues/761)\n- [Redux的thunk作用是什么？](https://github.com/haizlin/fe-interview/issues/740)\n- [Redux的数据存储和本地储存有什么区别？](https://github.com/haizlin/fe-interview/issues/739)\n- [在Redux中，什么是reducer？它有什么作用？](https://github.com/haizlin/fe-interview/issues/738)\n- [举例说明怎么在Redux中定义action？](https://github.com/haizlin/fe-interview/issues/737)\n- [在Redux中，什么是action？](https://github.com/haizlin/fe-interview/issues/736)\n- [在Redux中，什么是store？](https://github.com/haizlin/fe-interview/issues/735)\n- [为什么Redux能做到局部渲染呢？](https://github.com/haizlin/fe-interview/issues/734)\n- [说说Redux的优缺点分别是什么？](https://github.com/haizlin/fe-interview/issues/733)\n- [Redux和Flux的区别是什么？](https://github.com/haizlin/fe-interview/issues/732)\n- [Redux它的三个原则是什么？](https://github.com/haizlin/fe-interview/issues/731)\n- [什么是单一数据源？](https://github.com/haizlin/fe-interview/issues/730)\n- [什么是Redux？说说你对Redux的理解？有哪些运用场景？](https://github.com/haizlin/fe-interview/issues/729)\n\n### Flux\n- [请说说点击按钮触发到状态更改，数据的流向？](https://github.com/haizlin/fe-interview/issues/742)\n- [请描述下Flux的思想](https://github.com/haizlin/fe-interview/issues/742)\n- [什么是Flux？说说你对Flux的理解？有哪些运用场景？](https://github.com/haizlin/fe-interview/issues/741)\n\n## Reference\n\n- <https://github.com/qiu-deqing/FE-interview>\n- <https://github.com/haizlin/fe-interview>\n","slug":"2-每日-3-1","published":0,"updated":"2022-03-07T01:54:18.869Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k5bv7o002u0h3l6hivd3y1","content":"<ul>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/897\">你有使用过loadable组件吗？它帮我们解决了什么问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/896\">你有使用过suspense组件吗？它帮我们解决了什么问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/895\">怎样动态导入组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/894\">如何给非控组件设置默认的值？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/893\">怎么在React中引入其它的UI库，例如Bootstrap</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/892\">怎样将事件传递给子组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/891\">怎样使用Hooks获取服务端数据？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/890\">使用Hooks要遵守哪些原则？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/889\">render方法的原理你有了解吗？它返回的数据类型是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/888\">useEffect和useLayoutEffect有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/887\">在React项目中你用过哪些动画的包？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/886\">React必须使用JSX吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/885\">自定义组件时render是可选的吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/884\">需要把keys设置为全局唯一吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/883\">怎么定时更新一个组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/882\">React根据不同的环境打包不同的域名？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/881\">使用webpack打包React项目，怎么减小生成的js大小？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/880\">在React中怎么使用async/await？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/879\">你阅读了几遍React的源码？都有哪些收获？你是怎么阅读的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/878\">什么是React.forwardRef？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/877\">写个例子说明什么是JSX的内联条件渲染</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/876\">在React中怎么将参数传递给事件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/875\">React的事件和普通的HTML事件有什么不同？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/874\">在React中怎么阻止事件的默认行为？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/873\">你最喜欢React的哪一个特性（说一个就好）？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/872\">在React中什么时候使用箭头函数更方便呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/871\">你最不喜欢React的哪一个特性（说一个就好）？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/870\">说说你对React的reconciliation（一致化算法）的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/869\">使用PropTypes和Flow有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/868\">怎样有条件地渲染组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/867\">在JSX中如何写注释？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/866\">constructor和getInitialState有不同？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/865\">写例子说明React如何在JSX中实现for循环</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/864\">为什么建议Fragment包裹元素？它的简写是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/863\">你有用过React.Fragment吗？说说它有什么用途？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/862\">在React中你有遇到过安全问题吗？怎么解决？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/861\">React中如何监听state的变化？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/860\">React什么是有状态组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/859\">React v15中怎么处理错误边界？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/858\">React Fiber它的目的是解决什么问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/857\">React为什么不要直接修改state？如果想修改怎么做？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/856\">create-react-app有什么好处？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/855\">装饰器(Decorator)在React中有什么应用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/854\">使用高阶组件(HOC)实现一个loading组件</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/853\">如何用React实现滚动动画？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/852\">说出几点你认为的React最佳实践</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/851\">你是如何划分React组件的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/850\">举例说明如何在React创建一个事件</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/849\">如何更新组件的状态？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/848\">怎样将多个组件嵌入到一个组件中？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/847\">React的render中可以写{if else}这样的判断吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/846\">React为什么要搞一个Hooks？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/845\">React Hooks帮我们解决了哪些问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/844\">使用React的memo和forwardRef包装的组件为什么提示children类型不对？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/843\">有在项目中使用过Antd吗？说说它的好处</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/842\">在React中如果去除生产环境上的sourcemap？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/841\">在React中怎么引用sass或less？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/840\">组件卸载前，加在DOM元素的监听事件和定时器要不要手动清除？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/839\">为什么标签里的for要写成htmlFor呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/838\">状态管理器解决了什么问题？什么时候用状态管理器？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/837\">状态管理器它精髓是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/836\">函数式组件有没有生命周期？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/835\">在React中怎么引用第三方插件？比如说jQuery等</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/834\">React的触摸事件有哪几种？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/833\">路由切换时同一组件无法重新渲染的有什么方法可以解决？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/832\">React16新特性有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/831\">你有用过哪些React的UI库？它们的优缺点分别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/830\"><code>&lt;div onClick=&#123;handlerClick&#125;&gt;单击&lt;/div&gt;</code>和<code>&lt;div onClick=&#123;handlerClick(1)&#125;&gt;单击&lt;/div&gt;</code>有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/829\">在React中如何引入图片？哪种方式更好？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/828\">在React中怎么使用字体图标？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/827\">React的应用如何打包发布？它的步骤是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/826\">ES6的语法’…’在React中有哪些应用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/825\">如何封装一个React的全局公共组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/824\">在React中组件的props改变时更新组件的有哪些方法？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/823\">immutable的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/822\">你对immutable有了解吗？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/821\">如何提高组件的渲染效率呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/820\">在React中如何避免不必要的render？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/819\">render在什么时候会被触发？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/818\">写出React动态改变class切换组件样式</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/817\">React中怎么操作虚拟DOM的Class属性？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/816\">为什么属性使用className而不是class呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/815\">请说下react组件更新的机制是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/814\">怎么在JSX里属性可以被覆盖吗？覆盖的原则是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/813\">怎么在JSX里使用自定义属性？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/812\">怎么防止HTML被转义？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/811\">经常用React，你知道React的核心思想是什么吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/810\">在React中我们怎么做静态类型检测？都有哪些方法可以做到？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/809\">在React中组件的state和setState有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/808\">React怎样跳过重新渲染？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/807\">React怎么判断什么时候重新渲染组件呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/806\">什么是React的实例？函数式组件有没有实例？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/805\">在React中如何判断点击元素属于哪一个组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/804\">在React中组件和元素有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/803\">在React中声明组件时组件名的第一个字母必须是大写吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/802\">举例说明什么是高阶组件(HOC)的反向继承？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/801\">有用过React Devtools吗？说说它的优缺点分别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/800\">举例说明什么是高阶组件(HOC)的属性代理？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/799\">React的isMounted有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/798\">React组件命名推荐的方式是哪个？为什么不推荐使用displayName？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/797\">React的displayName有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/796\">说说你对React的组件命名规范的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/795\">说说你对React的项目结构的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/794\">React16废弃了哪些生命周期？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/793\">怎样在React中开启生产模式？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/792\">React中getInitialState方法的作用是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/791\">React中你知道creatClass的原理吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/790\">React中验证props的目的是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/789\">React中你有使用过getDefaultProps吗？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/788\">React中你有使用过propType吗？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/787\">React中怎么检验props？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/786\">React.createClass和extends Component的区别有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/785\">高阶组件(HOC)有哪些优点和缺点？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/784\">给组件设置很多属性时不想一个个去设置有什么办法可以解决这问题呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/756\">React16跟之前的版本生命周期有哪些变化？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/755\">怎样实现React组件的记忆？原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/754\">创建React动画有哪些方式？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/753\">为什么建议不要过渡使用Refs？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/752\">在React使用高阶组件(HOC)有遇到过哪些问题？如何解决？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/751\">在使用React过程中什么时候用高阶组件(HOC)？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/724\">说说React diff的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/723\">React怎么提高列表渲染的性能？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/722\">使用ES6的class定义的组件不支持mixins了，那用什么可以替代呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/720\">为何说虚拟DOM会提高性能？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/719\">React的性能优化在哪个生命周期？它优化的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/718\">你知道的React性能优化有哪些方法？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/717\">举例说明在React中怎么使用样式？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/716\">React有哪几种方法来处理表单输入？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/715\">什么是浅层渲染？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/714\">你有做过React的单元测试吗？如果有，用的是哪些工具？怎么做的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/713\">在React中什么是合成事件？有什么用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/712\">使用React写一个todo应用，说说你的思路</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/711\">React16的reconciliation和commit分别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/710\">React的函数式组件有没有生命周期？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/709\">useState和this.state的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/708\">请说说什么是useImperativeHandle？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/707\">请说说什么是useReducer？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/706\">请说说什么是useRef？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/705\">请说说什么是useEffect？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/704\">举例说明useState</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/703\">请说说什么是useState？为什么要使用useState？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/702\">请描述下你对React的新特性Hooks的理解？它有哪些应用场景？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/701\">说说你对Error Boundaries的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/700\">说说你对Fiber架构的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/699\">说说你是怎么理解React的业务组件和技术组件的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/698\">为什么建议setState的第一个参数是callback而不是一个对象呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/697\">展示组件和容器组件有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/696\">Mern和Yeoman脚手架有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/695\">你有在项目中使用过Yeoman脚手架吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/694\">你有在项目中使用过Mern脚手架吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/693\">shouldComponentUpdate方法是做什么的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/692\">怎样在React中使用innerHTML？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/691\">你有写过React的中间件插件吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/690\">React的中间件机制是怎么样的？这种机制有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/689\">React中你用过哪些第三方的中间件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/688\">不用脚手架，你会手动搭建React项目吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/687\">请说说React中Portal是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/686\">React中修改prop引发的生命周期有哪几个？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/685\">React多个setState调用的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/684\">React中调用setState会更新的生命周期有哪几个？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/683\">React中setState的第二个参数作用是什么呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/682\">React中的setState是同步还是异步的呢？为什么state并不一定会同步更新？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/681\">React中的setState批量更新的过程是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/680\">React中的setState执行机制是什么呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/679\">在React中遍历的方法有哪些？它们有什么区别呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/678\">请说说你对React的render方法的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/677\">props.children.map和js的map有什么区别？为什么优先选择React的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/676\">有用过React的严格模式吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/675\">React中的setState和replaceState的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/674\">React中的setState缺点是什么呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/673\">有用过React的Fragment吗？它的运用场景是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/672\">React组件间共享数据方法有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/671\">React的状态提升是什么？使用场景有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/670\">简单描述下你有做过哪些React项目？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/669\">在构造函数中调用super(props)的目的是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/668\">你是如何学习React的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/667\">从旧版本的React升级到新版本的React有做过吗？有遇到过什么坑？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/666\">你用过React版本有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/665\">有用过React的服务端渲染吗？怎么做的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/664\">React的mixins有什么作用？适用于什么场景？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/663\">React怎么拿到组件对应的DOM元素？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/662\">请描述下事件在React中的处理方式是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/661\">JSX和HTML有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/660\">React的书写规范有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/659\">create-react-app创建新运用怎么解决卡的问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/658\">使用React的方式有哪几种？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/657\">说说你对reader的context的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/656\">同时引用这三个库React.js、React-dom.js和babel.js它们都有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/655\">你知道Virtual DOM的工作原理吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/654\">你阅读过React的源码吗？简要说下它的执行流程</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/653\">React中怎样阻止组件渲染？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/652\">React非兄弟组件如何通信？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/651\">React兄弟组件如何通信？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/650\">React非父子组件如何通信？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/649\">React父子组件如何通信？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/648\">React组件间的通信有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/647\">类组件和函数式组件有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/646\">React自定义组件你写过吗？说说看都写过哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/645\">React组件的state和props两者有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/644\">React有几种构建组件的方式？可以写出来吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/643\">React中遍历时为什么不用索引作为唯一的key值？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/642\">React中的key有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/641\">React中除了在构造函数中绑定this,还有别的方式吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/640\">在React中页面重新加载时怎样保留数据？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/639\">请描述下React的事件机制</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/638\">怎样在React中创建一个事件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/637\">在React中无状态组件有什么运用场景？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/636\">描述下在React中无状态组件和有状态组件的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/635\">写一个React的高阶组件(HOC)并说明你对它的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/634\">React中可以在render访问refs吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/633\">React中refs的作用是什么？有哪些应用场景？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/632\">请描述你对纯函数的理解？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/631\">受控组件和非受控组件有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/630\">React中什么是非控组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/629\">React中什么是受控组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/628\">React中发起网络请求应该在哪个生命周期中进行？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/627\">说说React的生命周期有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/626\">说说你对“在React中，一切都是组件”的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/625\">写React你是用es6还是es5的语法？有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/624\">浏览器为什么无法直接JSX？怎么解决呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/623\">在使用React过程中你都踩过哪些坑？你是怎么填坑的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/622\">说说你喜欢React的原因是什么？它有什么优缺点？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/621\">如何解决引用类型在pureComponent下修改值的时候，页面不渲染的问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/620\">createElement与cloneElement两者有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/619\">解释下React中Element 和Component两者的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/618\">解释下React中component和pureComponent两者的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/617\">React的虚拟DOM和vue的虚拟DOM有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/616\">你觉得React上手快不快？它有哪些限制？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/615\">说说你对声明式编程的理解？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/614\">React与angular、vue有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/613\">React是哪个公司开发的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/612\">React是什么？它的主要特点是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/611\">简要描述下你知道的React工作原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/606\">在React中怎样改变组件状态，以及状态改变的过程是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/605\">在React中你是怎么进行状态管理的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/604\">React声明组件有哪几种方法，各有什么不同？</a></li>\n</ul>\n<h3 id=\"ReactNative\"><a href=\"#ReactNative\" class=\"headerlink\" title=\"ReactNative\"></a>ReactNative</h3><ul>\n<li><a href=\"\">如何在React Native中设置环境变量？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/783\">请描述下Code Push的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/782\">React Native怎样查看日记？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/781\">React Native怎样测试？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/780\">React Native怎样调试？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/779\">React Native和React有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/725\">有做过React Native项目吗？</a></li>\n</ul>\n<h3 id=\"React-Router\"><a href=\"#React-Router\" class=\"headerlink\" title=\"React-Router\"></a>React-Router</h3><ul>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/922\">React-Router怎么获取历史对象？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/921\">React-Router怎么获取URL的参数？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/778\">在history模式中push和replace有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/777\">React-Router怎么设置重定向？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/776\">React-Router 4中<code>&lt;Router&gt;</code>组件有几种类型？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/775\">React-Router 3和React-Router 4有什么变化？添加了什么好的特性？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/774\">React-Router的实现原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/773\">React-Router 4的switch有什么用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/772\">React-Router的路由有几种模式？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/771\">React-Router 4怎样在路由变化时重新渲染同一个组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/770\">React-Router的<code>&lt;Link&gt;</code>标签和<code>&lt;a&gt;</code>标签有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/728\">React的路由和普通路由有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/727\">请你说说React的路由的优缺点？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/726\">请你说说React的路由是什么？</a></li>\n</ul>\n<h3 id=\"Redux-Mobx\"><a href=\"#Redux-Mobx\" class=\"headerlink\" title=\"Redux/Mobx\"></a>Redux/Mobx</h3><ul>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/920\">你有了解Rxjs是什么吗？它是做什么的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/919\">在Redux中怎么发起网络请求？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/918\">Redux怎样重置状态？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/917\">Redux怎样设置初始状态？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/916\">Context api可以取代Redux吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/915\">推荐在reducer中触发Action吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/914\">Redux怎么添加新的中间件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/913\">redux-saga和redux-thunk有什么本质的区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/912\">在React中你是怎么对异步方案进行选型的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/911\">你知道redux-saga的原理吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/910\">你有使用过redux-saga中间件吗？它是干什么的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/769\">Redux中异步action和同步action最大的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/768\">Redux和vuex有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/767\">Redux的中间件是什么？你有用过哪些Redux的中间件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/766\">说说Redux的实现流程</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/765\">Mobx的设计思想是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/764\">Redux由哪些组件构成？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/763\">Mobx和Redux有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/762\">在React项目中你是如何选择Redux和Mobx的？说说你的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/761\">你有在React中使用过Mobx吗？它的运用场景有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/740\">Redux的thunk作用是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/739\">Redux的数据存储和本地储存有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/738\">在Redux中，什么是reducer？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/737\">举例说明怎么在Redux中定义action？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/736\">在Redux中，什么是action？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/735\">在Redux中，什么是store？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/734\">为什么Redux能做到局部渲染呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/733\">说说Redux的优缺点分别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/732\">Redux和Flux的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/731\">Redux它的三个原则是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/730\">什么是单一数据源？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/729\">什么是Redux？说说你对Redux的理解？有哪些运用场景？</a></li>\n</ul>\n<h3 id=\"Flux\"><a href=\"#Flux\" class=\"headerlink\" title=\"Flux\"></a>Flux</h3><ul>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/742\">请说说点击按钮触发到状态更改，数据的流向？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/742\">请描述下Flux的思想</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/741\">什么是Flux？说说你对Flux的理解？有哪些运用场景？</a></li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ul>\n<li><a href=\"https://github.com/qiu-deqing/FE-interview\">https://github.com/qiu-deqing/FE-interview</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview\">https://github.com/haizlin/fe-interview</a></li>\n</ul>\n","site":{"data":{}},"wordcount":6721,"excerpt":"","more":"<ul>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/897\">你有使用过loadable组件吗？它帮我们解决了什么问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/896\">你有使用过suspense组件吗？它帮我们解决了什么问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/895\">怎样动态导入组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/894\">如何给非控组件设置默认的值？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/893\">怎么在React中引入其它的UI库，例如Bootstrap</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/892\">怎样将事件传递给子组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/891\">怎样使用Hooks获取服务端数据？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/890\">使用Hooks要遵守哪些原则？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/889\">render方法的原理你有了解吗？它返回的数据类型是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/888\">useEffect和useLayoutEffect有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/887\">在React项目中你用过哪些动画的包？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/886\">React必须使用JSX吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/885\">自定义组件时render是可选的吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/884\">需要把keys设置为全局唯一吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/883\">怎么定时更新一个组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/882\">React根据不同的环境打包不同的域名？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/881\">使用webpack打包React项目，怎么减小生成的js大小？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/880\">在React中怎么使用async/await？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/879\">你阅读了几遍React的源码？都有哪些收获？你是怎么阅读的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/878\">什么是React.forwardRef？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/877\">写个例子说明什么是JSX的内联条件渲染</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/876\">在React中怎么将参数传递给事件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/875\">React的事件和普通的HTML事件有什么不同？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/874\">在React中怎么阻止事件的默认行为？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/873\">你最喜欢React的哪一个特性（说一个就好）？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/872\">在React中什么时候使用箭头函数更方便呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/871\">你最不喜欢React的哪一个特性（说一个就好）？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/870\">说说你对React的reconciliation（一致化算法）的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/869\">使用PropTypes和Flow有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/868\">怎样有条件地渲染组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/867\">在JSX中如何写注释？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/866\">constructor和getInitialState有不同？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/865\">写例子说明React如何在JSX中实现for循环</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/864\">为什么建议Fragment包裹元素？它的简写是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/863\">你有用过React.Fragment吗？说说它有什么用途？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/862\">在React中你有遇到过安全问题吗？怎么解决？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/861\">React中如何监听state的变化？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/860\">React什么是有状态组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/859\">React v15中怎么处理错误边界？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/858\">React Fiber它的目的是解决什么问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/857\">React为什么不要直接修改state？如果想修改怎么做？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/856\">create-react-app有什么好处？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/855\">装饰器(Decorator)在React中有什么应用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/854\">使用高阶组件(HOC)实现一个loading组件</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/853\">如何用React实现滚动动画？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/852\">说出几点你认为的React最佳实践</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/851\">你是如何划分React组件的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/850\">举例说明如何在React创建一个事件</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/849\">如何更新组件的状态？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/848\">怎样将多个组件嵌入到一个组件中？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/847\">React的render中可以写{if else}这样的判断吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/846\">React为什么要搞一个Hooks？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/845\">React Hooks帮我们解决了哪些问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/844\">使用React的memo和forwardRef包装的组件为什么提示children类型不对？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/843\">有在项目中使用过Antd吗？说说它的好处</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/842\">在React中如果去除生产环境上的sourcemap？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/841\">在React中怎么引用sass或less？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/840\">组件卸载前，加在DOM元素的监听事件和定时器要不要手动清除？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/839\">为什么标签里的for要写成htmlFor呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/838\">状态管理器解决了什么问题？什么时候用状态管理器？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/837\">状态管理器它精髓是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/836\">函数式组件有没有生命周期？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/835\">在React中怎么引用第三方插件？比如说jQuery等</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/834\">React的触摸事件有哪几种？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/833\">路由切换时同一组件无法重新渲染的有什么方法可以解决？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/832\">React16新特性有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/831\">你有用过哪些React的UI库？它们的优缺点分别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/830\"><code>&lt;div onClick=&#123;handlerClick&#125;&gt;单击&lt;/div&gt;</code>和<code>&lt;div onClick=&#123;handlerClick(1)&#125;&gt;单击&lt;/div&gt;</code>有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/829\">在React中如何引入图片？哪种方式更好？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/828\">在React中怎么使用字体图标？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/827\">React的应用如何打包发布？它的步骤是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/826\">ES6的语法’…’在React中有哪些应用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/825\">如何封装一个React的全局公共组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/824\">在React中组件的props改变时更新组件的有哪些方法？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/823\">immutable的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/822\">你对immutable有了解吗？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/821\">如何提高组件的渲染效率呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/820\">在React中如何避免不必要的render？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/819\">render在什么时候会被触发？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/818\">写出React动态改变class切换组件样式</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/817\">React中怎么操作虚拟DOM的Class属性？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/816\">为什么属性使用className而不是class呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/815\">请说下react组件更新的机制是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/814\">怎么在JSX里属性可以被覆盖吗？覆盖的原则是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/813\">怎么在JSX里使用自定义属性？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/812\">怎么防止HTML被转义？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/811\">经常用React，你知道React的核心思想是什么吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/810\">在React中我们怎么做静态类型检测？都有哪些方法可以做到？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/809\">在React中组件的state和setState有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/808\">React怎样跳过重新渲染？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/807\">React怎么判断什么时候重新渲染组件呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/806\">什么是React的实例？函数式组件有没有实例？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/805\">在React中如何判断点击元素属于哪一个组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/804\">在React中组件和元素有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/803\">在React中声明组件时组件名的第一个字母必须是大写吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/802\">举例说明什么是高阶组件(HOC)的反向继承？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/801\">有用过React Devtools吗？说说它的优缺点分别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/800\">举例说明什么是高阶组件(HOC)的属性代理？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/799\">React的isMounted有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/798\">React组件命名推荐的方式是哪个？为什么不推荐使用displayName？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/797\">React的displayName有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/796\">说说你对React的组件命名规范的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/795\">说说你对React的项目结构的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/794\">React16废弃了哪些生命周期？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/793\">怎样在React中开启生产模式？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/792\">React中getInitialState方法的作用是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/791\">React中你知道creatClass的原理吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/790\">React中验证props的目的是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/789\">React中你有使用过getDefaultProps吗？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/788\">React中你有使用过propType吗？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/787\">React中怎么检验props？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/786\">React.createClass和extends Component的区别有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/785\">高阶组件(HOC)有哪些优点和缺点？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/784\">给组件设置很多属性时不想一个个去设置有什么办法可以解决这问题呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/756\">React16跟之前的版本生命周期有哪些变化？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/755\">怎样实现React组件的记忆？原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/754\">创建React动画有哪些方式？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/753\">为什么建议不要过渡使用Refs？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/752\">在React使用高阶组件(HOC)有遇到过哪些问题？如何解决？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/751\">在使用React过程中什么时候用高阶组件(HOC)？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/724\">说说React diff的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/723\">React怎么提高列表渲染的性能？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/722\">使用ES6的class定义的组件不支持mixins了，那用什么可以替代呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/720\">为何说虚拟DOM会提高性能？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/719\">React的性能优化在哪个生命周期？它优化的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/718\">你知道的React性能优化有哪些方法？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/717\">举例说明在React中怎么使用样式？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/716\">React有哪几种方法来处理表单输入？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/715\">什么是浅层渲染？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/714\">你有做过React的单元测试吗？如果有，用的是哪些工具？怎么做的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/713\">在React中什么是合成事件？有什么用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/712\">使用React写一个todo应用，说说你的思路</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/711\">React16的reconciliation和commit分别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/710\">React的函数式组件有没有生命周期？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/709\">useState和this.state的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/708\">请说说什么是useImperativeHandle？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/707\">请说说什么是useReducer？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/706\">请说说什么是useRef？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/705\">请说说什么是useEffect？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/704\">举例说明useState</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/703\">请说说什么是useState？为什么要使用useState？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/702\">请描述下你对React的新特性Hooks的理解？它有哪些应用场景？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/701\">说说你对Error Boundaries的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/700\">说说你对Fiber架构的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/699\">说说你是怎么理解React的业务组件和技术组件的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/698\">为什么建议setState的第一个参数是callback而不是一个对象呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/697\">展示组件和容器组件有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/696\">Mern和Yeoman脚手架有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/695\">你有在项目中使用过Yeoman脚手架吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/694\">你有在项目中使用过Mern脚手架吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/693\">shouldComponentUpdate方法是做什么的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/692\">怎样在React中使用innerHTML？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/691\">你有写过React的中间件插件吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/690\">React的中间件机制是怎么样的？这种机制有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/689\">React中你用过哪些第三方的中间件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/688\">不用脚手架，你会手动搭建React项目吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/687\">请说说React中Portal是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/686\">React中修改prop引发的生命周期有哪几个？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/685\">React多个setState调用的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/684\">React中调用setState会更新的生命周期有哪几个？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/683\">React中setState的第二个参数作用是什么呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/682\">React中的setState是同步还是异步的呢？为什么state并不一定会同步更新？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/681\">React中的setState批量更新的过程是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/680\">React中的setState执行机制是什么呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/679\">在React中遍历的方法有哪些？它们有什么区别呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/678\">请说说你对React的render方法的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/677\">props.children.map和js的map有什么区别？为什么优先选择React的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/676\">有用过React的严格模式吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/675\">React中的setState和replaceState的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/674\">React中的setState缺点是什么呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/673\">有用过React的Fragment吗？它的运用场景是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/672\">React组件间共享数据方法有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/671\">React的状态提升是什么？使用场景有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/670\">简单描述下你有做过哪些React项目？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/669\">在构造函数中调用super(props)的目的是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/668\">你是如何学习React的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/667\">从旧版本的React升级到新版本的React有做过吗？有遇到过什么坑？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/666\">你用过React版本有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/665\">有用过React的服务端渲染吗？怎么做的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/664\">React的mixins有什么作用？适用于什么场景？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/663\">React怎么拿到组件对应的DOM元素？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/662\">请描述下事件在React中的处理方式是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/661\">JSX和HTML有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/660\">React的书写规范有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/659\">create-react-app创建新运用怎么解决卡的问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/658\">使用React的方式有哪几种？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/657\">说说你对reader的context的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/656\">同时引用这三个库React.js、React-dom.js和babel.js它们都有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/655\">你知道Virtual DOM的工作原理吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/654\">你阅读过React的源码吗？简要说下它的执行流程</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/653\">React中怎样阻止组件渲染？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/652\">React非兄弟组件如何通信？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/651\">React兄弟组件如何通信？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/650\">React非父子组件如何通信？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/649\">React父子组件如何通信？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/648\">React组件间的通信有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/647\">类组件和函数式组件有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/646\">React自定义组件你写过吗？说说看都写过哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/645\">React组件的state和props两者有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/644\">React有几种构建组件的方式？可以写出来吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/643\">React中遍历时为什么不用索引作为唯一的key值？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/642\">React中的key有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/641\">React中除了在构造函数中绑定this,还有别的方式吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/640\">在React中页面重新加载时怎样保留数据？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/639\">请描述下React的事件机制</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/638\">怎样在React中创建一个事件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/637\">在React中无状态组件有什么运用场景？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/636\">描述下在React中无状态组件和有状态组件的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/635\">写一个React的高阶组件(HOC)并说明你对它的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/634\">React中可以在render访问refs吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/633\">React中refs的作用是什么？有哪些应用场景？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/632\">请描述你对纯函数的理解？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/631\">受控组件和非受控组件有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/630\">React中什么是非控组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/629\">React中什么是受控组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/628\">React中发起网络请求应该在哪个生命周期中进行？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/627\">说说React的生命周期有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/626\">说说你对“在React中，一切都是组件”的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/625\">写React你是用es6还是es5的语法？有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/624\">浏览器为什么无法直接JSX？怎么解决呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/623\">在使用React过程中你都踩过哪些坑？你是怎么填坑的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/622\">说说你喜欢React的原因是什么？它有什么优缺点？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/621\">如何解决引用类型在pureComponent下修改值的时候，页面不渲染的问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/620\">createElement与cloneElement两者有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/619\">解释下React中Element 和Component两者的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/618\">解释下React中component和pureComponent两者的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/617\">React的虚拟DOM和vue的虚拟DOM有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/616\">你觉得React上手快不快？它有哪些限制？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/615\">说说你对声明式编程的理解？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/614\">React与angular、vue有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/613\">React是哪个公司开发的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/612\">React是什么？它的主要特点是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/611\">简要描述下你知道的React工作原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/606\">在React中怎样改变组件状态，以及状态改变的过程是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/605\">在React中你是怎么进行状态管理的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/604\">React声明组件有哪几种方法，各有什么不同？</a></li>\n</ul>\n<h3 id=\"ReactNative\"><a href=\"#ReactNative\" class=\"headerlink\" title=\"ReactNative\"></a>ReactNative</h3><ul>\n<li><a href=\"\">如何在React Native中设置环境变量？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/783\">请描述下Code Push的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/782\">React Native怎样查看日记？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/781\">React Native怎样测试？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/780\">React Native怎样调试？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/779\">React Native和React有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/725\">有做过React Native项目吗？</a></li>\n</ul>\n<h3 id=\"React-Router\"><a href=\"#React-Router\" class=\"headerlink\" title=\"React-Router\"></a>React-Router</h3><ul>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/922\">React-Router怎么获取历史对象？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/921\">React-Router怎么获取URL的参数？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/778\">在history模式中push和replace有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/777\">React-Router怎么设置重定向？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/776\">React-Router 4中<code>&lt;Router&gt;</code>组件有几种类型？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/775\">React-Router 3和React-Router 4有什么变化？添加了什么好的特性？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/774\">React-Router的实现原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/773\">React-Router 4的switch有什么用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/772\">React-Router的路由有几种模式？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/771\">React-Router 4怎样在路由变化时重新渲染同一个组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/770\">React-Router的<code>&lt;Link&gt;</code>标签和<code>&lt;a&gt;</code>标签有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/728\">React的路由和普通路由有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/727\">请你说说React的路由的优缺点？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/726\">请你说说React的路由是什么？</a></li>\n</ul>\n<h3 id=\"Redux-Mobx\"><a href=\"#Redux-Mobx\" class=\"headerlink\" title=\"Redux/Mobx\"></a>Redux/Mobx</h3><ul>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/920\">你有了解Rxjs是什么吗？它是做什么的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/919\">在Redux中怎么发起网络请求？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/918\">Redux怎样重置状态？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/917\">Redux怎样设置初始状态？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/916\">Context api可以取代Redux吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/915\">推荐在reducer中触发Action吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/914\">Redux怎么添加新的中间件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/913\">redux-saga和redux-thunk有什么本质的区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/912\">在React中你是怎么对异步方案进行选型的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/911\">你知道redux-saga的原理吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/910\">你有使用过redux-saga中间件吗？它是干什么的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/769\">Redux中异步action和同步action最大的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/768\">Redux和vuex有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/767\">Redux的中间件是什么？你有用过哪些Redux的中间件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/766\">说说Redux的实现流程</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/765\">Mobx的设计思想是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/764\">Redux由哪些组件构成？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/763\">Mobx和Redux有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/762\">在React项目中你是如何选择Redux和Mobx的？说说你的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/761\">你有在React中使用过Mobx吗？它的运用场景有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/740\">Redux的thunk作用是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/739\">Redux的数据存储和本地储存有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/738\">在Redux中，什么是reducer？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/737\">举例说明怎么在Redux中定义action？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/736\">在Redux中，什么是action？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/735\">在Redux中，什么是store？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/734\">为什么Redux能做到局部渲染呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/733\">说说Redux的优缺点分别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/732\">Redux和Flux的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/731\">Redux它的三个原则是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/730\">什么是单一数据源？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/729\">什么是Redux？说说你对Redux的理解？有哪些运用场景？</a></li>\n</ul>\n<h3 id=\"Flux\"><a href=\"#Flux\" class=\"headerlink\" title=\"Flux\"></a>Flux</h3><ul>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/742\">请说说点击按钮触发到状态更改，数据的流向？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/742\">请描述下Flux的思想</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/741\">什么是Flux？说说你对Flux的理解？有哪些运用场景？</a></li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ul>\n<li><a href=\"https://github.com/qiu-deqing/FE-interview\">https://github.com/qiu-deqing/FE-interview</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview\">https://github.com/haizlin/fe-interview</a></li>\n</ul>\n"},{"title":"TypeScript 笔记","index_img":"/img/2022-03-16-1.png","abbrlink":"81dvefb9","date":"2022-03-16T15:19:28.000Z","_content":"\n## 声明空间\n\nts 中有两种：类型声明空间与变量声明空间\n\n类型声明空间：\n\n```ts\nclass Foo {}\ninterface Bar {}\ntype Bas = {};\n```\n\n如下当做类型注解使用\n\n```ts\nlet foo: Foo;\nlet bar: Bar;\nlet bas: Bas;\n```\n\n定义 interface Bar {} 不能当做变量来用，因为它没有定义在变量声明空间中。\n\n## 模块\n\n如下方式定义在 **全局模块** 中\n\n```ts\nconst foo = 123;\n```\n\n如下方式文件的根级别位置含有 import 或者 export,在文件中创建本地作用域，是定义在 **文件模块** 中\n\n```ts\nexport const foo = 123;\n```\n\n## 命名空间\n\n命名空间一个最明确的目的就是解决重名问题。\n\n命名空间是位于全局命名空间下的一个普通的带有名字的 JavaScript 对象。作用是将一系列相关的全局变量组织到一个对象的属性。\n\n```ts\nnamespace Letter { \n  export let a = 1; \n  export let b = 2; \n} \n```\n\n编译成 js 如下：\n\n```ts\nvar Letter; \n(function (Letter) { \n    Letter.a = 1; \n    Letter.b = 2; \n})(Letter || (Letter = {})); \n```\n\n## 动态导入表达式 import()\n\nimport() 异步加载一个模块, 该语句用于 Webpack Code Splitting。\n\n```ts\nimport(/* webpackChunkName: \"momentjs\" */ 'moment')\n  .then(moment => {\n    const time = moment().format();\n    console.log('TypeScript >= 2.4.0 Dynamic Import Expression:');\n    console.log(time);\n  })\n  .catch(err => {\n    console.log('Failed to load moment', err);\n  });\n```\n\n## TS 类型系统\n\n原始类型 string、number、boolean 可以被用作类型注解。\n\n## 数组\n\n两种方式定义数组：\n\n1、元素类型后加 []\n\n```ts\nlet list: number[] = [1, 2, 3];\n```\n\n2、 数组泛型 Array<元素类型>\n\n```js\nlet list: Array<number> = [1, 2, 3];\n```\n\n## 接口\n\n合并众多类型声明至一个类型声明\n\n```ts\ninterface Name {\n  first: string;\n  second: string;\n}\n\nlet name: Name = {\n  first: 'John',\n  second: 'Doe'\n};\n\n```\n\n## 内联类型注解\n\n```ts\nlet name: {\n  first: string;\n  second: string;\n};\n\nname = {\n  first: 'John',\n  second: 'Doe'\n};\n```\n\n内联类型注解可以省去为类型起名的麻烦。\n\n如果你发现需要多次使用相同的内联注解时，那么考虑把它重构为一个接口（或者是 type alias)\n\n## 特殊类型\n\nany、 null、 undefined 以及 void\n\n:void 来表示一个函数没有一个返回值\n\n```ts\nfunction log(message: string): void {\n  console.log(message);\n}\n```\n\n## 泛型\n\n在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。\n\n```ts\nfunction reverse<T>(items: T[]): T[] {\n  const toreturn = [];\n  for (let i = items.length - 1; i >= 0; i--) {\n    toreturn.push(items[i]);\n  }\n  return toreturn;\n}\n```\n\n## 联合类型\n\n多种类型之一\n\n```ts\nfunction formatCommandline(command: string[] | string) {\n  let line = '';\n  if (typeof command === 'string') {\n    line = command.trim();\n  } else {\n    line = command.join(' ').trim();\n  }\n\n  // Do stuff with line: string\n}\n```\n\n## 交叉类型\n\nextend 是一种非常常见的模式，从两个对象中创建一个新对象，新对象拥有着两个对象所有的功能。\n\n```ts\nfunction extend<T extends object, U extends object>(first: T, second: U): T & U {\n  const result = <T & U>{};\n  for (let id in first) {\n    (<T>result)[id] = first[id];\n  }\n  for (let id in second) {\n    if (!result.hasOwnProperty(id)) {\n      (<U>result)[id] = second[id];\n    }\n  }\n\n  return result;\n}\n\nconst x = extend({ a: 'hello' }, { b: 42 });\n\n// 现在 x 拥有了 a 属性与 b 属性\nconst a = x.a;\nconst b = x.b;\n```\n\n## 元祖类型 Tuple\n\n固定长度的，元素数据类型不同的数组。数据不可变。\n\n```js\ntype FixedArray = [string, number, string];\n\nconst mixedArray: FixedArray = ['a', 2, 'c'];\n```\n\n## 类型别名\n\n以为任意的类型注解提供类型别名,在联合类型和交叉类型中比较实用。\n\n```ts\ntype StrOrNum = string | number;\n\n// 使用\nlet sample: StrOrNum;\nsample = 123;\nsample = '123';\n\n// 会检查类型\nsample = true; // Error\n```\n\n```ts\ntype Text = string | { text: string };\ntype Coordinates = [number, number];\ntype Callback = (data: string) => void;\n```\n\n## @types\n\n通过 npm 来安装使用 @types,如 `npm install @types/jquery --save-dev`\n\n## declare 声明文件\n\n.d.ts文件是ts用来声明变量，模块，type，interface等等的。\n\n在这种后缀的ts文件声明这些东西和在纯ts文件声明这些东西又什么区别呢？\n\n在.d.ts声明变量或者模块等东西之后，在其他地方可以不用import导入这些东西就可以直接用，用，而且有语法提示。\n\ndeclare声明一个类型:\n\n```ts\ndeclare type Asd {\n    name: string;\n}\n```\n\n在tsconfig.json文件里面的include数组里面添加这个文件, 在include包含的文件范围内可以直接使用Asd这个type。\n\ndeclare声明一个模块:\n\n```ts\ndeclare module '*.css';\ndeclare module '*.less';\ndeclare module '*.png';\n```\n\n编译ts文件的时候，导入一个.css/.less/.png格式的文件，如果没有经过declare的话是会提示语法错误的\n\ndeclare声明一个变量:\n\n在项目中引入了一个sdk，这个sdk（我们以微信的sdk为例）里面有一些全局的对象（比如wx），但是如果不经过任何的声明，在ts文件里面直接用wx.config()的话，肯定会报错。\n\ndeclare声明一个作用域:\n\n```ts\ndeclare namespace API {\n    interface ResponseList {}\n}\n```\n\n声明完之后在其他地方的ts就可以直接API.ResponseList引用到这个接口类型\n\n## 接口\n\n两种声明方式：\n\n```ts\n// 内联注解\ndeclare const myPoint: { x: number; y: number };\n\n// 接口形式\ninterface Point {\n  x: number;\n  y: number;\n}\ndeclare const myPoint: Point;\n```\n\n接口形式的好处在于，如果有人创建了一个基于 myPoint 的库来添加新成员, 可以轻松将此成员添加到 myPoint 的现有声明中\n\n```ts\n// Lib a.d.ts\ninterface Point {\n  x: number,\n  y: number\n}\ndeclare const myPoint: Point\n\n// Lib b.d.ts\ninterface Point {\n  z: number\n}\n\n// Your code\nmyPoint.z // Allowed!\n```\n\n## 函数重载\n\n函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 |操作符或者?操作符，把所有可能的输入类型全部包含进去，以具体实现。\n\n```ts\n// 上边是声明\nfunction add (arg1: string, arg2: string): string\nfunction add (arg1: number, arg2: number): number\n// 因为我们在下边有具体函数的实现，所以这里并不需要添加 declare 关键字\n\n// 下边是实现\nfunction add (arg1: string | number, arg2: string | number) {\n  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2\n  if (typeof arg1 === 'string' && typeof arg2 === 'string') {\n    return arg1 + arg2\n  } else if (typeof arg1 === 'number' && typeof arg2 === 'number') {\n    return arg1 + arg2\n  }\n}\n```\n\n函数重载的意义在于能够让你知道传入不同的参数得到不同的结果，如果传入的参数不同，但是得到的结果（类型）却相同，那么不要使用函数重载（没有意义）。\n如果函数的返回值类型相同，那么也不需要使用函数重载\n\n以下场景可以不需要重载：\n\n```ts\nfunction func (a: number): number\nfunction func (a: number, b: number): number\n\n// 像这样的是参数个数的区别，我们可以使用可选参数来代替函数重载的定义\n\nfunction func (a: number, b?: number): number\n```\n\n```ts\n// 亦或是一些参数类型的区别导致的\nfunction func (a: number): number\nfunction func (a: string): number\n\n// 这时我们应该使用联合类型来代替函数重载\nfunction func (a: number | string): number\n```\n\n## 函数声明\n\n在没有提供函数实现的情况下，有两种声明函数类型的方式:\n\n```ts\ntype LongHand = {\n  (a: number): number;\n}; //当你想使用函数重载时, 只能用此方式\n\ntype ShortHand = (a: number) => number;\n```\n\n## 可调用的类型注解\n\n使用类型别名或者接口来表示一个可被调用的类型注解：\n\n```ts\ninterface ReturnString {\n  (): string;\n}\n// 表示一个返回值为 string 的函数：\n```\n\n```ts\ndeclare const foo: ReturnString;\n\nconst bar = foo(); // bar 被推断为一个字符串。\n```\n\n## 类型断言\n\nts 允许你覆盖它的推断，并且能以你任何你想要的方式分析它\n\njs 迁移到 ts 时常见：\n\n```ts\nconst foo = {};\nfoo.bar = 123; // Error: 'bar' 属性不存在于 ‘{}’\nfoo.bas = 'hello'; // Error: 'bas' 属性不存在于 '{}'\n```\n\nfoo 类型推断为 {}，不存在属性。通过类型断言来避免该问题\n\n```ts\ninterface Foo {\n  bar: number;\n  bas: string;\n}\n\nconst foo = {} as Foo;\nfoo.bar = 123;\nfoo.bas = 'hello';\n```\n\n## 允许额外的属性\n\n包含索引签名，以明确表明可以使用额外的属性：\n\n```ts\nlet x: { foo: number, [x: string]: any };\n\nx = { foo: 1, baz: 2 }; // ok, 'baz' 属性匹配于索引签名\n```\n\nReact State 中示例：\n\n```ts\n// 假设\ninterface State {\n  foo: string;\n  bar: string;\n}\n\n// 你可能想做：\nthis.setState({ foo: 'Hello' }); // Error: 没有属性 'bar'\n\n// 因为 state 包含 'foo' 与 'bar'，TypeScript 会强制你这么做：\nthis.setState({ foo: 'Hello', bar: this.state.bar });\n```\n\n## 类型保护\n\nts 会推到条件块中的变量类型\n\n```ts\nfunction doSome(x: number | string) {\n  if (typeof x === 'string') {\n    // 在这个块中，TypeScript 知道 `x` 的类型必须是 `string`\n    console.log(x.subtr(1)); // Error: 'subtr' 方法并没有存在于 `string` 上\n    console.log(x.substr(1)); // ok\n  }\n\n  x.substr(1); // Error: 无法保证 `x` 是 `string` 类型\n}\n```\n\nin 操作符可以一个对象上是否存在一个属性，它通常也被作为类型保护使用\n\n```ts\ninterface A {\n  x: number;\n}\n\ninterface B {\n  y: string;\n}\n\nfunction doStuff(q: A | B) {\n  if ('x' in q) {\n    // q: A\n  } else {\n    // q: B\n  }\n}\n```\n\n## 字面量类型\n\n字面量类型本身不使用，在一个联合类型中组合创建一个强大的（实用的）抽象。\n\n字符串字面量：\n\n```ts\nlet foo: 'Hello';\nfoo = 'Bar'; // Error: 'bar' 不能赋值给类型 'Hello'\n```\n\n```ts\ntype CardinalDirection = 'North' | 'East' | 'South' | 'West';\n\nfunction move(distance: number, direction: CardinalDirection) {\n  // ...\n}\n\nmove(1, 'North'); // ok\nmove(1, 'Nurth'); // Error\n```\n\nboolean 和 number 的字面量类型：\n\n```ts\ntype OneToFive = 1 | 2 | 3 | 4 | 5;\ntype Bools = true | false;\n```\n\n## Readonly\n\n```ts\nfunction foo(config: { readonly bar: number, readonly bas: number }) {\n  // ..\n}\n\ntype Foo = {\n  readonly bar: number;\n  readonly bas: number;\n};\n\n```\n\n这有一个 Readonly 的映射类型，它接收一个泛型 T，用来把它的所有属性标记为只读类型：\n\n```ts\ntype Foo = {\n  bar: number;\n  bas: number;\n};\n\ntype FooReadonly = Readonly<Foo>;\n```\n\n## 泛型2\n\n创建泛型类\n\n```ts\n// 创建一个泛型类\nclass Queue<T> {\n  private data: T[] = [];\n  push = (item: T) => this.data.push(item);\n  pop = (): T | undefined => this.data.shift();\n}\n\n// 简单的使用\nconst queue = new Queue<number>();\nqueue.push(0);\nqueue.push('1'); // Error：不能推入一个 `string`，只有 number 类型被允许\n```\n\n泛型的误用：近在单个参数或一个位置被使用\n\n```ts\ndeclare function foo<T>(arg: T): void;  \n// \ndeclare function foo(arg: any): void;\n```\n\naxios 请求中 泛型的使用：\n\n通常情况下，我们会把后端返回数据格式单独放入一个 interface 里：\n\n```ts\n// 请求接口数据\nexport interface ResponseData<T = any> {\n  /**\n   * 状态码\n   * @type { number }\n   */\n  code: number;\n\n  /**\n   * 数据\n   * @type { T }\n   */\n  result: T;\n\n  /**\n   * 消息\n   * @type { string }\n   */\n  message: string;\n}\n```\n\n```ts\n// 在 axios.ts 文件中对 axios 进行了处理，例如添加通用配置、拦截器等\nimport Ax from './axios';\n\nimport { ResponseData } from './interface.ts';\n\nexport function getUser<T>() {\n  return Ax.get<ResponseData<T>>('/somepath')\n    .then(res => res.data)\n    .catch(err => console.error(err));\n}\n```\n\n写入返回的数据类型 User\n\n```ts\ninterface User {\n  name: string;\n  age: number;\n}\n\nasync function test() {\n  // user 被推断出为\n  // {\n  //  code: number,\n  //  result: { name: string, age: number },\n  //  message: string\n  // }\n  const user = await getUser<User>();\n}\n```\n\n## never 类型\n\n常用在\n\n- 从来不会有返回值的函数（如：如果函数内含有 while(true) {}）\n- 总是会抛出错误的函数 throw new Error\n\nnever 类型仅能被赋值给另外一个 never\n\n```ts\nlet bar: never = (() => {\n  throw new Error('Throw my hands in the air like I just dont care');\n})();\n```\n\nvoid 和 never 的区别：\n\n- void 表示没有任何类型，never 表示永远不存在的值的类型。\n- 当一个函数返回空值时，它的返回值为 void 类型，但是，当一个函数永不返回时（或者总是抛出错误），它的返回值为 never 类型。\n- void 类型可以被赋值，但是除了 never 本身以外，其他任何类型不能赋值给 never。\n\n## redux 中的联合类型\n\n```ts\nimport { createStore } from 'redux';\n\ntype Action =\n  | {\n      type: 'INCREMENT';\n    }\n  | {\n      type: 'DECREMENT';\n    };\n\n//reducer\nfunction counter(state = 0, action: Action) {\n  switch (action.type) {\n    case 'INCREMENT':\n      return state + 1;\n    case 'DECREMENT':\n      return state - 1;\n    default:\n      return state;\n  }\n}\n```\n\n## 索引签名\n\n声明一个索引签名时，所有明确的成员都必须符合索引签名：\n\n```ts\ninterface Bar {\n  [key: string]: number;\n  x: number;\n  y: string; // Error: y 属性必须为 number 类型\n}\n```\n\n映射类型来使索引字符串为联合类型中的一员\n\n```ts\ntype Index = 'a' | 'b' | 'c';\ntype FromIndex = { [k in Index]?: number };\n\nconst bad: FromIndex = { b: 1, c: 2, d: 3 }; //err\n```\n\n```ts\ntype FromSomeIndex<K extends string> = { [key in K]: number };\n```\n\n## 索引签名中排除某些属性\n\n用交叉类型解决\n\n```ts\ntype FieldState = {\n  value: string;\n};\n\ntype FromState = {\n  isValid: boolean; // Error: 不符合索引签名\n  [filedName: string]: FieldState;\n};\n```\n\n交叉类型：\n\n```ts\ntype FieldState = {\n  value: string;\n};\n\ntype FormState = { isValid: boolean } & { [fieldName: string]: FieldState };\n```\n\n## 流动的类型\n\n捕获变量的类型\n\n```ts\nlet foo = 123;\nlet bar: typeof foo; // 'bar' 类型与 'foo' 类型相同（在这里是： 'number'）\n```\n\n捕获类成员类型 需要声明一个变量\n\n```ts\nclass Foo {\n  foo: number; // 我们想要捕获的类型\n}\n\ndeclare let _foo: Foo;\n\n// 与之前做法相同\nlet bar: typeof _foo.foo;\n```\n\n捕获键的名称\n\n```ts\nconst colors = {\n  red: 'red',\n  blue: 'blue'\n};\n\ntype Colors = keyof typeof colors;\n\nlet color: Colors; // color 的类型是 'red' | 'blue'\ncolor = 'red'; // ok\ncolor = 'blue'; // ok\ncolor = 'anythingElse'; // Error\n```\n\n## JSX 的支持\n\n函数组件\n\n```ts\ntype Props = {\n  foo: string;\n};\n\nconst MyComponent: React.FunctionComponent<Props> = props => {\n  return <span>{props.foo}</span>;\n};\n\n<MyComponent foo=\"bar\" />;\n```\n\n类组件\n\n```ts\ntype Props = {\n  foo: string;\n};\n\nclass MyComponent extends React.Component<Props, {}> {\n  render() {\n    return <span>{this.props.foo}</span>;\n  }\n}\n\n<MyComponent foo=\"bar\" />;\n```\n\n泛型组件\n\n```ts\n// 一个泛型组件\ntype SelectProps<T> = { items: T[] };\nclass Select<T> extends React.Component<SelectProps<T>, any> {}\n\n// 使用\nconst Form = () => <Select<string> items={['a', 'b']} />;\n```\n\n泛型函数\n\n```ts\nfunction foo<T>(x: T): T {\n  return x;\n}\n\n// 不能使用箭头函数\nconst foo = <T>(x: T) => T; // Error: T 标签没有关闭\n\n解决办法：用 extends 提示编译器这是泛型\nconst foo = <T extends {}>(x: T) => x;\n```\n\nRefs\n\n一个变量时，使用 ref 和 null 的联合类型\n\n```ts\nclass Use {\n  exampleRef: Example | null = null;\n\n  render() {\n    return <Example ref={exampleRef => (this.exampleRef = exampleRef)} />;\n  }\n}\n```\n\n## 参考\n\n- [深入理解 TypeScript](https://jkchao.github.io/typescript-book-chinese/)\n- [https://www.tslang.cn/docs/handbook/generics.html](https://www.tslang.cn/docs/handbook/generics.html)\n","source":"_posts/9.TypeScript 笔记.md","raw":"---\ntitle: TypeScript 笔记\nindex_img: /img/2022-03-16-1.png\nabbrlink: 81dvefb9\ndate: 2022-03-16 23:19:28\ntags: TypeScript\ncategories: TypeScript\n---\n\n## 声明空间\n\nts 中有两种：类型声明空间与变量声明空间\n\n类型声明空间：\n\n```ts\nclass Foo {}\ninterface Bar {}\ntype Bas = {};\n```\n\n如下当做类型注解使用\n\n```ts\nlet foo: Foo;\nlet bar: Bar;\nlet bas: Bas;\n```\n\n定义 interface Bar {} 不能当做变量来用，因为它没有定义在变量声明空间中。\n\n## 模块\n\n如下方式定义在 **全局模块** 中\n\n```ts\nconst foo = 123;\n```\n\n如下方式文件的根级别位置含有 import 或者 export,在文件中创建本地作用域，是定义在 **文件模块** 中\n\n```ts\nexport const foo = 123;\n```\n\n## 命名空间\n\n命名空间一个最明确的目的就是解决重名问题。\n\n命名空间是位于全局命名空间下的一个普通的带有名字的 JavaScript 对象。作用是将一系列相关的全局变量组织到一个对象的属性。\n\n```ts\nnamespace Letter { \n  export let a = 1; \n  export let b = 2; \n} \n```\n\n编译成 js 如下：\n\n```ts\nvar Letter; \n(function (Letter) { \n    Letter.a = 1; \n    Letter.b = 2; \n})(Letter || (Letter = {})); \n```\n\n## 动态导入表达式 import()\n\nimport() 异步加载一个模块, 该语句用于 Webpack Code Splitting。\n\n```ts\nimport(/* webpackChunkName: \"momentjs\" */ 'moment')\n  .then(moment => {\n    const time = moment().format();\n    console.log('TypeScript >= 2.4.0 Dynamic Import Expression:');\n    console.log(time);\n  })\n  .catch(err => {\n    console.log('Failed to load moment', err);\n  });\n```\n\n## TS 类型系统\n\n原始类型 string、number、boolean 可以被用作类型注解。\n\n## 数组\n\n两种方式定义数组：\n\n1、元素类型后加 []\n\n```ts\nlet list: number[] = [1, 2, 3];\n```\n\n2、 数组泛型 Array<元素类型>\n\n```js\nlet list: Array<number> = [1, 2, 3];\n```\n\n## 接口\n\n合并众多类型声明至一个类型声明\n\n```ts\ninterface Name {\n  first: string;\n  second: string;\n}\n\nlet name: Name = {\n  first: 'John',\n  second: 'Doe'\n};\n\n```\n\n## 内联类型注解\n\n```ts\nlet name: {\n  first: string;\n  second: string;\n};\n\nname = {\n  first: 'John',\n  second: 'Doe'\n};\n```\n\n内联类型注解可以省去为类型起名的麻烦。\n\n如果你发现需要多次使用相同的内联注解时，那么考虑把它重构为一个接口（或者是 type alias)\n\n## 特殊类型\n\nany、 null、 undefined 以及 void\n\n:void 来表示一个函数没有一个返回值\n\n```ts\nfunction log(message: string): void {\n  console.log(message);\n}\n```\n\n## 泛型\n\n在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。\n\n```ts\nfunction reverse<T>(items: T[]): T[] {\n  const toreturn = [];\n  for (let i = items.length - 1; i >= 0; i--) {\n    toreturn.push(items[i]);\n  }\n  return toreturn;\n}\n```\n\n## 联合类型\n\n多种类型之一\n\n```ts\nfunction formatCommandline(command: string[] | string) {\n  let line = '';\n  if (typeof command === 'string') {\n    line = command.trim();\n  } else {\n    line = command.join(' ').trim();\n  }\n\n  // Do stuff with line: string\n}\n```\n\n## 交叉类型\n\nextend 是一种非常常见的模式，从两个对象中创建一个新对象，新对象拥有着两个对象所有的功能。\n\n```ts\nfunction extend<T extends object, U extends object>(first: T, second: U): T & U {\n  const result = <T & U>{};\n  for (let id in first) {\n    (<T>result)[id] = first[id];\n  }\n  for (let id in second) {\n    if (!result.hasOwnProperty(id)) {\n      (<U>result)[id] = second[id];\n    }\n  }\n\n  return result;\n}\n\nconst x = extend({ a: 'hello' }, { b: 42 });\n\n// 现在 x 拥有了 a 属性与 b 属性\nconst a = x.a;\nconst b = x.b;\n```\n\n## 元祖类型 Tuple\n\n固定长度的，元素数据类型不同的数组。数据不可变。\n\n```js\ntype FixedArray = [string, number, string];\n\nconst mixedArray: FixedArray = ['a', 2, 'c'];\n```\n\n## 类型别名\n\n以为任意的类型注解提供类型别名,在联合类型和交叉类型中比较实用。\n\n```ts\ntype StrOrNum = string | number;\n\n// 使用\nlet sample: StrOrNum;\nsample = 123;\nsample = '123';\n\n// 会检查类型\nsample = true; // Error\n```\n\n```ts\ntype Text = string | { text: string };\ntype Coordinates = [number, number];\ntype Callback = (data: string) => void;\n```\n\n## @types\n\n通过 npm 来安装使用 @types,如 `npm install @types/jquery --save-dev`\n\n## declare 声明文件\n\n.d.ts文件是ts用来声明变量，模块，type，interface等等的。\n\n在这种后缀的ts文件声明这些东西和在纯ts文件声明这些东西又什么区别呢？\n\n在.d.ts声明变量或者模块等东西之后，在其他地方可以不用import导入这些东西就可以直接用，用，而且有语法提示。\n\ndeclare声明一个类型:\n\n```ts\ndeclare type Asd {\n    name: string;\n}\n```\n\n在tsconfig.json文件里面的include数组里面添加这个文件, 在include包含的文件范围内可以直接使用Asd这个type。\n\ndeclare声明一个模块:\n\n```ts\ndeclare module '*.css';\ndeclare module '*.less';\ndeclare module '*.png';\n```\n\n编译ts文件的时候，导入一个.css/.less/.png格式的文件，如果没有经过declare的话是会提示语法错误的\n\ndeclare声明一个变量:\n\n在项目中引入了一个sdk，这个sdk（我们以微信的sdk为例）里面有一些全局的对象（比如wx），但是如果不经过任何的声明，在ts文件里面直接用wx.config()的话，肯定会报错。\n\ndeclare声明一个作用域:\n\n```ts\ndeclare namespace API {\n    interface ResponseList {}\n}\n```\n\n声明完之后在其他地方的ts就可以直接API.ResponseList引用到这个接口类型\n\n## 接口\n\n两种声明方式：\n\n```ts\n// 内联注解\ndeclare const myPoint: { x: number; y: number };\n\n// 接口形式\ninterface Point {\n  x: number;\n  y: number;\n}\ndeclare const myPoint: Point;\n```\n\n接口形式的好处在于，如果有人创建了一个基于 myPoint 的库来添加新成员, 可以轻松将此成员添加到 myPoint 的现有声明中\n\n```ts\n// Lib a.d.ts\ninterface Point {\n  x: number,\n  y: number\n}\ndeclare const myPoint: Point\n\n// Lib b.d.ts\ninterface Point {\n  z: number\n}\n\n// Your code\nmyPoint.z // Allowed!\n```\n\n## 函数重载\n\n函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 |操作符或者?操作符，把所有可能的输入类型全部包含进去，以具体实现。\n\n```ts\n// 上边是声明\nfunction add (arg1: string, arg2: string): string\nfunction add (arg1: number, arg2: number): number\n// 因为我们在下边有具体函数的实现，所以这里并不需要添加 declare 关键字\n\n// 下边是实现\nfunction add (arg1: string | number, arg2: string | number) {\n  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2\n  if (typeof arg1 === 'string' && typeof arg2 === 'string') {\n    return arg1 + arg2\n  } else if (typeof arg1 === 'number' && typeof arg2 === 'number') {\n    return arg1 + arg2\n  }\n}\n```\n\n函数重载的意义在于能够让你知道传入不同的参数得到不同的结果，如果传入的参数不同，但是得到的结果（类型）却相同，那么不要使用函数重载（没有意义）。\n如果函数的返回值类型相同，那么也不需要使用函数重载\n\n以下场景可以不需要重载：\n\n```ts\nfunction func (a: number): number\nfunction func (a: number, b: number): number\n\n// 像这样的是参数个数的区别，我们可以使用可选参数来代替函数重载的定义\n\nfunction func (a: number, b?: number): number\n```\n\n```ts\n// 亦或是一些参数类型的区别导致的\nfunction func (a: number): number\nfunction func (a: string): number\n\n// 这时我们应该使用联合类型来代替函数重载\nfunction func (a: number | string): number\n```\n\n## 函数声明\n\n在没有提供函数实现的情况下，有两种声明函数类型的方式:\n\n```ts\ntype LongHand = {\n  (a: number): number;\n}; //当你想使用函数重载时, 只能用此方式\n\ntype ShortHand = (a: number) => number;\n```\n\n## 可调用的类型注解\n\n使用类型别名或者接口来表示一个可被调用的类型注解：\n\n```ts\ninterface ReturnString {\n  (): string;\n}\n// 表示一个返回值为 string 的函数：\n```\n\n```ts\ndeclare const foo: ReturnString;\n\nconst bar = foo(); // bar 被推断为一个字符串。\n```\n\n## 类型断言\n\nts 允许你覆盖它的推断，并且能以你任何你想要的方式分析它\n\njs 迁移到 ts 时常见：\n\n```ts\nconst foo = {};\nfoo.bar = 123; // Error: 'bar' 属性不存在于 ‘{}’\nfoo.bas = 'hello'; // Error: 'bas' 属性不存在于 '{}'\n```\n\nfoo 类型推断为 {}，不存在属性。通过类型断言来避免该问题\n\n```ts\ninterface Foo {\n  bar: number;\n  bas: string;\n}\n\nconst foo = {} as Foo;\nfoo.bar = 123;\nfoo.bas = 'hello';\n```\n\n## 允许额外的属性\n\n包含索引签名，以明确表明可以使用额外的属性：\n\n```ts\nlet x: { foo: number, [x: string]: any };\n\nx = { foo: 1, baz: 2 }; // ok, 'baz' 属性匹配于索引签名\n```\n\nReact State 中示例：\n\n```ts\n// 假设\ninterface State {\n  foo: string;\n  bar: string;\n}\n\n// 你可能想做：\nthis.setState({ foo: 'Hello' }); // Error: 没有属性 'bar'\n\n// 因为 state 包含 'foo' 与 'bar'，TypeScript 会强制你这么做：\nthis.setState({ foo: 'Hello', bar: this.state.bar });\n```\n\n## 类型保护\n\nts 会推到条件块中的变量类型\n\n```ts\nfunction doSome(x: number | string) {\n  if (typeof x === 'string') {\n    // 在这个块中，TypeScript 知道 `x` 的类型必须是 `string`\n    console.log(x.subtr(1)); // Error: 'subtr' 方法并没有存在于 `string` 上\n    console.log(x.substr(1)); // ok\n  }\n\n  x.substr(1); // Error: 无法保证 `x` 是 `string` 类型\n}\n```\n\nin 操作符可以一个对象上是否存在一个属性，它通常也被作为类型保护使用\n\n```ts\ninterface A {\n  x: number;\n}\n\ninterface B {\n  y: string;\n}\n\nfunction doStuff(q: A | B) {\n  if ('x' in q) {\n    // q: A\n  } else {\n    // q: B\n  }\n}\n```\n\n## 字面量类型\n\n字面量类型本身不使用，在一个联合类型中组合创建一个强大的（实用的）抽象。\n\n字符串字面量：\n\n```ts\nlet foo: 'Hello';\nfoo = 'Bar'; // Error: 'bar' 不能赋值给类型 'Hello'\n```\n\n```ts\ntype CardinalDirection = 'North' | 'East' | 'South' | 'West';\n\nfunction move(distance: number, direction: CardinalDirection) {\n  // ...\n}\n\nmove(1, 'North'); // ok\nmove(1, 'Nurth'); // Error\n```\n\nboolean 和 number 的字面量类型：\n\n```ts\ntype OneToFive = 1 | 2 | 3 | 4 | 5;\ntype Bools = true | false;\n```\n\n## Readonly\n\n```ts\nfunction foo(config: { readonly bar: number, readonly bas: number }) {\n  // ..\n}\n\ntype Foo = {\n  readonly bar: number;\n  readonly bas: number;\n};\n\n```\n\n这有一个 Readonly 的映射类型，它接收一个泛型 T，用来把它的所有属性标记为只读类型：\n\n```ts\ntype Foo = {\n  bar: number;\n  bas: number;\n};\n\ntype FooReadonly = Readonly<Foo>;\n```\n\n## 泛型2\n\n创建泛型类\n\n```ts\n// 创建一个泛型类\nclass Queue<T> {\n  private data: T[] = [];\n  push = (item: T) => this.data.push(item);\n  pop = (): T | undefined => this.data.shift();\n}\n\n// 简单的使用\nconst queue = new Queue<number>();\nqueue.push(0);\nqueue.push('1'); // Error：不能推入一个 `string`，只有 number 类型被允许\n```\n\n泛型的误用：近在单个参数或一个位置被使用\n\n```ts\ndeclare function foo<T>(arg: T): void;  \n// \ndeclare function foo(arg: any): void;\n```\n\naxios 请求中 泛型的使用：\n\n通常情况下，我们会把后端返回数据格式单独放入一个 interface 里：\n\n```ts\n// 请求接口数据\nexport interface ResponseData<T = any> {\n  /**\n   * 状态码\n   * @type { number }\n   */\n  code: number;\n\n  /**\n   * 数据\n   * @type { T }\n   */\n  result: T;\n\n  /**\n   * 消息\n   * @type { string }\n   */\n  message: string;\n}\n```\n\n```ts\n// 在 axios.ts 文件中对 axios 进行了处理，例如添加通用配置、拦截器等\nimport Ax from './axios';\n\nimport { ResponseData } from './interface.ts';\n\nexport function getUser<T>() {\n  return Ax.get<ResponseData<T>>('/somepath')\n    .then(res => res.data)\n    .catch(err => console.error(err));\n}\n```\n\n写入返回的数据类型 User\n\n```ts\ninterface User {\n  name: string;\n  age: number;\n}\n\nasync function test() {\n  // user 被推断出为\n  // {\n  //  code: number,\n  //  result: { name: string, age: number },\n  //  message: string\n  // }\n  const user = await getUser<User>();\n}\n```\n\n## never 类型\n\n常用在\n\n- 从来不会有返回值的函数（如：如果函数内含有 while(true) {}）\n- 总是会抛出错误的函数 throw new Error\n\nnever 类型仅能被赋值给另外一个 never\n\n```ts\nlet bar: never = (() => {\n  throw new Error('Throw my hands in the air like I just dont care');\n})();\n```\n\nvoid 和 never 的区别：\n\n- void 表示没有任何类型，never 表示永远不存在的值的类型。\n- 当一个函数返回空值时，它的返回值为 void 类型，但是，当一个函数永不返回时（或者总是抛出错误），它的返回值为 never 类型。\n- void 类型可以被赋值，但是除了 never 本身以外，其他任何类型不能赋值给 never。\n\n## redux 中的联合类型\n\n```ts\nimport { createStore } from 'redux';\n\ntype Action =\n  | {\n      type: 'INCREMENT';\n    }\n  | {\n      type: 'DECREMENT';\n    };\n\n//reducer\nfunction counter(state = 0, action: Action) {\n  switch (action.type) {\n    case 'INCREMENT':\n      return state + 1;\n    case 'DECREMENT':\n      return state - 1;\n    default:\n      return state;\n  }\n}\n```\n\n## 索引签名\n\n声明一个索引签名时，所有明确的成员都必须符合索引签名：\n\n```ts\ninterface Bar {\n  [key: string]: number;\n  x: number;\n  y: string; // Error: y 属性必须为 number 类型\n}\n```\n\n映射类型来使索引字符串为联合类型中的一员\n\n```ts\ntype Index = 'a' | 'b' | 'c';\ntype FromIndex = { [k in Index]?: number };\n\nconst bad: FromIndex = { b: 1, c: 2, d: 3 }; //err\n```\n\n```ts\ntype FromSomeIndex<K extends string> = { [key in K]: number };\n```\n\n## 索引签名中排除某些属性\n\n用交叉类型解决\n\n```ts\ntype FieldState = {\n  value: string;\n};\n\ntype FromState = {\n  isValid: boolean; // Error: 不符合索引签名\n  [filedName: string]: FieldState;\n};\n```\n\n交叉类型：\n\n```ts\ntype FieldState = {\n  value: string;\n};\n\ntype FormState = { isValid: boolean } & { [fieldName: string]: FieldState };\n```\n\n## 流动的类型\n\n捕获变量的类型\n\n```ts\nlet foo = 123;\nlet bar: typeof foo; // 'bar' 类型与 'foo' 类型相同（在这里是： 'number'）\n```\n\n捕获类成员类型 需要声明一个变量\n\n```ts\nclass Foo {\n  foo: number; // 我们想要捕获的类型\n}\n\ndeclare let _foo: Foo;\n\n// 与之前做法相同\nlet bar: typeof _foo.foo;\n```\n\n捕获键的名称\n\n```ts\nconst colors = {\n  red: 'red',\n  blue: 'blue'\n};\n\ntype Colors = keyof typeof colors;\n\nlet color: Colors; // color 的类型是 'red' | 'blue'\ncolor = 'red'; // ok\ncolor = 'blue'; // ok\ncolor = 'anythingElse'; // Error\n```\n\n## JSX 的支持\n\n函数组件\n\n```ts\ntype Props = {\n  foo: string;\n};\n\nconst MyComponent: React.FunctionComponent<Props> = props => {\n  return <span>{props.foo}</span>;\n};\n\n<MyComponent foo=\"bar\" />;\n```\n\n类组件\n\n```ts\ntype Props = {\n  foo: string;\n};\n\nclass MyComponent extends React.Component<Props, {}> {\n  render() {\n    return <span>{this.props.foo}</span>;\n  }\n}\n\n<MyComponent foo=\"bar\" />;\n```\n\n泛型组件\n\n```ts\n// 一个泛型组件\ntype SelectProps<T> = { items: T[] };\nclass Select<T> extends React.Component<SelectProps<T>, any> {}\n\n// 使用\nconst Form = () => <Select<string> items={['a', 'b']} />;\n```\n\n泛型函数\n\n```ts\nfunction foo<T>(x: T): T {\n  return x;\n}\n\n// 不能使用箭头函数\nconst foo = <T>(x: T) => T; // Error: T 标签没有关闭\n\n解决办法：用 extends 提示编译器这是泛型\nconst foo = <T extends {}>(x: T) => x;\n```\n\nRefs\n\n一个变量时，使用 ref 和 null 的联合类型\n\n```ts\nclass Use {\n  exampleRef: Example | null = null;\n\n  render() {\n    return <Example ref={exampleRef => (this.exampleRef = exampleRef)} />;\n  }\n}\n```\n\n## 参考\n\n- [深入理解 TypeScript](https://jkchao.github.io/typescript-book-chinese/)\n- [https://www.tslang.cn/docs/handbook/generics.html](https://www.tslang.cn/docs/handbook/generics.html)\n","slug":"9-TypeScript-笔记","published":1,"updated":"2022-03-20T09:16:59.149Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k5bv7o002w0h3lgm312xnt","content":"<h2 id=\"声明空间\"><a href=\"#声明空间\" class=\"headerlink\" title=\"声明空间\"></a>声明空间</h2><p>ts 中有两种：类型声明空间与变量声明空间</p>\n<p>类型声明空间：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Foo</span> </span>&#123;&#125;\n<span class=\"hljs-keyword\">interface</span> Bar &#123;&#125;\n<span class=\"hljs-keyword\">type</span> Bas = &#123;&#125;;</code></pre></div>\n\n<p>如下当做类型注解使用</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> foo: Foo;\n<span class=\"hljs-keyword\">let</span> bar: Bar;\n<span class=\"hljs-keyword\">let</span> bas: Bas;</code></pre></div>\n\n<p>定义 interface Bar {} 不能当做变量来用，因为它没有定义在变量声明空间中。</p>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><p>如下方式定义在 <strong>全局模块</strong> 中</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-number\">123</span>;</code></pre></div>\n\n<p>如下方式文件的根级别位置含有 import 或者 export,在文件中创建本地作用域，是定义在 <strong>文件模块</strong> 中</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-number\">123</span>;</code></pre></div>\n\n<h2 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h2><p>命名空间一个最明确的目的就是解决重名问题。</p>\n<p>命名空间是位于全局命名空间下的一个普通的带有名字的 JavaScript 对象。作用是将一系列相关的全局变量组织到一个对象的属性。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">namespace</span> Letter &#123; \n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">1</span>; \n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-number\">2</span>; \n&#125;</code></pre></div>\n\n<p>编译成 js 如下：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">var</span> Letter; \n(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">Letter</span>) </span>&#123; \n    Letter.a = <span class=\"hljs-number\">1</span>; \n    Letter.b = <span class=\"hljs-number\">2</span>; \n&#125;)(Letter || (Letter = &#123;&#125;));</code></pre></div>\n\n<h2 id=\"动态导入表达式-import\"><a href=\"#动态导入表达式-import\" class=\"headerlink\" title=\"动态导入表达式 import()\"></a>动态导入表达式 import()</h2><p>import() 异步加载一个模块, 该语句用于 Webpack Code Splitting。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span>(<span class=\"hljs-comment\">/* webpackChunkName: &quot;momentjs&quot; */</span> <span class=\"hljs-string\">&#x27;moment&#x27;</span>)\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">moment</span> =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> time = moment().format();\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;TypeScript &gt;= 2.4.0 Dynamic Import Expression:&#x27;</span>);\n    <span class=\"hljs-built_in\">console</span>.log(time);\n  &#125;)\n  .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;Failed to load moment&#x27;</span>, err);\n  &#125;);</code></pre></div>\n\n<h2 id=\"TS-类型系统\"><a href=\"#TS-类型系统\" class=\"headerlink\" title=\"TS 类型系统\"></a>TS 类型系统</h2><p>原始类型 string、number、boolean 可以被用作类型注解。</p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>两种方式定义数组：</p>\n<p>1、元素类型后加 []</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> list: <span class=\"hljs-built_in\">number</span>[] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];</code></pre></div>\n\n<p>2、 数组泛型 Array&lt;元素类型&gt;</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> list: <span class=\"hljs-built_in\">Array</span>&lt;number&gt; = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];</code></pre></div>\n\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>合并众多类型声明至一个类型声明</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> Name &#123;\n  <span class=\"hljs-attr\">first</span>: <span class=\"hljs-built_in\">string</span>;\n  second: <span class=\"hljs-built_in\">string</span>;\n&#125;\n\n<span class=\"hljs-keyword\">let</span> name: Name = &#123;\n  <span class=\"hljs-attr\">first</span>: <span class=\"hljs-string\">&#x27;John&#x27;</span>,\n  <span class=\"hljs-attr\">second</span>: <span class=\"hljs-string\">&#x27;Doe&#x27;</span>\n&#125;;\n</code></pre></div>\n\n<h2 id=\"内联类型注解\"><a href=\"#内联类型注解\" class=\"headerlink\" title=\"内联类型注解\"></a>内联类型注解</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> name: &#123;\n  <span class=\"hljs-attr\">first</span>: <span class=\"hljs-built_in\">string</span>;\n  second: <span class=\"hljs-built_in\">string</span>;\n&#125;;\n\nname = &#123;\n  <span class=\"hljs-attr\">first</span>: <span class=\"hljs-string\">&#x27;John&#x27;</span>,\n  <span class=\"hljs-attr\">second</span>: <span class=\"hljs-string\">&#x27;Doe&#x27;</span>\n&#125;;</code></pre></div>\n\n<p>内联类型注解可以省去为类型起名的麻烦。</p>\n<p>如果你发现需要多次使用相同的内联注解时，那么考虑把它重构为一个接口（或者是 type alias)</p>\n<h2 id=\"特殊类型\"><a href=\"#特殊类型\" class=\"headerlink\" title=\"特殊类型\"></a>特殊类型</h2><p>any、 null、 undefined 以及 void</p>\n<p>:void 来表示一个函数没有一个返回值</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">log</span>(<span class=\"hljs-params\">message: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">void</span> </span>&#123;\n  <span class=\"hljs-built_in\">console</span>.log(message);\n&#125;</code></pre></div>\n\n<h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><p>在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reverse</span>&lt;<span class=\"hljs-title\">T</span>&gt;(<span class=\"hljs-params\">items: T[]</span>): <span class=\"hljs-title\">T</span>[] </span>&#123;\n  <span class=\"hljs-keyword\">const</span> toreturn = [];\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = items.length - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) &#123;\n    toreturn.push(items[i]);\n  &#125;\n  <span class=\"hljs-keyword\">return</span> toreturn;\n&#125;</code></pre></div>\n\n<h2 id=\"联合类型\"><a href=\"#联合类型\" class=\"headerlink\" title=\"联合类型\"></a>联合类型</h2><p>多种类型之一</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">formatCommandline</span>(<span class=\"hljs-params\">command: <span class=\"hljs-built_in\">string</span>[] | <span class=\"hljs-built_in\">string</span></span>) </span>&#123;\n  <span class=\"hljs-keyword\">let</span> line = <span class=\"hljs-string\">&#x27;&#x27;</span>;\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> command === <span class=\"hljs-string\">&#x27;string&#x27;</span>) &#123;\n    line = command.trim();\n  &#125; <span class=\"hljs-keyword\">else</span> &#123;\n    line = command.join(<span class=\"hljs-string\">&#x27; &#x27;</span>).trim();\n  &#125;\n\n  <span class=\"hljs-comment\">// Do stuff with line: string</span>\n&#125;</code></pre></div>\n\n<h2 id=\"交叉类型\"><a href=\"#交叉类型\" class=\"headerlink\" title=\"交叉类型\"></a>交叉类型</h2><p>extend 是一种非常常见的模式，从两个对象中创建一个新对象，新对象拥有着两个对象所有的功能。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">extend</span>&lt;<span class=\"hljs-title\">T</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">object</span>, <span class=\"hljs-title\">U</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">object</span>&gt;(<span class=\"hljs-params\">first: T, second: U</span>): <span class=\"hljs-title\">T</span> &amp; <span class=\"hljs-title\">U</span> </span>&#123;\n  <span class=\"hljs-keyword\">const</span> result = &lt;T &amp; U&gt;&#123;&#125;;\n  for (let id in first) &#123;\n    (&lt;T&gt;result)[id] = first[id];\n  &#125;\n  for (let id in second) &#123;\n    if (!result.hasOwnProperty(id)) &#123;\n      (&lt;U&gt;result)[id] = second[id];\n    &#125;\n  &#125;\n\n  return result;\n&#125;\n\nconst x = extend(&#123; a: &#x27;hello&#x27; &#125;, &#123; b: 42 &#125;);\n\n// 现在 x 拥有了 a 属性与 b 属性\nconst a = x.a;\nconst b = x.b;</code></pre></div>\n\n<h2 id=\"元祖类型-Tuple\"><a href=\"#元祖类型-Tuple\" class=\"headerlink\" title=\"元祖类型 Tuple\"></a>元祖类型 Tuple</h2><p>固定长度的，元素数据类型不同的数组。数据不可变。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\">type FixedArray = [string, number, string];\n\n<span class=\"hljs-keyword\">const</span> mixedArray: FixedArray = [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>];</code></pre></div>\n\n<h2 id=\"类型别名\"><a href=\"#类型别名\" class=\"headerlink\" title=\"类型别名\"></a>类型别名</h2><p>以为任意的类型注解提供类型别名,在联合类型和交叉类型中比较实用。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> StrOrNum = <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>;\n\n<span class=\"hljs-comment\">// 使用</span>\n<span class=\"hljs-keyword\">let</span> sample: StrOrNum;\nsample = <span class=\"hljs-number\">123</span>;\nsample = <span class=\"hljs-string\">&#x27;123&#x27;</span>;\n\n<span class=\"hljs-comment\">// 会检查类型</span>\nsample = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// Error</span></code></pre></div>\n\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> Text = <span class=\"hljs-built_in\">string</span> | &#123; <span class=\"hljs-attr\">text</span>: <span class=\"hljs-built_in\">string</span> &#125;;\n<span class=\"hljs-keyword\">type</span> Coordinates = [<span class=\"hljs-built_in\">number</span>, <span class=\"hljs-built_in\">number</span>];\n<span class=\"hljs-keyword\">type</span> Callback = <span class=\"hljs-function\">(<span class=\"hljs-params\">data: <span class=\"hljs-built_in\">string</span></span>) =&gt;</span> <span class=\"hljs-built_in\">void</span>;</code></pre></div>\n\n<h2 id=\"types\"><a href=\"#types\" class=\"headerlink\" title=\"@types\"></a>@types</h2><p>通过 npm 来安装使用 @types,如 <code>npm install @types/jquery --save-dev</code></p>\n<h2 id=\"declare-声明文件\"><a href=\"#declare-声明文件\" class=\"headerlink\" title=\"declare 声明文件\"></a>declare 声明文件</h2><p>.d.ts文件是ts用来声明变量，模块，type，interface等等的。</p>\n<p>在这种后缀的ts文件声明这些东西和在纯ts文件声明这些东西又什么区别呢？</p>\n<p>在.d.ts声明变量或者模块等东西之后，在其他地方可以不用import导入这些东西就可以直接用，用，而且有语法提示。</p>\n<p>declare声明一个类型:</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">type</span> Asd &#123;\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;</code></pre></div>\n\n<p>在tsconfig.json文件里面的include数组里面添加这个文件, 在include包含的文件范围内可以直接使用Asd这个type。</p>\n<p>declare声明一个模块:</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-built_in\">module</span> <span class=\"hljs-string\">&#x27;*.css&#x27;</span>;\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-built_in\">module</span> <span class=\"hljs-string\">&#x27;*.less&#x27;</span>;\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-built_in\">module</span> <span class=\"hljs-string\">&#x27;*.png&#x27;</span>;</code></pre></div>\n\n<p>编译ts文件的时候，导入一个.css/.less/.png格式的文件，如果没有经过declare的话是会提示语法错误的</p>\n<p>declare声明一个变量:</p>\n<p>在项目中引入了一个sdk，这个sdk（我们以微信的sdk为例）里面有一些全局的对象（比如wx），但是如果不经过任何的声明，在ts文件里面直接用wx.config()的话，肯定会报错。</p>\n<p>declare声明一个作用域:</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">namespace</span> API &#123;\n    <span class=\"hljs-keyword\">interface</span> ResponseList &#123;&#125;\n&#125;</code></pre></div>\n\n<p>声明完之后在其他地方的ts就可以直接API.ResponseList引用到这个接口类型</p>\n<h2 id=\"接口-1\"><a href=\"#接口-1\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>两种声明方式：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 内联注解</span>\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">const</span> myPoint: &#123; <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">number</span>; y: <span class=\"hljs-built_in\">number</span> &#125;;\n\n<span class=\"hljs-comment\">// 接口形式</span>\n<span class=\"hljs-keyword\">interface</span> Point &#123;\n  <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">number</span>;\n  y: <span class=\"hljs-built_in\">number</span>;\n&#125;\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">const</span> myPoint: Point;</code></pre></div>\n\n<p>接口形式的好处在于，如果有人创建了一个基于 myPoint 的库来添加新成员, 可以轻松将此成员添加到 myPoint 的现有声明中</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// Lib a.d.ts</span>\n<span class=\"hljs-keyword\">interface</span> Point &#123;\n  <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">number</span>,\n  <span class=\"hljs-attr\">y</span>: <span class=\"hljs-built_in\">number</span>\n&#125;\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">const</span> myPoint: Point\n\n<span class=\"hljs-comment\">// Lib b.d.ts</span>\n<span class=\"hljs-keyword\">interface</span> Point &#123;\n  <span class=\"hljs-attr\">z</span>: <span class=\"hljs-built_in\">number</span>\n&#125;\n\n<span class=\"hljs-comment\">// Your code</span>\nmyPoint.z <span class=\"hljs-comment\">// Allowed!</span></code></pre></div>\n\n<h2 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h2><p>函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 |操作符或者?操作符，把所有可能的输入类型全部包含进去，以具体实现。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 上边是声明</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">string</span>, arg2: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">string</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">number</span>, arg2: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\">// 因为我们在下边有具体函数的实现，所以这里并不需要添加 <span class=\"hljs-title\">declare</span> 关键字</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\">// 下边是实现</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>, arg2: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span></span>) </span>&#123;</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\">  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 <span class=\"hljs-title\">arg1</span> + <span class=\"hljs-title\">arg2</span></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\">  <span class=\"hljs-title\">if</span> (<span class=\"hljs-params\"><span class=\"hljs-keyword\">typeof</span> arg1 === <span class=\"hljs-string\">&#x27;string&#x27;</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> arg2 === <span class=\"hljs-string\">&#x27;string&#x27;</span></span>) </span>&#123;</span>\n<span class=\"hljs-function\">    <span class=\"hljs-title\">return</span> <span class=\"hljs-title\">arg1</span> + <span class=\"hljs-title\">arg2</span></span>\n<span class=\"hljs-function\">  &#125; <span class=\"hljs-title\">else</span> <span class=\"hljs-title\">if</span> (<span class=\"hljs-params\"><span class=\"hljs-keyword\">typeof</span> arg1 === <span class=\"hljs-string\">&#x27;number&#x27;</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> arg2 === <span class=\"hljs-string\">&#x27;number&#x27;</span></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> arg1 + arg2\n  &#125;\n&#125;</code></pre></div>\n\n<p>函数重载的意义在于能够让你知道传入不同的参数得到不同的结果，如果传入的参数不同，但是得到的结果（类型）却相同，那么不要使用函数重载（没有意义）。<br>如果函数的返回值类型相同，那么也不需要使用函数重载</p>\n<p>以下场景可以不需要重载：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span> (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span> (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, b: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\">// 像这样的是参数个数的区别，我们可以使用可选参数来代替函数重载的定义</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span> (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, b?: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span></span></span></code></pre></div>\n\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 亦或是一些参数类型的区别导致的</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span> (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span> (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">number</span></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\">// 这时我们应该使用联合类型来代替函数重载</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span> (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">number</span></span></span></span></code></pre></div>\n\n<h2 id=\"函数声明\"><a href=\"#函数声明\" class=\"headerlink\" title=\"函数声明\"></a>函数声明</h2><p>在没有提供函数实现的情况下，有两种声明函数类型的方式:</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> LongHand = &#123;\n  (a: <span class=\"hljs-built_in\">number</span>): <span class=\"hljs-built_in\">number</span>;\n&#125;; <span class=\"hljs-comment\">//当你想使用函数重载时, 只能用此方式</span>\n\n<span class=\"hljs-keyword\">type</span> ShortHand = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> <span class=\"hljs-built_in\">number</span>;</code></pre></div>\n\n<h2 id=\"可调用的类型注解\"><a href=\"#可调用的类型注解\" class=\"headerlink\" title=\"可调用的类型注解\"></a>可调用的类型注解</h2><p>使用类型别名或者接口来表示一个可被调用的类型注解：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> ReturnString &#123;\n  (): <span class=\"hljs-built_in\">string</span>;\n&#125;\n<span class=\"hljs-comment\">// 表示一个返回值为 string 的函数：</span></code></pre></div>\n\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">const</span> foo: ReturnString;\n\n<span class=\"hljs-keyword\">const</span> bar = foo(); <span class=\"hljs-comment\">// bar 被推断为一个字符串。</span></code></pre></div>\n\n<h2 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h2><p>ts 允许你覆盖它的推断，并且能以你任何你想要的方式分析它</p>\n<p>js 迁移到 ts 时常见：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> foo = &#123;&#125;;\nfoo.bar = <span class=\"hljs-number\">123</span>; <span class=\"hljs-comment\">// Error: &#x27;bar&#x27; 属性不存在于 ‘&#123;&#125;’</span>\nfoo.bas = <span class=\"hljs-string\">&#x27;hello&#x27;</span>; <span class=\"hljs-comment\">// Error: &#x27;bas&#x27; 属性不存在于 &#x27;&#123;&#125;&#x27;</span></code></pre></div>\n\n<p>foo 类型推断为 {}，不存在属性。通过类型断言来避免该问题</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> Foo &#123;\n  <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-built_in\">number</span>;\n  bas: <span class=\"hljs-built_in\">string</span>;\n&#125;\n\n<span class=\"hljs-keyword\">const</span> foo = &#123;&#125; <span class=\"hljs-keyword\">as</span> Foo;\nfoo.bar = <span class=\"hljs-number\">123</span>;\nfoo.bas = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;</code></pre></div>\n\n<h2 id=\"允许额外的属性\"><a href=\"#允许额外的属性\" class=\"headerlink\" title=\"允许额外的属性\"></a>允许额外的属性</h2><p>包含索引签名，以明确表明可以使用额外的属性：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> x: &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-built_in\">number</span>, [x: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">any</span> &#125;;\n\nx = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-number\">2</span> &#125;; <span class=\"hljs-comment\">// ok, &#x27;baz&#x27; 属性匹配于索引签名</span></code></pre></div>\n\n<p>React State 中示例：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 假设</span>\n<span class=\"hljs-keyword\">interface</span> State &#123;\n  <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-built_in\">string</span>;\n  bar: <span class=\"hljs-built_in\">string</span>;\n&#125;\n\n<span class=\"hljs-comment\">// 你可能想做：</span>\n<span class=\"hljs-built_in\">this</span>.setState(&#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;Hello&#x27;</span> &#125;); <span class=\"hljs-comment\">// Error: 没有属性 &#x27;bar&#x27;</span>\n\n<span class=\"hljs-comment\">// 因为 state 包含 &#x27;foo&#x27; 与 &#x27;bar&#x27;，TypeScript 会强制你这么做：</span>\n<span class=\"hljs-built_in\">this</span>.setState(&#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;Hello&#x27;</span>, <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-built_in\">this</span>.state.bar &#125;);</code></pre></div>\n\n<h2 id=\"类型保护\"><a href=\"#类型保护\" class=\"headerlink\" title=\"类型保护\"></a>类型保护</h2><p>ts 会推到条件块中的变量类型</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">doSome</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span></span>) </span>&#123;\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> x === <span class=\"hljs-string\">&#x27;string&#x27;</span>) &#123;\n    <span class=\"hljs-comment\">// 在这个块中，TypeScript 知道 `x` 的类型必须是 `string`</span>\n    <span class=\"hljs-built_in\">console</span>.log(x.subtr(<span class=\"hljs-number\">1</span>)); <span class=\"hljs-comment\">// Error: &#x27;subtr&#x27; 方法并没有存在于 `string` 上</span>\n    <span class=\"hljs-built_in\">console</span>.log(x.substr(<span class=\"hljs-number\">1</span>)); <span class=\"hljs-comment\">// ok</span>\n  &#125;\n\n  x.substr(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// Error: 无法保证 `x` 是 `string` 类型</span>\n&#125;</code></pre></div>\n\n<p>in 操作符可以一个对象上是否存在一个属性，它通常也被作为类型保护使用</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> A &#123;\n  <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">number</span>;\n&#125;\n\n<span class=\"hljs-keyword\">interface</span> B &#123;\n  <span class=\"hljs-attr\">y</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">doStuff</span>(<span class=\"hljs-params\">q: A | B</span>) </span>&#123;\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">&#x27;x&#x27;</span> <span class=\"hljs-keyword\">in</span> q) &#123;\n    <span class=\"hljs-comment\">// q: A</span>\n  &#125; <span class=\"hljs-keyword\">else</span> &#123;\n    <span class=\"hljs-comment\">// q: B</span>\n  &#125;\n&#125;</code></pre></div>\n\n<h2 id=\"字面量类型\"><a href=\"#字面量类型\" class=\"headerlink\" title=\"字面量类型\"></a>字面量类型</h2><p>字面量类型本身不使用，在一个联合类型中组合创建一个强大的（实用的）抽象。</p>\n<p>字符串字面量：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> foo: <span class=\"hljs-string\">&#x27;Hello&#x27;</span>;\nfoo = <span class=\"hljs-string\">&#x27;Bar&#x27;</span>; <span class=\"hljs-comment\">// Error: &#x27;bar&#x27; 不能赋值给类型 &#x27;Hello&#x27;</span></code></pre></div>\n\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> CardinalDirection = <span class=\"hljs-string\">&#x27;North&#x27;</span> | <span class=\"hljs-string\">&#x27;East&#x27;</span> | <span class=\"hljs-string\">&#x27;South&#x27;</span> | <span class=\"hljs-string\">&#x27;West&#x27;</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">move</span>(<span class=\"hljs-params\">distance: <span class=\"hljs-built_in\">number</span>, direction: CardinalDirection</span>) </span>&#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n\nmove(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;North&#x27;</span>); <span class=\"hljs-comment\">// ok</span>\nmove(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;Nurth&#x27;</span>); <span class=\"hljs-comment\">// Error</span></code></pre></div>\n\n<p>boolean 和 number 的字面量类型：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> OneToFive = <span class=\"hljs-number\">1</span> | <span class=\"hljs-number\">2</span> | <span class=\"hljs-number\">3</span> | <span class=\"hljs-number\">4</span> | <span class=\"hljs-number\">5</span>;\n<span class=\"hljs-keyword\">type</span> Bools = <span class=\"hljs-literal\">true</span> | <span class=\"hljs-literal\">false</span>;</code></pre></div>\n\n<h2 id=\"Readonly\"><a href=\"#Readonly\" class=\"headerlink\" title=\"Readonly\"></a>Readonly</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">config: &#123; <span class=\"hljs-keyword\">readonly</span> bar: <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-keyword\">readonly</span> bas: <span class=\"hljs-built_in\">number</span> &#125;</span>) </span>&#123;\n  <span class=\"hljs-comment\">// ..</span>\n&#125;\n\n<span class=\"hljs-keyword\">type</span> Foo = &#123;\n  <span class=\"hljs-keyword\">readonly</span> bar: <span class=\"hljs-built_in\">number</span>;\n  <span class=\"hljs-keyword\">readonly</span> bas: <span class=\"hljs-built_in\">number</span>;\n&#125;;\n</code></pre></div>\n\n<p>这有一个 Readonly 的映射类型，它接收一个泛型 T，用来把它的所有属性标记为只读类型：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> Foo = &#123;\n  <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-built_in\">number</span>;\n  bas: <span class=\"hljs-built_in\">number</span>;\n&#125;;\n\n<span class=\"hljs-keyword\">type</span> FooReadonly = Readonly&lt;Foo&gt;;</code></pre></div>\n\n<h2 id=\"泛型2\"><a href=\"#泛型2\" class=\"headerlink\" title=\"泛型2\"></a>泛型2</h2><p>创建泛型类</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 创建一个泛型类</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Queue</span>&lt;<span class=\"hljs-title\">T</span>&gt; </span>&#123;\n  <span class=\"hljs-keyword\">private</span> data: T[] = [];\n  push = <span class=\"hljs-function\">(<span class=\"hljs-params\">item: T</span>) =&gt;</span> <span class=\"hljs-built_in\">this</span>.data.push(item);\n  pop = (): T | <span class=\"hljs-function\"><span class=\"hljs-params\">undefined</span> =&gt;</span> <span class=\"hljs-built_in\">this</span>.data.shift();\n&#125;\n\n<span class=\"hljs-comment\">// 简单的使用</span>\n<span class=\"hljs-keyword\">const</span> queue = <span class=\"hljs-keyword\">new</span> Queue&lt;<span class=\"hljs-built_in\">number</span>&gt;();\nqueue.push(<span class=\"hljs-number\">0</span>);\nqueue.push(<span class=\"hljs-string\">&#x27;1&#x27;</span>); <span class=\"hljs-comment\">// Error：不能推入一个 `string`，只有 number 类型被允许</span></code></pre></div>\n\n<p>泛型的误用：近在单个参数或一个位置被使用</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>&lt;<span class=\"hljs-title\">T</span>&gt;(<span class=\"hljs-params\">arg: T</span>): <span class=\"hljs-title\">void</span></span>;  \n<span class=\"hljs-comment\">// </span>\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">arg: <span class=\"hljs-built_in\">any</span></span>): <span class=\"hljs-title\">void</span></span>;</code></pre></div>\n\n<p>axios 请求中 泛型的使用：</p>\n<p>通常情况下，我们会把后端返回数据格式单独放入一个 interface 里：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 请求接口数据</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> ResponseData&lt;T = any&gt; &#123;\n  <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">   * 状态码</span>\n<span class=\"hljs-comment\">   * <span class=\"hljs-doctag\">@type <span class=\"hljs-type\">&#123; number &#125;</span></span></span>\n<span class=\"hljs-comment\">   */</span>\n  <span class=\"hljs-attr\">code</span>: <span class=\"hljs-built_in\">number</span>;\n\n  <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">   * 数据</span>\n<span class=\"hljs-comment\">   * <span class=\"hljs-doctag\">@type <span class=\"hljs-type\">&#123; T &#125;</span></span></span>\n<span class=\"hljs-comment\">   */</span>\n  result: T;\n\n  <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">   * 消息</span>\n<span class=\"hljs-comment\">   * <span class=\"hljs-doctag\">@type <span class=\"hljs-type\">&#123; string &#125;</span></span></span>\n<span class=\"hljs-comment\">   */</span>\n  message: <span class=\"hljs-built_in\">string</span>;\n&#125;</code></pre></div>\n\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 在 axios.ts 文件中对 axios 进行了处理，例如添加通用配置、拦截器等</span>\n<span class=\"hljs-keyword\">import</span> Ax <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./axios&#x27;</span>;\n\n<span class=\"hljs-keyword\">import</span> &#123; ResponseData &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./interface.ts&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getUser</span>&lt;<span class=\"hljs-title\">T</span>&gt;(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> Ax.get&lt;ResponseData&lt;T&gt;&gt;(<span class=\"hljs-string\">&#x27;/somepath&#x27;</span>)\n    .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> res.data)\n    .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.error(err));\n&#125;</code></pre></div>\n\n<p>写入返回的数据类型 User</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> User &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n  age: <span class=\"hljs-built_in\">number</span>;\n&#125;\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// user 被推断出为</span>\n  <span class=\"hljs-comment\">// &#123;</span>\n  <span class=\"hljs-comment\">//  code: number,</span>\n  <span class=\"hljs-comment\">//  result: &#123; name: string, age: number &#125;,</span>\n  <span class=\"hljs-comment\">//  message: string</span>\n  <span class=\"hljs-comment\">// &#125;</span>\n  <span class=\"hljs-keyword\">const</span> user = <span class=\"hljs-keyword\">await</span> getUser&lt;User&gt;();\n&#125;</code></pre></div>\n\n<h2 id=\"never-类型\"><a href=\"#never-类型\" class=\"headerlink\" title=\"never 类型\"></a>never 类型</h2><p>常用在</p>\n<ul>\n<li>从来不会有返回值的函数（如：如果函数内含有 while(true) {}）</li>\n<li>总是会抛出错误的函数 throw new Error</li>\n</ul>\n<p>never 类型仅能被赋值给另外一个 never</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> bar: <span class=\"hljs-built_in\">never</span> = (<span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;Throw my hands in the air like I just dont care&#x27;</span>);\n&#125;)();</code></pre></div>\n\n<p>void 和 never 的区别：</p>\n<ul>\n<li>void 表示没有任何类型，never 表示永远不存在的值的类型。</li>\n<li>当一个函数返回空值时，它的返回值为 void 类型，但是，当一个函数永不返回时（或者总是抛出错误），它的返回值为 never 类型。</li>\n<li>void 类型可以被赋值，但是除了 never 本身以外，其他任何类型不能赋值给 never。</li>\n</ul>\n<h2 id=\"redux-中的联合类型\"><a href=\"#redux-中的联合类型\" class=\"headerlink\" title=\"redux 中的联合类型\"></a>redux 中的联合类型</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> &#123; createStore &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;redux&#x27;</span>;\n\n<span class=\"hljs-keyword\">type</span> Action =\n  | &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;INCREMENT&#x27;</span>;\n    &#125;\n  | &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;DECREMENT&#x27;</span>;\n    &#125;;\n\n<span class=\"hljs-comment\">//reducer</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">counter</span>(<span class=\"hljs-params\">state = <span class=\"hljs-number\">0</span>, action: Action</span>) </span>&#123;\n  <span class=\"hljs-keyword\">switch</span> (action.type) &#123;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;INCREMENT&#x27;</span>:\n      <span class=\"hljs-keyword\">return</span> state + <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;DECREMENT&#x27;</span>:\n      <span class=\"hljs-keyword\">return</span> state - <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">default</span>:\n      <span class=\"hljs-keyword\">return</span> state;\n  &#125;\n&#125;</code></pre></div>\n\n<h2 id=\"索引签名\"><a href=\"#索引签名\" class=\"headerlink\" title=\"索引签名\"></a>索引签名</h2><p>声明一个索引签名时，所有明确的成员都必须符合索引签名：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> Bar &#123;\n  [key: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">number</span>;\n  x: <span class=\"hljs-built_in\">number</span>;\n  y: <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-comment\">// Error: y 属性必须为 number 类型</span>\n&#125;</code></pre></div>\n\n<p>映射类型来使索引字符串为联合类型中的一员</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> Index = <span class=\"hljs-string\">&#x27;a&#x27;</span> | <span class=\"hljs-string\">&#x27;b&#x27;</span> | <span class=\"hljs-string\">&#x27;c&#x27;</span>;\n<span class=\"hljs-keyword\">type</span> FromIndex = &#123; [k <span class=\"hljs-keyword\">in</span> Index]?: <span class=\"hljs-built_in\">number</span> &#125;;\n\n<span class=\"hljs-keyword\">const</span> bad: FromIndex = &#123; <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">d</span>: <span class=\"hljs-number\">3</span> &#125;; <span class=\"hljs-comment\">//err</span></code></pre></div>\n\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> FromSomeIndex&lt;K <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">string</span>&gt; = &#123; [key <span class=\"hljs-keyword\">in</span> K]: <span class=\"hljs-built_in\">number</span> &#125;;</code></pre></div>\n\n<h2 id=\"索引签名中排除某些属性\"><a href=\"#索引签名中排除某些属性\" class=\"headerlink\" title=\"索引签名中排除某些属性\"></a>索引签名中排除某些属性</h2><p>用交叉类型解决</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> FieldState = &#123;\n  <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;;\n\n<span class=\"hljs-keyword\">type</span> FromState = &#123;\n  <span class=\"hljs-attr\">isValid</span>: <span class=\"hljs-built_in\">boolean</span>; <span class=\"hljs-comment\">// Error: 不符合索引签名</span>\n  [filedName: <span class=\"hljs-built_in\">string</span>]: FieldState;\n&#125;;</code></pre></div>\n\n<p>交叉类型：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> FieldState = &#123;\n  <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;;\n\n<span class=\"hljs-keyword\">type</span> FormState = &#123; <span class=\"hljs-attr\">isValid</span>: <span class=\"hljs-built_in\">boolean</span> &#125; &amp; &#123; [fieldName: <span class=\"hljs-built_in\">string</span>]: FieldState &#125;;</code></pre></div>\n\n<h2 id=\"流动的类型\"><a href=\"#流动的类型\" class=\"headerlink\" title=\"流动的类型\"></a>流动的类型</h2><p>捕获变量的类型</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-number\">123</span>;\n<span class=\"hljs-keyword\">let</span> bar: <span class=\"hljs-keyword\">typeof</span> foo; <span class=\"hljs-comment\">// &#x27;bar&#x27; 类型与 &#x27;foo&#x27; 类型相同（在这里是： &#x27;number&#x27;）</span></code></pre></div>\n\n<p>捕获类成员类型 需要声明一个变量</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Foo</span> </span>&#123;\n  <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-built_in\">number</span>; <span class=\"hljs-comment\">// 我们想要捕获的类型</span>\n&#125;\n\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">let</span> _foo: Foo;\n\n<span class=\"hljs-comment\">// 与之前做法相同</span>\n<span class=\"hljs-keyword\">let</span> bar: <span class=\"hljs-keyword\">typeof</span> _foo.foo;</code></pre></div>\n\n<p>捕获键的名称</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> colors = &#123;\n  <span class=\"hljs-attr\">red</span>: <span class=\"hljs-string\">&#x27;red&#x27;</span>,\n  <span class=\"hljs-attr\">blue</span>: <span class=\"hljs-string\">&#x27;blue&#x27;</span>\n&#125;;\n\n<span class=\"hljs-keyword\">type</span> Colors = keyof <span class=\"hljs-keyword\">typeof</span> colors;\n\n<span class=\"hljs-keyword\">let</span> color: Colors; <span class=\"hljs-comment\">// color 的类型是 &#x27;red&#x27; | &#x27;blue&#x27;</span>\ncolor = <span class=\"hljs-string\">&#x27;red&#x27;</span>; <span class=\"hljs-comment\">// ok</span>\ncolor = <span class=\"hljs-string\">&#x27;blue&#x27;</span>; <span class=\"hljs-comment\">// ok</span>\ncolor = <span class=\"hljs-string\">&#x27;anythingElse&#x27;</span>; <span class=\"hljs-comment\">// Error</span></code></pre></div>\n\n<h2 id=\"JSX-的支持\"><a href=\"#JSX-的支持\" class=\"headerlink\" title=\"JSX 的支持\"></a>JSX 的支持</h2><p>函数组件</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> Props = &#123;\n  <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;;\n\n<span class=\"hljs-keyword\">const</span> MyComponent: React.FunctionComponent&lt;Props&gt; = <span class=\"hljs-function\"><span class=\"hljs-params\">props</span> =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>&#123;props.foo&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></span>;\n&#125;;\n\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span> <span class=\"hljs-attr\">foo</span>=<span class=\"hljs-string\">&quot;bar&quot;</span> /&gt;</span></span>;</code></pre></div>\n\n<p>类组件</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> Props = &#123;\n  <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyComponent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">Props</span>, </span>&#123;&#125;&gt; &#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>&#123;this.props.foo&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></span>;\n  &#125;\n&#125;\n\n&lt;MyComponent foo=<span class=\"hljs-string\">&quot;bar&quot;</span> /&gt;;</code></pre></div>\n\n<p>泛型组件</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 一个泛型组件</span>\n<span class=\"hljs-keyword\">type</span> SelectProps&lt;T&gt; = &#123; <span class=\"hljs-attr\">items</span>: T[] &#125;;\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Select</span>&lt;<span class=\"hljs-title\">T</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">SelectProps</span>&lt;<span class=\"hljs-title\">T</span>&gt;, <span class=\"hljs-title\">any</span>&gt; </span>&#123;&#125;\n\n<span class=\"hljs-comment\">// 使用</span>\n<span class=\"hljs-keyword\">const</span> Form = <span class=\"hljs-function\">() =&gt;</span> &lt;Select&lt;<span class=\"hljs-built_in\">string</span>&gt; items=&#123;[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>]&#125; /&gt;;</code></pre></div>\n\n<p>泛型函数</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>&lt;<span class=\"hljs-title\">T</span>&gt;(<span class=\"hljs-params\">x: T</span>): <span class=\"hljs-title\">T</span> </span>&#123;\n  <span class=\"hljs-keyword\">return</span> x;\n&#125;\n\n<span class=\"hljs-comment\">// 不能使用箭头函数</span>\n<span class=\"hljs-keyword\">const</span> foo = &lt;T&gt;<span class=\"hljs-function\">(<span class=\"hljs-params\">x: T</span>) =&gt;</span> T; <span class=\"hljs-comment\">// Error: T 标签没有关闭</span>\n\n解决办法：用 <span class=\"hljs-keyword\">extends</span> 提示编译器这是泛型\n<span class=\"hljs-keyword\">const</span> foo = <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">T</span> <span class=\"hljs-attr\">extends</span> &#123;&#125;&gt;</span>(x: T) =&gt; x;</span></code></pre></div>\n\n<p>Refs</p>\n<p>一个变量时，使用 ref 和 null 的联合类型</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Use</span> </span>&#123;\n  <span class=\"hljs-attr\">exampleRef</span>: Example | <span class=\"hljs-literal\">null</span> = <span class=\"hljs-literal\">null</span>;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Example</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">&#123;exampleRef</span> =&gt;</span> (this.exampleRef = exampleRef)&#125; /&gt;</span>;\n  &#125;\n&#125;</code></pre></div>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://jkchao.github.io/typescript-book-chinese/\">深入理解 TypeScript</a></li>\n<li><a href=\"https://www.tslang.cn/docs/handbook/generics.html\">https://www.tslang.cn/docs/handbook/generics.html</a></li>\n</ul>\n","site":{"data":{}},"wordcount":10922,"excerpt":"","more":"<h2 id=\"声明空间\"><a href=\"#声明空间\" class=\"headerlink\" title=\"声明空间\"></a>声明空间</h2><p>ts 中有两种：类型声明空间与变量声明空间</p>\n<p>类型声明空间：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Foo</span> </span>&#123;&#125;\n<span class=\"hljs-keyword\">interface</span> Bar &#123;&#125;\n<span class=\"hljs-keyword\">type</span> Bas = &#123;&#125;;</code></pre>\n\n<p>如下当做类型注解使用</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> foo: Foo;\n<span class=\"hljs-keyword\">let</span> bar: Bar;\n<span class=\"hljs-keyword\">let</span> bas: Bas;</code></pre>\n\n<p>定义 interface Bar {} 不能当做变量来用，因为它没有定义在变量声明空间中。</p>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><p>如下方式定义在 <strong>全局模块</strong> 中</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-number\">123</span>;</code></pre>\n\n<p>如下方式文件的根级别位置含有 import 或者 export,在文件中创建本地作用域，是定义在 <strong>文件模块</strong> 中</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-number\">123</span>;</code></pre>\n\n<h2 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h2><p>命名空间一个最明确的目的就是解决重名问题。</p>\n<p>命名空间是位于全局命名空间下的一个普通的带有名字的 JavaScript 对象。作用是将一系列相关的全局变量组织到一个对象的属性。</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">namespace</span> Letter &#123; \n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">1</span>; \n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-number\">2</span>; \n&#125;</code></pre>\n\n<p>编译成 js 如下：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">var</span> Letter; \n(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">Letter</span>) </span>&#123; \n    Letter.a = <span class=\"hljs-number\">1</span>; \n    Letter.b = <span class=\"hljs-number\">2</span>; \n&#125;)(Letter || (Letter = &#123;&#125;));</code></pre>\n\n<h2 id=\"动态导入表达式-import\"><a href=\"#动态导入表达式-import\" class=\"headerlink\" title=\"动态导入表达式 import()\"></a>动态导入表达式 import()</h2><p>import() 异步加载一个模块, 该语句用于 Webpack Code Splitting。</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span>(<span class=\"hljs-comment\">/* webpackChunkName: &quot;momentjs&quot; */</span> <span class=\"hljs-string\">&#x27;moment&#x27;</span>)\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">moment</span> =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> time = moment().format();\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;TypeScript &gt;= 2.4.0 Dynamic Import Expression:&#x27;</span>);\n    <span class=\"hljs-built_in\">console</span>.log(time);\n  &#125;)\n  .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;Failed to load moment&#x27;</span>, err);\n  &#125;);</code></pre>\n\n<h2 id=\"TS-类型系统\"><a href=\"#TS-类型系统\" class=\"headerlink\" title=\"TS 类型系统\"></a>TS 类型系统</h2><p>原始类型 string、number、boolean 可以被用作类型注解。</p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>两种方式定义数组：</p>\n<p>1、元素类型后加 []</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> list: <span class=\"hljs-built_in\">number</span>[] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];</code></pre>\n\n<p>2、 数组泛型 Array&lt;元素类型&gt;</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> list: <span class=\"hljs-built_in\">Array</span>&lt;number&gt; = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];</code></pre>\n\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>合并众多类型声明至一个类型声明</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> Name &#123;\n  <span class=\"hljs-attr\">first</span>: <span class=\"hljs-built_in\">string</span>;\n  second: <span class=\"hljs-built_in\">string</span>;\n&#125;\n\n<span class=\"hljs-keyword\">let</span> name: Name = &#123;\n  <span class=\"hljs-attr\">first</span>: <span class=\"hljs-string\">&#x27;John&#x27;</span>,\n  <span class=\"hljs-attr\">second</span>: <span class=\"hljs-string\">&#x27;Doe&#x27;</span>\n&#125;;\n</code></pre>\n\n<h2 id=\"内联类型注解\"><a href=\"#内联类型注解\" class=\"headerlink\" title=\"内联类型注解\"></a>内联类型注解</h2><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> name: &#123;\n  <span class=\"hljs-attr\">first</span>: <span class=\"hljs-built_in\">string</span>;\n  second: <span class=\"hljs-built_in\">string</span>;\n&#125;;\n\nname = &#123;\n  <span class=\"hljs-attr\">first</span>: <span class=\"hljs-string\">&#x27;John&#x27;</span>,\n  <span class=\"hljs-attr\">second</span>: <span class=\"hljs-string\">&#x27;Doe&#x27;</span>\n&#125;;</code></pre>\n\n<p>内联类型注解可以省去为类型起名的麻烦。</p>\n<p>如果你发现需要多次使用相同的内联注解时，那么考虑把它重构为一个接口（或者是 type alias)</p>\n<h2 id=\"特殊类型\"><a href=\"#特殊类型\" class=\"headerlink\" title=\"特殊类型\"></a>特殊类型</h2><p>any、 null、 undefined 以及 void</p>\n<p>:void 来表示一个函数没有一个返回值</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">log</span>(<span class=\"hljs-params\">message: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">void</span> </span>&#123;\n  <span class=\"hljs-built_in\">console</span>.log(message);\n&#125;</code></pre>\n\n<h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><p>在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reverse</span>&lt;<span class=\"hljs-title\">T</span>&gt;(<span class=\"hljs-params\">items: T[]</span>): <span class=\"hljs-title\">T</span>[] </span>&#123;\n  <span class=\"hljs-keyword\">const</span> toreturn = [];\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = items.length - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) &#123;\n    toreturn.push(items[i]);\n  &#125;\n  <span class=\"hljs-keyword\">return</span> toreturn;\n&#125;</code></pre>\n\n<h2 id=\"联合类型\"><a href=\"#联合类型\" class=\"headerlink\" title=\"联合类型\"></a>联合类型</h2><p>多种类型之一</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">formatCommandline</span>(<span class=\"hljs-params\">command: <span class=\"hljs-built_in\">string</span>[] | <span class=\"hljs-built_in\">string</span></span>) </span>&#123;\n  <span class=\"hljs-keyword\">let</span> line = <span class=\"hljs-string\">&#x27;&#x27;</span>;\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> command === <span class=\"hljs-string\">&#x27;string&#x27;</span>) &#123;\n    line = command.trim();\n  &#125; <span class=\"hljs-keyword\">else</span> &#123;\n    line = command.join(<span class=\"hljs-string\">&#x27; &#x27;</span>).trim();\n  &#125;\n\n  <span class=\"hljs-comment\">// Do stuff with line: string</span>\n&#125;</code></pre>\n\n<h2 id=\"交叉类型\"><a href=\"#交叉类型\" class=\"headerlink\" title=\"交叉类型\"></a>交叉类型</h2><p>extend 是一种非常常见的模式，从两个对象中创建一个新对象，新对象拥有着两个对象所有的功能。</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">extend</span>&lt;<span class=\"hljs-title\">T</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">object</span>, <span class=\"hljs-title\">U</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">object</span>&gt;(<span class=\"hljs-params\">first: T, second: U</span>): <span class=\"hljs-title\">T</span> &amp; <span class=\"hljs-title\">U</span> </span>&#123;\n  <span class=\"hljs-keyword\">const</span> result = &lt;T &amp; U&gt;&#123;&#125;;\n  for (let id in first) &#123;\n    (&lt;T&gt;result)[id] = first[id];\n  &#125;\n  for (let id in second) &#123;\n    if (!result.hasOwnProperty(id)) &#123;\n      (&lt;U&gt;result)[id] = second[id];\n    &#125;\n  &#125;\n\n  return result;\n&#125;\n\nconst x = extend(&#123; a: &#x27;hello&#x27; &#125;, &#123; b: 42 &#125;);\n\n// 现在 x 拥有了 a 属性与 b 属性\nconst a = x.a;\nconst b = x.b;</code></pre>\n\n<h2 id=\"元祖类型-Tuple\"><a href=\"#元祖类型-Tuple\" class=\"headerlink\" title=\"元祖类型 Tuple\"></a>元祖类型 Tuple</h2><p>固定长度的，元素数据类型不同的数组。数据不可变。</p>\n<pre><code class=\"hljs js\">type FixedArray = [string, number, string];\n\n<span class=\"hljs-keyword\">const</span> mixedArray: FixedArray = [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>];</code></pre>\n\n<h2 id=\"类型别名\"><a href=\"#类型别名\" class=\"headerlink\" title=\"类型别名\"></a>类型别名</h2><p>以为任意的类型注解提供类型别名,在联合类型和交叉类型中比较实用。</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> StrOrNum = <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>;\n\n<span class=\"hljs-comment\">// 使用</span>\n<span class=\"hljs-keyword\">let</span> sample: StrOrNum;\nsample = <span class=\"hljs-number\">123</span>;\nsample = <span class=\"hljs-string\">&#x27;123&#x27;</span>;\n\n<span class=\"hljs-comment\">// 会检查类型</span>\nsample = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// Error</span></code></pre>\n\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> Text = <span class=\"hljs-built_in\">string</span> | &#123; <span class=\"hljs-attr\">text</span>: <span class=\"hljs-built_in\">string</span> &#125;;\n<span class=\"hljs-keyword\">type</span> Coordinates = [<span class=\"hljs-built_in\">number</span>, <span class=\"hljs-built_in\">number</span>];\n<span class=\"hljs-keyword\">type</span> Callback = <span class=\"hljs-function\">(<span class=\"hljs-params\">data: <span class=\"hljs-built_in\">string</span></span>) =&gt;</span> <span class=\"hljs-built_in\">void</span>;</code></pre>\n\n<h2 id=\"types\"><a href=\"#types\" class=\"headerlink\" title=\"@types\"></a>@types</h2><p>通过 npm 来安装使用 @types,如 <code>npm install @types/jquery --save-dev</code></p>\n<h2 id=\"declare-声明文件\"><a href=\"#declare-声明文件\" class=\"headerlink\" title=\"declare 声明文件\"></a>declare 声明文件</h2><p>.d.ts文件是ts用来声明变量，模块，type，interface等等的。</p>\n<p>在这种后缀的ts文件声明这些东西和在纯ts文件声明这些东西又什么区别呢？</p>\n<p>在.d.ts声明变量或者模块等东西之后，在其他地方可以不用import导入这些东西就可以直接用，用，而且有语法提示。</p>\n<p>declare声明一个类型:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">type</span> Asd &#123;\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;</code></pre>\n\n<p>在tsconfig.json文件里面的include数组里面添加这个文件, 在include包含的文件范围内可以直接使用Asd这个type。</p>\n<p>declare声明一个模块:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-built_in\">module</span> <span class=\"hljs-string\">&#x27;*.css&#x27;</span>;\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-built_in\">module</span> <span class=\"hljs-string\">&#x27;*.less&#x27;</span>;\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-built_in\">module</span> <span class=\"hljs-string\">&#x27;*.png&#x27;</span>;</code></pre>\n\n<p>编译ts文件的时候，导入一个.css/.less/.png格式的文件，如果没有经过declare的话是会提示语法错误的</p>\n<p>declare声明一个变量:</p>\n<p>在项目中引入了一个sdk，这个sdk（我们以微信的sdk为例）里面有一些全局的对象（比如wx），但是如果不经过任何的声明，在ts文件里面直接用wx.config()的话，肯定会报错。</p>\n<p>declare声明一个作用域:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">namespace</span> API &#123;\n    <span class=\"hljs-keyword\">interface</span> ResponseList &#123;&#125;\n&#125;</code></pre>\n\n<p>声明完之后在其他地方的ts就可以直接API.ResponseList引用到这个接口类型</p>\n<h2 id=\"接口-1\"><a href=\"#接口-1\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>两种声明方式：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 内联注解</span>\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">const</span> myPoint: &#123; <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">number</span>; y: <span class=\"hljs-built_in\">number</span> &#125;;\n\n<span class=\"hljs-comment\">// 接口形式</span>\n<span class=\"hljs-keyword\">interface</span> Point &#123;\n  <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">number</span>;\n  y: <span class=\"hljs-built_in\">number</span>;\n&#125;\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">const</span> myPoint: Point;</code></pre>\n\n<p>接口形式的好处在于，如果有人创建了一个基于 myPoint 的库来添加新成员, 可以轻松将此成员添加到 myPoint 的现有声明中</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// Lib a.d.ts</span>\n<span class=\"hljs-keyword\">interface</span> Point &#123;\n  <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">number</span>,\n  <span class=\"hljs-attr\">y</span>: <span class=\"hljs-built_in\">number</span>\n&#125;\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">const</span> myPoint: Point\n\n<span class=\"hljs-comment\">// Lib b.d.ts</span>\n<span class=\"hljs-keyword\">interface</span> Point &#123;\n  <span class=\"hljs-attr\">z</span>: <span class=\"hljs-built_in\">number</span>\n&#125;\n\n<span class=\"hljs-comment\">// Your code</span>\nmyPoint.z <span class=\"hljs-comment\">// Allowed!</span></code></pre>\n\n<h2 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h2><p>函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 |操作符或者?操作符，把所有可能的输入类型全部包含进去，以具体实现。</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 上边是声明</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">string</span>, arg2: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">string</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">number</span>, arg2: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\">// 因为我们在下边有具体函数的实现，所以这里并不需要添加 <span class=\"hljs-title\">declare</span> 关键字</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\">// 下边是实现</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>, arg2: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span></span>) </span>&#123;</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\">  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 <span class=\"hljs-title\">arg1</span> + <span class=\"hljs-title\">arg2</span></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\">  <span class=\"hljs-title\">if</span> (<span class=\"hljs-params\"><span class=\"hljs-keyword\">typeof</span> arg1 === <span class=\"hljs-string\">&#x27;string&#x27;</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> arg2 === <span class=\"hljs-string\">&#x27;string&#x27;</span></span>) </span>&#123;</span>\n<span class=\"hljs-function\">    <span class=\"hljs-title\">return</span> <span class=\"hljs-title\">arg1</span> + <span class=\"hljs-title\">arg2</span></span>\n<span class=\"hljs-function\">  &#125; <span class=\"hljs-title\">else</span> <span class=\"hljs-title\">if</span> (<span class=\"hljs-params\"><span class=\"hljs-keyword\">typeof</span> arg1 === <span class=\"hljs-string\">&#x27;number&#x27;</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> arg2 === <span class=\"hljs-string\">&#x27;number&#x27;</span></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> arg1 + arg2\n  &#125;\n&#125;</code></pre>\n\n<p>函数重载的意义在于能够让你知道传入不同的参数得到不同的结果，如果传入的参数不同，但是得到的结果（类型）却相同，那么不要使用函数重载（没有意义）。<br>如果函数的返回值类型相同，那么也不需要使用函数重载</p>\n<p>以下场景可以不需要重载：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span> (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span> (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, b: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\">// 像这样的是参数个数的区别，我们可以使用可选参数来代替函数重载的定义</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span> (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, b?: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span></span></span></code></pre>\n\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 亦或是一些参数类型的区别导致的</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span> (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span> (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">number</span></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\">// 这时我们应该使用联合类型来代替函数重载</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span> (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">number</span></span></span></span></code></pre>\n\n<h2 id=\"函数声明\"><a href=\"#函数声明\" class=\"headerlink\" title=\"函数声明\"></a>函数声明</h2><p>在没有提供函数实现的情况下，有两种声明函数类型的方式:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> LongHand = &#123;\n  (a: <span class=\"hljs-built_in\">number</span>): <span class=\"hljs-built_in\">number</span>;\n&#125;; <span class=\"hljs-comment\">//当你想使用函数重载时, 只能用此方式</span>\n\n<span class=\"hljs-keyword\">type</span> ShortHand = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> <span class=\"hljs-built_in\">number</span>;</code></pre>\n\n<h2 id=\"可调用的类型注解\"><a href=\"#可调用的类型注解\" class=\"headerlink\" title=\"可调用的类型注解\"></a>可调用的类型注解</h2><p>使用类型别名或者接口来表示一个可被调用的类型注解：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> ReturnString &#123;\n  (): <span class=\"hljs-built_in\">string</span>;\n&#125;\n<span class=\"hljs-comment\">// 表示一个返回值为 string 的函数：</span></code></pre>\n\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">const</span> foo: ReturnString;\n\n<span class=\"hljs-keyword\">const</span> bar = foo(); <span class=\"hljs-comment\">// bar 被推断为一个字符串。</span></code></pre>\n\n<h2 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h2><p>ts 允许你覆盖它的推断，并且能以你任何你想要的方式分析它</p>\n<p>js 迁移到 ts 时常见：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> foo = &#123;&#125;;\nfoo.bar = <span class=\"hljs-number\">123</span>; <span class=\"hljs-comment\">// Error: &#x27;bar&#x27; 属性不存在于 ‘&#123;&#125;’</span>\nfoo.bas = <span class=\"hljs-string\">&#x27;hello&#x27;</span>; <span class=\"hljs-comment\">// Error: &#x27;bas&#x27; 属性不存在于 &#x27;&#123;&#125;&#x27;</span></code></pre>\n\n<p>foo 类型推断为 {}，不存在属性。通过类型断言来避免该问题</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> Foo &#123;\n  <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-built_in\">number</span>;\n  bas: <span class=\"hljs-built_in\">string</span>;\n&#125;\n\n<span class=\"hljs-keyword\">const</span> foo = &#123;&#125; <span class=\"hljs-keyword\">as</span> Foo;\nfoo.bar = <span class=\"hljs-number\">123</span>;\nfoo.bas = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;</code></pre>\n\n<h2 id=\"允许额外的属性\"><a href=\"#允许额外的属性\" class=\"headerlink\" title=\"允许额外的属性\"></a>允许额外的属性</h2><p>包含索引签名，以明确表明可以使用额外的属性：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> x: &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-built_in\">number</span>, [x: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">any</span> &#125;;\n\nx = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-number\">2</span> &#125;; <span class=\"hljs-comment\">// ok, &#x27;baz&#x27; 属性匹配于索引签名</span></code></pre>\n\n<p>React State 中示例：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 假设</span>\n<span class=\"hljs-keyword\">interface</span> State &#123;\n  <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-built_in\">string</span>;\n  bar: <span class=\"hljs-built_in\">string</span>;\n&#125;\n\n<span class=\"hljs-comment\">// 你可能想做：</span>\n<span class=\"hljs-built_in\">this</span>.setState(&#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;Hello&#x27;</span> &#125;); <span class=\"hljs-comment\">// Error: 没有属性 &#x27;bar&#x27;</span>\n\n<span class=\"hljs-comment\">// 因为 state 包含 &#x27;foo&#x27; 与 &#x27;bar&#x27;，TypeScript 会强制你这么做：</span>\n<span class=\"hljs-built_in\">this</span>.setState(&#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;Hello&#x27;</span>, <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-built_in\">this</span>.state.bar &#125;);</code></pre>\n\n<h2 id=\"类型保护\"><a href=\"#类型保护\" class=\"headerlink\" title=\"类型保护\"></a>类型保护</h2><p>ts 会推到条件块中的变量类型</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">doSome</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span></span>) </span>&#123;\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> x === <span class=\"hljs-string\">&#x27;string&#x27;</span>) &#123;\n    <span class=\"hljs-comment\">// 在这个块中，TypeScript 知道 `x` 的类型必须是 `string`</span>\n    <span class=\"hljs-built_in\">console</span>.log(x.subtr(<span class=\"hljs-number\">1</span>)); <span class=\"hljs-comment\">// Error: &#x27;subtr&#x27; 方法并没有存在于 `string` 上</span>\n    <span class=\"hljs-built_in\">console</span>.log(x.substr(<span class=\"hljs-number\">1</span>)); <span class=\"hljs-comment\">// ok</span>\n  &#125;\n\n  x.substr(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// Error: 无法保证 `x` 是 `string` 类型</span>\n&#125;</code></pre>\n\n<p>in 操作符可以一个对象上是否存在一个属性，它通常也被作为类型保护使用</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> A &#123;\n  <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">number</span>;\n&#125;\n\n<span class=\"hljs-keyword\">interface</span> B &#123;\n  <span class=\"hljs-attr\">y</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">doStuff</span>(<span class=\"hljs-params\">q: A | B</span>) </span>&#123;\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">&#x27;x&#x27;</span> <span class=\"hljs-keyword\">in</span> q) &#123;\n    <span class=\"hljs-comment\">// q: A</span>\n  &#125; <span class=\"hljs-keyword\">else</span> &#123;\n    <span class=\"hljs-comment\">// q: B</span>\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"字面量类型\"><a href=\"#字面量类型\" class=\"headerlink\" title=\"字面量类型\"></a>字面量类型</h2><p>字面量类型本身不使用，在一个联合类型中组合创建一个强大的（实用的）抽象。</p>\n<p>字符串字面量：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> foo: <span class=\"hljs-string\">&#x27;Hello&#x27;</span>;\nfoo = <span class=\"hljs-string\">&#x27;Bar&#x27;</span>; <span class=\"hljs-comment\">// Error: &#x27;bar&#x27; 不能赋值给类型 &#x27;Hello&#x27;</span></code></pre>\n\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> CardinalDirection = <span class=\"hljs-string\">&#x27;North&#x27;</span> | <span class=\"hljs-string\">&#x27;East&#x27;</span> | <span class=\"hljs-string\">&#x27;South&#x27;</span> | <span class=\"hljs-string\">&#x27;West&#x27;</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">move</span>(<span class=\"hljs-params\">distance: <span class=\"hljs-built_in\">number</span>, direction: CardinalDirection</span>) </span>&#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n\nmove(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;North&#x27;</span>); <span class=\"hljs-comment\">// ok</span>\nmove(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;Nurth&#x27;</span>); <span class=\"hljs-comment\">// Error</span></code></pre>\n\n<p>boolean 和 number 的字面量类型：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> OneToFive = <span class=\"hljs-number\">1</span> | <span class=\"hljs-number\">2</span> | <span class=\"hljs-number\">3</span> | <span class=\"hljs-number\">4</span> | <span class=\"hljs-number\">5</span>;\n<span class=\"hljs-keyword\">type</span> Bools = <span class=\"hljs-literal\">true</span> | <span class=\"hljs-literal\">false</span>;</code></pre>\n\n<h2 id=\"Readonly\"><a href=\"#Readonly\" class=\"headerlink\" title=\"Readonly\"></a>Readonly</h2><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">config: &#123; <span class=\"hljs-keyword\">readonly</span> bar: <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-keyword\">readonly</span> bas: <span class=\"hljs-built_in\">number</span> &#125;</span>) </span>&#123;\n  <span class=\"hljs-comment\">// ..</span>\n&#125;\n\n<span class=\"hljs-keyword\">type</span> Foo = &#123;\n  <span class=\"hljs-keyword\">readonly</span> bar: <span class=\"hljs-built_in\">number</span>;\n  <span class=\"hljs-keyword\">readonly</span> bas: <span class=\"hljs-built_in\">number</span>;\n&#125;;\n</code></pre>\n\n<p>这有一个 Readonly 的映射类型，它接收一个泛型 T，用来把它的所有属性标记为只读类型：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> Foo = &#123;\n  <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-built_in\">number</span>;\n  bas: <span class=\"hljs-built_in\">number</span>;\n&#125;;\n\n<span class=\"hljs-keyword\">type</span> FooReadonly = Readonly&lt;Foo&gt;;</code></pre>\n\n<h2 id=\"泛型2\"><a href=\"#泛型2\" class=\"headerlink\" title=\"泛型2\"></a>泛型2</h2><p>创建泛型类</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 创建一个泛型类</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Queue</span>&lt;<span class=\"hljs-title\">T</span>&gt; </span>&#123;\n  <span class=\"hljs-keyword\">private</span> data: T[] = [];\n  push = <span class=\"hljs-function\">(<span class=\"hljs-params\">item: T</span>) =&gt;</span> <span class=\"hljs-built_in\">this</span>.data.push(item);\n  pop = (): T | <span class=\"hljs-function\"><span class=\"hljs-params\">undefined</span> =&gt;</span> <span class=\"hljs-built_in\">this</span>.data.shift();\n&#125;\n\n<span class=\"hljs-comment\">// 简单的使用</span>\n<span class=\"hljs-keyword\">const</span> queue = <span class=\"hljs-keyword\">new</span> Queue&lt;<span class=\"hljs-built_in\">number</span>&gt;();\nqueue.push(<span class=\"hljs-number\">0</span>);\nqueue.push(<span class=\"hljs-string\">&#x27;1&#x27;</span>); <span class=\"hljs-comment\">// Error：不能推入一个 `string`，只有 number 类型被允许</span></code></pre>\n\n<p>泛型的误用：近在单个参数或一个位置被使用</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>&lt;<span class=\"hljs-title\">T</span>&gt;(<span class=\"hljs-params\">arg: T</span>): <span class=\"hljs-title\">void</span></span>;  \n<span class=\"hljs-comment\">// </span>\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">arg: <span class=\"hljs-built_in\">any</span></span>): <span class=\"hljs-title\">void</span></span>;</code></pre>\n\n<p>axios 请求中 泛型的使用：</p>\n<p>通常情况下，我们会把后端返回数据格式单独放入一个 interface 里：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 请求接口数据</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> ResponseData&lt;T = any&gt; &#123;\n  <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">   * 状态码</span>\n<span class=\"hljs-comment\">   * <span class=\"hljs-doctag\">@type <span class=\"hljs-type\">&#123; number &#125;</span></span></span>\n<span class=\"hljs-comment\">   */</span>\n  <span class=\"hljs-attr\">code</span>: <span class=\"hljs-built_in\">number</span>;\n\n  <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">   * 数据</span>\n<span class=\"hljs-comment\">   * <span class=\"hljs-doctag\">@type <span class=\"hljs-type\">&#123; T &#125;</span></span></span>\n<span class=\"hljs-comment\">   */</span>\n  result: T;\n\n  <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">   * 消息</span>\n<span class=\"hljs-comment\">   * <span class=\"hljs-doctag\">@type <span class=\"hljs-type\">&#123; string &#125;</span></span></span>\n<span class=\"hljs-comment\">   */</span>\n  message: <span class=\"hljs-built_in\">string</span>;\n&#125;</code></pre>\n\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 在 axios.ts 文件中对 axios 进行了处理，例如添加通用配置、拦截器等</span>\n<span class=\"hljs-keyword\">import</span> Ax <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./axios&#x27;</span>;\n\n<span class=\"hljs-keyword\">import</span> &#123; ResponseData &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./interface.ts&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getUser</span>&lt;<span class=\"hljs-title\">T</span>&gt;(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> Ax.get&lt;ResponseData&lt;T&gt;&gt;(<span class=\"hljs-string\">&#x27;/somepath&#x27;</span>)\n    .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> res.data)\n    .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.error(err));\n&#125;</code></pre>\n\n<p>写入返回的数据类型 User</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> User &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n  age: <span class=\"hljs-built_in\">number</span>;\n&#125;\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// user 被推断出为</span>\n  <span class=\"hljs-comment\">// &#123;</span>\n  <span class=\"hljs-comment\">//  code: number,</span>\n  <span class=\"hljs-comment\">//  result: &#123; name: string, age: number &#125;,</span>\n  <span class=\"hljs-comment\">//  message: string</span>\n  <span class=\"hljs-comment\">// &#125;</span>\n  <span class=\"hljs-keyword\">const</span> user = <span class=\"hljs-keyword\">await</span> getUser&lt;User&gt;();\n&#125;</code></pre>\n\n<h2 id=\"never-类型\"><a href=\"#never-类型\" class=\"headerlink\" title=\"never 类型\"></a>never 类型</h2><p>常用在</p>\n<ul>\n<li>从来不会有返回值的函数（如：如果函数内含有 while(true) {}）</li>\n<li>总是会抛出错误的函数 throw new Error</li>\n</ul>\n<p>never 类型仅能被赋值给另外一个 never</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> bar: <span class=\"hljs-built_in\">never</span> = (<span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;Throw my hands in the air like I just dont care&#x27;</span>);\n&#125;)();</code></pre>\n\n<p>void 和 never 的区别：</p>\n<ul>\n<li>void 表示没有任何类型，never 表示永远不存在的值的类型。</li>\n<li>当一个函数返回空值时，它的返回值为 void 类型，但是，当一个函数永不返回时（或者总是抛出错误），它的返回值为 never 类型。</li>\n<li>void 类型可以被赋值，但是除了 never 本身以外，其他任何类型不能赋值给 never。</li>\n</ul>\n<h2 id=\"redux-中的联合类型\"><a href=\"#redux-中的联合类型\" class=\"headerlink\" title=\"redux 中的联合类型\"></a>redux 中的联合类型</h2><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> &#123; createStore &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;redux&#x27;</span>;\n\n<span class=\"hljs-keyword\">type</span> Action =\n  | &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;INCREMENT&#x27;</span>;\n    &#125;\n  | &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;DECREMENT&#x27;</span>;\n    &#125;;\n\n<span class=\"hljs-comment\">//reducer</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">counter</span>(<span class=\"hljs-params\">state = <span class=\"hljs-number\">0</span>, action: Action</span>) </span>&#123;\n  <span class=\"hljs-keyword\">switch</span> (action.type) &#123;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;INCREMENT&#x27;</span>:\n      <span class=\"hljs-keyword\">return</span> state + <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;DECREMENT&#x27;</span>:\n      <span class=\"hljs-keyword\">return</span> state - <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">default</span>:\n      <span class=\"hljs-keyword\">return</span> state;\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"索引签名\"><a href=\"#索引签名\" class=\"headerlink\" title=\"索引签名\"></a>索引签名</h2><p>声明一个索引签名时，所有明确的成员都必须符合索引签名：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> Bar &#123;\n  [key: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">number</span>;\n  x: <span class=\"hljs-built_in\">number</span>;\n  y: <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-comment\">// Error: y 属性必须为 number 类型</span>\n&#125;</code></pre>\n\n<p>映射类型来使索引字符串为联合类型中的一员</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> Index = <span class=\"hljs-string\">&#x27;a&#x27;</span> | <span class=\"hljs-string\">&#x27;b&#x27;</span> | <span class=\"hljs-string\">&#x27;c&#x27;</span>;\n<span class=\"hljs-keyword\">type</span> FromIndex = &#123; [k <span class=\"hljs-keyword\">in</span> Index]?: <span class=\"hljs-built_in\">number</span> &#125;;\n\n<span class=\"hljs-keyword\">const</span> bad: FromIndex = &#123; <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">d</span>: <span class=\"hljs-number\">3</span> &#125;; <span class=\"hljs-comment\">//err</span></code></pre>\n\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> FromSomeIndex&lt;K <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">string</span>&gt; = &#123; [key <span class=\"hljs-keyword\">in</span> K]: <span class=\"hljs-built_in\">number</span> &#125;;</code></pre>\n\n<h2 id=\"索引签名中排除某些属性\"><a href=\"#索引签名中排除某些属性\" class=\"headerlink\" title=\"索引签名中排除某些属性\"></a>索引签名中排除某些属性</h2><p>用交叉类型解决</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> FieldState = &#123;\n  <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;;\n\n<span class=\"hljs-keyword\">type</span> FromState = &#123;\n  <span class=\"hljs-attr\">isValid</span>: <span class=\"hljs-built_in\">boolean</span>; <span class=\"hljs-comment\">// Error: 不符合索引签名</span>\n  [filedName: <span class=\"hljs-built_in\">string</span>]: FieldState;\n&#125;;</code></pre>\n\n<p>交叉类型：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> FieldState = &#123;\n  <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;;\n\n<span class=\"hljs-keyword\">type</span> FormState = &#123; <span class=\"hljs-attr\">isValid</span>: <span class=\"hljs-built_in\">boolean</span> &#125; &amp; &#123; [fieldName: <span class=\"hljs-built_in\">string</span>]: FieldState &#125;;</code></pre>\n\n<h2 id=\"流动的类型\"><a href=\"#流动的类型\" class=\"headerlink\" title=\"流动的类型\"></a>流动的类型</h2><p>捕获变量的类型</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-number\">123</span>;\n<span class=\"hljs-keyword\">let</span> bar: <span class=\"hljs-keyword\">typeof</span> foo; <span class=\"hljs-comment\">// &#x27;bar&#x27; 类型与 &#x27;foo&#x27; 类型相同（在这里是： &#x27;number&#x27;）</span></code></pre>\n\n<p>捕获类成员类型 需要声明一个变量</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Foo</span> </span>&#123;\n  <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-built_in\">number</span>; <span class=\"hljs-comment\">// 我们想要捕获的类型</span>\n&#125;\n\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">let</span> _foo: Foo;\n\n<span class=\"hljs-comment\">// 与之前做法相同</span>\n<span class=\"hljs-keyword\">let</span> bar: <span class=\"hljs-keyword\">typeof</span> _foo.foo;</code></pre>\n\n<p>捕获键的名称</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> colors = &#123;\n  <span class=\"hljs-attr\">red</span>: <span class=\"hljs-string\">&#x27;red&#x27;</span>,\n  <span class=\"hljs-attr\">blue</span>: <span class=\"hljs-string\">&#x27;blue&#x27;</span>\n&#125;;\n\n<span class=\"hljs-keyword\">type</span> Colors = keyof <span class=\"hljs-keyword\">typeof</span> colors;\n\n<span class=\"hljs-keyword\">let</span> color: Colors; <span class=\"hljs-comment\">// color 的类型是 &#x27;red&#x27; | &#x27;blue&#x27;</span>\ncolor = <span class=\"hljs-string\">&#x27;red&#x27;</span>; <span class=\"hljs-comment\">// ok</span>\ncolor = <span class=\"hljs-string\">&#x27;blue&#x27;</span>; <span class=\"hljs-comment\">// ok</span>\ncolor = <span class=\"hljs-string\">&#x27;anythingElse&#x27;</span>; <span class=\"hljs-comment\">// Error</span></code></pre>\n\n<h2 id=\"JSX-的支持\"><a href=\"#JSX-的支持\" class=\"headerlink\" title=\"JSX 的支持\"></a>JSX 的支持</h2><p>函数组件</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> Props = &#123;\n  <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;;\n\n<span class=\"hljs-keyword\">const</span> MyComponent: React.FunctionComponent&lt;Props&gt; = <span class=\"hljs-function\"><span class=\"hljs-params\">props</span> =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>&#123;props.foo&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></span>;\n&#125;;\n\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span> <span class=\"hljs-attr\">foo</span>=<span class=\"hljs-string\">&quot;bar&quot;</span> /&gt;</span></span>;</code></pre>\n\n<p>类组件</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> Props = &#123;\n  <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyComponent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">Props</span>, </span>&#123;&#125;&gt; &#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>&#123;this.props.foo&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></span>;\n  &#125;\n&#125;\n\n&lt;MyComponent foo=<span class=\"hljs-string\">&quot;bar&quot;</span> /&gt;;</code></pre>\n\n<p>泛型组件</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 一个泛型组件</span>\n<span class=\"hljs-keyword\">type</span> SelectProps&lt;T&gt; = &#123; <span class=\"hljs-attr\">items</span>: T[] &#125;;\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Select</span>&lt;<span class=\"hljs-title\">T</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">SelectProps</span>&lt;<span class=\"hljs-title\">T</span>&gt;, <span class=\"hljs-title\">any</span>&gt; </span>&#123;&#125;\n\n<span class=\"hljs-comment\">// 使用</span>\n<span class=\"hljs-keyword\">const</span> Form = <span class=\"hljs-function\">() =&gt;</span> &lt;Select&lt;<span class=\"hljs-built_in\">string</span>&gt; items=&#123;[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>]&#125; /&gt;;</code></pre>\n\n<p>泛型函数</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>&lt;<span class=\"hljs-title\">T</span>&gt;(<span class=\"hljs-params\">x: T</span>): <span class=\"hljs-title\">T</span> </span>&#123;\n  <span class=\"hljs-keyword\">return</span> x;\n&#125;\n\n<span class=\"hljs-comment\">// 不能使用箭头函数</span>\n<span class=\"hljs-keyword\">const</span> foo = &lt;T&gt;<span class=\"hljs-function\">(<span class=\"hljs-params\">x: T</span>) =&gt;</span> T; <span class=\"hljs-comment\">// Error: T 标签没有关闭</span>\n\n解决办法：用 <span class=\"hljs-keyword\">extends</span> 提示编译器这是泛型\n<span class=\"hljs-keyword\">const</span> foo = <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">T</span> <span class=\"hljs-attr\">extends</span> &#123;&#125;&gt;</span>(x: T) =&gt; x;</span></code></pre>\n\n<p>Refs</p>\n<p>一个变量时，使用 ref 和 null 的联合类型</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Use</span> </span>&#123;\n  <span class=\"hljs-attr\">exampleRef</span>: Example | <span class=\"hljs-literal\">null</span> = <span class=\"hljs-literal\">null</span>;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Example</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">&#123;exampleRef</span> =&gt;</span> (this.exampleRef = exampleRef)&#125; /&gt;</span>;\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://jkchao.github.io/typescript-book-chinese/\">深入理解 TypeScript</a></li>\n<li><a href=\"https://www.tslang.cn/docs/handbook/generics.html\">https://www.tslang.cn/docs/handbook/generics.html</a></li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl2k5bv6p00020h3l10748t2d","category_id":"cl2k5bv6t00050h3l2lhrav8t","_id":"cl2k5bv71000g0h3l6v10122g"},{"post_id":"cl2k5bv6u00070h3l086s1m0s","category_id":"cl2k5bv6t00050h3l2lhrav8t","_id":"cl2k5bv72000l0h3l9n7sbehq"},{"post_id":"cl2k5bv6v00090h3la1vk7rsz","category_id":"cl2k5bv70000f0h3l2vzd8c2y","_id":"cl2k5bv77000r0h3l51gx0nb4"},{"post_id":"cl2k5bv72000k0h3le07zc068","category_id":"cl2k5bv6t00050h3l2lhrav8t","_id":"cl2k5bv78000w0h3l2upjeq4o"},{"post_id":"cl2k5bv6y000d0h3l416xbufi","category_id":"cl2k5bv73000m0h3l8b0vcwfe","_id":"cl2k5bv78000z0h3l4xtb607r"},{"post_id":"cl2k5bv6z000e0h3l2fia7obw","category_id":"cl2k5bv77000t0h3ld1e2fhwx","_id":"cl2k5bv7900150h3lgqg7dlcy"},{"post_id":"cl2k5bv71000i0h3laejafuyh","category_id":"cl2k5bv7800100h3lb464hukr","_id":"cl2k5bv7b001d0h3l0bpodcci"},{"post_id":"cl2k5bv73000o0h3leg51e76w","category_id":"cl2k5bv7800100h3lb464hukr","_id":"cl2k5bv7d001n0h3lgaxyg5e3"},{"post_id":"cl2k5bv73000o0h3leg51e76w","category_id":"cl2k5bv7b001c0h3lc8t7e70w","_id":"cl2k5bv7d001p0h3l0hci1gdw"},{"post_id":"cl2k5bv76000q0h3l5h1t99e6","category_id":"cl2k5bv7b001c0h3lc8t7e70w","_id":"cl2k5bv7f001s0h3l0epa4xa8"},{"post_id":"cl2k5bv7c001k0h3l3ywkbvao","category_id":"cl2k5bv7b001c0h3lc8t7e70w","_id":"cl2k5bv7f001u0h3l8iad1cuc"},{"post_id":"cl2k5bv77000v0h3l1nuddd7u","category_id":"cl2k5bv7b001c0h3lc8t7e70w","_id":"cl2k5bv7f001w0h3l50cb452x"},{"post_id":"cl2k5bv7d001m0h3lg87d6g45","category_id":"cl2k5bv73000m0h3l8b0vcwfe","_id":"cl2k5bv7g001z0h3lbkat59cj"},{"post_id":"cl2k5bv7800110h3l06e23e2l","category_id":"cl2k5bv7b001c0h3lc8t7e70w","_id":"cl2k5bv7g00230h3l29bc978k"},{"post_id":"cl2k5bv78000y0h3l4mz21cti","category_id":"cl2k5bv7800100h3lb464hukr","_id":"cl2k5bv7g00240h3l9xfob802"},{"post_id":"cl2k5bv78000y0h3l4mz21cti","category_id":"cl2k5bv7b001c0h3lc8t7e70w","_id":"cl2k5bv7g00270h3l60tvawkb"},{"post_id":"cl2k5bv7900140h3l9jhsbawi","category_id":"cl2k5bv7b001c0h3lc8t7e70w","_id":"cl2k5bv7h00280h3lejnl606j"},{"post_id":"cl2k5bv7900160h3l8txg2nb3","category_id":"cl2k5bv7b001c0h3lc8t7e70w","_id":"cl2k5bv7h002b0h3lak9d6t02"},{"post_id":"cl2k5bv7a00190h3l3mra3aoz","category_id":"cl2k5bv7b001c0h3lc8t7e70w","_id":"cl2k5bv7i002f0h3l55lv70xu"},{"post_id":"cl2k5bv7a001b0h3lfngh372f","category_id":"cl2k5bv7h002a0h3l1z6uet2p","_id":"cl2k5bv7i002j0h3lbztmednm"},{"post_id":"cl2k5bv7b001f0h3l76mgg3fm","category_id":"cl2k5bv7i002g0h3l7g3zfgvn","_id":"cl2k5bv7i002m0h3l87lycvs0"},{"post_id":"cl2k5bv7m002t0h3l9x881c1g","category_id":"cl2k5bv6t00050h3l2lhrav8t","_id":"cl2k5bv7p002x0h3lb2tu4wqo"},{"post_id":"cl2k5bv7o002w0h3lgm312xnt","category_id":"cl2k5bv7p002y0h3l7r12bttt","_id":"cl2k5bv7p00310h3l56n122jl"}],"PostTag":[{"post_id":"cl2k5bv6p00020h3l10748t2d","tag_id":"cl2k5bv6u00060h3l0w8w9xge","_id":"cl2k5bv6y000c0h3lctg388v0"},{"post_id":"cl2k5bv6u00070h3l086s1m0s","tag_id":"cl2k5bv6w000b0h3l6sl5cmz1","_id":"cl2k5bv72000j0h3lhg413564"},{"post_id":"cl2k5bv6v00090h3la1vk7rsz","tag_id":"cl2k5bv71000h0h3l08pw4rrd","_id":"cl2k5bv76000p0h3laoqr51nz"},{"post_id":"cl2k5bv72000k0h3le07zc068","tag_id":"cl2k5bv6w000b0h3l6sl5cmz1","_id":"cl2k5bv77000s0h3le0fl89sk"},{"post_id":"cl2k5bv6y000d0h3l416xbufi","tag_id":"cl2k5bv73000n0h3l9j7thb0n","_id":"cl2k5bv78000x0h3ldx5x1kmt"},{"post_id":"cl2k5bv6z000e0h3l2fia7obw","tag_id":"cl2k5bv77000u0h3lhgbggd95","_id":"cl2k5bv7900130h3l22v19tu9"},{"post_id":"cl2k5bv71000i0h3laejafuyh","tag_id":"cl2k5bv7900120h3lgprtgpuj","_id":"cl2k5bv7a001a0h3l2oldg1i9"},{"post_id":"cl2k5bv73000o0h3leg51e76w","tag_id":"cl2k5bv7a00180h3l12cu967v","_id":"cl2k5bv7b001g0h3ld3nr959y"},{"post_id":"cl2k5bv76000q0h3l5h1t99e6","tag_id":"cl2k5bv7b001e0h3l9gxv06xy","_id":"cl2k5bv7d001l0h3l5d6mb6yr"},{"post_id":"cl2k5bv77000v0h3l1nuddd7u","tag_id":"cl2k5bv7c001j0h3lguiwaosq","_id":"cl2k5bv7f001r0h3ld1nl6jez"},{"post_id":"cl2k5bv78000y0h3l4mz21cti","tag_id":"cl2k5bv7d001q0h3lgcta4nli","_id":"cl2k5bv7f001x0h3lhgrgg423"},{"post_id":"cl2k5bv7800110h3l06e23e2l","tag_id":"cl2k5bv7c001j0h3lguiwaosq","_id":"cl2k5bv7g00210h3lfn4h5uyq"},{"post_id":"cl2k5bv7900140h3l9jhsbawi","tag_id":"cl2k5bv7g00200h3l9aemh5j7","_id":"cl2k5bv7h002c0h3l81cfgfj0"},{"post_id":"cl2k5bv7900140h3l9jhsbawi","tag_id":"cl2k5bv7g00250h3lfbzif0o4","_id":"cl2k5bv7h002d0h3l7fgx9buc"},{"post_id":"cl2k5bv7900160h3l8txg2nb3","tag_id":"cl2k5bv7c001j0h3lguiwaosq","_id":"cl2k5bv7i002h0h3l66c9f5g4"},{"post_id":"cl2k5bv7a00190h3l3mra3aoz","tag_id":"cl2k5bv7g00250h3lfbzif0o4","_id":"cl2k5bv7i002k0h3l6os97nsg"},{"post_id":"cl2k5bv7a001b0h3lfngh372f","tag_id":"cl2k5bv7i002i0h3lerwd6w6s","_id":"cl2k5bv7i002n0h3lenvmasux"},{"post_id":"cl2k5bv7b001f0h3l76mgg3fm","tag_id":"cl2k5bv7i002l0h3l21bz9t1u","_id":"cl2k5bv7j002p0h3lgigk0phz"},{"post_id":"cl2k5bv7c001k0h3l3ywkbvao","tag_id":"cl2k5bv7g00250h3lfbzif0o4","_id":"cl2k5bv7j002r0h3lg36bg9cq"},{"post_id":"cl2k5bv7d001m0h3lg87d6g45","tag_id":"cl2k5bv7j002q0h3ld14t12uf","_id":"cl2k5bv7j002s0h3lczgsb05a"},{"post_id":"cl2k5bv7m002t0h3l9x881c1g","tag_id":"cl2k5bv6w000b0h3l6sl5cmz1","_id":"cl2k5bv7o002v0h3lcvzkddfb"},{"post_id":"cl2k5bv7o002w0h3lgm312xnt","tag_id":"cl2k5bv7p002z0h3ldrrv25ih","_id":"cl2k5bv7p00300h3lapwe5iyb"}],"Tag":[{"name":"前端实习生","_id":"cl2k5bv6u00060h3l0w8w9xge"},{"name":"前端","_id":"cl2k5bv6w000b0h3l6sl5cmz1"},{"name":"Mobx","_id":"cl2k5bv71000h0h3l08pw4rrd"},{"name":"Bad&Good","_id":"cl2k5bv73000n0h3l9j7thb0n"},{"name":"webpack","_id":"cl2k5bv77000u0h3lhgbggd95"},{"name":"闭包","_id":"cl2k5bv7900120h3lgprtgpuj"},{"name":"useEffect","_id":"cl2k5bv7a00180h3l12cu967v"},{"name":"React TypeScript","_id":"cl2k5bv7b001e0h3l9gxv06xy"},{"name":"Hook","_id":"cl2k5bv7c001j0h3lguiwaosq"},{"name":"useCallback","_id":"cl2k5bv7d001q0h3lgcta4nli"},{"name":"React","_id":"cl2k5bv7g00200h3l9aemh5j7"},{"name":"HooK","_id":"cl2k5bv7g00250h3lfbzif0o4"},{"name":"Vue3","_id":"cl2k5bv7i002i0h3lerwd6w6s"},{"name":"vscode","_id":"cl2k5bv7i002l0h3l21bz9t1u"},{"name":"map","_id":"cl2k5bv7j002q0h3ld14t12uf"},{"name":"TypeScript","_id":"cl2k5bv7p002z0h3ldrrv25ih"}]}}