{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1},{"_id":"source/img/2021-12-15-1.png","path":"img/2021-12-15-1.png","modified":1,"renderable":0},{"_id":"source/img/2021-12-22-1.png","path":"img/2021-12-22-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-01-1.jpeg","path":"img/2022-01-01-1.jpeg","modified":1,"renderable":0},{"_id":"source/img/2022-01-13-1.png","path":"img/2022-01-13-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-14-1.png","path":"img/2022-01-14-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-14-2.png","path":"img/2022-01-14-2.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-14-3.png","path":"img/2022-01-14-3.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-22-1.jpeg","path":"img/2022-01-22-1.jpeg","modified":1,"renderable":0},{"_id":"source/img/2022-01-24-1.png","path":"img/2022-01-24-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-24-2.png","path":"img/2022-01-24-2.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-24-3.png","path":"img/2022-01-24-3.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-24-4.png","path":"img/2022-01-24-4.png","modified":1,"renderable":0},{"_id":"source/img/2022-02-08-1.jpeg","path":"img/2022-02-08-1.jpeg","modified":1,"renderable":0},{"_id":"source/img/2022-02-16-1.jpeg","path":"img/2022-02-16-1.jpeg","modified":1,"renderable":0},{"_id":"source/img/2022-02-22-1.jpeg","path":"img/2022-02-22-1.jpeg","modified":1,"renderable":0},{"_id":"source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":0},{"_id":"source/img/default.jpg","path":"img/default.jpg","modified":1,"renderable":0},{"_id":"source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":0},{"_id":"source/img/index-img.png","path":"img/index-img.png","modified":1,"renderable":0},{"_id":"source/img/miaomiao.JPG","path":"img/miaomiao.JPG","modified":1,"renderable":0}],"Cache":[{"_id":"source/_drafts/2021-12-15-1.md","hash":"efd781168c344a2b85e3401bbf9d78d7719dff7a","modified":1646015949200},{"_id":"source/_drafts/2021-12-22-1.md","hash":"055b6fa21adaaf72f4fe37c2d9e33f21e8a4455d","modified":1646014114746},{"_id":"source/_posts/2022-01-01-1.md","hash":"0eda6ee5946d7d6192f8b9bf256bc2c29362ef05","modified":1646043173099},{"_id":"source/.DS_Store","hash":"76aac0ad9b5cf8b05622ca5b0d56a11dfb93bd6b","modified":1646013422426},{"_id":"source/_posts/2022-01-13-1.md","hash":"45d00b69d306d03d2004e7aaba72db815037821b","modified":1646016052487},{"_id":"source/_drafts/2022-02-22-1.md","hash":"0e5bc4653725e91da56ea7c8c1aac2833fcb77b1","modified":1646016757517},{"_id":"source/_posts/2022-01-14-2.md","hash":"3c91e45724253ab1640ef7acaa72f82796f1870f","modified":1646016180839},{"_id":"source/_drafts/2022-02-08-1.md","hash":"c06f37d5f6314dad64ee9ecec97c82b65d7bb2b5","modified":1646016931838},{"_id":"source/_posts/2022-01-14-1.md","hash":"f29f59cd84749b623b62544e0a1c57812d0ccfa3","modified":1646016144035},{"_id":"source/img/.DS_Store","hash":"53c3c76e5b49a042ce0adea2c31a5d430db5dff3","modified":1646024100307},{"_id":"source/css/custom.css","hash":"f24fec7800ead60a19749e06b7f7f64c00a4633d","modified":1645772214842},{"_id":"source/_posts/2022-01-14-3.md","hash":"5fb13f1baebeba78980189b9666c6e9bff5de6f0","modified":1646016210199},{"_id":"source/_posts/2022-01-22-1.md","hash":"d18c866bd0da4636e4b0a20e4b1766ea9f6e3994","modified":1646016464086},{"_id":"source/_posts/2022-02-15-1.md","hash":"3b1c97d16273c8cf00ef428443a99510decdd67b","modified":1646016618784},{"_id":"source/img/2022-01-13-1.png","hash":"ca711c0f3099cc42172cb5b0e72a322d7f6d3eae","modified":1646015981781},{"_id":"source/img/2021-12-15-1.png","hash":"0bb7c1fe8c45832813e1b155a1b93859bdb64d6c","modified":1646015938987},{"_id":"source/about/index.md","hash":"0f524cd97aa6a7e7a55bb61cb99084029c94cce7","modified":1645524847734},{"_id":"source/img/2022-01-01-1.jpeg","hash":"637bfc4c59e0448a36da0992dab88b32449bacc2","modified":1646014956663},{"_id":"source/img/2022-01-14-2.png","hash":"1b573758b98a28cb7b9f276413152c4ff826ea38","modified":1646016169557},{"_id":"source/img/2022-01-14-3.png","hash":"038e34cdfb8ee37c9b12ce22a931c3f54b765756","modified":1646016196232},{"_id":"source/img/2022-01-14-1.png","hash":"457563e3b79c3c5f22d065b8bb966b58ed413e77","modified":1646016128450},{"_id":"source/img/2022-01-22-1.jpeg","hash":"104465a44f28ae47be6bb42740896883fc6e9d97","modified":1646016233814},{"_id":"source/img/2022-01-24-1.png","hash":"7cac7a9aef2c512af1e8b8b1cc8a8b20cac94745","modified":1646016262776},{"_id":"source/img/2022-01-24-2.png","hash":"6fa5684418ffd50020153e1173830e3d8ee71327","modified":1646016305143},{"_id":"source/img/2022-01-24-4.png","hash":"868d8a69b778000e352ab17d22aa72c3b8eed312","modified":1646016437004},{"_id":"source/img/2022-01-24-3.png","hash":"30f86b353805b575ed8516fccb258143fa79d01e","modified":1646016394604},{"_id":"source/img/2022-02-08-1.jpeg","hash":"3e4ed33f30d6f54d5bf437062ec55c6348a4fc66","modified":1646016830499},{"_id":"source/img/2022-02-22-1.jpeg","hash":"e34dc1856ace7e149c338048fbc92d21d21d8cd1","modified":1646016746310},{"_id":"source/img/2022-02-16-1.jpeg","hash":"c049a498846cbc8d2bf6e45be0b43c97fd3d9edf","modified":1646016606165},{"_id":"source/img/avatar.png","hash":"7ba2b5e584fdcff16ac464c31012e0717df0e154","modified":1642143447663},{"_id":"source/img/favicon.png","hash":"7ba2b5e584fdcff16ac464c31012e0717df0e154","modified":1642143447663},{"_id":"source/js/custom.js","hash":"c8d2f0fa59c1803a6d50f5976d08525b518332c7","modified":1645769871072},{"_id":"source/img/miaomiao.JPG","hash":"60b94fd56002070d8be535b35adfef67f0b4be6c","modified":1642146142925},{"_id":"source/img/2021-12-22-1.png","hash":"023912be2857823f083116c0bb43078f83cb9c2a","modified":1646014018177},{"_id":"source/img/index-img.png","hash":"f7314828a14a3e236deecbe33816f99d0f65c5cf","modified":1646016966643},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"03cfa8e5f149514b57ef80dcb84eb7fea261370d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"ee5f90b4642735bb42161c389e4b86b00bc4fac5","modified":1642149993961},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"df5b54be535593d5442cebafbea34eb9bd69b987","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README_en.md","hash":"ca8fd19a4948de1f253616a62c0e8a7d81f692f5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a0c7984495d4f2d33b64adfa33adebbf768a5ac3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"8a7f1534c228538e2ab56249d5a65829650170ed","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"1a6d415446da11dee5c5f400e7d67544fbe743ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"472d0813ca5b88000a7bc6039f33b7e27b5a3216","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"ad6fed7b646d3ca961db83db0fbe020e3a5d42ad","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"20c2a195a109d2a263b5fa6e79cbcc62932508ad","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"58291dfec65c36889dfce0ddc603540b67e4c598","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"f3ae4395e751c4a02d5895e07856b1e8edfdda08","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"13a6a799415fc2f6f69ebd1a399fb44426a5d641","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7f566edf750241e62d7c54abfbb0c504fdab850a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"2a7b49f0f9aecf07550b5a0b99242aab5654cf2b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"1014b901d396f4fc445cb1ffc938d5380d894d71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"79e3679a7069351a6172c281b9d09f59d7580484","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"0ad89eb7c92a822980fa9a85285e6d94ad845d1d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"16d33eb89ecf90f4046720fde5395d972c7ba1fd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"af977ed0792508bb0766ea8afe82d34ef1e8fb3c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/beian.ejs","hash":"58b4bbe36386de4305a8da5ffd7d56802df23049","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/archive-list.ejs","hash":"53a4f6029373a40394a87aba9284696a71610f90","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/css.ejs","hash":"c363829a4b80f74fc1c565e41f6dab41c95006ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/footer.ejs","hash":"a62278c38a310da495d96c39abacacef266945cb","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/nav.ejs","hash":"e71b3c4aa263163597d31b1f91e5a1a877084cfd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/post-meta.ejs","hash":"32a17edadeed40da6db21d2d8031bd47d2fc9bf4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"6c37e9f1ac1d6d00b3c32794e02e244dba942cd9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"44faef3e77ab08b91e4c5c6f1cd9087a9faff443","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/head.ejs","hash":"f7f3494ed001e8cdcdc3e8a1d2cd1195cff2ded5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/toc.ejs","hash":"3d2fb5552f373e5a0c56bc356702d807bcbcb411","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"cde964c8cd3217268a231de5e018a62c53c2e047","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"3aa5b4ea879cd34d3a32468d88da18d72cbcc8e0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"b917b893b1777e6ffcb53188f9f5644510e5f20d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"649457796374c79e49a19bd541e4ad8e78fe8995","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/scripts.ejs","hash":"0ee838b6fcd895d21a29d9d67dbb99b752d623d1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"f1fdd512f3ef92ff5db4a49f5a3143d5ddea9858","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"53987b7a668ea0623370eb83ed5311766221b557","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"633f0142c657805359b0197f287e12ae4bcde731","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"4a43f2700e91937650bef511fd438825b001c4c6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"d058f30bd09b28769c4d8313428ff23dfc8d52dd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/twikoo.ejs","hash":"1af53bc0be642610a3a4d4e7c05287854a821508","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/utterances.ejs","hash":"e1ed6530dfd7310f91060a75766a93ac3c39be3a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/valine.ejs","hash":"4052ab2a8f78efa92f0fe17abe8f66135943390a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/waline.ejs","hash":"21e00443054802e893aac1f668b69d5bb4b39b3a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"b5fd5a2d9c463eb59318af0f47c591c485b6ad27","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"28e186c32576eb3d5d923273471a001c47fe8071","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/math.ejs","hash":"df6941bd3b860180d01fd39ee859ed2d42f4d1f0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"fd5fcb6a61ad865197a778eeae889b80484227dd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"c1db1a4f9eca6e36b660530641e3a4fb6a30c8d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/typed.ejs","hash":"e8e01c5db46b383748855452aecd70fcda99f598","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"08b455b848b21d57e0563b87071c4bae2b63bafe","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"80098e8354069631bde8edcd1181a53091a92949","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"d547ab0b91f84eb0acd0bc0c5d716ce17c30361a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"c2d8bfd04bf0734b387c049402b46a06a05fc582","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"7e32a3268accf3d524209c213e15e2d5d5e2e1a6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post.styl","hash":"5e86487de0f16c30ca3e16460ab94b57620e31c5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/rewrite.styl","hash":"a2993f23701de9a83e3f428300e62c5c52b4ff4b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/tag_plugin.styl","hash":"b89b96c8a6a433a6f372b42710554b05cab85a24","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"616c1f7147078c3d532dd1cfd2af09c0c3a816f0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"30f8fab95a5214d79df0ccc02b937df8bd885676","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"d8011325756eb6e4ce619b3e7b4d6d80c2de8a57","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"0ce7552dc4993926426019398d73e817cfd841a1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"55e10a6965462f8f62f85e75fd5e143af02a4b44","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"9f932ca3f9625c13aa5353f58319881e62c0c653","modified":499162500000},{"_id":"source/img/default.jpg","hash":"d48e1d1c2a174a0286776448c0e74f95aaa5fa5e","modified":1645520847967},{"_id":"public/css/custom.css","hash":"f24fec7800ead60a19749e06b7f7f64c00a4633d","modified":1646043178112},{"_id":"public/js/custom.js","hash":"c8d2f0fa59c1803a6d50f5976d08525b518332c7","modified":1646043178112},{"_id":"public/atom.xml","hash":"a528c70f69e78e3001a0ba09cce373840360ec3b","modified":1646043178112},{"_id":"public/local-search.xml","hash":"0126365a4152956a4d5a6114cf0c36e5fbd590d9","modified":1646043178112},{"_id":"public/about/index.html","hash":"fa610b15525b9a38703fdd4d13fb33b4b7fd32a5","modified":1646043178112},{"_id":"public/archives/index.html","hash":"b3629e8e8286fa39d336f11fabfd582bbaed8577","modified":1646043178112},{"_id":"public/archives/2022/index.html","hash":"30b984f80de6f7fa54a74a568b22960d83ecacc9","modified":1646043178112},{"_id":"public/archives/2022/01/index.html","hash":"1e685c3d78e2dcac333fe674a5f9cf1adb0452d1","modified":1646043178112},{"_id":"public/archives/2022/02/index.html","hash":"2cbd68c8b06ffe37f14da86cfbf862158f0ef790","modified":1646043178112},{"_id":"public/categories/面试/index.html","hash":"7673b5fdef6ed38aa60d2b074fbd4ed48c6e456d","modified":1646043178112},{"_id":"public/categories/JS/index.html","hash":"0830149a1ac96a51a1e78d0919109b2ef7a93d75","modified":1646043178112},{"_id":"public/categories/React/index.html","hash":"bec20b75ffd4d70a61d1e228284bee91d837e437","modified":1646043178112},{"_id":"public/categories/Vue/index.html","hash":"c46f14947d607f7889698ea892c542f751ddb0e5","modified":1646043178112},{"_id":"public/tags/前端/index.html","hash":"af98b8cf7545a4bbd83a412e6300f1341edc8371","modified":1646043178112},{"_id":"public/tags/React/index.html","hash":"d320eaf4fd556b490a40755e436ee0b580f67b55","modified":1646043178112},{"_id":"public/tags/HooK/index.html","hash":"0e4f1061a3f0d2369483f645b67cf7bd28471cf2","modified":1646043178112},{"_id":"public/tags/map/index.html","hash":"d9004b58c888e12a3dc17c4758f019cc399def81","modified":1646043178112},{"_id":"public/tags/Vue3/index.html","hash":"6242e6a6372f9661726f8ca4bfc89ef174f2db0c","modified":1646043178112},{"_id":"public/tags/面试/index.html","hash":"7927c6e1f0657527108d2e9a27b6501527a3b8fa","modified":1646043178112},{"_id":"public/404.html","hash":"93d273170c66b01cff13b0c564c67211a089aea2","modified":1646043178112},{"_id":"public/tags/index.html","hash":"f2840e64e4f23a3bcb56cee7974e0bb75d12b5e5","modified":1646043178112},{"_id":"public/categories/index.html","hash":"ac1f38f4624bd42a48832e371e77e788b2fdbcfa","modified":1646043178112},{"_id":"public/links/index.html","hash":"4bc1815f26dba7d9ef4bed9a7e141664c53c17d6","modified":1646043178112},{"_id":"public/2022/02/27/1/index.html","hash":"9c48abc79ff34d3cfbdc9cc1cb34b6c3b2a85d5b","modified":1646043178112},{"_id":"public/2022/02/15/1/index.html","hash":"55fa019ca9339333640965d1395c89d57a9d576f","modified":1646043178112},{"_id":"public/2022/01/22/1/index.html","hash":"033e0451ea201c043cc83adaa17d0945328dc35d","modified":1646043178112},{"_id":"public/2022/01/14/3/index.html","hash":"3e872f7fc4d5f711681a7474b07c33e795dcecf2","modified":1646043178112},{"_id":"public/2022/01/14/2/index.html","hash":"f51b0651d07a382752dced61cccaeb7a53fe4e1f","modified":1646043178112},{"_id":"public/2022/01/14/1/index.html","hash":"56ce22f4c38cc7d21981b76414d9bc98b503c10a","modified":1646043178112},{"_id":"public/2022/01/13/1/index.html","hash":"ae282dfcaafd2c8e6e864a203798d54657388858","modified":1646043178112},{"_id":"public/index.html","hash":"dc289467919e89382402c48495f7e4a200382722","modified":1646043178112},{"_id":"public/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1646043178112},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1646043178112},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1646043178112},{"_id":"public/img/favicon.png","hash":"7ba2b5e584fdcff16ac464c31012e0717df0e154","modified":1646043178112},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1646043178112},{"_id":"public/img/2021-12-15-1.png","hash":"0bb7c1fe8c45832813e1b155a1b93859bdb64d6c","modified":1646043178112},{"_id":"public/img/2022-01-01-1.jpeg","hash":"637bfc4c59e0448a36da0992dab88b32449bacc2","modified":1646043178112},{"_id":"public/img/2022-01-13-1.png","hash":"ca711c0f3099cc42172cb5b0e72a322d7f6d3eae","modified":1646043178112},{"_id":"public/img/2022-01-14-1.png","hash":"457563e3b79c3c5f22d065b8bb966b58ed413e77","modified":1646043178112},{"_id":"public/img/2022-01-14-3.png","hash":"038e34cdfb8ee37c9b12ce22a931c3f54b765756","modified":1646043178112},{"_id":"public/img/2022-01-24-1.png","hash":"7cac7a9aef2c512af1e8b8b1cc8a8b20cac94745","modified":1646043178112},{"_id":"public/img/2022-01-22-1.jpeg","hash":"104465a44f28ae47be6bb42740896883fc6e9d97","modified":1646043178112},{"_id":"public/img/2022-01-24-2.png","hash":"6fa5684418ffd50020153e1173830e3d8ee71327","modified":1646043178112},{"_id":"public/img/2022-01-14-2.png","hash":"1b573758b98a28cb7b9f276413152c4ff826ea38","modified":1646043178112},{"_id":"public/img/2022-01-24-3.png","hash":"30f86b353805b575ed8516fccb258143fa79d01e","modified":1646043178112},{"_id":"public/img/2022-01-24-4.png","hash":"868d8a69b778000e352ab17d22aa72c3b8eed312","modified":1646043178112},{"_id":"public/img/2022-02-08-1.jpeg","hash":"3e4ed33f30d6f54d5bf437062ec55c6348a4fc66","modified":1646043178112},{"_id":"public/img/2022-02-16-1.jpeg","hash":"c049a498846cbc8d2bf6e45be0b43c97fd3d9edf","modified":1646043178112},{"_id":"public/img/2022-02-22-1.jpeg","hash":"e34dc1856ace7e149c338048fbc92d21d21d8cd1","modified":1646043178112},{"_id":"public/img/avatar.png","hash":"7ba2b5e584fdcff16ac464c31012e0717df0e154","modified":1646043178112},{"_id":"public/img/miaomiao.JPG","hash":"60b94fd56002070d8be535b35adfef67f0b4be6c","modified":1646043178112},{"_id":"public/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":1646043178112},{"_id":"public/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":1646043178112},{"_id":"public/js/color-schema.js","hash":"f1fdd512f3ef92ff5db4a49f5a3143d5ddea9858","modified":1646043178112},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1646043178112},{"_id":"public/js/local-search.js","hash":"633f0142c657805359b0197f287e12ae4bcde731","modified":1646043178112},{"_id":"public/js/leancloud.js","hash":"53987b7a668ea0623370eb83ed5311766221b557","modified":1646043178112},{"_id":"public/js/utils.js","hash":"4a43f2700e91937650bef511fd438825b001c4c6","modified":1646043178112},{"_id":"public/js/plugins.js","hash":"d058f30bd09b28769c4d8313428ff23dfc8d52dd","modified":1646043178112},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1646043178112},{"_id":"public/css/main.css","hash":"63bc59b8ca4b03afa2b93883143c349d461b1052","modified":1646043178112},{"_id":"public/img/2021-12-22-1.png","hash":"023912be2857823f083116c0bb43078f83cb9c2a","modified":1646043178112},{"_id":"public/img/index-img.png","hash":"f7314828a14a3e236deecbe33816f99d0f65c5cf","modified":1646043178112},{"_id":"public/img/default.jpg","hash":"d48e1d1c2a174a0286776448c0e74f95aaa5fa5e","modified":1646043178112}],"Category":[{"name":"Mobx","_id":"cl06jlx2o0004l03ldttr0o2g"},{"name":"webpack","_id":"cl06jlx2t000al03l6fmhbofc"},{"name":"面试","_id":"cl06jlx2u000el03ldvukdtpg"},{"name":"JS","_id":"cl06jlx2u000il03l31tjddg7"},{"name":"React","_id":"cl06jlx39000ul03l2shb3hga"},{"name":"Vue","_id":"cl06jlx3b0010l03la3ciadjc"}],"Data":[],"Page":[{"title":"about","date":"2022-01-12T15:32:19.000Z","layout":"about","_content":"\n1、关于我\n\n```text\n  前端开发一枚;女儿奴;家有蓝白，叫喵喵。\n```\n\n2、职业技能\n\n- 前端主流技术栈、框架\n- HTML、CSS、JS、TS\n- React 技术栈\n- Vue 技术栈\n- Node\n- Kubernetes 了解点概念，简单操作, CKA\n\n3、工作状况\n\n- 目前就职于九州云\n- 容器相关\n\n4、学习计划\n\n- 深入学习 React Hooks\n\n5、联系我\n\n- Email: moweiwei6@gmail.com\n- GitHub: https://github.com/moweiwei\n\n6、END\n\n- Stay hungry. Stay foolish.\n- 知人者智，自知者明。胜人者有力，自胜者强。\n\n---\n\n![](/img/miaomiao.JPG)\n\n---\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2022-01-12 23:32:19\nlayout: about\n---\n\n1、关于我\n\n```text\n  前端开发一枚;女儿奴;家有蓝白，叫喵喵。\n```\n\n2、职业技能\n\n- 前端主流技术栈、框架\n- HTML、CSS、JS、TS\n- React 技术栈\n- Vue 技术栈\n- Node\n- Kubernetes 了解点概念，简单操作, CKA\n\n3、工作状况\n\n- 目前就职于九州云\n- 容器相关\n\n4、学习计划\n\n- 深入学习 React Hooks\n\n5、联系我\n\n- Email: moweiwei6@gmail.com\n- GitHub: https://github.com/moweiwei\n\n6、END\n\n- Stay hungry. Stay foolish.\n- 知人者智，自知者明。胜人者有力，自胜者强。\n\n---\n\n![](/img/miaomiao.JPG)\n\n---\n","updated":"2022-02-22T10:14:07.734Z","path":"about/index.html","comments":1,"_id":"cl06jlx2f0000l03lcx9w3eyz","content":"<p>1、关于我</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs text\">前端开发一枚;女儿奴;家有蓝白，叫喵喵。<br></code></pre></div></td></tr></table></figure>\n\n<p>2、职业技能</p>\n<ul>\n<li>前端主流技术栈、框架</li>\n<li>HTML、CSS、JS、TS</li>\n<li>React 技术栈</li>\n<li>Vue 技术栈</li>\n<li>Node</li>\n<li>Kubernetes 了解点概念，简单操作, CKA</li>\n</ul>\n<p>3、工作状况</p>\n<ul>\n<li>目前就职于九州云</li>\n<li>容器相关</li>\n</ul>\n<p>4、学习计划</p>\n<ul>\n<li>深入学习 React Hooks</li>\n</ul>\n<p>5、联系我</p>\n<ul>\n<li>Email: <a href=\"mailto:&#x6d;&#111;&#x77;&#x65;&#105;&#119;&#x65;&#105;&#x36;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;\">&#x6d;&#111;&#x77;&#x65;&#105;&#119;&#x65;&#105;&#x36;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;</a></li>\n<li>GitHub: <a href=\"https://github.com/moweiwei\">https://github.com/moweiwei</a></li>\n</ul>\n<p>6、END</p>\n<ul>\n<li>Stay hungry. Stay foolish.</li>\n<li>知人者智，自知者明。胜人者有力，自胜者强。</li>\n</ul>\n<hr>\n<p><img src=\"/img/miaomiao.JPG\"></p>\n<hr>\n","site":{"data":{}},"wordcount":341,"excerpt":"","more":"<p>1、关于我</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">前端开发一枚;女儿奴;家有蓝白，叫喵喵。<br></code></pre></td></tr></table></figure>\n\n<p>2、职业技能</p>\n<ul>\n<li>前端主流技术栈、框架</li>\n<li>HTML、CSS、JS、TS</li>\n<li>React 技术栈</li>\n<li>Vue 技术栈</li>\n<li>Node</li>\n<li>Kubernetes 了解点概念，简单操作, CKA</li>\n</ul>\n<p>3、工作状况</p>\n<ul>\n<li>目前就职于九州云</li>\n<li>容器相关</li>\n</ul>\n<p>4、学习计划</p>\n<ul>\n<li>深入学习 React Hooks</li>\n</ul>\n<p>5、联系我</p>\n<ul>\n<li>Email: <a href=\"mailto:&#x6d;&#111;&#x77;&#x65;&#105;&#119;&#x65;&#105;&#x36;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;\">&#x6d;&#111;&#x77;&#x65;&#105;&#119;&#x65;&#105;&#x36;&#x40;&#103;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;</a></li>\n<li>GitHub: <a href=\"https://github.com/moweiwei\">https://github.com/moweiwei</a></li>\n</ul>\n<p>6、END</p>\n<ul>\n<li>Stay hungry. Stay foolish.</li>\n<li>知人者智，自知者明。胜人者有力，自胜者强。</li>\n</ul>\n<hr>\n<p><img src=\"/img/miaomiao.JPG\"></p>\n<hr>\n"},{"_content":"/* 代码块折叠 */\nfigure.highlight {\n  background: #21252b;\n  border-radius: 0.5rem;\n}\nfigure.highlight table {\n  border-radius: 0 0 0.5rem 0.5rem;\n}\nfigure.highlight > i {\n  color: #777;\n  margin-left: 10px;\n  line-height: 2rem;\n  transform: rotate(90deg);\n  transition: transform 0.2s ease-in-out;\n}\nfigure.highlight > i.collapsed {\n  transform: rotate(0deg);\n}\nfigure.highlight > span {\n  color: #777;\n  margin-left: 5px;\n  font-size: 0.875rem;\n}\nfigure.highlight td:first-child {\n  position: sticky;\n  left: 0;\n  z-index: 1;\n}\nfigure.highlight > i:before {\n  content: \"\\f2c3\";\n}\n\n/* 复制 */\n.copy-btn {\n  top: 5px;\n  font-size: 0.875rem;\n}\n.copy-btn > i {\n  font-size: 0.875rem;\n}\n.copy-btn-dark {\n  color: #2f4f4f;\n}\n","source":"css/custom.css","raw":"/* 代码块折叠 */\nfigure.highlight {\n  background: #21252b;\n  border-radius: 0.5rem;\n}\nfigure.highlight table {\n  border-radius: 0 0 0.5rem 0.5rem;\n}\nfigure.highlight > i {\n  color: #777;\n  margin-left: 10px;\n  line-height: 2rem;\n  transform: rotate(90deg);\n  transition: transform 0.2s ease-in-out;\n}\nfigure.highlight > i.collapsed {\n  transform: rotate(0deg);\n}\nfigure.highlight > span {\n  color: #777;\n  margin-left: 5px;\n  font-size: 0.875rem;\n}\nfigure.highlight td:first-child {\n  position: sticky;\n  left: 0;\n  z-index: 1;\n}\nfigure.highlight > i:before {\n  content: \"\\f2c3\";\n}\n\n/* 复制 */\n.copy-btn {\n  top: 5px;\n  font-size: 0.875rem;\n}\n.copy-btn > i {\n  font-size: 0.875rem;\n}\n.copy-btn-dark {\n  color: #2f4f4f;\n}\n","date":"2022-02-25T06:56:54.842Z","updated":"2022-02-25T06:56:54.842Z","path":"css/custom.css","layout":"false","title":"","comments":1,"_id":"cl06jlx2m0002l03l6k6u6jjb","content":"/* 代码块折叠 */\nfigure.highlight {\n  background: #21252b;\n  border-radius: 0.5rem;\n}\nfigure.highlight table {\n  border-radius: 0 0 0.5rem 0.5rem;\n}\nfigure.highlight > i {\n  color: #777;\n  margin-left: 10px;\n  line-height: 2rem;\n  transform: rotate(90deg);\n  transition: transform 0.2s ease-in-out;\n}\nfigure.highlight > i.collapsed {\n  transform: rotate(0deg);\n}\nfigure.highlight > span {\n  color: #777;\n  margin-left: 5px;\n  font-size: 0.875rem;\n}\nfigure.highlight td:first-child {\n  position: sticky;\n  left: 0;\n  z-index: 1;\n}\nfigure.highlight > i:before {\n  content: \"\\f2c3\";\n}\n\n/* 复制 */\n.copy-btn {\n  top: 5px;\n  font-size: 0.875rem;\n}\n.copy-btn > i {\n  font-size: 0.875rem;\n}\n.copy-btn-dark {\n  color: #2f4f4f;\n}\n","site":{"data":{}},"wordcount":580,"excerpt":"","more":"/* 代码块折叠 */\nfigure.highlight {\n  background: #21252b;\n  border-radius: 0.5rem;\n}\nfigure.highlight table {\n  border-radius: 0 0 0.5rem 0.5rem;\n}\nfigure.highlight > i {\n  color: #777;\n  margin-left: 10px;\n  line-height: 2rem;\n  transform: rotate(90deg);\n  transition: transform 0.2s ease-in-out;\n}\nfigure.highlight > i.collapsed {\n  transform: rotate(0deg);\n}\nfigure.highlight > span {\n  color: #777;\n  margin-left: 5px;\n  font-size: 0.875rem;\n}\nfigure.highlight td:first-child {\n  position: sticky;\n  left: 0;\n  z-index: 1;\n}\nfigure.highlight > i:before {\n  content: \"\\f2c3\";\n}\n\n/* 复制 */\n.copy-btn {\n  top: 5px;\n  font-size: 0.875rem;\n}\n.copy-btn > i {\n  font-size: 0.875rem;\n}\n.copy-btn-dark {\n  color: #2f4f4f;\n}\n"},{"_content":"// 代码语言标准形式（这里应该有更合理的解决方式，但是我不会写）\nvar code_language = {\n  txt: \"\",\n  md: \"Markdown\",\n  markdwon: \"Markdown\",\n\n  yml: \"YAML\",\n  yaml: \"YAML\",\n  json: \"JSON\",\n\n  xml: \"XML\",\n  html: \"HTML\",\n  css: \"CSS\",\n  styl: \"Stylus\",\n  stylus: \"Stylus\",\n\n  js: \"JavaScript\",\n  javascript: \"JavaScript\",\n  ts: \"TypeScript\",\n  typescript: \"TypeScript\",\n  py: \"Python\",\n  python: \"Python\",\n\n  c: \"C\",\n  \"c++\": \"C++\",\n  cpp: \"C++\",\n  cxx: \"C++\",\n  \"c#\": \"C#\",\n  cs: \"C#\",\n  csharp: \"C#\",\n  java: \"Java\"\n};\n\n// 代码语言格式化\nfunction getLanguage(lang) {\n  var lang_lower = lang.toLowerCase();\n  return lang_lower in code_language ? code_language[lang_lower] : lang;\n}\n\n// 获取唯一 ID\nfunction getUuiD() {\n  return Math.random().toString(36).substring(2, 8) + Date.now().toString(36);\n}\n\nfunction addLanguage() {\n  // 获取所有 figure.highlight 元素\n  var hs = $(\"figure.highlight\");\n  for (var i = 0; i < hs.length; i++) {\n    // 获取代码语言\n    var lang = hs[i].firstChild.firstChild.firstChild.lastChild.firstChild.firstChild.firstChild.classList[1];\n\n    // 折叠块的 id\n    var id = `kiyan-collapse-${getUuiD()}`;\n    // 前面折叠按钮，这里我使用了 FAS 图标\n    // 注意：这里是 bootstrap 的 collapse 功能的简略代码，使用时会自动补全，补全后的 HTML 可以通过浏览器 F12 查看，此外也可查看官方文档\n    var btn = `<i class=\"iconfont .icon-arrowdown\" type=\"button\" data-toggle=\"collapse\" data-target=\"#${id}\"></i>`;\n    // 代码语言\n    var span = `<span>${getLanguage(lang)}</span>`;\n    // 折叠块包裹原来的内容\n    var div = `<div class=\"collapse show\" id=\"${id}\">${hs[i].innerHTML}</div>`;\n    hs[i].innerHTML = btn + span + div;\n  }\n}\n\n$(document).ready(addLanguage);\n","source":"js/custom.js","raw":"// 代码语言标准形式（这里应该有更合理的解决方式，但是我不会写）\nvar code_language = {\n  txt: \"\",\n  md: \"Markdown\",\n  markdwon: \"Markdown\",\n\n  yml: \"YAML\",\n  yaml: \"YAML\",\n  json: \"JSON\",\n\n  xml: \"XML\",\n  html: \"HTML\",\n  css: \"CSS\",\n  styl: \"Stylus\",\n  stylus: \"Stylus\",\n\n  js: \"JavaScript\",\n  javascript: \"JavaScript\",\n  ts: \"TypeScript\",\n  typescript: \"TypeScript\",\n  py: \"Python\",\n  python: \"Python\",\n\n  c: \"C\",\n  \"c++\": \"C++\",\n  cpp: \"C++\",\n  cxx: \"C++\",\n  \"c#\": \"C#\",\n  cs: \"C#\",\n  csharp: \"C#\",\n  java: \"Java\"\n};\n\n// 代码语言格式化\nfunction getLanguage(lang) {\n  var lang_lower = lang.toLowerCase();\n  return lang_lower in code_language ? code_language[lang_lower] : lang;\n}\n\n// 获取唯一 ID\nfunction getUuiD() {\n  return Math.random().toString(36).substring(2, 8) + Date.now().toString(36);\n}\n\nfunction addLanguage() {\n  // 获取所有 figure.highlight 元素\n  var hs = $(\"figure.highlight\");\n  for (var i = 0; i < hs.length; i++) {\n    // 获取代码语言\n    var lang = hs[i].firstChild.firstChild.firstChild.lastChild.firstChild.firstChild.firstChild.classList[1];\n\n    // 折叠块的 id\n    var id = `kiyan-collapse-${getUuiD()}`;\n    // 前面折叠按钮，这里我使用了 FAS 图标\n    // 注意：这里是 bootstrap 的 collapse 功能的简略代码，使用时会自动补全，补全后的 HTML 可以通过浏览器 F12 查看，此外也可查看官方文档\n    var btn = `<i class=\"iconfont .icon-arrowdown\" type=\"button\" data-toggle=\"collapse\" data-target=\"#${id}\"></i>`;\n    // 代码语言\n    var span = `<span>${getLanguage(lang)}</span>`;\n    // 折叠块包裹原来的内容\n    var div = `<div class=\"collapse show\" id=\"${id}\">${hs[i].innerHTML}</div>`;\n    hs[i].innerHTML = btn + span + div;\n  }\n}\n\n$(document).ready(addLanguage);\n","date":"2022-02-25T06:17:51.072Z","updated":"2022-02-25T06:17:51.072Z","path":"js/custom.js","layout":"false","title":"","comments":1,"_id":"cl06jlx2q0006l03lgwdga6y1","content":"// 代码语言标准形式（这里应该有更合理的解决方式，但是我不会写）\nvar code_language = {\n  txt: \"\",\n  md: \"Markdown\",\n  markdwon: \"Markdown\",\n\n  yml: \"YAML\",\n  yaml: \"YAML\",\n  json: \"JSON\",\n\n  xml: \"XML\",\n  html: \"HTML\",\n  css: \"CSS\",\n  styl: \"Stylus\",\n  stylus: \"Stylus\",\n\n  js: \"JavaScript\",\n  javascript: \"JavaScript\",\n  ts: \"TypeScript\",\n  typescript: \"TypeScript\",\n  py: \"Python\",\n  python: \"Python\",\n\n  c: \"C\",\n  \"c++\": \"C++\",\n  cpp: \"C++\",\n  cxx: \"C++\",\n  \"c#\": \"C#\",\n  cs: \"C#\",\n  csharp: \"C#\",\n  java: \"Java\"\n};\n\n// 代码语言格式化\nfunction getLanguage(lang) {\n  var lang_lower = lang.toLowerCase();\n  return lang_lower in code_language ? code_language[lang_lower] : lang;\n}\n\n// 获取唯一 ID\nfunction getUuiD() {\n  return Math.random().toString(36).substring(2, 8) + Date.now().toString(36);\n}\n\nfunction addLanguage() {\n  // 获取所有 figure.highlight 元素\n  var hs = $(\"figure.highlight\");\n  for (var i = 0; i < hs.length; i++) {\n    // 获取代码语言\n    var lang = hs[i].firstChild.firstChild.firstChild.lastChild.firstChild.firstChild.firstChild.classList[1];\n\n    // 折叠块的 id\n    var id = `kiyan-collapse-${getUuiD()}`;\n    // 前面折叠按钮，这里我使用了 FAS 图标\n    // 注意：这里是 bootstrap 的 collapse 功能的简略代码，使用时会自动补全，补全后的 HTML 可以通过浏览器 F12 查看，此外也可查看官方文档\n    var btn = `<i class=\"iconfont .icon-arrowdown\" type=\"button\" data-toggle=\"collapse\" data-target=\"#${id}\"></i>`;\n    // 代码语言\n    var span = `<span>${getLanguage(lang)}</span>`;\n    // 折叠块包裹原来的内容\n    var div = `<div class=\"collapse show\" id=\"${id}\">${hs[i].innerHTML}</div>`;\n    hs[i].innerHTML = btn + span + div;\n  }\n}\n\n$(document).ready(addLanguage);\n","site":{"data":{}},"wordcount":1108,"excerpt":"","more":"// 代码语言标准形式（这里应该有更合理的解决方式，但是我不会写）\nvar code_language = {\n  txt: \"\",\n  md: \"Markdown\",\n  markdwon: \"Markdown\",\n\n  yml: \"YAML\",\n  yaml: \"YAML\",\n  json: \"JSON\",\n\n  xml: \"XML\",\n  html: \"HTML\",\n  css: \"CSS\",\n  styl: \"Stylus\",\n  stylus: \"Stylus\",\n\n  js: \"JavaScript\",\n  javascript: \"JavaScript\",\n  ts: \"TypeScript\",\n  typescript: \"TypeScript\",\n  py: \"Python\",\n  python: \"Python\",\n\n  c: \"C\",\n  \"c++\": \"C++\",\n  cpp: \"C++\",\n  cxx: \"C++\",\n  \"c#\": \"C#\",\n  cs: \"C#\",\n  csharp: \"C#\",\n  java: \"Java\"\n};\n\n// 代码语言格式化\nfunction getLanguage(lang) {\n  var lang_lower = lang.toLowerCase();\n  return lang_lower in code_language ? code_language[lang_lower] : lang;\n}\n\n// 获取唯一 ID\nfunction getUuiD() {\n  return Math.random().toString(36).substring(2, 8) + Date.now().toString(36);\n}\n\nfunction addLanguage() {\n  // 获取所有 figure.highlight 元素\n  var hs = $(\"figure.highlight\");\n  for (var i = 0; i < hs.length; i++) {\n    // 获取代码语言\n    var lang = hs[i].firstChild.firstChild.firstChild.lastChild.firstChild.firstChild.firstChild.classList[1];\n\n    // 折叠块的 id\n    var id = `kiyan-collapse-${getUuiD()}`;\n    // 前面折叠按钮，这里我使用了 FAS 图标\n    // 注意：这里是 bootstrap 的 collapse 功能的简略代码，使用时会自动补全，补全后的 HTML 可以通过浏览器 F12 查看，此外也可查看官方文档\n    var btn = `<i class=\"iconfont .icon-arrowdown\" type=\"button\" data-toggle=\"collapse\" data-target=\"#${id}\"></i>`;\n    // 代码语言\n    var span = `<span>${getLanguage(lang)}</span>`;\n    // 折叠块包裹原来的内容\n    var div = `<div class=\"collapse show\" id=\"${id}\">${hs[i].innerHTML}</div>`;\n    hs[i].innerHTML = btn + span + div;\n  }\n}\n\n$(document).ready(addLanguage);\n"}],"Post":[{"title":"Mobx 原理分析","index_img":"/img/2021-12-22-1.png","date":"2021-12-22T15:12:17.000Z","_content":"\n#  Mobx 原理分析","source":"_drafts/2021-12-22-1.md","raw":"---\ntitle: Mobx 原理分析\nindex_img: /img/2021-12-22-1.png\ndate: 2021-12-22 23:12:17\ntags: Mobx\ncategories: Mobx\n---\n\n#  Mobx 原理分析","slug":"1","published":0,"updated":"2022-02-28T02:08:34.746Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl06jlx2i0001l03lgp85747h","content":"<h1 id=\"Mobx-原理分析\"><a href=\"#Mobx-原理分析\" class=\"headerlink\" title=\"Mobx 原理分析\"></a>Mobx 原理分析</h1>","site":{"data":{}},"wordcount":8,"excerpt":"","more":"<h1 id=\"Mobx-原理分析\"><a href=\"#Mobx-原理分析\" class=\"headerlink\" title=\"Mobx 原理分析\"></a>Mobx 原理分析</h1>"},{"title":"Webpack 原理分析","index_img":"/img/2022-02-08-1.jpeg","date":"2022-02-08T02:29:04.000Z","_content":"\n# Webpack 原理分析","source":"_drafts/2022-02-08-1.md","raw":"---\ntitle: Webpack 原理分析\nindex_img: /img/2022-02-08-1.jpeg\ndate: 2022-02-08 10:29:04\ntags: webpack\ncategories: webpack\n---\n\n# Webpack 原理分析","slug":"1","published":0,"updated":"2022-02-28T02:55:31.838Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl06jlx2m0003l03l0eezf0v4","content":"<h1 id=\"Webpack-原理分析\"><a href=\"#Webpack-原理分析\" class=\"headerlink\" title=\"Webpack 原理分析\"></a>Webpack 原理分析</h1>","site":{"data":{}},"wordcount":11,"excerpt":"","more":"<h1 id=\"Webpack-原理分析\"><a href=\"#Webpack-原理分析\" class=\"headerlink\" title=\"Webpack 原理分析\"></a>Webpack 原理分析</h1>"},{"title":"实习生前端工程师面试题","index_img":"/img/2022-02-22-1.jpeg","date":"2022-02-22T10:03:22.000Z","_content":"\n# 实习生前端工程师面试题\n\n## CSS\n\n- 介绍下 BFC 及其应用\n\n  BFC（Block Format Context）块级格式化上下文，是页面盒模型中的一种 `CSS` 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。\n\n  创建 `BFC` 的方式有：\n\n  1. `html` 根元素\n  2. `float` 浮动\n  3. 绝对定位\n  4. `overflow` 不为 `visible`\n  5. `display` 为表格布局或者弹性布局；\n\n  `BFC` 主要的作用是：\n\n  1. 清除浮动\n  2. 防止同一 `BFC` 容器中的相邻元素间的外边距重叠问题\n\n- 怎么让一个 div 水平垂直居中？\n\n  ```html\n  <div class=\"parent\">\n    <div class=\"child\"></div>\n  </div>\n  ```\n\n  ```css\n  <!-- 1 -->\n  div.parent {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n  <!-- 2 -->\n  div.parent {\n    position: relative;\n  }\n  div.child {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%);\n  }\n  <!-- 3 -->\n  div.parent {\n    display: grid;\n  }\n  div.child {\n    justify-self: center;\n    align-self: center;\n  }\n  <!-- 4 -->\n  div.parent {\n    font-size: 0;\n    text-align: center;\n    &::before {\n      content: \"\";\n      display: inline-block;\n      width: 0;\n      height: 100%;\n      vertical-align: middle;\n    }\n  }\n  div.child {\n    display: inline-block;\n    vertical-align: middle;\n  }\n  ```\n\n- 简述 Rem 及其转换原理\n\n  `rem` 是 CSS3 新增的相对长度单位，是指相对于根元素 `html` 的 `font-size` 计算值的大小。\n\n  默认根元素的 `font-size` 都是 `16px`的。如果想要设置 `12px` 的字体大小也就是 `12px/16px = 0.75rem`。\n\n  - 由于 `px` 是相对固定单位，字号大小直接被定死，无法随着浏览器进行缩放；\n  - `rem` 直接相对于根元素 `html`，避开层级关系，移动端新型浏览器对其支持较好；\n\n  个人用 `vw` + 百分比布局用的比较多，可以使用 `webpack` 的 `postcss-loader` 的一个插件 `postcss-px-to-viewport` 实现对 `px` 到 `vw` 的自动转换，非常适合开发。\n\n- 简述伪类和伪元素\n\n  - 伪类\n\n  伪类用于当已有元素处于某种状态时，为其添加对应的样式，这个状态是根据用户行为变化而变化的。比如说 `:hover`。它只有处于 dom 树无法描述的状态才能为元素添加样式，所以称为伪类。\n\n  -  伪元素\n\n  伪元素用于创建一些原本不在文档树中的元素，并为其添加样式，比如说 `::before`。虽然用户可以看到这些内容，但是其实他不在文档树中。\n\n\n  - 区别\n\n  伪类的操作对象是文档树中已存在的元素，而伪元素是创建一个文档树外的元素。\n\n  css 规范中用双冒号 `::` 表示伪元素，用一个冒号 `:` 表示伪类。\n\n## JS\n\n","source":"_drafts/2022-02-22-1.md","raw":"---\ntitle: 实习生前端工程师面试题\nindex_img: /img/2022-02-22-1.jpeg\ndate: 2022-02-22 18:03:22\ntags: 前端实习生\ncategories: 面试\n---\n\n# 实习生前端工程师面试题\n\n## CSS\n\n- 介绍下 BFC 及其应用\n\n  BFC（Block Format Context）块级格式化上下文，是页面盒模型中的一种 `CSS` 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。\n\n  创建 `BFC` 的方式有：\n\n  1. `html` 根元素\n  2. `float` 浮动\n  3. 绝对定位\n  4. `overflow` 不为 `visible`\n  5. `display` 为表格布局或者弹性布局；\n\n  `BFC` 主要的作用是：\n\n  1. 清除浮动\n  2. 防止同一 `BFC` 容器中的相邻元素间的外边距重叠问题\n\n- 怎么让一个 div 水平垂直居中？\n\n  ```html\n  <div class=\"parent\">\n    <div class=\"child\"></div>\n  </div>\n  ```\n\n  ```css\n  <!-- 1 -->\n  div.parent {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n  <!-- 2 -->\n  div.parent {\n    position: relative;\n  }\n  div.child {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%);\n  }\n  <!-- 3 -->\n  div.parent {\n    display: grid;\n  }\n  div.child {\n    justify-self: center;\n    align-self: center;\n  }\n  <!-- 4 -->\n  div.parent {\n    font-size: 0;\n    text-align: center;\n    &::before {\n      content: \"\";\n      display: inline-block;\n      width: 0;\n      height: 100%;\n      vertical-align: middle;\n    }\n  }\n  div.child {\n    display: inline-block;\n    vertical-align: middle;\n  }\n  ```\n\n- 简述 Rem 及其转换原理\n\n  `rem` 是 CSS3 新增的相对长度单位，是指相对于根元素 `html` 的 `font-size` 计算值的大小。\n\n  默认根元素的 `font-size` 都是 `16px`的。如果想要设置 `12px` 的字体大小也就是 `12px/16px = 0.75rem`。\n\n  - 由于 `px` 是相对固定单位，字号大小直接被定死，无法随着浏览器进行缩放；\n  - `rem` 直接相对于根元素 `html`，避开层级关系，移动端新型浏览器对其支持较好；\n\n  个人用 `vw` + 百分比布局用的比较多，可以使用 `webpack` 的 `postcss-loader` 的一个插件 `postcss-px-to-viewport` 实现对 `px` 到 `vw` 的自动转换，非常适合开发。\n\n- 简述伪类和伪元素\n\n  - 伪类\n\n  伪类用于当已有元素处于某种状态时，为其添加对应的样式，这个状态是根据用户行为变化而变化的。比如说 `:hover`。它只有处于 dom 树无法描述的状态才能为元素添加样式，所以称为伪类。\n\n  -  伪元素\n\n  伪元素用于创建一些原本不在文档树中的元素，并为其添加样式，比如说 `::before`。虽然用户可以看到这些内容，但是其实他不在文档树中。\n\n\n  - 区别\n\n  伪类的操作对象是文档树中已存在的元素，而伪元素是创建一个文档树外的元素。\n\n  css 规范中用双冒号 `::` 表示伪元素，用一个冒号 `:` 表示伪类。\n\n## JS\n\n","slug":"1","published":0,"updated":"2022-02-28T02:52:37.517Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl06jlx2r0007l03ld1ooazb4","content":"<h1 id=\"实习生前端工程师面试题\"><a href=\"#实习生前端工程师面试题\" class=\"headerlink\" title=\"实习生前端工程师面试题\"></a>实习生前端工程师面试题</h1><h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><ul>\n<li><p>介绍下 BFC 及其应用</p>\n<p>BFC（Block Format Context）块级格式化上下文，是页面盒模型中的一种 <code>CSS</code> 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。</p>\n<p>创建 <code>BFC</code> 的方式有：</p>\n<ol>\n<li><code>html</code> 根元素</li>\n<li><code>float</code> 浮动</li>\n<li>绝对定位</li>\n<li><code>overflow</code> 不为 <code>visible</code></li>\n<li><code>display</code> 为表格布局或者弹性布局；</li>\n</ol>\n<p><code>BFC</code> 主要的作用是：</p>\n<ol>\n<li>清除浮动</li>\n<li>防止同一 <code>BFC</code> 容器中的相邻元素间的外边距重叠问题</li>\n</ol>\n</li>\n<li><p>怎么让一个 div 水平垂直居中？</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;parent&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;child&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs css\">&lt;!-- <span class=\"hljs-number\">1</span> --&gt;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;<br>  <span class=\"hljs-attribute\">display</span>: flex;<br>  <span class=\"hljs-attribute\">justify-content</span>: center;<br>  <span class=\"hljs-attribute\">align-items</span>: center;<br>&#125;<br>&lt;!-- <span class=\"hljs-number\">2</span> --&gt;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;<br>  <span class=\"hljs-attribute\">position</span>: relative;<br>&#125;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.child</span> &#123;<br>  <span class=\"hljs-attribute\">position</span>: absolute;<br>  <span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">50%</span>;<br>  <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">50%</span>;<br>  <span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-built_in\">translate</span>(-<span class=\"hljs-number\">50%</span>, -<span class=\"hljs-number\">50%</span>);<br>&#125;<br>&lt;!-- <span class=\"hljs-number\">3</span> --&gt;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;<br>  <span class=\"hljs-attribute\">display</span>: grid;<br>&#125;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.child</span> &#123;<br>  justify-self: center;<br>  <span class=\"hljs-attribute\">align-self</span>: center;<br>&#125;<br>&lt;!-- <span class=\"hljs-number\">4</span> --&gt;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;<br>  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-attribute\">text-align</span>: center;<br>  &amp;<span class=\"hljs-selector-pseudo\">::before</span> &#123;<br>    <span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">&quot;&quot;</span>;<br>    <span class=\"hljs-attribute\">display</span>: inline-block;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100%</span>;<br>    <span class=\"hljs-attribute\">vertical-align</span>: middle;<br>  &#125;<br>&#125;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.child</span> &#123;<br>  <span class=\"hljs-attribute\">display</span>: inline-block;<br>  <span class=\"hljs-attribute\">vertical-align</span>: middle;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>\n<li><p>简述 Rem 及其转换原理</p>\n<p><code>rem</code> 是 CSS3 新增的相对长度单位，是指相对于根元素 <code>html</code> 的 <code>font-size</code> 计算值的大小。</p>\n<p>默认根元素的 <code>font-size</code> 都是 <code>16px</code>的。如果想要设置 <code>12px</code> 的字体大小也就是 <code>12px/16px = 0.75rem</code>。</p>\n<ul>\n<li>由于 <code>px</code> 是相对固定单位，字号大小直接被定死，无法随着浏览器进行缩放；</li>\n<li><code>rem</code> 直接相对于根元素 <code>html</code>，避开层级关系，移动端新型浏览器对其支持较好；</li>\n</ul>\n<p>个人用 <code>vw</code> + 百分比布局用的比较多，可以使用 <code>webpack</code> 的 <code>postcss-loader</code> 的一个插件 <code>postcss-px-to-viewport</code> 实现对 <code>px</code> 到 <code>vw</code> 的自动转换，非常适合开发。</p>\n</li>\n<li><p>简述伪类和伪元素</p>\n<ul>\n<li>伪类</li>\n</ul>\n<p>伪类用于当已有元素处于某种状态时，为其添加对应的样式，这个状态是根据用户行为变化而变化的。比如说 <code>:hover</code>。它只有处于 dom 树无法描述的状态才能为元素添加样式，所以称为伪类。</p>\n<ul>\n<li> 伪元素</li>\n</ul>\n<p>伪元素用于创建一些原本不在文档树中的元素，并为其添加样式，比如说 <code>::before</code>。虽然用户可以看到这些内容，但是其实他不在文档树中。</p>\n</li>\n</ul>\n<ul>\n<li>区别</li>\n</ul>\n<p>  伪类的操作对象是文档树中已存在的元素，而伪元素是创建一个文档树外的元素。</p>\n<p>  css 规范中用双冒号 <code>::</code> 表示伪元素，用一个冒号 <code>:</code> 表示伪类。</p>\n<h2 id=\"JS\"><a href=\"#JS\" class=\"headerlink\" title=\"JS\"></a>JS</h2>","site":{"data":{}},"wordcount":1481,"excerpt":"","more":"<h1 id=\"实习生前端工程师面试题\"><a href=\"#实习生前端工程师面试题\" class=\"headerlink\" title=\"实习生前端工程师面试题\"></a>实习生前端工程师面试题</h1><h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><ul>\n<li><p>介绍下 BFC 及其应用</p>\n<p>BFC（Block Format Context）块级格式化上下文，是页面盒模型中的一种 <code>CSS</code> 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。</p>\n<p>创建 <code>BFC</code> 的方式有：</p>\n<ol>\n<li><code>html</code> 根元素</li>\n<li><code>float</code> 浮动</li>\n<li>绝对定位</li>\n<li><code>overflow</code> 不为 <code>visible</code></li>\n<li><code>display</code> 为表格布局或者弹性布局；</li>\n</ol>\n<p><code>BFC</code> 主要的作用是：</p>\n<ol>\n<li>清除浮动</li>\n<li>防止同一 <code>BFC</code> 容器中的相邻元素间的外边距重叠问题</li>\n</ol>\n</li>\n<li><p>怎么让一个 div 水平垂直居中？</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;parent&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;child&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">&lt;!-- <span class=\"hljs-number\">1</span> --&gt;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;<br>  <span class=\"hljs-attribute\">display</span>: flex;<br>  <span class=\"hljs-attribute\">justify-content</span>: center;<br>  <span class=\"hljs-attribute\">align-items</span>: center;<br>&#125;<br>&lt;!-- <span class=\"hljs-number\">2</span> --&gt;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;<br>  <span class=\"hljs-attribute\">position</span>: relative;<br>&#125;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.child</span> &#123;<br>  <span class=\"hljs-attribute\">position</span>: absolute;<br>  <span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">50%</span>;<br>  <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">50%</span>;<br>  <span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-built_in\">translate</span>(-<span class=\"hljs-number\">50%</span>, -<span class=\"hljs-number\">50%</span>);<br>&#125;<br>&lt;!-- <span class=\"hljs-number\">3</span> --&gt;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;<br>  <span class=\"hljs-attribute\">display</span>: grid;<br>&#125;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.child</span> &#123;<br>  justify-self: center;<br>  <span class=\"hljs-attribute\">align-self</span>: center;<br>&#125;<br>&lt;!-- <span class=\"hljs-number\">4</span> --&gt;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;<br>  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-attribute\">text-align</span>: center;<br>  &amp;<span class=\"hljs-selector-pseudo\">::before</span> &#123;<br>    <span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">&quot;&quot;</span>;<br>    <span class=\"hljs-attribute\">display</span>: inline-block;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100%</span>;<br>    <span class=\"hljs-attribute\">vertical-align</span>: middle;<br>  &#125;<br>&#125;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.child</span> &#123;<br>  <span class=\"hljs-attribute\">display</span>: inline-block;<br>  <span class=\"hljs-attribute\">vertical-align</span>: middle;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>简述 Rem 及其转换原理</p>\n<p><code>rem</code> 是 CSS3 新增的相对长度单位，是指相对于根元素 <code>html</code> 的 <code>font-size</code> 计算值的大小。</p>\n<p>默认根元素的 <code>font-size</code> 都是 <code>16px</code>的。如果想要设置 <code>12px</code> 的字体大小也就是 <code>12px/16px = 0.75rem</code>。</p>\n<ul>\n<li>由于 <code>px</code> 是相对固定单位，字号大小直接被定死，无法随着浏览器进行缩放；</li>\n<li><code>rem</code> 直接相对于根元素 <code>html</code>，避开层级关系，移动端新型浏览器对其支持较好；</li>\n</ul>\n<p>个人用 <code>vw</code> + 百分比布局用的比较多，可以使用 <code>webpack</code> 的 <code>postcss-loader</code> 的一个插件 <code>postcss-px-to-viewport</code> 实现对 <code>px</code> 到 <code>vw</code> 的自动转换，非常适合开发。</p>\n</li>\n<li><p>简述伪类和伪元素</p>\n<ul>\n<li>伪类</li>\n</ul>\n<p>伪类用于当已有元素处于某种状态时，为其添加对应的样式，这个状态是根据用户行为变化而变化的。比如说 <code>:hover</code>。它只有处于 dom 树无法描述的状态才能为元素添加样式，所以称为伪类。</p>\n<ul>\n<li> 伪元素</li>\n</ul>\n<p>伪元素用于创建一些原本不在文档树中的元素，并为其添加样式，比如说 <code>::before</code>。虽然用户可以看到这些内容，但是其实他不在文档树中。</p>\n</li>\n</ul>\n<ul>\n<li>区别</li>\n</ul>\n<p>  伪类的操作对象是文档树中已存在的元素，而伪元素是创建一个文档树外的元素。</p>\n<p>  css 规范中用双冒号 <code>::</code> 表示伪元素，用一个冒号 <code>:</code> 表示伪类。</p>\n<h2 id=\"JS\"><a href=\"#JS\" class=\"headerlink\" title=\"JS\"></a>JS</h2>"},{"title":"JS 代码 Bad & Good","index_img":"/img/2021-12-15-1.png","date":"2021-12-15T15:13:22.000Z","_content":"\n#  JS 代码 Bad & Good","source":"_drafts/2021-12-15-1.md","raw":"---\ntitle: JS 代码 Bad & Good\nindex_img: /img/2021-12-15-1.png\ndate: 2021-12-15 23:13:22\ntags: Bad&Good\ncategories: JS\n---\n\n#  JS 代码 Bad & Good","slug":"1","published":0,"updated":"2022-02-28T02:39:09.200Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl06jlx2s0008l03lf61n6kla","content":"<h1 id=\"JS-代码-Bad-amp-Good\"><a href=\"#JS-代码-Bad-amp-Good\" class=\"headerlink\" title=\"JS 代码 Bad &amp; Good\"></a>JS 代码 Bad &amp; Good</h1>","site":{"data":{}},"wordcount":16,"excerpt":"","more":"<h1 id=\"JS-代码-Bad-amp-Good\"><a href=\"#JS-代码-Bad-amp-Good\" class=\"headerlink\" title=\"JS 代码 Bad &amp; Good\"></a>JS 代码 Bad &amp; Good</h1>"},{"title":"FE-Interview","index_img":"/img/2022-01-01-1.jpeg","date":"2022-02-27T15:28:37.000Z","_content":"# FE-Interview\n\n## 第一天 (2020.01.01)\n\n- 什么时候使用状态管理器？\n\n    1. 组件状态要在多个组件共享时\n    1. 某个组件状态需要在任何地方可以拿到\n    1. 一个组件需要改变全局状态时\n    1. 一个组件需要改变另一个组件状态时\n    1. 组件状态提升提升不能满足需求时，层级过多时。\n\n- render函数中return如果没有使用()会有什么问题？\n\n    避免遇到自动插入分号陷阱。\n\n    我们在使用JSX语法书写react代码时，babel会将JSX语法编译成js，同时会在每行自动添加分号（；），如果return后换行了，那么就会变成 return； 一般情况下会报错：\n\n    Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.\n    上面这段英文翻译成中文：\n\n    渲染没有返回任何内容。这通常意味着缺少return语句。或者，为了不渲染，返回null。\n    为了代码可读性我们一般会在return后面添加括号这样代码可以折行书写，否则就在return 后面紧跟着语句，这样也是可以的。\n\n    举两个正确的书写例子：\n\n    ```jsx\n    const Nav = () => {\n      return (\n        <nav className=\"c_navbar\">\n          { some jsx magic here }\n        </nav>\n        )\n      }\n\n    const Nav = () => {\n    return <nav className=\"c_navbar\">\n        { some jsx magic here }\n      </nav>\n    }\n    ```\n\n    错误的写法：\n\n    ```jsx\n    const Nav = () => {\n      return\n        <nav className=\"c_navbar\">\n          { some jsx magic here }\n        </nav>\n    }\n    ```\n\n- componentWillUpdate可以直接修改state的值吗？\n\n    直接修改不可以，但是加上条件就可以。\n\n    文档原文：“你也可以在 componentDidUpdate() 中直接调用 setState()，但请注意它必须被包裹在一个条件语句里，正如上述的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。”\n\n    componentWillReceiveProps 同理\n\n- 说说你对React的渲染原理的理解\n\n    1. React会调用React.render()构建一颗DOM树，生成虚拟dom。\n    2. 通过改变state或props触发更新。\n    3. 对比新旧虚拟dom，diff算法，深度优先，将实际需要改变的反应到真实dom。\n\n\n## Reference\n\n- <https://github.com/qiu-deqing/FE-interview>\n- <https://github.com/haizlin/fe-interview>\n","source":"_posts/2022-01-01-1.md","raw":"---\ntitle: FE-Interview\nindex_img: /img/2022-01-01-1.jpeg\ndate: 2022-02-27 23:28:37\ntags: 前端\ncategories: 面试\n---\n# FE-Interview\n\n## 第一天 (2020.01.01)\n\n- 什么时候使用状态管理器？\n\n    1. 组件状态要在多个组件共享时\n    1. 某个组件状态需要在任何地方可以拿到\n    1. 一个组件需要改变全局状态时\n    1. 一个组件需要改变另一个组件状态时\n    1. 组件状态提升提升不能满足需求时，层级过多时。\n\n- render函数中return如果没有使用()会有什么问题？\n\n    避免遇到自动插入分号陷阱。\n\n    我们在使用JSX语法书写react代码时，babel会将JSX语法编译成js，同时会在每行自动添加分号（；），如果return后换行了，那么就会变成 return； 一般情况下会报错：\n\n    Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.\n    上面这段英文翻译成中文：\n\n    渲染没有返回任何内容。这通常意味着缺少return语句。或者，为了不渲染，返回null。\n    为了代码可读性我们一般会在return后面添加括号这样代码可以折行书写，否则就在return 后面紧跟着语句，这样也是可以的。\n\n    举两个正确的书写例子：\n\n    ```jsx\n    const Nav = () => {\n      return (\n        <nav className=\"c_navbar\">\n          { some jsx magic here }\n        </nav>\n        )\n      }\n\n    const Nav = () => {\n    return <nav className=\"c_navbar\">\n        { some jsx magic here }\n      </nav>\n    }\n    ```\n\n    错误的写法：\n\n    ```jsx\n    const Nav = () => {\n      return\n        <nav className=\"c_navbar\">\n          { some jsx magic here }\n        </nav>\n    }\n    ```\n\n- componentWillUpdate可以直接修改state的值吗？\n\n    直接修改不可以，但是加上条件就可以。\n\n    文档原文：“你也可以在 componentDidUpdate() 中直接调用 setState()，但请注意它必须被包裹在一个条件语句里，正如上述的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。”\n\n    componentWillReceiveProps 同理\n\n- 说说你对React的渲染原理的理解\n\n    1. React会调用React.render()构建一颗DOM树，生成虚拟dom。\n    2. 通过改变state或props触发更新。\n    3. 对比新旧虚拟dom，diff算法，深度优先，将实际需要改变的反应到真实dom。\n\n\n## Reference\n\n- <https://github.com/qiu-deqing/FE-interview>\n- <https://github.com/haizlin/fe-interview>\n","slug":"1","published":1,"updated":"2022-02-28T10:12:53.099Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl06jlx2t0009l03la0gthw2t","content":"<h1 id=\"FE-Interview\"><a href=\"#FE-Interview\" class=\"headerlink\" title=\"FE-Interview\"></a>FE-Interview</h1><h2 id=\"第一天-2020-01-01\"><a href=\"#第一天-2020-01-01\" class=\"headerlink\" title=\"第一天 (2020.01.01)\"></a>第一天 (2020.01.01)</h2><ul>\n<li><p>什么时候使用状态管理器？</p>\n<ol>\n<li>组件状态要在多个组件共享时</li>\n<li>某个组件状态需要在任何地方可以拿到</li>\n<li>一个组件需要改变全局状态时</li>\n<li>一个组件需要改变另一个组件状态时</li>\n<li>组件状态提升提升不能满足需求时，层级过多时。</li>\n</ol>\n</li>\n<li><p>render函数中return如果没有使用()会有什么问题？</p>\n<p>  避免遇到自动插入分号陷阱。</p>\n<p>  我们在使用JSX语法书写react代码时，babel会将JSX语法编译成js，同时会在每行自动添加分号（；），如果return后换行了，那么就会变成 return； 一般情况下会报错：</p>\n<p>  Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.<br>  上面这段英文翻译成中文：</p>\n<p>  渲染没有返回任何内容。这通常意味着缺少return语句。或者，为了不渲染，返回null。<br>  为了代码可读性我们一般会在return后面添加括号这样代码可以折行书写，否则就在return 后面紧跟着语句，这样也是可以的。</p>\n<p>  举两个正确的书写例子：</p>\n  <figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Nav = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;c_navbar&quot;</span>&gt;</span></span><br><span class=\"xml\">      &#123; some jsx magic here &#125;</span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span></span><br>    )<br>  &#125;<br><br><span class=\"hljs-keyword\">const</span> Nav = <span class=\"hljs-function\">() =&gt;</span> &#123;<br><span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;c_navbar&quot;</span>&gt;</span></span><br><span class=\"xml\">    &#123; some jsx magic here &#125;</span><br><span class=\"xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span></span><br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>  错误的写法：</p>\n  <figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Nav = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span><br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;c_navbar&quot;</span>&gt;</span></span><br><span class=\"xml\">      &#123; some jsx magic here &#125;</span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span></span><br>&#125;<br></code></pre></div></td></tr></table></figure></li>\n<li><p>componentWillUpdate可以直接修改state的值吗？</p>\n<p>  直接修改不可以，但是加上条件就可以。</p>\n<p>  文档原文：“你也可以在 componentDidUpdate() 中直接调用 setState()，但请注意它必须被包裹在一个条件语句里，正如上述的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。”</p>\n<p>  componentWillReceiveProps 同理</p>\n</li>\n<li><p>说说你对React的渲染原理的理解</p>\n<ol>\n<li>React会调用React.render()构建一颗DOM树，生成虚拟dom。</li>\n<li>通过改变state或props触发更新。</li>\n<li>对比新旧虚拟dom，diff算法，深度优先，将实际需要改变的反应到真实dom。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ul>\n<li><a href=\"https://github.com/qiu-deqing/FE-interview\">https://github.com/qiu-deqing/FE-interview</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview\">https://github.com/haizlin/fe-interview</a></li>\n</ul>\n","site":{"data":{}},"wordcount":1263,"excerpt":"","more":"<h1 id=\"FE-Interview\"><a href=\"#FE-Interview\" class=\"headerlink\" title=\"FE-Interview\"></a>FE-Interview</h1><h2 id=\"第一天-2020-01-01\"><a href=\"#第一天-2020-01-01\" class=\"headerlink\" title=\"第一天 (2020.01.01)\"></a>第一天 (2020.01.01)</h2><ul>\n<li><p>什么时候使用状态管理器？</p>\n<ol>\n<li>组件状态要在多个组件共享时</li>\n<li>某个组件状态需要在任何地方可以拿到</li>\n<li>一个组件需要改变全局状态时</li>\n<li>一个组件需要改变另一个组件状态时</li>\n<li>组件状态提升提升不能满足需求时，层级过多时。</li>\n</ol>\n</li>\n<li><p>render函数中return如果没有使用()会有什么问题？</p>\n<p>  避免遇到自动插入分号陷阱。</p>\n<p>  我们在使用JSX语法书写react代码时，babel会将JSX语法编译成js，同时会在每行自动添加分号（；），如果return后换行了，那么就会变成 return； 一般情况下会报错：</p>\n<p>  Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.<br>  上面这段英文翻译成中文：</p>\n<p>  渲染没有返回任何内容。这通常意味着缺少return语句。或者，为了不渲染，返回null。<br>  为了代码可读性我们一般会在return后面添加括号这样代码可以折行书写，否则就在return 后面紧跟着语句，这样也是可以的。</p>\n<p>  举两个正确的书写例子：</p>\n  <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Nav = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;c_navbar&quot;</span>&gt;</span></span><br><span class=\"xml\">      &#123; some jsx magic here &#125;</span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span></span><br>    )<br>  &#125;<br><br><span class=\"hljs-keyword\">const</span> Nav = <span class=\"hljs-function\">() =&gt;</span> &#123;<br><span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;c_navbar&quot;</span>&gt;</span></span><br><span class=\"xml\">    &#123; some jsx magic here &#125;</span><br><span class=\"xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>  错误的写法：</p>\n  <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Nav = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span><br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;c_navbar&quot;</span>&gt;</span></span><br><span class=\"xml\">      &#123; some jsx magic here &#125;</span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>componentWillUpdate可以直接修改state的值吗？</p>\n<p>  直接修改不可以，但是加上条件就可以。</p>\n<p>  文档原文：“你也可以在 componentDidUpdate() 中直接调用 setState()，但请注意它必须被包裹在一个条件语句里，正如上述的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。”</p>\n<p>  componentWillReceiveProps 同理</p>\n</li>\n<li><p>说说你对React的渲染原理的理解</p>\n<ol>\n<li>React会调用React.render()构建一颗DOM树，生成虚拟dom。</li>\n<li>通过改变state或props触发更新。</li>\n<li>对比新旧虚拟dom，diff算法，深度优先，将实际需要改变的反应到真实dom。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ul>\n<li><a href=\"https://github.com/qiu-deqing/FE-interview\">https://github.com/qiu-deqing/FE-interview</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview\">https://github.com/haizlin/fe-interview</a></li>\n</ul>\n"},{"title":"使用 useRef 跨生命周期保存变量","date":"2022-01-13T07:23:54.000Z","index_img":"/img/2022-01-13-1.png","_content":"\n# 使用 useRef 跨生命周期保存变量\n\nref 这一种访问 DOM 的主要方式。然而，useRef() 比 ref 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式.\n\n当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。\n\n## 场景 1：只在更新时运行 useEffect\n\n使用一个可变的 ref 手动存储一个布尔值来表示是首次渲染还是后续渲染.\n\n```jsx\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  const prevCountRef = useRef(false);\n  useEffect(() => {\n    if (prevCountRef.current) {\n      console.log(\"只在更新时候执行\");\n    } else {\n      console.log(\"首次渲染执行\");\n      prevCountRef.current = true;\n    }\n  });\n\n  return (\n    <div>\n      <div>{count}</div>\n      <button\n        onClick={() => {\n          setCount(count + 1);\n        }}\n      >\n        +\n      </button>\n    </div>\n  );\n}\n```\n\n抽成自定义 hook：\n\n```jsx\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  const update = useUpdate();\n  console.log(update, \"是否更新\");\n\n  return (\n    <div>\n      <div>{count}</div>\n      <button\n        onClick={() => {\n          setCount(count + 1);\n        }}\n      >\n        +\n      </button>\n    </div>\n  );\n}\n\nfunction useUpdate() {\n  const ref = useRef(false);\n  useEffect(() => {\n    ref.current = true;\n  });\n  return ref.current;\n}\n```\n\n## 场景 2：获取上一轮的 props 或 state\n\n为什么 ref.current 拿到是上次的值？原因：\n\n1. useEffect 很重要的一点是：它是在每次渲染之后才会触发的，是延迟执行的。\n2. return 语句是同步的，所以 return 的时候，ref.current 还是旧值。\n3. 以下代码的执行顺序是 1 3 2\n\n```jsx\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  const prevCountRef = useRef();\n\n  console.log(\"1\", count);\n  useEffect(() => {\n    console.log(\"2.\", count);\n    prevCountRef.current = count;\n  });\n\n  const prevCount = prevCountRef.current;\n\n  console.log(`3.之前的状态: ${prevCount};现在状态: ${count}`);\n  return (\n    <div>\n      <div>{count}</div>\n      <button\n        onClick={() => {\n          setCount(count + 1);\n        }}\n      >\n        +\n      </button>\n    </div>\n  );\n}\n```\n\n抽取成自定义 Hook:\n\n```jsx\nexport default function usePrevious(value) {\n  const ref = useRef();\n\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref.current;\n}\n```\n\n## 场景 3：解决 hooks 时，由于异步闭包无法获取最新 state 的问题\n\n```jsx\nimport React, { useState, useEffect, useRef } from \"react\";\n\nconst RefComponent = () => {\n  // 使用 useState 存放和改变展示的 number\n  const [number, setNumber] = useState(0);\n  // 使用 useRef 生成一个独立的 ref 对象\n  // 在它的 current 属性单独存放一个展示的 number, 初始值为 0\n  const numRef = useRef(0);\n\n  function incrementAndDelayLogging() {\n    // 点击按钮 number + 1\n    setNumber(number + 1);\n    // 同时 ref 对象的 current 属性值也 + 1\n    numRef.current++;\n    // 定时器函数中产生了闭包, 这里 number 的是组件更新前的 number 对象, 所以值一直会滞后 1\n    setTimeout(() => alert(`state: ${number} | ref: ${numRef.current}`), 1000);\n  }\n\n  // 直接渲染的组件是正常情况, 可以获取到最新的 state,\n  // 所以 ref.current 和 state 存储的值显示一致\n  return (\n    <div>\n      <h1>solving closure by useRef</h1>\n      <button onClick={incrementAndDelayLogging}>alert in setTimeout</button>\n      <h4>state: {number}</h4>\n      <h4>ref: {numRef.current}</h4>\n    </div>\n  );\n};\n```\n","source":"_posts/2022-01-13-1.md","raw":"---\ntitle: 使用 useRef 跨生命周期保存变量\ndate: 2022-01-13 15:23:54\ntags:\n  - React\n  - HooK\nindex_img: /img/2022-01-13-1.png\ncategories: React\n---\n\n# 使用 useRef 跨生命周期保存变量\n\nref 这一种访问 DOM 的主要方式。然而，useRef() 比 ref 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式.\n\n当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。\n\n## 场景 1：只在更新时运行 useEffect\n\n使用一个可变的 ref 手动存储一个布尔值来表示是首次渲染还是后续渲染.\n\n```jsx\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  const prevCountRef = useRef(false);\n  useEffect(() => {\n    if (prevCountRef.current) {\n      console.log(\"只在更新时候执行\");\n    } else {\n      console.log(\"首次渲染执行\");\n      prevCountRef.current = true;\n    }\n  });\n\n  return (\n    <div>\n      <div>{count}</div>\n      <button\n        onClick={() => {\n          setCount(count + 1);\n        }}\n      >\n        +\n      </button>\n    </div>\n  );\n}\n```\n\n抽成自定义 hook：\n\n```jsx\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  const update = useUpdate();\n  console.log(update, \"是否更新\");\n\n  return (\n    <div>\n      <div>{count}</div>\n      <button\n        onClick={() => {\n          setCount(count + 1);\n        }}\n      >\n        +\n      </button>\n    </div>\n  );\n}\n\nfunction useUpdate() {\n  const ref = useRef(false);\n  useEffect(() => {\n    ref.current = true;\n  });\n  return ref.current;\n}\n```\n\n## 场景 2：获取上一轮的 props 或 state\n\n为什么 ref.current 拿到是上次的值？原因：\n\n1. useEffect 很重要的一点是：它是在每次渲染之后才会触发的，是延迟执行的。\n2. return 语句是同步的，所以 return 的时候，ref.current 还是旧值。\n3. 以下代码的执行顺序是 1 3 2\n\n```jsx\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  const prevCountRef = useRef();\n\n  console.log(\"1\", count);\n  useEffect(() => {\n    console.log(\"2.\", count);\n    prevCountRef.current = count;\n  });\n\n  const prevCount = prevCountRef.current;\n\n  console.log(`3.之前的状态: ${prevCount};现在状态: ${count}`);\n  return (\n    <div>\n      <div>{count}</div>\n      <button\n        onClick={() => {\n          setCount(count + 1);\n        }}\n      >\n        +\n      </button>\n    </div>\n  );\n}\n```\n\n抽取成自定义 Hook:\n\n```jsx\nexport default function usePrevious(value) {\n  const ref = useRef();\n\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref.current;\n}\n```\n\n## 场景 3：解决 hooks 时，由于异步闭包无法获取最新 state 的问题\n\n```jsx\nimport React, { useState, useEffect, useRef } from \"react\";\n\nconst RefComponent = () => {\n  // 使用 useState 存放和改变展示的 number\n  const [number, setNumber] = useState(0);\n  // 使用 useRef 生成一个独立的 ref 对象\n  // 在它的 current 属性单独存放一个展示的 number, 初始值为 0\n  const numRef = useRef(0);\n\n  function incrementAndDelayLogging() {\n    // 点击按钮 number + 1\n    setNumber(number + 1);\n    // 同时 ref 对象的 current 属性值也 + 1\n    numRef.current++;\n    // 定时器函数中产生了闭包, 这里 number 的是组件更新前的 number 对象, 所以值一直会滞后 1\n    setTimeout(() => alert(`state: ${number} | ref: ${numRef.current}`), 1000);\n  }\n\n  // 直接渲染的组件是正常情况, 可以获取到最新的 state,\n  // 所以 ref.current 和 state 存储的值显示一致\n  return (\n    <div>\n      <h1>solving closure by useRef</h1>\n      <button onClick={incrementAndDelayLogging}>alert in setTimeout</button>\n      <h4>state: {number}</h4>\n      <h4>ref: {numRef.current}</h4>\n    </div>\n  );\n};\n```\n","slug":"1","published":1,"updated":"2022-02-28T02:40:52.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl06jlx35000sl03l9o4e2zh0","content":"<h1 id=\"使用-useRef-跨生命周期保存变量\"><a href=\"#使用-useRef-跨生命周期保存变量\" class=\"headerlink\" title=\"使用 useRef 跨生命周期保存变量\"></a>使用 useRef 跨生命周期保存变量</h1><p>ref 这一种访问 DOM 的主要方式。然而，useRef() 比 ref 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式.</p>\n<p>当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。</p>\n<h2 id=\"场景-1：只在更新时运行-useEffect\"><a href=\"#场景-1：只在更新时运行-useEffect\" class=\"headerlink\" title=\"场景 1：只在更新时运行 useEffect\"></a>场景 1：只在更新时运行 useEffect</h2><p>使用一个可变的 ref 手动存储一个布尔值来表示是首次渲染还是后续渲染.</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);<br><br>  <span class=\"hljs-keyword\">const</span> prevCountRef = useRef(<span class=\"hljs-literal\">false</span>);<br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (prevCountRef.current) &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;只在更新时候执行&quot;</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;首次渲染执行&quot;</span>);<br>      prevCountRef.current = <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>  &#125;);<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span></span></span><br><span class=\"hljs-tag\"><span class=\"xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span><br><span class=\"xml\">          setCount(count + 1);</span><br><span class=\"xml\">        &#125;&#125;</span><br><span class=\"xml\">      &gt;</span><br><span class=\"xml\">        +</span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>抽成自定义 hook：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);<br><br>  <span class=\"hljs-keyword\">const</span> update = useUpdate();<br>  <span class=\"hljs-built_in\">console</span>.log(update, <span class=\"hljs-string\">&quot;是否更新&quot;</span>);<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span></span></span><br><span class=\"hljs-tag\"><span class=\"xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span><br><span class=\"xml\">          setCount(count + 1);</span><br><span class=\"xml\">        &#125;&#125;</span><br><span class=\"xml\">      &gt;</span><br><span class=\"xml\">        +</span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useUpdate</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> ref = useRef(<span class=\"hljs-literal\">false</span>);<br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    ref.current = <span class=\"hljs-literal\">true</span>;<br>  &#125;);<br>  <span class=\"hljs-keyword\">return</span> ref.current;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"场景-2：获取上一轮的-props-或-state\"><a href=\"#场景-2：获取上一轮的-props-或-state\" class=\"headerlink\" title=\"场景 2：获取上一轮的 props 或 state\"></a>场景 2：获取上一轮的 props 或 state</h2><p>为什么 ref.current 拿到是上次的值？原因：</p>\n<ol>\n<li>useEffect 很重要的一点是：它是在每次渲染之后才会触发的，是延迟执行的。</li>\n<li>return 语句是同步的，所以 return 的时候，ref.current 还是旧值。</li>\n<li>以下代码的执行顺序是 1 3 2</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);<br><br>  <span class=\"hljs-keyword\">const</span> prevCountRef = useRef();<br><br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;1&quot;</span>, count);<br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;2.&quot;</span>, count);<br>    prevCountRef.current = count;<br>  &#125;);<br><br>  <span class=\"hljs-keyword\">const</span> prevCount = prevCountRef.current;<br><br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`3.之前的状态: <span class=\"hljs-subst\">$&#123;prevCount&#125;</span>;现在状态: <span class=\"hljs-subst\">$&#123;count&#125;</span>`</span>);<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span></span></span><br><span class=\"hljs-tag\"><span class=\"xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span><br><span class=\"xml\">          setCount(count + 1);</span><br><span class=\"xml\">        &#125;&#125;</span><br><span class=\"xml\">      &gt;</span><br><span class=\"xml\">        +</span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>抽取成自定义 Hook:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">usePrevious</span>(<span class=\"hljs-params\">value</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> ref = useRef();<br><br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    ref.current = value;<br>  &#125;, [value]);<br><br>  <span class=\"hljs-keyword\">return</span> ref.current;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"场景-3：解决-hooks-时，由于异步闭包无法获取最新-state-的问题\"><a href=\"#场景-3：解决-hooks-时，由于异步闭包无法获取最新-state-的问题\" class=\"headerlink\" title=\"场景 3：解决 hooks 时，由于异步闭包无法获取最新 state 的问题\"></a>场景 3：解决 hooks 时，由于异步闭包无法获取最新 state 的问题</h2><figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React, &#123; useState, useEffect, useRef &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> RefComponent = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-comment\">// 使用 useState 存放和改变展示的 number</span><br>  <span class=\"hljs-keyword\">const</span> [number, setNumber] = useState(<span class=\"hljs-number\">0</span>);<br>  <span class=\"hljs-comment\">// 使用 useRef 生成一个独立的 ref 对象</span><br>  <span class=\"hljs-comment\">// 在它的 current 属性单独存放一个展示的 number, 初始值为 0</span><br>  <span class=\"hljs-keyword\">const</span> numRef = useRef(<span class=\"hljs-number\">0</span>);<br><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">incrementAndDelayLogging</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-comment\">// 点击按钮 number + 1</span><br>    setNumber(number + <span class=\"hljs-number\">1</span>);<br>    <span class=\"hljs-comment\">// 同时 ref 对象的 current 属性值也 + 1</span><br>    numRef.current++;<br>    <span class=\"hljs-comment\">// 定时器函数中产生了闭包, 这里 number 的是组件更新前的 number 对象, 所以值一直会滞后 1</span><br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> alert(<span class=\"hljs-string\">`state: <span class=\"hljs-subst\">$&#123;number&#125;</span> | ref: <span class=\"hljs-subst\">$&#123;numRef.current&#125;</span>`</span>), <span class=\"hljs-number\">1000</span>);<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 直接渲染的组件是正常情况, 可以获取到最新的 state,</span><br>  <span class=\"hljs-comment\">// 所以 ref.current 和 state 存储的值显示一致</span><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>solving closure by useRef<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;incrementAndDelayLogging&#125;</span>&gt;</span>alert in setTimeout<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h4</span>&gt;</span>state: &#123;number&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h4</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h4</span>&gt;</span>ref: &#123;numRef.current&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h4</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n","site":{"data":{}},"wordcount":2905,"excerpt":"","more":"<h1 id=\"使用-useRef-跨生命周期保存变量\"><a href=\"#使用-useRef-跨生命周期保存变量\" class=\"headerlink\" title=\"使用 useRef 跨生命周期保存变量\"></a>使用 useRef 跨生命周期保存变量</h1><p>ref 这一种访问 DOM 的主要方式。然而，useRef() 比 ref 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式.</p>\n<p>当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。</p>\n<h2 id=\"场景-1：只在更新时运行-useEffect\"><a href=\"#场景-1：只在更新时运行-useEffect\" class=\"headerlink\" title=\"场景 1：只在更新时运行 useEffect\"></a>场景 1：只在更新时运行 useEffect</h2><p>使用一个可变的 ref 手动存储一个布尔值来表示是首次渲染还是后续渲染.</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);<br><br>  <span class=\"hljs-keyword\">const</span> prevCountRef = useRef(<span class=\"hljs-literal\">false</span>);<br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (prevCountRef.current) &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;只在更新时候执行&quot;</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;首次渲染执行&quot;</span>);<br>      prevCountRef.current = <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>  &#125;);<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span></span></span><br><span class=\"hljs-tag\"><span class=\"xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span><br><span class=\"xml\">          setCount(count + 1);</span><br><span class=\"xml\">        &#125;&#125;</span><br><span class=\"xml\">      &gt;</span><br><span class=\"xml\">        +</span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>抽成自定义 hook：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);<br><br>  <span class=\"hljs-keyword\">const</span> update = useUpdate();<br>  <span class=\"hljs-built_in\">console</span>.log(update, <span class=\"hljs-string\">&quot;是否更新&quot;</span>);<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span></span></span><br><span class=\"hljs-tag\"><span class=\"xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span><br><span class=\"xml\">          setCount(count + 1);</span><br><span class=\"xml\">        &#125;&#125;</span><br><span class=\"xml\">      &gt;</span><br><span class=\"xml\">        +</span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useUpdate</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> ref = useRef(<span class=\"hljs-literal\">false</span>);<br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    ref.current = <span class=\"hljs-literal\">true</span>;<br>  &#125;);<br>  <span class=\"hljs-keyword\">return</span> ref.current;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"场景-2：获取上一轮的-props-或-state\"><a href=\"#场景-2：获取上一轮的-props-或-state\" class=\"headerlink\" title=\"场景 2：获取上一轮的 props 或 state\"></a>场景 2：获取上一轮的 props 或 state</h2><p>为什么 ref.current 拿到是上次的值？原因：</p>\n<ol>\n<li>useEffect 很重要的一点是：它是在每次渲染之后才会触发的，是延迟执行的。</li>\n<li>return 语句是同步的，所以 return 的时候，ref.current 还是旧值。</li>\n<li>以下代码的执行顺序是 1 3 2</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);<br><br>  <span class=\"hljs-keyword\">const</span> prevCountRef = useRef();<br><br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;1&quot;</span>, count);<br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;2.&quot;</span>, count);<br>    prevCountRef.current = count;<br>  &#125;);<br><br>  <span class=\"hljs-keyword\">const</span> prevCount = prevCountRef.current;<br><br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`3.之前的状态: <span class=\"hljs-subst\">$&#123;prevCount&#125;</span>;现在状态: <span class=\"hljs-subst\">$&#123;count&#125;</span>`</span>);<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span></span></span><br><span class=\"hljs-tag\"><span class=\"xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span><br><span class=\"xml\">          setCount(count + 1);</span><br><span class=\"xml\">        &#125;&#125;</span><br><span class=\"xml\">      &gt;</span><br><span class=\"xml\">        +</span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>抽取成自定义 Hook:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">usePrevious</span>(<span class=\"hljs-params\">value</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> ref = useRef();<br><br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    ref.current = value;<br>  &#125;, [value]);<br><br>  <span class=\"hljs-keyword\">return</span> ref.current;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"场景-3：解决-hooks-时，由于异步闭包无法获取最新-state-的问题\"><a href=\"#场景-3：解决-hooks-时，由于异步闭包无法获取最新-state-的问题\" class=\"headerlink\" title=\"场景 3：解决 hooks 时，由于异步闭包无法获取最新 state 的问题\"></a>场景 3：解决 hooks 时，由于异步闭包无法获取最新 state 的问题</h2><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React, &#123; useState, useEffect, useRef &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> RefComponent = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-comment\">// 使用 useState 存放和改变展示的 number</span><br>  <span class=\"hljs-keyword\">const</span> [number, setNumber] = useState(<span class=\"hljs-number\">0</span>);<br>  <span class=\"hljs-comment\">// 使用 useRef 生成一个独立的 ref 对象</span><br>  <span class=\"hljs-comment\">// 在它的 current 属性单独存放一个展示的 number, 初始值为 0</span><br>  <span class=\"hljs-keyword\">const</span> numRef = useRef(<span class=\"hljs-number\">0</span>);<br><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">incrementAndDelayLogging</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-comment\">// 点击按钮 number + 1</span><br>    setNumber(number + <span class=\"hljs-number\">1</span>);<br>    <span class=\"hljs-comment\">// 同时 ref 对象的 current 属性值也 + 1</span><br>    numRef.current++;<br>    <span class=\"hljs-comment\">// 定时器函数中产生了闭包, 这里 number 的是组件更新前的 number 对象, 所以值一直会滞后 1</span><br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> alert(<span class=\"hljs-string\">`state: <span class=\"hljs-subst\">$&#123;number&#125;</span> | ref: <span class=\"hljs-subst\">$&#123;numRef.current&#125;</span>`</span>), <span class=\"hljs-number\">1000</span>);<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 直接渲染的组件是正常情况, 可以获取到最新的 state,</span><br>  <span class=\"hljs-comment\">// 所以 ref.current 和 state 存储的值显示一致</span><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>solving closure by useRef<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;incrementAndDelayLogging&#125;</span>&gt;</span>alert in setTimeout<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h4</span>&gt;</span>state: &#123;number&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h4</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h4</span>&gt;</span>ref: &#123;numRef.current&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h4</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>\n"},{"title":"map 到底改不改变原数组","index_img":"/img/2022-01-14-3.png","date":"2022-01-14T05:53:44.000Z","_content":"\n# map 到底改不改变原数组\n\n一般认为 map 不会对原数组进行修改，但事实并不是如此。\n\n## 数组内为基础类型数据时,原数组不变\n\n```js\nlet array = [1, 2, 3, 4, 5];\nlet newArray = array.map((item) => item * 2);\nconsole.log(array); // [1,2,3,4,5]\nconsole.log(newArray); //[2, 4, 6, 8, 10]\n```\n\n## 数据内是引用类型数据时，注意写法\n\n1. item 上直接修改，改变原数组\n\n   ```js\n   let array = [\n     { name: \"Anna\", age: 16 },\n     { name: \"James\", age: 18 }\n   ];\n   let newArray = array.map((item) => {\n     item.like = \"eat\";\n     return item;\n   });\n   console.log(array); // [{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}]\n   console.log(newArray); //[{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}]\n   ```\n\n1. 开辟新的引用地址, 不改变原数组\n\n   ```js\n   let array = [\n     { name: \"Anna\", age: 16 },\n     { name: \"James\", age: 18 }\n   ];\n   let newArray = array.map((item) => {\n     const obj = { ...item, like: \"eat\" };\n     return obj;\n   });\n   console.log(array); // [{ name: 'Anna', age: 16},{ name: 'James', age: 18}]\n   console.log(newArray); //[{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}]\n   ```\n","source":"_posts/2022-01-14-3.md","raw":"---\ntitle: map 到底改不改变原数组\nindex_img: /img/2022-01-14-3.png\ndate: 2022-01-14 13:53:44\ntags: map\ncategories: JS\n---\n\n# map 到底改不改变原数组\n\n一般认为 map 不会对原数组进行修改，但事实并不是如此。\n\n## 数组内为基础类型数据时,原数组不变\n\n```js\nlet array = [1, 2, 3, 4, 5];\nlet newArray = array.map((item) => item * 2);\nconsole.log(array); // [1,2,3,4,5]\nconsole.log(newArray); //[2, 4, 6, 8, 10]\n```\n\n## 数据内是引用类型数据时，注意写法\n\n1. item 上直接修改，改变原数组\n\n   ```js\n   let array = [\n     { name: \"Anna\", age: 16 },\n     { name: \"James\", age: 18 }\n   ];\n   let newArray = array.map((item) => {\n     item.like = \"eat\";\n     return item;\n   });\n   console.log(array); // [{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}]\n   console.log(newArray); //[{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}]\n   ```\n\n1. 开辟新的引用地址, 不改变原数组\n\n   ```js\n   let array = [\n     { name: \"Anna\", age: 16 },\n     { name: \"James\", age: 18 }\n   ];\n   let newArray = array.map((item) => {\n     const obj = { ...item, like: \"eat\" };\n     return obj;\n   });\n   console.log(array); // [{ name: 'Anna', age: 16},{ name: 'James', age: 18}]\n   console.log(newArray); //[{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}]\n   ```\n","slug":"3","published":1,"updated":"2022-02-28T02:43:30.199Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl06jlx38000tl03leslh4jbo","content":"<h1 id=\"map-到底改不改变原数组\"><a href=\"#map-到底改不改变原数组\" class=\"headerlink\" title=\"map 到底改不改变原数组\"></a>map 到底改不改变原数组</h1><p>一般认为 map 不会对原数组进行修改，但事实并不是如此。</p>\n<h2 id=\"数组内为基础类型数据时-原数组不变\"><a href=\"#数组内为基础类型数据时-原数组不变\" class=\"headerlink\" title=\"数组内为基础类型数据时,原数组不变\"></a>数组内为基础类型数据时,原数组不变</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> array = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];<br><span class=\"hljs-keyword\">let</span> newArray = array.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> item * <span class=\"hljs-number\">2</span>);<br><span class=\"hljs-built_in\">console</span>.log(array); <span class=\"hljs-comment\">// [1,2,3,4,5]</span><br><span class=\"hljs-built_in\">console</span>.log(newArray); <span class=\"hljs-comment\">//[2, 4, 6, 8, 10]</span><br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"数据内是引用类型数据时，注意写法\"><a href=\"#数据内是引用类型数据时，注意写法\" class=\"headerlink\" title=\"数据内是引用类型数据时，注意写法\"></a>数据内是引用类型数据时，注意写法</h2><ol>\n<li><p>item 上直接修改，改变原数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> array = [<br>  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Anna&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">16</span> &#125;,<br>  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;James&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span> &#125;<br>];<br><span class=\"hljs-keyword\">let</span> newArray = array.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> &#123;<br>  item.like = <span class=\"hljs-string\">&quot;eat&quot;</span>;<br>  <span class=\"hljs-keyword\">return</span> item;<br>&#125;);<br><span class=\"hljs-built_in\">console</span>.log(array); <span class=\"hljs-comment\">// [&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span><br><span class=\"hljs-built_in\">console</span>.log(newArray); <span class=\"hljs-comment\">//[&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span><br></code></pre></div></td></tr></table></figure></li>\n<li><p>开辟新的引用地址, 不改变原数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> array = [<br>  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Anna&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">16</span> &#125;,<br>  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;James&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span> &#125;<br>];<br><span class=\"hljs-keyword\">let</span> newArray = array.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> obj = &#123; ...item, <span class=\"hljs-attr\">like</span>: <span class=\"hljs-string\">&quot;eat&quot;</span> &#125;;<br>  <span class=\"hljs-keyword\">return</span> obj;<br>&#125;);<br><span class=\"hljs-built_in\">console</span>.log(array); <span class=\"hljs-comment\">// [&#123; name: &#x27;Anna&#x27;, age: 16&#125;,&#123; name: &#x27;James&#x27;, age: 18&#125;]</span><br><span class=\"hljs-built_in\">console</span>.log(newArray); <span class=\"hljs-comment\">//[&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span><br></code></pre></div></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"wordcount":1189,"excerpt":"","more":"<h1 id=\"map-到底改不改变原数组\"><a href=\"#map-到底改不改变原数组\" class=\"headerlink\" title=\"map 到底改不改变原数组\"></a>map 到底改不改变原数组</h1><p>一般认为 map 不会对原数组进行修改，但事实并不是如此。</p>\n<h2 id=\"数组内为基础类型数据时-原数组不变\"><a href=\"#数组内为基础类型数据时-原数组不变\" class=\"headerlink\" title=\"数组内为基础类型数据时,原数组不变\"></a>数组内为基础类型数据时,原数组不变</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> array = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];<br><span class=\"hljs-keyword\">let</span> newArray = array.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> item * <span class=\"hljs-number\">2</span>);<br><span class=\"hljs-built_in\">console</span>.log(array); <span class=\"hljs-comment\">// [1,2,3,4,5]</span><br><span class=\"hljs-built_in\">console</span>.log(newArray); <span class=\"hljs-comment\">//[2, 4, 6, 8, 10]</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"数据内是引用类型数据时，注意写法\"><a href=\"#数据内是引用类型数据时，注意写法\" class=\"headerlink\" title=\"数据内是引用类型数据时，注意写法\"></a>数据内是引用类型数据时，注意写法</h2><ol>\n<li><p>item 上直接修改，改变原数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> array = [<br>  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Anna&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">16</span> &#125;,<br>  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;James&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span> &#125;<br>];<br><span class=\"hljs-keyword\">let</span> newArray = array.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> &#123;<br>  item.like = <span class=\"hljs-string\">&quot;eat&quot;</span>;<br>  <span class=\"hljs-keyword\">return</span> item;<br>&#125;);<br><span class=\"hljs-built_in\">console</span>.log(array); <span class=\"hljs-comment\">// [&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span><br><span class=\"hljs-built_in\">console</span>.log(newArray); <span class=\"hljs-comment\">//[&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span><br></code></pre></td></tr></table></figure></li>\n<li><p>开辟新的引用地址, 不改变原数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> array = [<br>  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Anna&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">16</span> &#125;,<br>  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;James&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span> &#125;<br>];<br><span class=\"hljs-keyword\">let</span> newArray = array.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> obj = &#123; ...item, <span class=\"hljs-attr\">like</span>: <span class=\"hljs-string\">&quot;eat&quot;</span> &#125;;<br>  <span class=\"hljs-keyword\">return</span> obj;<br>&#125;);<br><span class=\"hljs-built_in\">console</span>.log(array); <span class=\"hljs-comment\">// [&#123; name: &#x27;Anna&#x27;, age: 16&#125;,&#123; name: &#x27;James&#x27;, age: 18&#125;]</span><br><span class=\"hljs-built_in\">console</span>.log(newArray); <span class=\"hljs-comment\">//[&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"Vue3 学习笔记","index_img":"/img/2022-01-22-1.jpeg","date":"2022-01-22T02:46:00.000Z","_content":"\n# Vue3 学习笔记\n\n## Vue 和 React 数据驱动原理对比\n\nVue1 解决方案是使用响应式，初始化的时候，watcher 监听数据的每个属性，数据发生变化的时候，就能够知道数据的哪个 key 变了，去修改对应的 DOM。\n\nReact 是虚拟 DOM 方案，用 JS 对象描述 DOM 树，这个对象就像数据和实际 DOM 的一个缓存层，通过管理这个对象的变化，来减少对实际 DOM 的操作。\n\n描述实际 DOM 的虚拟 DOM 对象如下：\n\nDOM:\n\n```html\n<div id=\"app\">\n  <p class=\"item\">Item1</p>\n  <div class=\"item\">Item2</div>\n</div>\n```\n\n虚拟 DOM：\n\n```js\n\n{\n  tag: \"div\",\n  attrs: {\n    id: \"app\"\n  },\n  children: [\n    {\n      tag: \"p\",\n      attrs: { className: \"item\" },\n      children: [\"Item1\"]\n    },\n    {\n      tag: \"div\",\n      attrs: { className: \"item\" },\n      children: [\"Item2\"]\n    }\n  ]\n}\n```\n\n数据变化的时候生成一个新的虚拟 DOM 数据，对比之前的虚拟 DOM 进行 diff 计算，算出要修改的 DOM，再对页面进行操作。\n\n通知页面更新的方式不同：\n\n- vue 中，数据变化，框架主动告诉你修改了哪些数据；\n- react 中，变化变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化\n\n性能问题：\n\n- vue 的响应式，在项目大了之后，每个数据都有一个 watcher 会影响性能\n- 如果 react 虚拟 dom 过于庞大，使得 diff 计算时间大于 16.6 ms(屏幕刷新率 60HZ, 1/60)，可能造成性能卡顿。\n\n为了解决性能问题， Vue 和 react 走了不同的道路。\n\n- react 借鉴操作系统时间分片概念，引入 Fiber 架构。把整个虚拟 DOM 树 微观化，变成链表，然后利用浏览器的空闲时间计算 diff。\n- vue1 的问题在于响应式数据过多，会带来内存占用过多的问题。vue2 引入虚拟 DOM 来解决响应式数据过多问题。\n\n响应式数据是主动推送变化，虚拟 DOM 是被动计算数据的 diff。vue2 将两者结合在一起，在组件级别来划分。\n\n组件间的变化，通过响应式来通知更新。组件内部的数据变化，通过虚拟 DOM 去更新页面。最终，把响应式监听器控制在组件级别，而虚拟 DOM 的量级控制在组件的大小。\n\n在模板书写上，vue 和 react 分别走了 template 和 jsx 两个路线。\n\n- react 世界只有 jsx，最终 jsx 都会在 Compiler 那层，即工程化那里编译成 js 来执行。\n- vue 默认 template。vue3 优秀的其中一点是在虚拟 DOM 的静态标记上做到了极致，让静态的部分越过虚拟 DOM 的计算，真正做到按需更新，很好的提高了性能。\n\n## Vue3 的新特性\n\n### 响应式系统\n\nVue 2 的响应式机制是基于 Object.defineProperty() 这个 API 实现的.Vue3 是基于 proxy。两者区别是 defineProperty 是拦截具体某个属性， Proxy 是全部拦截，是代理。\n\ndefineProperty 示例如下：\n\n```js\nObject.defineProperty(obj, \"title\", {\n  get() {},\n  set() {}\n});\n```\n\n当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。\n\n但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的 $set。\n\nProxy API 是真正的代理，示例如下：\n\n```js\nnew Proxy(obj, {\n  get() {},\n  set() {}\n});\n```\n\nProxy 拦截 obj 这个数据，不关心 obj 里面属性，统一拦截。\n\n### 自定义渲染器\n\nvue2 内部所有模块是揉在一起，导致不好扩展。vue3 采用 monorepo 方式进行拆包，响应式、编译和运行时全部独立。独立出来的响应式，甚至可以在 react、node 中使用。\n\n![vue 架构](/img/2022-01-24-1.png)\n\n渲染逻辑拆成 **平台无关渲染逻辑** 和 **浏览器渲染 API**。\n\n### 全部模块使用 TS 重构\n\nVue2 使用 Flow.js 做类型检测；Flow.js 已被抛弃，vue3 选择 TS。\n\n### Composition API 组合语法\n\nvue2 中示例：\n\n```js\nlet App = {\n  data() {\n    return { count: 1 };\n  },\n  methods: {\n    add() {\n      this.count++;\n    }\n  },\n  computed: {\n    double() {\n      return this.count * 2;\n    }\n  }\n};\n```\n\nvue2 中 Options API 存在以下问题：\n\n- 所有数据都挂载在 this 上，Options API 写法对 TS 类型推导不友好。\n- 新增的功能基本都要修改 data、method 等，代码行数多了以后，会经常需要上下反复横跳。\n- 代码不好复用，vue2 的组件很难抽离通用逻辑，只能使用 mixin，还会导致命名冲突问题。\n\nvue3 中采用新增的 setup 写法：\n\n```js\nconst { reactive, computed } = Vue;\nlet App = {\n  setup() {\n    const state = reactive({ count: 1 });\n    function add() {\n      state.count++;\n    }\n    const double = computed(() => state.count * 2);\n    return { state, add, double };\n  }\n};\n```\n\nComposition API 好处如下：\n\n- 所有 API 都是 import 引入。对 Tree-shaking 很友好，没用到功能，打包的时候会被清理掉 ，减小包的大小\n- 一个功能模块的 methods、data 放一起书写，避免上下反复横跳。\n- 代码复用方便，一个功能的所有 methods、data 封装在一个独立的函数里。\n- Composotion API 新增的 return 等语句，在实际项目中使用。\n\n![Composition API](/img/2022-01-24-2.png)\n\n### 新的组件\n\nVue 3 还内置了 Fragment、Teleport 和 Suspense 三个新组件。\n\n- Fragment: Vue 3 组件不再要求有一个唯一的根节点，清除了很多无用的占位 div。\n- Teleport: 允许组件渲染在别的元素内，主要开发弹窗组件的时候特别有用。\n- Suspense: 异步组件，更方便开发有异步请求的组件。\n\n### 新一代工程化工具 Vite\n\nwebpack 工程化的原理是 根据 import 依赖逻辑形成一个依赖图，然后调用对应的处理工具，把整个项目打包后，放在内存中再启动调试。因为要预打包，复杂项目开发时，启动开发环境和热更新时间都比较长，Vite 就是为了解决这个问题而出现的。\n\n现代浏览器已经默认支持 ES6 的 import 语法，Vite 就是基于这个原理实现的。\n\n在开发环境下，不需要全部预打包，只要把首页依赖的文件，依次通过网络请求去获取，开发体验得到巨大提升，做到复杂项目时，也能做到秒级调试和热更新。\n\nwebpack 工作原理如下，需要把所有路由依赖打包后，才能开始调试。\n\n![webpack 工作原理](/img/2022-01-24-3.png)\n\nVite 工作原理，根据首页的依赖模块，再去获取路由 1 的模块，按需加载。\n\n![Vite 工作原理](/img/2022-01-24-4.png)\n\n## Vue3 响应式机制\n\n响应式原理：Vue 中用过三种响应式解决方案，分别是 defineProperty、Proxy 和 value setter。\n\n---\n\ntodo: 07\n\n## Vue3 实践常见问题汇总\n\n1. vetur 报错， xx has no export.\n\n   使用 Vue3 `script setup` 语法糖时,VsCode 插件 Vetur 会报该错误，原因是 Vetur(v0.35.0) 暂不支持 ts。\n\n   解决办法： 卸载 Vetur， 用 Volar(尤大推荐) 以取代 Vetur。\n\n---\n\n上述笔记源于学习极客时间-大圣的 [玩转 Vue3 全家桶](http://gk.link/a/115Qp) 课程笔记整理。\n\n---\n","source":"_posts/2022-01-22-1.md","raw":"---\ntitle: Vue3 学习笔记\nindex_img: /img/2022-01-22-1.jpeg\ndate: 2022-01-22 10:46:00\ntags: Vue3\ncategories: Vue\n---\n\n# Vue3 学习笔记\n\n## Vue 和 React 数据驱动原理对比\n\nVue1 解决方案是使用响应式，初始化的时候，watcher 监听数据的每个属性，数据发生变化的时候，就能够知道数据的哪个 key 变了，去修改对应的 DOM。\n\nReact 是虚拟 DOM 方案，用 JS 对象描述 DOM 树，这个对象就像数据和实际 DOM 的一个缓存层，通过管理这个对象的变化，来减少对实际 DOM 的操作。\n\n描述实际 DOM 的虚拟 DOM 对象如下：\n\nDOM:\n\n```html\n<div id=\"app\">\n  <p class=\"item\">Item1</p>\n  <div class=\"item\">Item2</div>\n</div>\n```\n\n虚拟 DOM：\n\n```js\n\n{\n  tag: \"div\",\n  attrs: {\n    id: \"app\"\n  },\n  children: [\n    {\n      tag: \"p\",\n      attrs: { className: \"item\" },\n      children: [\"Item1\"]\n    },\n    {\n      tag: \"div\",\n      attrs: { className: \"item\" },\n      children: [\"Item2\"]\n    }\n  ]\n}\n```\n\n数据变化的时候生成一个新的虚拟 DOM 数据，对比之前的虚拟 DOM 进行 diff 计算，算出要修改的 DOM，再对页面进行操作。\n\n通知页面更新的方式不同：\n\n- vue 中，数据变化，框架主动告诉你修改了哪些数据；\n- react 中，变化变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化\n\n性能问题：\n\n- vue 的响应式，在项目大了之后，每个数据都有一个 watcher 会影响性能\n- 如果 react 虚拟 dom 过于庞大，使得 diff 计算时间大于 16.6 ms(屏幕刷新率 60HZ, 1/60)，可能造成性能卡顿。\n\n为了解决性能问题， Vue 和 react 走了不同的道路。\n\n- react 借鉴操作系统时间分片概念，引入 Fiber 架构。把整个虚拟 DOM 树 微观化，变成链表，然后利用浏览器的空闲时间计算 diff。\n- vue1 的问题在于响应式数据过多，会带来内存占用过多的问题。vue2 引入虚拟 DOM 来解决响应式数据过多问题。\n\n响应式数据是主动推送变化，虚拟 DOM 是被动计算数据的 diff。vue2 将两者结合在一起，在组件级别来划分。\n\n组件间的变化，通过响应式来通知更新。组件内部的数据变化，通过虚拟 DOM 去更新页面。最终，把响应式监听器控制在组件级别，而虚拟 DOM 的量级控制在组件的大小。\n\n在模板书写上，vue 和 react 分别走了 template 和 jsx 两个路线。\n\n- react 世界只有 jsx，最终 jsx 都会在 Compiler 那层，即工程化那里编译成 js 来执行。\n- vue 默认 template。vue3 优秀的其中一点是在虚拟 DOM 的静态标记上做到了极致，让静态的部分越过虚拟 DOM 的计算，真正做到按需更新，很好的提高了性能。\n\n## Vue3 的新特性\n\n### 响应式系统\n\nVue 2 的响应式机制是基于 Object.defineProperty() 这个 API 实现的.Vue3 是基于 proxy。两者区别是 defineProperty 是拦截具体某个属性， Proxy 是全部拦截，是代理。\n\ndefineProperty 示例如下：\n\n```js\nObject.defineProperty(obj, \"title\", {\n  get() {},\n  set() {}\n});\n```\n\n当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。\n\n但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的 $set。\n\nProxy API 是真正的代理，示例如下：\n\n```js\nnew Proxy(obj, {\n  get() {},\n  set() {}\n});\n```\n\nProxy 拦截 obj 这个数据，不关心 obj 里面属性，统一拦截。\n\n### 自定义渲染器\n\nvue2 内部所有模块是揉在一起，导致不好扩展。vue3 采用 monorepo 方式进行拆包，响应式、编译和运行时全部独立。独立出来的响应式，甚至可以在 react、node 中使用。\n\n![vue 架构](/img/2022-01-24-1.png)\n\n渲染逻辑拆成 **平台无关渲染逻辑** 和 **浏览器渲染 API**。\n\n### 全部模块使用 TS 重构\n\nVue2 使用 Flow.js 做类型检测；Flow.js 已被抛弃，vue3 选择 TS。\n\n### Composition API 组合语法\n\nvue2 中示例：\n\n```js\nlet App = {\n  data() {\n    return { count: 1 };\n  },\n  methods: {\n    add() {\n      this.count++;\n    }\n  },\n  computed: {\n    double() {\n      return this.count * 2;\n    }\n  }\n};\n```\n\nvue2 中 Options API 存在以下问题：\n\n- 所有数据都挂载在 this 上，Options API 写法对 TS 类型推导不友好。\n- 新增的功能基本都要修改 data、method 等，代码行数多了以后，会经常需要上下反复横跳。\n- 代码不好复用，vue2 的组件很难抽离通用逻辑，只能使用 mixin，还会导致命名冲突问题。\n\nvue3 中采用新增的 setup 写法：\n\n```js\nconst { reactive, computed } = Vue;\nlet App = {\n  setup() {\n    const state = reactive({ count: 1 });\n    function add() {\n      state.count++;\n    }\n    const double = computed(() => state.count * 2);\n    return { state, add, double };\n  }\n};\n```\n\nComposition API 好处如下：\n\n- 所有 API 都是 import 引入。对 Tree-shaking 很友好，没用到功能，打包的时候会被清理掉 ，减小包的大小\n- 一个功能模块的 methods、data 放一起书写，避免上下反复横跳。\n- 代码复用方便，一个功能的所有 methods、data 封装在一个独立的函数里。\n- Composotion API 新增的 return 等语句，在实际项目中使用。\n\n![Composition API](/img/2022-01-24-2.png)\n\n### 新的组件\n\nVue 3 还内置了 Fragment、Teleport 和 Suspense 三个新组件。\n\n- Fragment: Vue 3 组件不再要求有一个唯一的根节点，清除了很多无用的占位 div。\n- Teleport: 允许组件渲染在别的元素内，主要开发弹窗组件的时候特别有用。\n- Suspense: 异步组件，更方便开发有异步请求的组件。\n\n### 新一代工程化工具 Vite\n\nwebpack 工程化的原理是 根据 import 依赖逻辑形成一个依赖图，然后调用对应的处理工具，把整个项目打包后，放在内存中再启动调试。因为要预打包，复杂项目开发时，启动开发环境和热更新时间都比较长，Vite 就是为了解决这个问题而出现的。\n\n现代浏览器已经默认支持 ES6 的 import 语法，Vite 就是基于这个原理实现的。\n\n在开发环境下，不需要全部预打包，只要把首页依赖的文件，依次通过网络请求去获取，开发体验得到巨大提升，做到复杂项目时，也能做到秒级调试和热更新。\n\nwebpack 工作原理如下，需要把所有路由依赖打包后，才能开始调试。\n\n![webpack 工作原理](/img/2022-01-24-3.png)\n\nVite 工作原理，根据首页的依赖模块，再去获取路由 1 的模块，按需加载。\n\n![Vite 工作原理](/img/2022-01-24-4.png)\n\n## Vue3 响应式机制\n\n响应式原理：Vue 中用过三种响应式解决方案，分别是 defineProperty、Proxy 和 value setter。\n\n---\n\ntodo: 07\n\n## Vue3 实践常见问题汇总\n\n1. vetur 报错， xx has no export.\n\n   使用 Vue3 `script setup` 语法糖时,VsCode 插件 Vetur 会报该错误，原因是 Vetur(v0.35.0) 暂不支持 ts。\n\n   解决办法： 卸载 Vetur， 用 Volar(尤大推荐) 以取代 Vetur。\n\n---\n\n上述笔记源于学习极客时间-大圣的 [玩转 Vue3 全家桶](http://gk.link/a/115Qp) 课程笔记整理。\n\n---\n","slug":"1","published":1,"updated":"2022-02-28T02:47:44.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl06jlx39000wl03lfrm2drg4","content":"<h1 id=\"Vue3-学习笔记\"><a href=\"#Vue3-学习笔记\" class=\"headerlink\" title=\"Vue3 学习笔记\"></a>Vue3 学习笔记</h1><h2 id=\"Vue-和-React-数据驱动原理对比\"><a href=\"#Vue-和-React-数据驱动原理对比\" class=\"headerlink\" title=\"Vue 和 React 数据驱动原理对比\"></a>Vue 和 React 数据驱动原理对比</h2><p>Vue1 解决方案是使用响应式，初始化的时候，watcher 监听数据的每个属性，数据发生变化的时候，就能够知道数据的哪个 key 变了，去修改对应的 DOM。</p>\n<p>React 是虚拟 DOM 方案，用 JS 对象描述 DOM 树，这个对象就像数据和实际 DOM 的一个缓存层，通过管理这个对象的变化，来减少对实际 DOM 的操作。</p>\n<p>描述实际 DOM 的虚拟 DOM 对象如下：</p>\n<p>DOM:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>Item1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>Item2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>\n\n<p>虚拟 DOM：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><br>&#123;<br>  <span class=\"hljs-attr\">tag</span>: <span class=\"hljs-string\">&quot;div&quot;</span>,<br>  <span class=\"hljs-attr\">attrs</span>: &#123;<br>    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">&quot;app&quot;</span><br>  &#125;,<br>  <span class=\"hljs-attr\">children</span>: [<br>    &#123;<br>      <span class=\"hljs-attr\">tag</span>: <span class=\"hljs-string\">&quot;p&quot;</span>,<br>      <span class=\"hljs-attr\">attrs</span>: &#123; <span class=\"hljs-attr\">className</span>: <span class=\"hljs-string\">&quot;item&quot;</span> &#125;,<br>      <span class=\"hljs-attr\">children</span>: [<span class=\"hljs-string\">&quot;Item1&quot;</span>]<br>    &#125;,<br>    &#123;<br>      <span class=\"hljs-attr\">tag</span>: <span class=\"hljs-string\">&quot;div&quot;</span>,<br>      <span class=\"hljs-attr\">attrs</span>: &#123; <span class=\"hljs-attr\">className</span>: <span class=\"hljs-string\">&quot;item&quot;</span> &#125;,<br>      <span class=\"hljs-attr\">children</span>: [<span class=\"hljs-string\">&quot;Item2&quot;</span>]<br>    &#125;<br>  ]<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>数据变化的时候生成一个新的虚拟 DOM 数据，对比之前的虚拟 DOM 进行 diff 计算，算出要修改的 DOM，再对页面进行操作。</p>\n<p>通知页面更新的方式不同：</p>\n<ul>\n<li>vue 中，数据变化，框架主动告诉你修改了哪些数据；</li>\n<li>react 中，变化变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化</li>\n</ul>\n<p>性能问题：</p>\n<ul>\n<li>vue 的响应式，在项目大了之后，每个数据都有一个 watcher 会影响性能</li>\n<li>如果 react 虚拟 dom 过于庞大，使得 diff 计算时间大于 16.6 ms(屏幕刷新率 60HZ, 1/60)，可能造成性能卡顿。</li>\n</ul>\n<p>为了解决性能问题， Vue 和 react 走了不同的道路。</p>\n<ul>\n<li>react 借鉴操作系统时间分片概念，引入 Fiber 架构。把整个虚拟 DOM 树 微观化，变成链表，然后利用浏览器的空闲时间计算 diff。</li>\n<li>vue1 的问题在于响应式数据过多，会带来内存占用过多的问题。vue2 引入虚拟 DOM 来解决响应式数据过多问题。</li>\n</ul>\n<p>响应式数据是主动推送变化，虚拟 DOM 是被动计算数据的 diff。vue2 将两者结合在一起，在组件级别来划分。</p>\n<p>组件间的变化，通过响应式来通知更新。组件内部的数据变化，通过虚拟 DOM 去更新页面。最终，把响应式监听器控制在组件级别，而虚拟 DOM 的量级控制在组件的大小。</p>\n<p>在模板书写上，vue 和 react 分别走了 template 和 jsx 两个路线。</p>\n<ul>\n<li>react 世界只有 jsx，最终 jsx 都会在 Compiler 那层，即工程化那里编译成 js 来执行。</li>\n<li>vue 默认 template。vue3 优秀的其中一点是在虚拟 DOM 的静态标记上做到了极致，让静态的部分越过虚拟 DOM 的计算，真正做到按需更新，很好的提高了性能。</li>\n</ul>\n<h2 id=\"Vue3-的新特性\"><a href=\"#Vue3-的新特性\" class=\"headerlink\" title=\"Vue3 的新特性\"></a>Vue3 的新特性</h2><h3 id=\"响应式系统\"><a href=\"#响应式系统\" class=\"headerlink\" title=\"响应式系统\"></a>响应式系统</h3><p>Vue 2 的响应式机制是基于 Object.defineProperty() 这个 API 实现的.Vue3 是基于 proxy。两者区别是 defineProperty 是拦截具体某个属性， Proxy 是全部拦截，是代理。</p>\n<p>defineProperty 示例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">Object</span>.defineProperty(obj, <span class=\"hljs-string\">&quot;title&quot;</span>, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;,<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">set</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure>\n\n<p>当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。</p>\n<p>但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的 $set。</p>\n<p>Proxy API 是真正的代理，示例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>(obj, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;,<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">set</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure>\n\n<p>Proxy 拦截 obj 这个数据，不关心 obj 里面属性，统一拦截。</p>\n<h3 id=\"自定义渲染器\"><a href=\"#自定义渲染器\" class=\"headerlink\" title=\"自定义渲染器\"></a>自定义渲染器</h3><p>vue2 内部所有模块是揉在一起，导致不好扩展。vue3 采用 monorepo 方式进行拆包，响应式、编译和运行时全部独立。独立出来的响应式，甚至可以在 react、node 中使用。</p>\n<p><img src=\"/img/2022-01-24-1.png\" alt=\"vue 架构\"></p>\n<p>渲染逻辑拆成 <strong>平台无关渲染逻辑</strong> 和 <strong>浏览器渲染 API</strong>。</p>\n<h3 id=\"全部模块使用-TS-重构\"><a href=\"#全部模块使用-TS-重构\" class=\"headerlink\" title=\"全部模块使用 TS 重构\"></a>全部模块使用 TS 重构</h3><p>Vue2 使用 Flow.js 做类型检测；Flow.js 已被抛弃，vue3 选择 TS。</p>\n<h3 id=\"Composition-API-组合语法\"><a href=\"#Composition-API-组合语法\" class=\"headerlink\" title=\"Composition API 组合语法\"></a>Composition API 组合语法</h3><p>vue2 中示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> App = &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">1</span> &#125;;<br>  &#125;,<br>  <span class=\"hljs-attr\">methods</span>: &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">add</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>      <span class=\"hljs-built_in\">this</span>.count++;<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">computed</span>: &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">double</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.count * <span class=\"hljs-number\">2</span>;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n\n<p>vue2 中 Options API 存在以下问题：</p>\n<ul>\n<li>所有数据都挂载在 this 上，Options API 写法对 TS 类型推导不友好。</li>\n<li>新增的功能基本都要修改 data、method 等，代码行数多了以后，会经常需要上下反复横跳。</li>\n<li>代码不好复用，vue2 的组件很难抽离通用逻辑，只能使用 mixin，还会导致命名冲突问题。</li>\n</ul>\n<p>vue3 中采用新增的 setup 写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> &#123; reactive, computed &#125; = Vue;<br><span class=\"hljs-keyword\">let</span> App = &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">setup</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> state = reactive(&#123; <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">1</span> &#125;);<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>      state.count++;<br>    &#125;<br>    <span class=\"hljs-keyword\">const</span> double = computed(<span class=\"hljs-function\">() =&gt;</span> state.count * <span class=\"hljs-number\">2</span>);<br>    <span class=\"hljs-keyword\">return</span> &#123; state, add, double &#125;;<br>  &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n\n<p>Composition API 好处如下：</p>\n<ul>\n<li>所有 API 都是 import 引入。对 Tree-shaking 很友好，没用到功能，打包的时候会被清理掉 ，减小包的大小</li>\n<li>一个功能模块的 methods、data 放一起书写，避免上下反复横跳。</li>\n<li>代码复用方便，一个功能的所有 methods、data 封装在一个独立的函数里。</li>\n<li>Composotion API 新增的 return 等语句，在实际项目中使用。</li>\n</ul>\n<p><img src=\"/img/2022-01-24-2.png\" alt=\"Composition API\"></p>\n<h3 id=\"新的组件\"><a href=\"#新的组件\" class=\"headerlink\" title=\"新的组件\"></a>新的组件</h3><p>Vue 3 还内置了 Fragment、Teleport 和 Suspense 三个新组件。</p>\n<ul>\n<li>Fragment: Vue 3 组件不再要求有一个唯一的根节点，清除了很多无用的占位 div。</li>\n<li>Teleport: 允许组件渲染在别的元素内，主要开发弹窗组件的时候特别有用。</li>\n<li>Suspense: 异步组件，更方便开发有异步请求的组件。</li>\n</ul>\n<h3 id=\"新一代工程化工具-Vite\"><a href=\"#新一代工程化工具-Vite\" class=\"headerlink\" title=\"新一代工程化工具 Vite\"></a>新一代工程化工具 Vite</h3><p>webpack 工程化的原理是 根据 import 依赖逻辑形成一个依赖图，然后调用对应的处理工具，把整个项目打包后，放在内存中再启动调试。因为要预打包，复杂项目开发时，启动开发环境和热更新时间都比较长，Vite 就是为了解决这个问题而出现的。</p>\n<p>现代浏览器已经默认支持 ES6 的 import 语法，Vite 就是基于这个原理实现的。</p>\n<p>在开发环境下，不需要全部预打包，只要把首页依赖的文件，依次通过网络请求去获取，开发体验得到巨大提升，做到复杂项目时，也能做到秒级调试和热更新。</p>\n<p>webpack 工作原理如下，需要把所有路由依赖打包后，才能开始调试。</p>\n<p><img src=\"/img/2022-01-24-3.png\" alt=\"webpack 工作原理\"></p>\n<p>Vite 工作原理，根据首页的依赖模块，再去获取路由 1 的模块，按需加载。</p>\n<p><img src=\"/img/2022-01-24-4.png\" alt=\"Vite 工作原理\"></p>\n<h2 id=\"Vue3-响应式机制\"><a href=\"#Vue3-响应式机制\" class=\"headerlink\" title=\"Vue3 响应式机制\"></a>Vue3 响应式机制</h2><p>响应式原理：Vue 中用过三种响应式解决方案，分别是 defineProperty、Proxy 和 value setter。</p>\n<hr>\n<p>todo: 07</p>\n<h2 id=\"Vue3-实践常见问题汇总\"><a href=\"#Vue3-实践常见问题汇总\" class=\"headerlink\" title=\"Vue3 实践常见问题汇总\"></a>Vue3 实践常见问题汇总</h2><ol>\n<li><p>vetur 报错， xx has no export.</p>\n<p>使用 Vue3 <code>script setup</code> 语法糖时,VsCode 插件 Vetur 会报该错误，原因是 Vetur(v0.35.0) 暂不支持 ts。</p>\n<p>解决办法： 卸载 Vetur， 用 Volar(尤大推荐) 以取代 Vetur。</p>\n</li>\n</ol>\n<hr>\n<p>上述笔记源于学习极客时间-大圣的 <a href=\"http://gk.link/a/115Qp\">玩转 Vue3 全家桶</a> 课程笔记整理。</p>\n<hr>\n","site":{"data":{}},"wordcount":3560,"excerpt":"","more":"<h1 id=\"Vue3-学习笔记\"><a href=\"#Vue3-学习笔记\" class=\"headerlink\" title=\"Vue3 学习笔记\"></a>Vue3 学习笔记</h1><h2 id=\"Vue-和-React-数据驱动原理对比\"><a href=\"#Vue-和-React-数据驱动原理对比\" class=\"headerlink\" title=\"Vue 和 React 数据驱动原理对比\"></a>Vue 和 React 数据驱动原理对比</h2><p>Vue1 解决方案是使用响应式，初始化的时候，watcher 监听数据的每个属性，数据发生变化的时候，就能够知道数据的哪个 key 变了，去修改对应的 DOM。</p>\n<p>React 是虚拟 DOM 方案，用 JS 对象描述 DOM 树，这个对象就像数据和实际 DOM 的一个缓存层，通过管理这个对象的变化，来减少对实际 DOM 的操作。</p>\n<p>描述实际 DOM 的虚拟 DOM 对象如下：</p>\n<p>DOM:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>Item1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>Item2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>虚拟 DOM：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><br>&#123;<br>  <span class=\"hljs-attr\">tag</span>: <span class=\"hljs-string\">&quot;div&quot;</span>,<br>  <span class=\"hljs-attr\">attrs</span>: &#123;<br>    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">&quot;app&quot;</span><br>  &#125;,<br>  <span class=\"hljs-attr\">children</span>: [<br>    &#123;<br>      <span class=\"hljs-attr\">tag</span>: <span class=\"hljs-string\">&quot;p&quot;</span>,<br>      <span class=\"hljs-attr\">attrs</span>: &#123; <span class=\"hljs-attr\">className</span>: <span class=\"hljs-string\">&quot;item&quot;</span> &#125;,<br>      <span class=\"hljs-attr\">children</span>: [<span class=\"hljs-string\">&quot;Item1&quot;</span>]<br>    &#125;,<br>    &#123;<br>      <span class=\"hljs-attr\">tag</span>: <span class=\"hljs-string\">&quot;div&quot;</span>,<br>      <span class=\"hljs-attr\">attrs</span>: &#123; <span class=\"hljs-attr\">className</span>: <span class=\"hljs-string\">&quot;item&quot;</span> &#125;,<br>      <span class=\"hljs-attr\">children</span>: [<span class=\"hljs-string\">&quot;Item2&quot;</span>]<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>数据变化的时候生成一个新的虚拟 DOM 数据，对比之前的虚拟 DOM 进行 diff 计算，算出要修改的 DOM，再对页面进行操作。</p>\n<p>通知页面更新的方式不同：</p>\n<ul>\n<li>vue 中，数据变化，框架主动告诉你修改了哪些数据；</li>\n<li>react 中，变化变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化</li>\n</ul>\n<p>性能问题：</p>\n<ul>\n<li>vue 的响应式，在项目大了之后，每个数据都有一个 watcher 会影响性能</li>\n<li>如果 react 虚拟 dom 过于庞大，使得 diff 计算时间大于 16.6 ms(屏幕刷新率 60HZ, 1/60)，可能造成性能卡顿。</li>\n</ul>\n<p>为了解决性能问题， Vue 和 react 走了不同的道路。</p>\n<ul>\n<li>react 借鉴操作系统时间分片概念，引入 Fiber 架构。把整个虚拟 DOM 树 微观化，变成链表，然后利用浏览器的空闲时间计算 diff。</li>\n<li>vue1 的问题在于响应式数据过多，会带来内存占用过多的问题。vue2 引入虚拟 DOM 来解决响应式数据过多问题。</li>\n</ul>\n<p>响应式数据是主动推送变化，虚拟 DOM 是被动计算数据的 diff。vue2 将两者结合在一起，在组件级别来划分。</p>\n<p>组件间的变化，通过响应式来通知更新。组件内部的数据变化，通过虚拟 DOM 去更新页面。最终，把响应式监听器控制在组件级别，而虚拟 DOM 的量级控制在组件的大小。</p>\n<p>在模板书写上，vue 和 react 分别走了 template 和 jsx 两个路线。</p>\n<ul>\n<li>react 世界只有 jsx，最终 jsx 都会在 Compiler 那层，即工程化那里编译成 js 来执行。</li>\n<li>vue 默认 template。vue3 优秀的其中一点是在虚拟 DOM 的静态标记上做到了极致，让静态的部分越过虚拟 DOM 的计算，真正做到按需更新，很好的提高了性能。</li>\n</ul>\n<h2 id=\"Vue3-的新特性\"><a href=\"#Vue3-的新特性\" class=\"headerlink\" title=\"Vue3 的新特性\"></a>Vue3 的新特性</h2><h3 id=\"响应式系统\"><a href=\"#响应式系统\" class=\"headerlink\" title=\"响应式系统\"></a>响应式系统</h3><p>Vue 2 的响应式机制是基于 Object.defineProperty() 这个 API 实现的.Vue3 是基于 proxy。两者区别是 defineProperty 是拦截具体某个属性， Proxy 是全部拦截，是代理。</p>\n<p>defineProperty 示例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">Object</span>.defineProperty(obj, <span class=\"hljs-string\">&quot;title&quot;</span>, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;,<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">set</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。</p>\n<p>但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的 $set。</p>\n<p>Proxy API 是真正的代理，示例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>(obj, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;,<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">set</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>Proxy 拦截 obj 这个数据，不关心 obj 里面属性，统一拦截。</p>\n<h3 id=\"自定义渲染器\"><a href=\"#自定义渲染器\" class=\"headerlink\" title=\"自定义渲染器\"></a>自定义渲染器</h3><p>vue2 内部所有模块是揉在一起，导致不好扩展。vue3 采用 monorepo 方式进行拆包，响应式、编译和运行时全部独立。独立出来的响应式，甚至可以在 react、node 中使用。</p>\n<p><img src=\"/img/2022-01-24-1.png\" alt=\"vue 架构\"></p>\n<p>渲染逻辑拆成 <strong>平台无关渲染逻辑</strong> 和 <strong>浏览器渲染 API</strong>。</p>\n<h3 id=\"全部模块使用-TS-重构\"><a href=\"#全部模块使用-TS-重构\" class=\"headerlink\" title=\"全部模块使用 TS 重构\"></a>全部模块使用 TS 重构</h3><p>Vue2 使用 Flow.js 做类型检测；Flow.js 已被抛弃，vue3 选择 TS。</p>\n<h3 id=\"Composition-API-组合语法\"><a href=\"#Composition-API-组合语法\" class=\"headerlink\" title=\"Composition API 组合语法\"></a>Composition API 组合语法</h3><p>vue2 中示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> App = &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">1</span> &#125;;<br>  &#125;,<br>  <span class=\"hljs-attr\">methods</span>: &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">add</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>      <span class=\"hljs-built_in\">this</span>.count++;<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">computed</span>: &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">double</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.count * <span class=\"hljs-number\">2</span>;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>vue2 中 Options API 存在以下问题：</p>\n<ul>\n<li>所有数据都挂载在 this 上，Options API 写法对 TS 类型推导不友好。</li>\n<li>新增的功能基本都要修改 data、method 等，代码行数多了以后，会经常需要上下反复横跳。</li>\n<li>代码不好复用，vue2 的组件很难抽离通用逻辑，只能使用 mixin，还会导致命名冲突问题。</li>\n</ul>\n<p>vue3 中采用新增的 setup 写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> &#123; reactive, computed &#125; = Vue;<br><span class=\"hljs-keyword\">let</span> App = &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">setup</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> state = reactive(&#123; <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">1</span> &#125;);<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>      state.count++;<br>    &#125;<br>    <span class=\"hljs-keyword\">const</span> double = computed(<span class=\"hljs-function\">() =&gt;</span> state.count * <span class=\"hljs-number\">2</span>);<br>    <span class=\"hljs-keyword\">return</span> &#123; state, add, double &#125;;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>Composition API 好处如下：</p>\n<ul>\n<li>所有 API 都是 import 引入。对 Tree-shaking 很友好，没用到功能，打包的时候会被清理掉 ，减小包的大小</li>\n<li>一个功能模块的 methods、data 放一起书写，避免上下反复横跳。</li>\n<li>代码复用方便，一个功能的所有 methods、data 封装在一个独立的函数里。</li>\n<li>Composotion API 新增的 return 等语句，在实际项目中使用。</li>\n</ul>\n<p><img src=\"/img/2022-01-24-2.png\" alt=\"Composition API\"></p>\n<h3 id=\"新的组件\"><a href=\"#新的组件\" class=\"headerlink\" title=\"新的组件\"></a>新的组件</h3><p>Vue 3 还内置了 Fragment、Teleport 和 Suspense 三个新组件。</p>\n<ul>\n<li>Fragment: Vue 3 组件不再要求有一个唯一的根节点，清除了很多无用的占位 div。</li>\n<li>Teleport: 允许组件渲染在别的元素内，主要开发弹窗组件的时候特别有用。</li>\n<li>Suspense: 异步组件，更方便开发有异步请求的组件。</li>\n</ul>\n<h3 id=\"新一代工程化工具-Vite\"><a href=\"#新一代工程化工具-Vite\" class=\"headerlink\" title=\"新一代工程化工具 Vite\"></a>新一代工程化工具 Vite</h3><p>webpack 工程化的原理是 根据 import 依赖逻辑形成一个依赖图，然后调用对应的处理工具，把整个项目打包后，放在内存中再启动调试。因为要预打包，复杂项目开发时，启动开发环境和热更新时间都比较长，Vite 就是为了解决这个问题而出现的。</p>\n<p>现代浏览器已经默认支持 ES6 的 import 语法，Vite 就是基于这个原理实现的。</p>\n<p>在开发环境下，不需要全部预打包，只要把首页依赖的文件，依次通过网络请求去获取，开发体验得到巨大提升，做到复杂项目时，也能做到秒级调试和热更新。</p>\n<p>webpack 工作原理如下，需要把所有路由依赖打包后，才能开始调试。</p>\n<p><img src=\"/img/2022-01-24-3.png\" alt=\"webpack 工作原理\"></p>\n<p>Vite 工作原理，根据首页的依赖模块，再去获取路由 1 的模块，按需加载。</p>\n<p><img src=\"/img/2022-01-24-4.png\" alt=\"Vite 工作原理\"></p>\n<h2 id=\"Vue3-响应式机制\"><a href=\"#Vue3-响应式机制\" class=\"headerlink\" title=\"Vue3 响应式机制\"></a>Vue3 响应式机制</h2><p>响应式原理：Vue 中用过三种响应式解决方案，分别是 defineProperty、Proxy 和 value setter。</p>\n<hr>\n<p>todo: 07</p>\n<h2 id=\"Vue3-实践常见问题汇总\"><a href=\"#Vue3-实践常见问题汇总\" class=\"headerlink\" title=\"Vue3 实践常见问题汇总\"></a>Vue3 实践常见问题汇总</h2><ol>\n<li><p>vetur 报错， xx has no export.</p>\n<p>使用 Vue3 <code>script setup</code> 语法糖时,VsCode 插件 Vetur 会报该错误，原因是 Vetur(v0.35.0) 暂不支持 ts。</p>\n<p>解决办法： 卸载 Vetur， 用 Volar(尤大推荐) 以取代 Vetur。</p>\n</li>\n</ol>\n<hr>\n<p>上述笔记源于学习极客时间-大圣的 <a href=\"http://gk.link/a/115Qp\">玩转 Vue3 全家桶</a> 课程笔记整理。</p>\n<hr>\n"},{"title":"如何在 class 组件中使用 hooks","index_img":"/img/2022-01-14-2.png","date":"2022-01-14T03:03:28.000Z","_content":"\n# 如何在 class 组件中使用 hooks\n\n解决办法\n\n以一个简单的 `useScreenWidthhook` 函数为例，它的目的是获取全屏的宽度，并且去监听浏览器窗口的变化，更新宽度：\n\n```jsx\nimport { useEffect, useState } from \"react\";\n\nexport function useScreenWidth(): number {\n  const [width, setWidth] = useState(window.innerWidth);\n\n  useEffect(() => {\n    const handler = (event: any) => {\n      setWidth(event.target.innerWidth);\n    };\n    // 监听浏览器窗口变化\n    window.addEventListener(\"resize\", handler);\n    // 组件unmount时要解除监听\n    return () => {\n      window.removeEventListener(\"resize\", handler);\n    };\n  }, []);\n\n  return width;\n}\n```\n\n## 方法 1：将 Hook 包装成 HOC\n\nHOC 是 React 中复用组件的高级用法，它的本质是一个函数，它的输入参数是一个组件，返回相同的组件以及一些额外的 props。在我们的例子里，可以让 hook 函数作为 props 传递到目标组件中:\n\n```jsx\nimport React from \"react\";\nimport { useScreenWidth } from \"../hooks/useScreenWidth\";\n\nexport const withHooksHOC = (Component: any) => {\n  return (props: any) => {\n    const screenWidth = useScreenWidth();\n\n    return <Component width={screenWidth} {...props} />;\n  };\n};\n```\n\n将我们的目标组件用上述的 withHooksHOC 包装起来\n\n```jsx\nimport React from \"react\";\nimport { withHooksHOC } from \"./withHooksHOC\";\n\ninterface IHooksHOCProps {\n  width: number;\n}\n\nclass HooksHOC extends React.Component<IHooksHOCProps> {\n  render() {\n    return <p>width: {this.props.width}</p>;\n  }\n}\n\nexport default withHooksHOC(HooksHOC);\n```\n\n## 方法 2：将 Hook 包装成函数组件\n\n将 hook 变成函数组件，它接收一个参数为 width 的 children 函数，然后将 width 作为 render prop 传递：\n\n```jsx\nimport { FunctionComponent } from \"react\";\nimport { useScreenWidth } from \"../hooks/useScreenWidth\";\n\ntype ScreenWidthChildren = (screenWidth: number) => React.ReactNode;\n\ninterface IScreenWidthProps {\n  children: ScreenWidthChildren;\n}\n\nexport const ScreenWidth: FunctionComponent<IScreenWidthProps> = ({ children }) => {\n  const screenWidth: number = useScreenWidth();\n\n  return children(screenWidth);\n};\n```\n\n使用：\n\n```jsx\nimport React from \"react\";\nimport { ScreenWidth } from \"./ScreenWidth\";\n\nexport class HooksRenderProps extends React.Component {\n  render() {\n    return <ScreenWidth>{(width) => <p style={{ fontSize: \"48px\" }}>width: {width}</p>}</ScreenWidth>;\n  }\n}\n```\n","source":"_posts/2022-01-14-2.md","raw":"---\ntitle: 如何在 class 组件中使用 hooks\nindex_img: /img/2022-01-14-2.png\ndate: 2022-01-14 11:03:28\ntags: HooK\ncategories: React\n---\n\n# 如何在 class 组件中使用 hooks\n\n解决办法\n\n以一个简单的 `useScreenWidthhook` 函数为例，它的目的是获取全屏的宽度，并且去监听浏览器窗口的变化，更新宽度：\n\n```jsx\nimport { useEffect, useState } from \"react\";\n\nexport function useScreenWidth(): number {\n  const [width, setWidth] = useState(window.innerWidth);\n\n  useEffect(() => {\n    const handler = (event: any) => {\n      setWidth(event.target.innerWidth);\n    };\n    // 监听浏览器窗口变化\n    window.addEventListener(\"resize\", handler);\n    // 组件unmount时要解除监听\n    return () => {\n      window.removeEventListener(\"resize\", handler);\n    };\n  }, []);\n\n  return width;\n}\n```\n\n## 方法 1：将 Hook 包装成 HOC\n\nHOC 是 React 中复用组件的高级用法，它的本质是一个函数，它的输入参数是一个组件，返回相同的组件以及一些额外的 props。在我们的例子里，可以让 hook 函数作为 props 传递到目标组件中:\n\n```jsx\nimport React from \"react\";\nimport { useScreenWidth } from \"../hooks/useScreenWidth\";\n\nexport const withHooksHOC = (Component: any) => {\n  return (props: any) => {\n    const screenWidth = useScreenWidth();\n\n    return <Component width={screenWidth} {...props} />;\n  };\n};\n```\n\n将我们的目标组件用上述的 withHooksHOC 包装起来\n\n```jsx\nimport React from \"react\";\nimport { withHooksHOC } from \"./withHooksHOC\";\n\ninterface IHooksHOCProps {\n  width: number;\n}\n\nclass HooksHOC extends React.Component<IHooksHOCProps> {\n  render() {\n    return <p>width: {this.props.width}</p>;\n  }\n}\n\nexport default withHooksHOC(HooksHOC);\n```\n\n## 方法 2：将 Hook 包装成函数组件\n\n将 hook 变成函数组件，它接收一个参数为 width 的 children 函数，然后将 width 作为 render prop 传递：\n\n```jsx\nimport { FunctionComponent } from \"react\";\nimport { useScreenWidth } from \"../hooks/useScreenWidth\";\n\ntype ScreenWidthChildren = (screenWidth: number) => React.ReactNode;\n\ninterface IScreenWidthProps {\n  children: ScreenWidthChildren;\n}\n\nexport const ScreenWidth: FunctionComponent<IScreenWidthProps> = ({ children }) => {\n  const screenWidth: number = useScreenWidth();\n\n  return children(screenWidth);\n};\n```\n\n使用：\n\n```jsx\nimport React from \"react\";\nimport { ScreenWidth } from \"./ScreenWidth\";\n\nexport class HooksRenderProps extends React.Component {\n  render() {\n    return <ScreenWidth>{(width) => <p style={{ fontSize: \"48px\" }}>width: {width}</p>}</ScreenWidth>;\n  }\n}\n```\n","slug":"2","published":1,"updated":"2022-02-28T02:43:00.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl06jlx3a000xl03l1umdf853","content":"<h1 id=\"如何在-class-组件中使用-hooks\"><a href=\"#如何在-class-组件中使用-hooks\" class=\"headerlink\" title=\"如何在 class 组件中使用 hooks\"></a>如何在 class 组件中使用 hooks</h1><p>解决办法</p>\n<p>以一个简单的 <code>useScreenWidthhook</code> 函数为例，它的目的是获取全屏的宽度，并且去监听浏览器窗口的变化，更新宽度：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; useEffect, useState &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useScreenWidth</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">number</span> </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> [width, setWidth] = useState(<span class=\"hljs-built_in\">window</span>.innerWidth);<br><br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> handler = <span class=\"hljs-function\">(<span class=\"hljs-params\">event: any</span>) =&gt;</span> &#123;<br>      setWidth(event.target.innerWidth);<br>    &#125;;<br>    <span class=\"hljs-comment\">// 监听浏览器窗口变化</span><br>    <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">&quot;resize&quot;</span>, handler);<br>    <span class=\"hljs-comment\">// 组件unmount时要解除监听</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-built_in\">window</span>.removeEventListener(<span class=\"hljs-string\">&quot;resize&quot;</span>, handler);<br>    &#125;;<br>  &#125;, []);<br><br>  <span class=\"hljs-keyword\">return</span> width;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"方法-1：将-Hook-包装成-HOC\"><a href=\"#方法-1：将-Hook-包装成-HOC\" class=\"headerlink\" title=\"方法 1：将 Hook 包装成 HOC\"></a>方法 1：将 Hook 包装成 HOC</h2><p>HOC 是 React 中复用组件的高级用法，它的本质是一个函数，它的输入参数是一个组件，返回相同的组件以及一些额外的 props。在我们的例子里，可以让 hook 函数作为 props 传递到目标组件中:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; useScreenWidth &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../hooks/useScreenWidth&quot;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> withHooksHOC = <span class=\"hljs-function\">(<span class=\"hljs-params\">Component: any</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">props: any</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> screenWidth = useScreenWidth();<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Component</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&#123;screenWidth&#125;</span> &#123;<span class=\"hljs-attr\">...props</span>&#125; /&gt;</span></span>;<br>  &#125;;<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n\n<p>将我们的目标组件用上述的 withHooksHOC 包装起来</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; withHooksHOC &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./withHooksHOC&quot;</span>;<br><br>interface IHooksHOCProps &#123;<br>  <span class=\"hljs-attr\">width</span>: number;<br>&#125;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HooksHOC</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">IHooksHOCProps</span>&gt; </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>width: &#123;this.props.width&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> withHooksHOC(HooksHOC);<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"方法-2：将-Hook-包装成函数组件\"><a href=\"#方法-2：将-Hook-包装成函数组件\" class=\"headerlink\" title=\"方法 2：将 Hook 包装成函数组件\"></a>方法 2：将 Hook 包装成函数组件</h2><p>将 hook 变成函数组件，它接收一个参数为 width 的 children 函数，然后将 width 作为 render prop 传递：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; FunctionComponent &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; useScreenWidth &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../hooks/useScreenWidth&quot;</span>;<br><br>type ScreenWidthChildren = <span class=\"hljs-function\">(<span class=\"hljs-params\">screenWidth: number</span>) =&gt;</span> React.ReactNode;<br><br>interface IScreenWidthProps &#123;<br>  <span class=\"hljs-attr\">children</span>: ScreenWidthChildren;<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> ScreenWidth: FunctionComponent&lt;IScreenWidthProps&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">&#123; children &#125;</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> screenWidth: number = useScreenWidth();<br><br>  <span class=\"hljs-keyword\">return</span> children(screenWidth);<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n\n<p>使用：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; ScreenWidth &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./ScreenWidth&quot;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HooksRenderProps</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ScreenWidth</span>&gt;</span>&#123;(width) =&gt; <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&#123;&#123;</span> <span class=\"hljs-attr\">fontSize:</span> &quot;<span class=\"hljs-attr\">48px</span>&quot; &#125;&#125;&gt;</span>width: &#123;width&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ScreenWidth</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n","site":{"data":{}},"wordcount":2234,"excerpt":"","more":"<h1 id=\"如何在-class-组件中使用-hooks\"><a href=\"#如何在-class-组件中使用-hooks\" class=\"headerlink\" title=\"如何在 class 组件中使用 hooks\"></a>如何在 class 组件中使用 hooks</h1><p>解决办法</p>\n<p>以一个简单的 <code>useScreenWidthhook</code> 函数为例，它的目的是获取全屏的宽度，并且去监听浏览器窗口的变化，更新宽度：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; useEffect, useState &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useScreenWidth</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">number</span> </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> [width, setWidth] = useState(<span class=\"hljs-built_in\">window</span>.innerWidth);<br><br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> handler = <span class=\"hljs-function\">(<span class=\"hljs-params\">event: any</span>) =&gt;</span> &#123;<br>      setWidth(event.target.innerWidth);<br>    &#125;;<br>    <span class=\"hljs-comment\">// 监听浏览器窗口变化</span><br>    <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">&quot;resize&quot;</span>, handler);<br>    <span class=\"hljs-comment\">// 组件unmount时要解除监听</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-built_in\">window</span>.removeEventListener(<span class=\"hljs-string\">&quot;resize&quot;</span>, handler);<br>    &#125;;<br>  &#125;, []);<br><br>  <span class=\"hljs-keyword\">return</span> width;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"方法-1：将-Hook-包装成-HOC\"><a href=\"#方法-1：将-Hook-包装成-HOC\" class=\"headerlink\" title=\"方法 1：将 Hook 包装成 HOC\"></a>方法 1：将 Hook 包装成 HOC</h2><p>HOC 是 React 中复用组件的高级用法，它的本质是一个函数，它的输入参数是一个组件，返回相同的组件以及一些额外的 props。在我们的例子里，可以让 hook 函数作为 props 传递到目标组件中:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; useScreenWidth &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../hooks/useScreenWidth&quot;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> withHooksHOC = <span class=\"hljs-function\">(<span class=\"hljs-params\">Component: any</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">props: any</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> screenWidth = useScreenWidth();<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Component</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&#123;screenWidth&#125;</span> &#123;<span class=\"hljs-attr\">...props</span>&#125; /&gt;</span></span>;<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>将我们的目标组件用上述的 withHooksHOC 包装起来</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; withHooksHOC &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./withHooksHOC&quot;</span>;<br><br>interface IHooksHOCProps &#123;<br>  <span class=\"hljs-attr\">width</span>: number;<br>&#125;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HooksHOC</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">IHooksHOCProps</span>&gt; </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>width: &#123;this.props.width&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> withHooksHOC(HooksHOC);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"方法-2：将-Hook-包装成函数组件\"><a href=\"#方法-2：将-Hook-包装成函数组件\" class=\"headerlink\" title=\"方法 2：将 Hook 包装成函数组件\"></a>方法 2：将 Hook 包装成函数组件</h2><p>将 hook 变成函数组件，它接收一个参数为 width 的 children 函数，然后将 width 作为 render prop 传递：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; FunctionComponent &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; useScreenWidth &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../hooks/useScreenWidth&quot;</span>;<br><br>type ScreenWidthChildren = <span class=\"hljs-function\">(<span class=\"hljs-params\">screenWidth: number</span>) =&gt;</span> React.ReactNode;<br><br>interface IScreenWidthProps &#123;<br>  <span class=\"hljs-attr\">children</span>: ScreenWidthChildren;<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> ScreenWidth: FunctionComponent&lt;IScreenWidthProps&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">&#123; children &#125;</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> screenWidth: number = useScreenWidth();<br><br>  <span class=\"hljs-keyword\">return</span> children(screenWidth);<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>使用：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; ScreenWidth &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./ScreenWidth&quot;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HooksRenderProps</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ScreenWidth</span>&gt;</span>&#123;(width) =&gt; <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&#123;&#123;</span> <span class=\"hljs-attr\">fontSize:</span> &quot;<span class=\"hljs-attr\">48px</span>&quot; &#125;&#125;&gt;</span>width: &#123;width&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ScreenWidth</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"useState 引用类型数据更新不触发重新渲染问题","date":"2022-01-14T02:24:50.000Z","index_img":"/img/2022-01-14-1.png","_content":"\n# useState 引用类型数据更新不触发重新渲染问题\n\n## useState 函数式更新\n\n与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。\n\n```jsx\nconst [state, setState] = useState({});\nsetState((prevState) => {\n  // 也可以使用 Object.assign\n  return { ...prevState, ...updatedValues };\n});\n```\n\n## 引用类型 state 更新\n\n经常 state 数据不是简单数据类型(值类型)，而是数组、对象之类(引用类型).而 React 组件的更新机制对 state 只进行浅对比，也就是更新某个复杂类型数据时只要它的引用地址没变，那就不会重新渲染组件。\n\n尤其当被更新的引用类型数据需要依赖之前的数据时，容易踩坑,不触发更新。更新复杂 state 的时候必须传给它一个全新的对象，而不是复制了它引用地址再修改的对象。\n\n两种解决办法：\n\n1. 结合展开运算符返回一个新对象\n\n   ```jsx\n   function nextValue(preValue) {\n     let ipValue = Number.parseInt(newVal, 10);\n\n     if (Number.isNaN(ipValue)) {\n       ipValue = undefined;\n     }\n     if (ipValue < 0) {\n       ipValue = 0;\n     }\n     if (ipValue > 255) {\n       ipValue = 255;\n     }\n     preValue[index] = ipValue; //这里数据引用地址的值同样被修改\n     return [...preValue]; // 数据最外层的引用地址不同即可触发组件更新\n   }\n\n   setValue((preValue) => nextValue(preValue));\n   ```\n\n1. 深拷贝对象，用全新的副本更新数据。\n\n   ```jsx\n   function nextValue(preValue) {\n     const newValue = _.cloneDeep(preValue);\n     let ipValue = Number.parseInt(newVal, 10);\n\n     if (Number.isNaN(ipValue)) {\n       ipValue = undefined;\n     }\n     if (ipValue < 0) {\n       ipValue = 0;\n     }\n     if (ipValue > 255) {\n       ipValue = 255;\n     }\n     newValue[index] = ipValue; //这里数据引用地址的值同样被修改\n     return newValue; // 数据最外层的引用地址不同即可触发组件更新\n   }\n\n   setValue((preValue) => nextValue(preValue));\n   ```\n","source":"_posts/2022-01-14-1.md","raw":"---\ntitle: useState 引用类型数据更新不触发重新渲染问题\ndate: 2022-01-14 10:24:50\ntags: HooK\nindex_img: /img/2022-01-14-1.png\ncategories: React\n---\n\n# useState 引用类型数据更新不触发重新渲染问题\n\n## useState 函数式更新\n\n与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。\n\n```jsx\nconst [state, setState] = useState({});\nsetState((prevState) => {\n  // 也可以使用 Object.assign\n  return { ...prevState, ...updatedValues };\n});\n```\n\n## 引用类型 state 更新\n\n经常 state 数据不是简单数据类型(值类型)，而是数组、对象之类(引用类型).而 React 组件的更新机制对 state 只进行浅对比，也就是更新某个复杂类型数据时只要它的引用地址没变，那就不会重新渲染组件。\n\n尤其当被更新的引用类型数据需要依赖之前的数据时，容易踩坑,不触发更新。更新复杂 state 的时候必须传给它一个全新的对象，而不是复制了它引用地址再修改的对象。\n\n两种解决办法：\n\n1. 结合展开运算符返回一个新对象\n\n   ```jsx\n   function nextValue(preValue) {\n     let ipValue = Number.parseInt(newVal, 10);\n\n     if (Number.isNaN(ipValue)) {\n       ipValue = undefined;\n     }\n     if (ipValue < 0) {\n       ipValue = 0;\n     }\n     if (ipValue > 255) {\n       ipValue = 255;\n     }\n     preValue[index] = ipValue; //这里数据引用地址的值同样被修改\n     return [...preValue]; // 数据最外层的引用地址不同即可触发组件更新\n   }\n\n   setValue((preValue) => nextValue(preValue));\n   ```\n\n1. 深拷贝对象，用全新的副本更新数据。\n\n   ```jsx\n   function nextValue(preValue) {\n     const newValue = _.cloneDeep(preValue);\n     let ipValue = Number.parseInt(newVal, 10);\n\n     if (Number.isNaN(ipValue)) {\n       ipValue = undefined;\n     }\n     if (ipValue < 0) {\n       ipValue = 0;\n     }\n     if (ipValue > 255) {\n       ipValue = 255;\n     }\n     newValue[index] = ipValue; //这里数据引用地址的值同样被修改\n     return newValue; // 数据最外层的引用地址不同即可触发组件更新\n   }\n\n   setValue((preValue) => nextValue(preValue));\n   ```\n","slug":"1","published":1,"updated":"2022-02-28T02:42:24.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl06jlx3b000yl03l8e5c8tlz","content":"<h1 id=\"useState-引用类型数据更新不触发重新渲染问题\"><a href=\"#useState-引用类型数据更新不触发重新渲染问题\" class=\"headerlink\" title=\"useState 引用类型数据更新不触发重新渲染问题\"></a>useState 引用类型数据更新不触发重新渲染问题</h1><h2 id=\"useState-函数式更新\"><a href=\"#useState-函数式更新\" class=\"headerlink\" title=\"useState 函数式更新\"></a>useState 函数式更新</h2><p>与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> [state, setState] = useState(&#123;&#125;);<br>setState(<span class=\"hljs-function\">(<span class=\"hljs-params\">prevState</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-comment\">// 也可以使用 Object.assign</span><br>  <span class=\"hljs-keyword\">return</span> &#123; ...prevState, ...updatedValues &#125;;<br>&#125;);<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"引用类型-state-更新\"><a href=\"#引用类型-state-更新\" class=\"headerlink\" title=\"引用类型 state 更新\"></a>引用类型 state 更新</h2><p>经常 state 数据不是简单数据类型(值类型)，而是数组、对象之类(引用类型).而 React 组件的更新机制对 state 只进行浅对比，也就是更新某个复杂类型数据时只要它的引用地址没变，那就不会重新渲染组件。</p>\n<p>尤其当被更新的引用类型数据需要依赖之前的数据时，容易踩坑,不触发更新。更新复杂 state 的时候必须传给它一个全新的对象，而不是复制了它引用地址再修改的对象。</p>\n<p>两种解决办法：</p>\n<ol>\n<li><p>结合展开运算符返回一个新对象</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">nextValue</span>(<span class=\"hljs-params\">preValue</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> ipValue = <span class=\"hljs-built_in\">Number</span>.parseInt(newVal, <span class=\"hljs-number\">10</span>);<br><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Number</span>.isNaN(ipValue)) &#123;<br>    ipValue = <span class=\"hljs-literal\">undefined</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (ipValue &lt; <span class=\"hljs-number\">0</span>) &#123;<br>    ipValue = <span class=\"hljs-number\">0</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (ipValue &gt; <span class=\"hljs-number\">255</span>) &#123;<br>    ipValue = <span class=\"hljs-number\">255</span>;<br>  &#125;<br>  preValue[index] = ipValue; <span class=\"hljs-comment\">//这里数据引用地址的值同样被修改</span><br>  <span class=\"hljs-keyword\">return</span> [...preValue]; <span class=\"hljs-comment\">// 数据最外层的引用地址不同即可触发组件更新</span><br>&#125;<br><br>setValue(<span class=\"hljs-function\">(<span class=\"hljs-params\">preValue</span>) =&gt;</span> nextValue(preValue));<br></code></pre></div></td></tr></table></figure></li>\n<li><p>深拷贝对象，用全新的副本更新数据。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">nextValue</span>(<span class=\"hljs-params\">preValue</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> newValue = _.cloneDeep(preValue);<br>  <span class=\"hljs-keyword\">let</span> ipValue = <span class=\"hljs-built_in\">Number</span>.parseInt(newVal, <span class=\"hljs-number\">10</span>);<br><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Number</span>.isNaN(ipValue)) &#123;<br>    ipValue = <span class=\"hljs-literal\">undefined</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (ipValue &lt; <span class=\"hljs-number\">0</span>) &#123;<br>    ipValue = <span class=\"hljs-number\">0</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (ipValue &gt; <span class=\"hljs-number\">255</span>) &#123;<br>    ipValue = <span class=\"hljs-number\">255</span>;<br>  &#125;<br>  newValue[index] = ipValue; <span class=\"hljs-comment\">//这里数据引用地址的值同样被修改</span><br>  <span class=\"hljs-keyword\">return</span> newValue; <span class=\"hljs-comment\">// 数据最外层的引用地址不同即可触发组件更新</span><br>&#125;<br><br>setValue(<span class=\"hljs-function\">(<span class=\"hljs-params\">preValue</span>) =&gt;</span> nextValue(preValue));<br></code></pre></div></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"wordcount":1264,"excerpt":"","more":"<h1 id=\"useState-引用类型数据更新不触发重新渲染问题\"><a href=\"#useState-引用类型数据更新不触发重新渲染问题\" class=\"headerlink\" title=\"useState 引用类型数据更新不触发重新渲染问题\"></a>useState 引用类型数据更新不触发重新渲染问题</h1><h2 id=\"useState-函数式更新\"><a href=\"#useState-函数式更新\" class=\"headerlink\" title=\"useState 函数式更新\"></a>useState 函数式更新</h2><p>与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> [state, setState] = useState(&#123;&#125;);<br>setState(<span class=\"hljs-function\">(<span class=\"hljs-params\">prevState</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-comment\">// 也可以使用 Object.assign</span><br>  <span class=\"hljs-keyword\">return</span> &#123; ...prevState, ...updatedValues &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"引用类型-state-更新\"><a href=\"#引用类型-state-更新\" class=\"headerlink\" title=\"引用类型 state 更新\"></a>引用类型 state 更新</h2><p>经常 state 数据不是简单数据类型(值类型)，而是数组、对象之类(引用类型).而 React 组件的更新机制对 state 只进行浅对比，也就是更新某个复杂类型数据时只要它的引用地址没变，那就不会重新渲染组件。</p>\n<p>尤其当被更新的引用类型数据需要依赖之前的数据时，容易踩坑,不触发更新。更新复杂 state 的时候必须传给它一个全新的对象，而不是复制了它引用地址再修改的对象。</p>\n<p>两种解决办法：</p>\n<ol>\n<li><p>结合展开运算符返回一个新对象</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">nextValue</span>(<span class=\"hljs-params\">preValue</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> ipValue = <span class=\"hljs-built_in\">Number</span>.parseInt(newVal, <span class=\"hljs-number\">10</span>);<br><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Number</span>.isNaN(ipValue)) &#123;<br>    ipValue = <span class=\"hljs-literal\">undefined</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (ipValue &lt; <span class=\"hljs-number\">0</span>) &#123;<br>    ipValue = <span class=\"hljs-number\">0</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (ipValue &gt; <span class=\"hljs-number\">255</span>) &#123;<br>    ipValue = <span class=\"hljs-number\">255</span>;<br>  &#125;<br>  preValue[index] = ipValue; <span class=\"hljs-comment\">//这里数据引用地址的值同样被修改</span><br>  <span class=\"hljs-keyword\">return</span> [...preValue]; <span class=\"hljs-comment\">// 数据最外层的引用地址不同即可触发组件更新</span><br>&#125;<br><br>setValue(<span class=\"hljs-function\">(<span class=\"hljs-params\">preValue</span>) =&gt;</span> nextValue(preValue));<br></code></pre></td></tr></table></figure></li>\n<li><p>深拷贝对象，用全新的副本更新数据。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">nextValue</span>(<span class=\"hljs-params\">preValue</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> newValue = _.cloneDeep(preValue);<br>  <span class=\"hljs-keyword\">let</span> ipValue = <span class=\"hljs-built_in\">Number</span>.parseInt(newVal, <span class=\"hljs-number\">10</span>);<br><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Number</span>.isNaN(ipValue)) &#123;<br>    ipValue = <span class=\"hljs-literal\">undefined</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (ipValue &lt; <span class=\"hljs-number\">0</span>) &#123;<br>    ipValue = <span class=\"hljs-number\">0</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (ipValue &gt; <span class=\"hljs-number\">255</span>) &#123;<br>    ipValue = <span class=\"hljs-number\">255</span>;<br>  &#125;<br>  newValue[index] = ipValue; <span class=\"hljs-comment\">//这里数据引用地址的值同样被修改</span><br>  <span class=\"hljs-keyword\">return</span> newValue; <span class=\"hljs-comment\">// 数据最外层的引用地址不同即可触发组件更新</span><br>&#125;<br><br>setValue(<span class=\"hljs-function\">(<span class=\"hljs-params\">preValue</span>) =&gt;</span> nextValue(preValue));<br></code></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"中高级前端工程师面试题","index_img":"/img/2022-02-16-1.jpeg","date":"2022-02-15T02:39:21.000Z","_content":"\n# 中高级前端工程师面试题\n\n## 基础\n\n1、浏览器地址栏输入 URL 到页面打开的整个解析过程？\n\n## JS\n\n1、请你讲一下闭包?\n\n> 简单：闭包是有权限访问其他函数作用域内的变量的一个函数。\n>\n> 完整：由于在JS中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之回收，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数——也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后作用域内的值也不会被销毁。\n\n- 闭包解决了什么？\n\n> 由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。以平时使用的Ajax成功回调为例，这里其实就是个闭包，由于上述的特性，回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。开发者不用去写钩子函数来操作上级函数作用域内部的变量了。\n\n- 闭包有哪些应用场景?\n\n> 闭包随处可见，一个Ajax请求的成功回调，一个事件绑定的回调方法，一个setTimeout的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。\n\n2、介绍一下 JS 里面的原型？\n\n> 每个对象都有一个 prototype 属性，就是原型，是一个对象，叫原型对象。\n\n- 原型的作用是什么？\n\n > 共享方法\n\n- 原型中this的指向是什么？\n\n> 原型中this的指向是实例。\n\n- 说一下平时开发使用到 prototype 的例子？\n\n3、如何理解 es6 class 中 constructor 方法？ 和 super的作用？\n\n> constructor 方法是类的构造函数。\n通过 new 命令创建对象实例时，自动调用该方法。\nconstructor 内定义的方法是 实例方法；class 内直接定义的方法是原型方法。\n>\n> super...\n\n4、eventloop\n\n## React\n\n1、介绍一下 Virtual DOM 的工作原理？\n\n> Virtual DOM 是一个轻量级的 JavaScript 对象，它最初只是 real DOM 的副本。它是一个节点树，它将元素、它们的属性和内容作为对象及其属性。 React 的渲染函数从 React 组件中创建一个节点树。然后它响应数据模型中的变化来更新该树，该变化是由用户或系统完成的各种动作引起的。\n\nVirtual DOM 工作过程有三步：\n\n  1. 每当底层数据发生改变时，整个 UI 都将在 Virtual DOM 描述中重新渲染。\n  2. 然后计算之前 DOM 表示与新表示的之间的差异。\n  3. 完成计算后，将只用实际更改的内容更新 real DOM。\n\n2、react 里什么是高阶组件？使用高阶组件的场景？\n\n> 高阶组件(HOC)是接受一个组件并返回一个新组件的函数。\n\n3、React Hooks 解决了哪些问题？\n\n> 在组件之间复用状态逻辑很难;复杂组件变得难以理解\n\n4、说一下 useRef 有哪些用法？\n\n> useRef 除了获取 dom，另一个用法：\n保存数据，不造成 rerender\n想要保存数据，又不想触发函数的更新，该数据的更新不会造成组件 rerender\n\n5、什么情况下使用 useCallback ？\n子组件接收一个方法，避免子组件重复渲染\n\n- react 中只要父组件的 render 了，那么默认情况下就会触发子组的 render，react 提供了来避免这种重渲染的性能开销的一些方法：React.PureComponent、React.memo ，shouldComponentUpdate()\n- 使用 React.memo 避免子组件做没必要的渲染。\n- Reace.memo 只会对 props 做浅比较，也就是父组件重新 render 之后会传入 不同引用的方法 getList，浅比较之后不相等，导致子组件还是依然会渲染。\n- useCallback 缓存一个函数，当依赖没有改变的时候，会一直返回同一个引用\n\n6、useCallback 与 useMemo 作用用来缓存，两者的区别是什么？\n\n> useMemo 缓存值；useCallback 缓存函数\n\n7、 react 项目里做过哪些性能优化？\n\n代码层面：\n\n- 使用return null而不是CSS的display:none来控制节点的显示隐藏。保证同一时间页面的DOM节点尽可能的少。\n- props和state的数据尽可能简单明了，扁平化。\n- 不要使用数组下标作为key\n- 利用 shouldComponentUpdate 和 PureComponent 避免过多 render function\n- render里面尽量减少新建变量和bind函数，传递参数是尽量减少传递参数的数量。\n- 尽量将 props 和 state 扁平化，只传递 component 需要的 props（传得太多，或者层次传得太深，都会加重shouldComponentUpdate里面的数据比较负担），慎将 component 当作 props 传入\n\n代码体积优化:\n\n- 使用 babel-plugin-import 优化业务组件的引入，实现按需加载\n- 使用 生产版本\n- 使用 SplitChunksPlugin 拆分公共代码\n- 分析 CSS 和 JS 代码覆盖率\n- 优化 Webpack 中的库\n- 使用动态 import，懒加载 React 组件\n- 使用 webpack-bundle-analyzer 可视化 webpack 输出文件的大小\n- 使用动态 import，懒加载 React 组件\n- 使用 Tree Shaking & 教程 & Tree Shaking 优化\n\n## Vue\n\n1、Vue 组件 data 为什么必须是函数？\n\n> 因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染。\n所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。\n\n2、直接给一个数组项赋值，Vue 能检测到变化吗？\n\n由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。\n\n> Vue 不能检测到以下数组的变动:\n>\n> 1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue\n>\n> 2.当你修改数组的长度时，例如：vm.items.length = newLength\n\n```js\nvm.$set(vm.items, indexOfItem, newValue)\n\nvm.items.splice(newLength)\n```\n\n- 检测不到的原因是什么？\n\n> 当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。\n>\n> 但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的 $set。\n\n3、vue2 中响应式（双向绑定）的原理？vue3 的原理？\nProxy 与 Object.defineProperty 的优劣对比?\n为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？\n\n> Proxy的优势如下:\nProxy 可以直接监听对象而非属性\nProxy 可以直接监听数组的变化\nProxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的\nProxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改\nProxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利\n>\n> Object.defineProperty 的优势如下:\n>\n> 兼容性好,支持 IE9\n\n4、vuex 的工作流程是怎么样？\n\n> Vuex有5个重要的属性，分别是 State、Getter、Mutation、Action、Module，由 view 层发起一个 Action 给 Mutation，在 Mutation 中修改状态，返回新的状态，通过 Getter暴露给 view层的组件或者页面，页面监测到状态改变于是更新页面。\n\n5、 Vue3 有哪些新的新特性？\n\n- 响应式系统\n- 自定义渲染器\n- 全部模块使用 TS 重构\n- Composition API 组合语法\n- 新一代工程化工具 Vite\n\n6、父组件可以监听到子组件的生命周期吗？\n\n比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理。\n\n方法一：手动通过 $emit 触发父组件的事件\n\n```js\n// Parent.vue\n<Child @mounted=\"doSomething\"/>\n    \n// Child.vue\nmounted() {\n  this.$emit(\"mounted\");\n}\n```\n\n方法二：父组件引用子组件时通过 @hook 来监听\n\n```js\n//  Parent.vue\n<Child @hook:mounted=\"doSomething\" ></Child>\n    \n//  Child.vue\nmounted(){\n   console.log('子组件触发 mounted 钩子函数 ...');\n},       \n```\n@hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。\n\n7、比较 Vue 和 React 两个框架，你觉得有哪些区别？\n\n- 监听数据变化的实现原理不同:\n\n    Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化.\n    react 中，数据变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化。\n- 数据流的不同:\n- 模板渲染方式的不同:\n\n8、什么是异步组件？\n\n在声明或注册组件时，Vue 接受提供 Promise 的工厂函数。然后可以在调用该组件时对其进行“解析”。\n\n```js\nnew Vue({\n    components: {\n        ‘tweet-box’: () => import(‘./components/async/TweetBox’)\n    }\n}); \n```\n\n## http\n\n1、HTTP有哪些请求方法？PUT 和 PATCH 有什么区别？\n\n- GET, POST 和 HEAD方法；OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT\n- PUT和PATCH都是更新资源，而PATCH用来对资源进行局部更新。\n\n2、http 状态码 403 是什么错误？\n\n- 403 forbidden，表示对请求资源的访问被服务器拒绝\n\n3、知道哪些 http 的缓存策略 ？控制缓存的请求头有哪些？\n\n- HTTP缓存机制分为强制缓存和协商缓存两类。\n- 强制缓存的意思就是不要问了(不发起请求)，直接用缓存吧。\n- 强制缓存常见技术有Expires和Cache-Control。\n- Expires的值是一个时间，表示这个时间前缓存都有效，都不需要发起请求。\n- Cache-Control有很多属性值，常用属性max-age设置了缓存有效的时间长度，单位为秒，这个时间没到，都不用发起请求。\n- immutable也是Cache-Control的一个属性，表示这个资源这辈子都不用再请求了，但是他兼容性不好，Cache-Control其他属性可以参考MDN的文档。\n- Cache-Control的max-age优先级比Expires高。\n- 协商缓存是为了知道有没有更新，必须跟服务端沟通过才知道的。常见技术有ETag和Last-Modified。\n- ETag其实就是给资源算一个hash值或者版本号，对应的常用request header为If-None-Match。\n- Last-Modified其实就是加上资源修改的时间，对应的常用request header为If-Modified-Since，精度为秒。\n- ETag每次修改都会改变，而Last-Modified的精度只到秒，所以ETag更准确，优先级更高，但是需要计算，所以服务端开销更大。\n- 强制缓存和协商缓存都存在的情况下，先判断强制缓存是否生效，如果生效，不用发起请求，直接用缓存。如果强制缓存不生效再发起请求判断协商缓存。\n\n> Cache-Control，ETag，Last-Modified\n\n## 其他\n\n1、有没有读过哪些源码？\n2、最近开发的项目具体业务是怎么样的？介绍一下？\n\n## Devops 相关\n\n### nginx\n\n1. 谈谈一下对 nginx 的理解，项目中用到 nginx 的哪些功能？\n\n- Nginx ，是一个 Web 服务器和反向代理服务器用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。\n- 主要功能如下：\n    正向、反向代理 2、负载均衡、分流 3、虚拟主机（绑定host）\n\n2、正向代理和反向代理区别是什么？\n\n- 正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定原始服务器，然后代理向原始服务器转交请求并将获得的内容返回给客户端。代理服务器和客户端处于同一个局域网内。\n- 比如说fanqiang。我知道我要访问谷歌，于是我就告诉代理服务器让它帮我转发。\n- 反向代理实际运行方式是代理服务器接受网络上的连接请求。它将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给网络上请求连接的客户端 。代理服务器和原始服务器处于同一个局域网内。\n- 比如说我要访问taobao，对我来说不知道图片、json、css 是不是同一个服务器返回回来的，但是我不关心，是反向代理 处理的，我不知道原始服务器。\n\n3、nginx 如何来实现负载均衡？\n\n负载均衡的5种策略:\n\n```sh\n\n 1.轮询（默认）\n 每个请求按时间顺序逐一分配到不同的后端服务器\n\n upstream backserver {\n    server 192.168.0.14;\n    server 192.168.0.15;\n}\n\n2.weight\n指定轮询几率，weight和访问概率成正比\n\nupstream backserver {\n    server 192.168.0.14 weight=3;\n    server 192.168.0.15 weight=7;\n}\n\n3.ip_hash\n已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的.ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。\n\nupstream backserver {\n    ip_hash;\n    server 192.168.0.14:88;\n    server 192.168.0.15:80;\n}\n\n4.fair\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n\nupstream backserver {\n    server server1;\n    server server2;\n    fair;\n}\n\n5.url_hash\n按访问url的hash结果来分配请求，使每个url定向到同一个（对应的）后端服务器，后端服务器为缓存时比较有效。\n\nupstream backserver {\n    server squid1:3128;\n    server squid2:3128;\n    hash $request_uri;\n    hash_method crc32;\n}\n```\n\n### docker\n\n1、什么是 Docker？\n\n- Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。\n\n2、Dockerfile中最常见的指令是什么？\n\n- FROM：指定基础镜像；LABEL：功能是为镜像指定标签；RUN：运行指定的命令；CMD：容器启动时要运行的命令。\n\n### k8s\n\n1、k8s是什么？请说出你的了解？\n\n- Kubernetes 是一个针对容器应用，进行自动部署，弹性伸缩和管理的开源系统。主要功能是生产环境中的容器编排。\n\n2、k8s 集群里面最小的单位是什么？\n\n- pod 是最小单位。每个pod里边可以运行一个或多个container（容器）\n\n3、Service这种资源对象的作用是什么？\n\n- 用来给相同的多个pod对象提供一个固定的统一访问接口，常用于服务发现和服务访问。\n\n### openstack\n\n1、openstack 里 KeyStone 组件是用于提供什么服务的？Nova 组件是做什么用？\n\n- 认证服务（KeyStone）\nNova – 用于在计算级别管理虚拟机，并在计算或管理程序级别执行其他计算任务。\n\n### linux 基本命令\n\n```sh\nsudo\nls\ncd\nmkdir\nrm\napt-get\ngrep\ncat\n```\n","source":"_posts/2022-02-15-1.md","raw":"---\ntitle: 中高级前端工程师面试题\nindex_img: /img/2022-02-16-1.jpeg\ndate: 2022-02-15 10:39:21\ntags: 面试\ncategories: 面试\n---\n\n# 中高级前端工程师面试题\n\n## 基础\n\n1、浏览器地址栏输入 URL 到页面打开的整个解析过程？\n\n## JS\n\n1、请你讲一下闭包?\n\n> 简单：闭包是有权限访问其他函数作用域内的变量的一个函数。\n>\n> 完整：由于在JS中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之回收，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数——也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后作用域内的值也不会被销毁。\n\n- 闭包解决了什么？\n\n> 由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。以平时使用的Ajax成功回调为例，这里其实就是个闭包，由于上述的特性，回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。开发者不用去写钩子函数来操作上级函数作用域内部的变量了。\n\n- 闭包有哪些应用场景?\n\n> 闭包随处可见，一个Ajax请求的成功回调，一个事件绑定的回调方法，一个setTimeout的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。\n\n2、介绍一下 JS 里面的原型？\n\n> 每个对象都有一个 prototype 属性，就是原型，是一个对象，叫原型对象。\n\n- 原型的作用是什么？\n\n > 共享方法\n\n- 原型中this的指向是什么？\n\n> 原型中this的指向是实例。\n\n- 说一下平时开发使用到 prototype 的例子？\n\n3、如何理解 es6 class 中 constructor 方法？ 和 super的作用？\n\n> constructor 方法是类的构造函数。\n通过 new 命令创建对象实例时，自动调用该方法。\nconstructor 内定义的方法是 实例方法；class 内直接定义的方法是原型方法。\n>\n> super...\n\n4、eventloop\n\n## React\n\n1、介绍一下 Virtual DOM 的工作原理？\n\n> Virtual DOM 是一个轻量级的 JavaScript 对象，它最初只是 real DOM 的副本。它是一个节点树，它将元素、它们的属性和内容作为对象及其属性。 React 的渲染函数从 React 组件中创建一个节点树。然后它响应数据模型中的变化来更新该树，该变化是由用户或系统完成的各种动作引起的。\n\nVirtual DOM 工作过程有三步：\n\n  1. 每当底层数据发生改变时，整个 UI 都将在 Virtual DOM 描述中重新渲染。\n  2. 然后计算之前 DOM 表示与新表示的之间的差异。\n  3. 完成计算后，将只用实际更改的内容更新 real DOM。\n\n2、react 里什么是高阶组件？使用高阶组件的场景？\n\n> 高阶组件(HOC)是接受一个组件并返回一个新组件的函数。\n\n3、React Hooks 解决了哪些问题？\n\n> 在组件之间复用状态逻辑很难;复杂组件变得难以理解\n\n4、说一下 useRef 有哪些用法？\n\n> useRef 除了获取 dom，另一个用法：\n保存数据，不造成 rerender\n想要保存数据，又不想触发函数的更新，该数据的更新不会造成组件 rerender\n\n5、什么情况下使用 useCallback ？\n子组件接收一个方法，避免子组件重复渲染\n\n- react 中只要父组件的 render 了，那么默认情况下就会触发子组的 render，react 提供了来避免这种重渲染的性能开销的一些方法：React.PureComponent、React.memo ，shouldComponentUpdate()\n- 使用 React.memo 避免子组件做没必要的渲染。\n- Reace.memo 只会对 props 做浅比较，也就是父组件重新 render 之后会传入 不同引用的方法 getList，浅比较之后不相等，导致子组件还是依然会渲染。\n- useCallback 缓存一个函数，当依赖没有改变的时候，会一直返回同一个引用\n\n6、useCallback 与 useMemo 作用用来缓存，两者的区别是什么？\n\n> useMemo 缓存值；useCallback 缓存函数\n\n7、 react 项目里做过哪些性能优化？\n\n代码层面：\n\n- 使用return null而不是CSS的display:none来控制节点的显示隐藏。保证同一时间页面的DOM节点尽可能的少。\n- props和state的数据尽可能简单明了，扁平化。\n- 不要使用数组下标作为key\n- 利用 shouldComponentUpdate 和 PureComponent 避免过多 render function\n- render里面尽量减少新建变量和bind函数，传递参数是尽量减少传递参数的数量。\n- 尽量将 props 和 state 扁平化，只传递 component 需要的 props（传得太多，或者层次传得太深，都会加重shouldComponentUpdate里面的数据比较负担），慎将 component 当作 props 传入\n\n代码体积优化:\n\n- 使用 babel-plugin-import 优化业务组件的引入，实现按需加载\n- 使用 生产版本\n- 使用 SplitChunksPlugin 拆分公共代码\n- 分析 CSS 和 JS 代码覆盖率\n- 优化 Webpack 中的库\n- 使用动态 import，懒加载 React 组件\n- 使用 webpack-bundle-analyzer 可视化 webpack 输出文件的大小\n- 使用动态 import，懒加载 React 组件\n- 使用 Tree Shaking & 教程 & Tree Shaking 优化\n\n## Vue\n\n1、Vue 组件 data 为什么必须是函数？\n\n> 因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染。\n所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。\n\n2、直接给一个数组项赋值，Vue 能检测到变化吗？\n\n由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。\n\n> Vue 不能检测到以下数组的变动:\n>\n> 1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue\n>\n> 2.当你修改数组的长度时，例如：vm.items.length = newLength\n\n```js\nvm.$set(vm.items, indexOfItem, newValue)\n\nvm.items.splice(newLength)\n```\n\n- 检测不到的原因是什么？\n\n> 当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。\n>\n> 但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的 $set。\n\n3、vue2 中响应式（双向绑定）的原理？vue3 的原理？\nProxy 与 Object.defineProperty 的优劣对比?\n为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？\n\n> Proxy的优势如下:\nProxy 可以直接监听对象而非属性\nProxy 可以直接监听数组的变化\nProxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的\nProxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改\nProxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利\n>\n> Object.defineProperty 的优势如下:\n>\n> 兼容性好,支持 IE9\n\n4、vuex 的工作流程是怎么样？\n\n> Vuex有5个重要的属性，分别是 State、Getter、Mutation、Action、Module，由 view 层发起一个 Action 给 Mutation，在 Mutation 中修改状态，返回新的状态，通过 Getter暴露给 view层的组件或者页面，页面监测到状态改变于是更新页面。\n\n5、 Vue3 有哪些新的新特性？\n\n- 响应式系统\n- 自定义渲染器\n- 全部模块使用 TS 重构\n- Composition API 组合语法\n- 新一代工程化工具 Vite\n\n6、父组件可以监听到子组件的生命周期吗？\n\n比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理。\n\n方法一：手动通过 $emit 触发父组件的事件\n\n```js\n// Parent.vue\n<Child @mounted=\"doSomething\"/>\n    \n// Child.vue\nmounted() {\n  this.$emit(\"mounted\");\n}\n```\n\n方法二：父组件引用子组件时通过 @hook 来监听\n\n```js\n//  Parent.vue\n<Child @hook:mounted=\"doSomething\" ></Child>\n    \n//  Child.vue\nmounted(){\n   console.log('子组件触发 mounted 钩子函数 ...');\n},       \n```\n@hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。\n\n7、比较 Vue 和 React 两个框架，你觉得有哪些区别？\n\n- 监听数据变化的实现原理不同:\n\n    Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化.\n    react 中，数据变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化。\n- 数据流的不同:\n- 模板渲染方式的不同:\n\n8、什么是异步组件？\n\n在声明或注册组件时，Vue 接受提供 Promise 的工厂函数。然后可以在调用该组件时对其进行“解析”。\n\n```js\nnew Vue({\n    components: {\n        ‘tweet-box’: () => import(‘./components/async/TweetBox’)\n    }\n}); \n```\n\n## http\n\n1、HTTP有哪些请求方法？PUT 和 PATCH 有什么区别？\n\n- GET, POST 和 HEAD方法；OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT\n- PUT和PATCH都是更新资源，而PATCH用来对资源进行局部更新。\n\n2、http 状态码 403 是什么错误？\n\n- 403 forbidden，表示对请求资源的访问被服务器拒绝\n\n3、知道哪些 http 的缓存策略 ？控制缓存的请求头有哪些？\n\n- HTTP缓存机制分为强制缓存和协商缓存两类。\n- 强制缓存的意思就是不要问了(不发起请求)，直接用缓存吧。\n- 强制缓存常见技术有Expires和Cache-Control。\n- Expires的值是一个时间，表示这个时间前缓存都有效，都不需要发起请求。\n- Cache-Control有很多属性值，常用属性max-age设置了缓存有效的时间长度，单位为秒，这个时间没到，都不用发起请求。\n- immutable也是Cache-Control的一个属性，表示这个资源这辈子都不用再请求了，但是他兼容性不好，Cache-Control其他属性可以参考MDN的文档。\n- Cache-Control的max-age优先级比Expires高。\n- 协商缓存是为了知道有没有更新，必须跟服务端沟通过才知道的。常见技术有ETag和Last-Modified。\n- ETag其实就是给资源算一个hash值或者版本号，对应的常用request header为If-None-Match。\n- Last-Modified其实就是加上资源修改的时间，对应的常用request header为If-Modified-Since，精度为秒。\n- ETag每次修改都会改变，而Last-Modified的精度只到秒，所以ETag更准确，优先级更高，但是需要计算，所以服务端开销更大。\n- 强制缓存和协商缓存都存在的情况下，先判断强制缓存是否生效，如果生效，不用发起请求，直接用缓存。如果强制缓存不生效再发起请求判断协商缓存。\n\n> Cache-Control，ETag，Last-Modified\n\n## 其他\n\n1、有没有读过哪些源码？\n2、最近开发的项目具体业务是怎么样的？介绍一下？\n\n## Devops 相关\n\n### nginx\n\n1. 谈谈一下对 nginx 的理解，项目中用到 nginx 的哪些功能？\n\n- Nginx ，是一个 Web 服务器和反向代理服务器用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。\n- 主要功能如下：\n    正向、反向代理 2、负载均衡、分流 3、虚拟主机（绑定host）\n\n2、正向代理和反向代理区别是什么？\n\n- 正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定原始服务器，然后代理向原始服务器转交请求并将获得的内容返回给客户端。代理服务器和客户端处于同一个局域网内。\n- 比如说fanqiang。我知道我要访问谷歌，于是我就告诉代理服务器让它帮我转发。\n- 反向代理实际运行方式是代理服务器接受网络上的连接请求。它将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给网络上请求连接的客户端 。代理服务器和原始服务器处于同一个局域网内。\n- 比如说我要访问taobao，对我来说不知道图片、json、css 是不是同一个服务器返回回来的，但是我不关心，是反向代理 处理的，我不知道原始服务器。\n\n3、nginx 如何来实现负载均衡？\n\n负载均衡的5种策略:\n\n```sh\n\n 1.轮询（默认）\n 每个请求按时间顺序逐一分配到不同的后端服务器\n\n upstream backserver {\n    server 192.168.0.14;\n    server 192.168.0.15;\n}\n\n2.weight\n指定轮询几率，weight和访问概率成正比\n\nupstream backserver {\n    server 192.168.0.14 weight=3;\n    server 192.168.0.15 weight=7;\n}\n\n3.ip_hash\n已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的.ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。\n\nupstream backserver {\n    ip_hash;\n    server 192.168.0.14:88;\n    server 192.168.0.15:80;\n}\n\n4.fair\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n\nupstream backserver {\n    server server1;\n    server server2;\n    fair;\n}\n\n5.url_hash\n按访问url的hash结果来分配请求，使每个url定向到同一个（对应的）后端服务器，后端服务器为缓存时比较有效。\n\nupstream backserver {\n    server squid1:3128;\n    server squid2:3128;\n    hash $request_uri;\n    hash_method crc32;\n}\n```\n\n### docker\n\n1、什么是 Docker？\n\n- Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。\n\n2、Dockerfile中最常见的指令是什么？\n\n- FROM：指定基础镜像；LABEL：功能是为镜像指定标签；RUN：运行指定的命令；CMD：容器启动时要运行的命令。\n\n### k8s\n\n1、k8s是什么？请说出你的了解？\n\n- Kubernetes 是一个针对容器应用，进行自动部署，弹性伸缩和管理的开源系统。主要功能是生产环境中的容器编排。\n\n2、k8s 集群里面最小的单位是什么？\n\n- pod 是最小单位。每个pod里边可以运行一个或多个container（容器）\n\n3、Service这种资源对象的作用是什么？\n\n- 用来给相同的多个pod对象提供一个固定的统一访问接口，常用于服务发现和服务访问。\n\n### openstack\n\n1、openstack 里 KeyStone 组件是用于提供什么服务的？Nova 组件是做什么用？\n\n- 认证服务（KeyStone）\nNova – 用于在计算级别管理虚拟机，并在计算或管理程序级别执行其他计算任务。\n\n### linux 基本命令\n\n```sh\nsudo\nls\ncd\nmkdir\nrm\napt-get\ngrep\ncat\n```\n","slug":"1","published":1,"updated":"2022-02-28T02:50:18.784Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl06jlx3b0012l03l1ypjer70","content":"<h1 id=\"中高级前端工程师面试题\"><a href=\"#中高级前端工程师面试题\" class=\"headerlink\" title=\"中高级前端工程师面试题\"></a>中高级前端工程师面试题</h1><h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><p>1、浏览器地址栏输入 URL 到页面打开的整个解析过程？</p>\n<h2 id=\"JS\"><a href=\"#JS\" class=\"headerlink\" title=\"JS\"></a>JS</h2><p>1、请你讲一下闭包?</p>\n<blockquote>\n<p>简单：闭包是有权限访问其他函数作用域内的变量的一个函数。</p>\n<p>完整：由于在JS中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之回收，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数——也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后作用域内的值也不会被销毁。</p>\n</blockquote>\n<ul>\n<li>闭包解决了什么？</li>\n</ul>\n<blockquote>\n<p>由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。以平时使用的Ajax成功回调为例，这里其实就是个闭包，由于上述的特性，回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。开发者不用去写钩子函数来操作上级函数作用域内部的变量了。</p>\n</blockquote>\n<ul>\n<li>闭包有哪些应用场景?</li>\n</ul>\n<blockquote>\n<p>闭包随处可见，一个Ajax请求的成功回调，一个事件绑定的回调方法，一个setTimeout的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。</p>\n</blockquote>\n<p>2、介绍一下 JS 里面的原型？</p>\n<blockquote>\n<p>每个对象都有一个 prototype 属性，就是原型，是一个对象，叫原型对象。</p>\n</blockquote>\n<ul>\n<li>原型的作用是什么？</li>\n</ul>\n<blockquote>\n<p>共享方法</p>\n</blockquote>\n<ul>\n<li>原型中this的指向是什么？</li>\n</ul>\n<blockquote>\n<p>原型中this的指向是实例。</p>\n</blockquote>\n<ul>\n<li>说一下平时开发使用到 prototype 的例子？</li>\n</ul>\n<p>3、如何理解 es6 class 中 constructor 方法？ 和 super的作用？</p>\n<blockquote>\n<p>constructor 方法是类的构造函数。<br>通过 new 命令创建对象实例时，自动调用该方法。<br>constructor 内定义的方法是 实例方法；class 内直接定义的方法是原型方法。</p>\n<p>super…</p>\n</blockquote>\n<p>4、eventloop</p>\n<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><p>1、介绍一下 Virtual DOM 的工作原理？</p>\n<blockquote>\n<p>Virtual DOM 是一个轻量级的 JavaScript 对象，它最初只是 real DOM 的副本。它是一个节点树，它将元素、它们的属性和内容作为对象及其属性。 React 的渲染函数从 React 组件中创建一个节点树。然后它响应数据模型中的变化来更新该树，该变化是由用户或系统完成的各种动作引起的。</p>\n</blockquote>\n<p>Virtual DOM 工作过程有三步：</p>\n<ol>\n<li>每当底层数据发生改变时，整个 UI 都将在 Virtual DOM 描述中重新渲染。</li>\n<li>然后计算之前 DOM 表示与新表示的之间的差异。</li>\n<li>完成计算后，将只用实际更改的内容更新 real DOM。</li>\n</ol>\n<p>2、react 里什么是高阶组件？使用高阶组件的场景？</p>\n<blockquote>\n<p>高阶组件(HOC)是接受一个组件并返回一个新组件的函数。</p>\n</blockquote>\n<p>3、React Hooks 解决了哪些问题？</p>\n<blockquote>\n<p>在组件之间复用状态逻辑很难;复杂组件变得难以理解</p>\n</blockquote>\n<p>4、说一下 useRef 有哪些用法？</p>\n<blockquote>\n<p>useRef 除了获取 dom，另一个用法：<br>保存数据，不造成 rerender<br>想要保存数据，又不想触发函数的更新，该数据的更新不会造成组件 rerender</p>\n</blockquote>\n<p>5、什么情况下使用 useCallback ？<br>子组件接收一个方法，避免子组件重复渲染</p>\n<ul>\n<li>react 中只要父组件的 render 了，那么默认情况下就会触发子组的 render，react 提供了来避免这种重渲染的性能开销的一些方法：React.PureComponent、React.memo ，shouldComponentUpdate()</li>\n<li>使用 React.memo 避免子组件做没必要的渲染。</li>\n<li>Reace.memo 只会对 props 做浅比较，也就是父组件重新 render 之后会传入 不同引用的方法 getList，浅比较之后不相等，导致子组件还是依然会渲染。</li>\n<li>useCallback 缓存一个函数，当依赖没有改变的时候，会一直返回同一个引用</li>\n</ul>\n<p>6、useCallback 与 useMemo 作用用来缓存，两者的区别是什么？</p>\n<blockquote>\n<p>useMemo 缓存值；useCallback 缓存函数</p>\n</blockquote>\n<p>7、 react 项目里做过哪些性能优化？</p>\n<p>代码层面：</p>\n<ul>\n<li>使用return null而不是CSS的display:none来控制节点的显示隐藏。保证同一时间页面的DOM节点尽可能的少。</li>\n<li>props和state的数据尽可能简单明了，扁平化。</li>\n<li>不要使用数组下标作为key</li>\n<li>利用 shouldComponentUpdate 和 PureComponent 避免过多 render function</li>\n<li>render里面尽量减少新建变量和bind函数，传递参数是尽量减少传递参数的数量。</li>\n<li>尽量将 props 和 state 扁平化，只传递 component 需要的 props（传得太多，或者层次传得太深，都会加重shouldComponentUpdate里面的数据比较负担），慎将 component 当作 props 传入</li>\n</ul>\n<p>代码体积优化:</p>\n<ul>\n<li>使用 babel-plugin-import 优化业务组件的引入，实现按需加载</li>\n<li>使用 生产版本</li>\n<li>使用 SplitChunksPlugin 拆分公共代码</li>\n<li>分析 CSS 和 JS 代码覆盖率</li>\n<li>优化 Webpack 中的库</li>\n<li>使用动态 import，懒加载 React 组件</li>\n<li>使用 webpack-bundle-analyzer 可视化 webpack 输出文件的大小</li>\n<li>使用动态 import，懒加载 React 组件</li>\n<li>使用 Tree Shaking &amp; 教程 &amp; Tree Shaking 优化</li>\n</ul>\n<h2 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h2><p>1、Vue 组件 data 为什么必须是函数？</p>\n<blockquote>\n<p>因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染。<br>所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。</p>\n</blockquote>\n<p>2、直接给一个数组项赋值，Vue 能检测到变化吗？</p>\n<p>由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。</p>\n<blockquote>\n<p>Vue 不能检测到以下数组的变动:</p>\n<p>1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue</p>\n<p>2.当你修改数组的长度时，例如：vm.items.length = newLength</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\">vm.$set(vm.items, indexOfItem, newValue)<br><br>vm.items.splice(newLength)<br></code></pre></div></td></tr></table></figure>\n\n<ul>\n<li>检测不到的原因是什么？</li>\n</ul>\n<blockquote>\n<p>当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。</p>\n<p>但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的 $set。</p>\n</blockquote>\n<p>3、vue2 中响应式（双向绑定）的原理？vue3 的原理？<br>Proxy 与 Object.defineProperty 的优劣对比?<br>为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？</p>\n<blockquote>\n<p>Proxy的优势如下:<br>Proxy 可以直接监听对象而非属性<br>Proxy 可以直接监听数组的变化<br>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的<br>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改<br>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利</p>\n<p>Object.defineProperty 的优势如下:</p>\n<p>兼容性好,支持 IE9</p>\n</blockquote>\n<p>4、vuex 的工作流程是怎么样？</p>\n<blockquote>\n<p>Vuex有5个重要的属性，分别是 State、Getter、Mutation、Action、Module，由 view 层发起一个 Action 给 Mutation，在 Mutation 中修改状态，返回新的状态，通过 Getter暴露给 view层的组件或者页面，页面监测到状态改变于是更新页面。</p>\n</blockquote>\n<p>5、 Vue3 有哪些新的新特性？</p>\n<ul>\n<li>响应式系统</li>\n<li>自定义渲染器</li>\n<li>全部模块使用 TS 重构</li>\n<li>Composition API 组合语法</li>\n<li>新一代工程化工具 Vite</li>\n</ul>\n<p>6、父组件可以监听到子组件的生命周期吗？</p>\n<p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理。</p>\n<p>方法一：手动通过 $emit 触发父组件的事件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Parent.vue</span><br>&lt;Child @mounted=<span class=\"hljs-string\">&quot;doSomething&quot;</span>/&gt;<br>    <br><span class=\"hljs-comment\">// Child.vue</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">mounted</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>  <span class=\"hljs-built_in\">this</span>.$emit(<span class=\"hljs-string\">&quot;mounted&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>方法二：父组件引用子组件时通过 @hook 来监听</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//  Parent.vue</span><br>&lt;Child @hook:mounted=<span class=\"hljs-string\">&quot;doSomething&quot;</span> &gt;&lt;/Child&gt;<br>    <br><span class=\"hljs-comment\">//  Child.vue</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">mounted</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>   <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;子组件触发 mounted 钩子函数 ...&#x27;</span>);<br>&#125;,       <br></code></pre></div></td></tr></table></figure>\n<p>@hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p>\n<p>7、比较 Vue 和 React 两个框架，你觉得有哪些区别？</p>\n<ul>\n<li><p>监听数据变化的实现原理不同:</p>\n<p>  Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化.<br>  react 中，数据变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化。</p>\n</li>\n<li><p>数据流的不同:</p>\n</li>\n<li><p>模板渲染方式的不同:</p>\n</li>\n</ul>\n<p>8、什么是异步组件？</p>\n<p>在声明或注册组件时，Vue 接受提供 Promise 的工厂函数。然后可以在调用该组件时对其进行“解析”。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;<br>    <span class=\"hljs-attr\">components</span>: &#123;<br>        ‘tweet-box’: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">import</span>(‘./components/<span class=\"hljs-keyword\">async</span>/TweetBox’)<br>    &#125;<br>&#125;); <br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"http\"><a href=\"#http\" class=\"headerlink\" title=\"http\"></a>http</h2><p>1、HTTP有哪些请求方法？PUT 和 PATCH 有什么区别？</p>\n<ul>\n<li>GET, POST 和 HEAD方法；OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT</li>\n<li>PUT和PATCH都是更新资源，而PATCH用来对资源进行局部更新。</li>\n</ul>\n<p>2、http 状态码 403 是什么错误？</p>\n<ul>\n<li>403 forbidden，表示对请求资源的访问被服务器拒绝</li>\n</ul>\n<p>3、知道哪些 http 的缓存策略 ？控制缓存的请求头有哪些？</p>\n<ul>\n<li>HTTP缓存机制分为强制缓存和协商缓存两类。</li>\n<li>强制缓存的意思就是不要问了(不发起请求)，直接用缓存吧。</li>\n<li>强制缓存常见技术有Expires和Cache-Control。</li>\n<li>Expires的值是一个时间，表示这个时间前缓存都有效，都不需要发起请求。</li>\n<li>Cache-Control有很多属性值，常用属性max-age设置了缓存有效的时间长度，单位为秒，这个时间没到，都不用发起请求。</li>\n<li>immutable也是Cache-Control的一个属性，表示这个资源这辈子都不用再请求了，但是他兼容性不好，Cache-Control其他属性可以参考MDN的文档。</li>\n<li>Cache-Control的max-age优先级比Expires高。</li>\n<li>协商缓存是为了知道有没有更新，必须跟服务端沟通过才知道的。常见技术有ETag和Last-Modified。</li>\n<li>ETag其实就是给资源算一个hash值或者版本号，对应的常用request header为If-None-Match。</li>\n<li>Last-Modified其实就是加上资源修改的时间，对应的常用request header为If-Modified-Since，精度为秒。</li>\n<li>ETag每次修改都会改变，而Last-Modified的精度只到秒，所以ETag更准确，优先级更高，但是需要计算，所以服务端开销更大。</li>\n<li>强制缓存和协商缓存都存在的情况下，先判断强制缓存是否生效，如果生效，不用发起请求，直接用缓存。如果强制缓存不生效再发起请求判断协商缓存。</li>\n</ul>\n<blockquote>\n<p>Cache-Control，ETag，Last-Modified</p>\n</blockquote>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>1、有没有读过哪些源码？<br>2、最近开发的项目具体业务是怎么样的？介绍一下？</p>\n<h2 id=\"Devops-相关\"><a href=\"#Devops-相关\" class=\"headerlink\" title=\"Devops 相关\"></a>Devops 相关</h2><h3 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h3><ol>\n<li>谈谈一下对 nginx 的理解，项目中用到 nginx 的哪些功能？</li>\n</ol>\n<ul>\n<li>Nginx ，是一个 Web 服务器和反向代理服务器用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。</li>\n<li>主要功能如下：<br>  正向、反向代理 2、负载均衡、分流 3、虚拟主机（绑定host）</li>\n</ul>\n<p>2、正向代理和反向代理区别是什么？</p>\n<ul>\n<li>正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定原始服务器，然后代理向原始服务器转交请求并将获得的内容返回给客户端。代理服务器和客户端处于同一个局域网内。</li>\n<li>比如说fanqiang。我知道我要访问谷歌，于是我就告诉代理服务器让它帮我转发。</li>\n<li>反向代理实际运行方式是代理服务器接受网络上的连接请求。它将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给网络上请求连接的客户端 。代理服务器和原始服务器处于同一个局域网内。</li>\n<li>比如说我要访问taobao，对我来说不知道图片、json、css 是不是同一个服务器返回回来的，但是我不关心，是反向代理 处理的，我不知道原始服务器。</li>\n</ul>\n<p>3、nginx 如何来实现负载均衡？</p>\n<p>负载均衡的5种策略:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\"><br> 1.轮询（默认）<br> 每个请求按时间顺序逐一分配到不同的后端服务器<br><br> upstream backserver &#123;<br>    server 192.168.0.14;<br>    server 192.168.0.15;<br>&#125;<br><br>2.weight<br>指定轮询几率，weight和访问概率成正比<br><br>upstream backserver &#123;<br>    server 192.168.0.14 weight=3;<br>    server 192.168.0.15 weight=7;<br>&#125;<br><br>3.ip_hash<br>已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的.ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。<br><br>upstream backserver &#123;<br>    ip_hash;<br>    server 192.168.0.14:88;<br>    server 192.168.0.15:80;<br>&#125;<br><br>4.fair<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br><br>upstream backserver &#123;<br>    server server1;<br>    server server2;<br>    fair;<br>&#125;<br><br>5.url_hash<br>按访问url的<span class=\"hljs-built_in\">hash</span>结果来分配请求，使每个url定向到同一个（对应的）后端服务器，后端服务器为缓存时比较有效。<br><br>upstream backserver &#123;<br>    server squid1:3128;<br>    server squid2:3128;<br>    <span class=\"hljs-built_in\">hash</span> <span class=\"hljs-variable\">$request_uri</span>;<br>    hash_method crc32;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"docker\"><a href=\"#docker\" class=\"headerlink\" title=\"docker\"></a>docker</h3><p>1、什么是 Docker？</p>\n<ul>\n<li>Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。</li>\n</ul>\n<p>2、Dockerfile中最常见的指令是什么？</p>\n<ul>\n<li>FROM：指定基础镜像；LABEL：功能是为镜像指定标签；RUN：运行指定的命令；CMD：容器启动时要运行的命令。</li>\n</ul>\n<h3 id=\"k8s\"><a href=\"#k8s\" class=\"headerlink\" title=\"k8s\"></a>k8s</h3><p>1、k8s是什么？请说出你的了解？</p>\n<ul>\n<li>Kubernetes 是一个针对容器应用，进行自动部署，弹性伸缩和管理的开源系统。主要功能是生产环境中的容器编排。</li>\n</ul>\n<p>2、k8s 集群里面最小的单位是什么？</p>\n<ul>\n<li>pod 是最小单位。每个pod里边可以运行一个或多个container（容器）</li>\n</ul>\n<p>3、Service这种资源对象的作用是什么？</p>\n<ul>\n<li>用来给相同的多个pod对象提供一个固定的统一访问接口，常用于服务发现和服务访问。</li>\n</ul>\n<h3 id=\"openstack\"><a href=\"#openstack\" class=\"headerlink\" title=\"openstack\"></a>openstack</h3><p>1、openstack 里 KeyStone 组件是用于提供什么服务的？Nova 组件是做什么用？</p>\n<ul>\n<li>认证服务（KeyStone）<br>Nova – 用于在计算级别管理虚拟机，并在计算或管理程序级别执行其他计算任务。</li>\n</ul>\n<h3 id=\"linux-基本命令\"><a href=\"#linux-基本命令\" class=\"headerlink\" title=\"linux 基本命令\"></a>linux 基本命令</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">sudo<br>ls<br><span class=\"hljs-built_in\">cd</span><br>mkdir<br>rm<br>apt-get<br>grep<br>cat<br></code></pre></div></td></tr></table></figure>\n","site":{"data":{}},"wordcount":6733,"excerpt":"","more":"<h1 id=\"中高级前端工程师面试题\"><a href=\"#中高级前端工程师面试题\" class=\"headerlink\" title=\"中高级前端工程师面试题\"></a>中高级前端工程师面试题</h1><h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><p>1、浏览器地址栏输入 URL 到页面打开的整个解析过程？</p>\n<h2 id=\"JS\"><a href=\"#JS\" class=\"headerlink\" title=\"JS\"></a>JS</h2><p>1、请你讲一下闭包?</p>\n<blockquote>\n<p>简单：闭包是有权限访问其他函数作用域内的变量的一个函数。</p>\n<p>完整：由于在JS中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之回收，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数——也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后作用域内的值也不会被销毁。</p>\n</blockquote>\n<ul>\n<li>闭包解决了什么？</li>\n</ul>\n<blockquote>\n<p>由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。以平时使用的Ajax成功回调为例，这里其实就是个闭包，由于上述的特性，回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。开发者不用去写钩子函数来操作上级函数作用域内部的变量了。</p>\n</blockquote>\n<ul>\n<li>闭包有哪些应用场景?</li>\n</ul>\n<blockquote>\n<p>闭包随处可见，一个Ajax请求的成功回调，一个事件绑定的回调方法，一个setTimeout的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。</p>\n</blockquote>\n<p>2、介绍一下 JS 里面的原型？</p>\n<blockquote>\n<p>每个对象都有一个 prototype 属性，就是原型，是一个对象，叫原型对象。</p>\n</blockquote>\n<ul>\n<li>原型的作用是什么？</li>\n</ul>\n<blockquote>\n<p>共享方法</p>\n</blockquote>\n<ul>\n<li>原型中this的指向是什么？</li>\n</ul>\n<blockquote>\n<p>原型中this的指向是实例。</p>\n</blockquote>\n<ul>\n<li>说一下平时开发使用到 prototype 的例子？</li>\n</ul>\n<p>3、如何理解 es6 class 中 constructor 方法？ 和 super的作用？</p>\n<blockquote>\n<p>constructor 方法是类的构造函数。<br>通过 new 命令创建对象实例时，自动调用该方法。<br>constructor 内定义的方法是 实例方法；class 内直接定义的方法是原型方法。</p>\n<p>super…</p>\n</blockquote>\n<p>4、eventloop</p>\n<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><p>1、介绍一下 Virtual DOM 的工作原理？</p>\n<blockquote>\n<p>Virtual DOM 是一个轻量级的 JavaScript 对象，它最初只是 real DOM 的副本。它是一个节点树，它将元素、它们的属性和内容作为对象及其属性。 React 的渲染函数从 React 组件中创建一个节点树。然后它响应数据模型中的变化来更新该树，该变化是由用户或系统完成的各种动作引起的。</p>\n</blockquote>\n<p>Virtual DOM 工作过程有三步：</p>\n<ol>\n<li>每当底层数据发生改变时，整个 UI 都将在 Virtual DOM 描述中重新渲染。</li>\n<li>然后计算之前 DOM 表示与新表示的之间的差异。</li>\n<li>完成计算后，将只用实际更改的内容更新 real DOM。</li>\n</ol>\n<p>2、react 里什么是高阶组件？使用高阶组件的场景？</p>\n<blockquote>\n<p>高阶组件(HOC)是接受一个组件并返回一个新组件的函数。</p>\n</blockquote>\n<p>3、React Hooks 解决了哪些问题？</p>\n<blockquote>\n<p>在组件之间复用状态逻辑很难;复杂组件变得难以理解</p>\n</blockquote>\n<p>4、说一下 useRef 有哪些用法？</p>\n<blockquote>\n<p>useRef 除了获取 dom，另一个用法：<br>保存数据，不造成 rerender<br>想要保存数据，又不想触发函数的更新，该数据的更新不会造成组件 rerender</p>\n</blockquote>\n<p>5、什么情况下使用 useCallback ？<br>子组件接收一个方法，避免子组件重复渲染</p>\n<ul>\n<li>react 中只要父组件的 render 了，那么默认情况下就会触发子组的 render，react 提供了来避免这种重渲染的性能开销的一些方法：React.PureComponent、React.memo ，shouldComponentUpdate()</li>\n<li>使用 React.memo 避免子组件做没必要的渲染。</li>\n<li>Reace.memo 只会对 props 做浅比较，也就是父组件重新 render 之后会传入 不同引用的方法 getList，浅比较之后不相等，导致子组件还是依然会渲染。</li>\n<li>useCallback 缓存一个函数，当依赖没有改变的时候，会一直返回同一个引用</li>\n</ul>\n<p>6、useCallback 与 useMemo 作用用来缓存，两者的区别是什么？</p>\n<blockquote>\n<p>useMemo 缓存值；useCallback 缓存函数</p>\n</blockquote>\n<p>7、 react 项目里做过哪些性能优化？</p>\n<p>代码层面：</p>\n<ul>\n<li>使用return null而不是CSS的display:none来控制节点的显示隐藏。保证同一时间页面的DOM节点尽可能的少。</li>\n<li>props和state的数据尽可能简单明了，扁平化。</li>\n<li>不要使用数组下标作为key</li>\n<li>利用 shouldComponentUpdate 和 PureComponent 避免过多 render function</li>\n<li>render里面尽量减少新建变量和bind函数，传递参数是尽量减少传递参数的数量。</li>\n<li>尽量将 props 和 state 扁平化，只传递 component 需要的 props（传得太多，或者层次传得太深，都会加重shouldComponentUpdate里面的数据比较负担），慎将 component 当作 props 传入</li>\n</ul>\n<p>代码体积优化:</p>\n<ul>\n<li>使用 babel-plugin-import 优化业务组件的引入，实现按需加载</li>\n<li>使用 生产版本</li>\n<li>使用 SplitChunksPlugin 拆分公共代码</li>\n<li>分析 CSS 和 JS 代码覆盖率</li>\n<li>优化 Webpack 中的库</li>\n<li>使用动态 import，懒加载 React 组件</li>\n<li>使用 webpack-bundle-analyzer 可视化 webpack 输出文件的大小</li>\n<li>使用动态 import，懒加载 React 组件</li>\n<li>使用 Tree Shaking &amp; 教程 &amp; Tree Shaking 优化</li>\n</ul>\n<h2 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h2><p>1、Vue 组件 data 为什么必须是函数？</p>\n<blockquote>\n<p>因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染。<br>所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。</p>\n</blockquote>\n<p>2、直接给一个数组项赋值，Vue 能检测到变化吗？</p>\n<p>由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。</p>\n<blockquote>\n<p>Vue 不能检测到以下数组的变动:</p>\n<p>1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue</p>\n<p>2.当你修改数组的长度时，例如：vm.items.length = newLength</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">vm.$set(vm.items, indexOfItem, newValue)<br><br>vm.items.splice(newLength)<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>检测不到的原因是什么？</li>\n</ul>\n<blockquote>\n<p>当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。</p>\n<p>但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的 $set。</p>\n</blockquote>\n<p>3、vue2 中响应式（双向绑定）的原理？vue3 的原理？<br>Proxy 与 Object.defineProperty 的优劣对比?<br>为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？</p>\n<blockquote>\n<p>Proxy的优势如下:<br>Proxy 可以直接监听对象而非属性<br>Proxy 可以直接监听数组的变化<br>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的<br>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改<br>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利</p>\n<p>Object.defineProperty 的优势如下:</p>\n<p>兼容性好,支持 IE9</p>\n</blockquote>\n<p>4、vuex 的工作流程是怎么样？</p>\n<blockquote>\n<p>Vuex有5个重要的属性，分别是 State、Getter、Mutation、Action、Module，由 view 层发起一个 Action 给 Mutation，在 Mutation 中修改状态，返回新的状态，通过 Getter暴露给 view层的组件或者页面，页面监测到状态改变于是更新页面。</p>\n</blockquote>\n<p>5、 Vue3 有哪些新的新特性？</p>\n<ul>\n<li>响应式系统</li>\n<li>自定义渲染器</li>\n<li>全部模块使用 TS 重构</li>\n<li>Composition API 组合语法</li>\n<li>新一代工程化工具 Vite</li>\n</ul>\n<p>6、父组件可以监听到子组件的生命周期吗？</p>\n<p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理。</p>\n<p>方法一：手动通过 $emit 触发父组件的事件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Parent.vue</span><br>&lt;Child @mounted=<span class=\"hljs-string\">&quot;doSomething&quot;</span>/&gt;<br>    <br><span class=\"hljs-comment\">// Child.vue</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">mounted</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>  <span class=\"hljs-built_in\">this</span>.$emit(<span class=\"hljs-string\">&quot;mounted&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>方法二：父组件引用子组件时通过 @hook 来监听</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//  Parent.vue</span><br>&lt;Child @hook:mounted=<span class=\"hljs-string\">&quot;doSomething&quot;</span> &gt;&lt;/Child&gt;<br>    <br><span class=\"hljs-comment\">//  Child.vue</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">mounted</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>   <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;子组件触发 mounted 钩子函数 ...&#x27;</span>);<br>&#125;,       <br></code></pre></td></tr></table></figure>\n<p>@hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p>\n<p>7、比较 Vue 和 React 两个框架，你觉得有哪些区别？</p>\n<ul>\n<li><p>监听数据变化的实现原理不同:</p>\n<p>  Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化.<br>  react 中，数据变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化。</p>\n</li>\n<li><p>数据流的不同:</p>\n</li>\n<li><p>模板渲染方式的不同:</p>\n</li>\n</ul>\n<p>8、什么是异步组件？</p>\n<p>在声明或注册组件时，Vue 接受提供 Promise 的工厂函数。然后可以在调用该组件时对其进行“解析”。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;<br>    <span class=\"hljs-attr\">components</span>: &#123;<br>        ‘tweet-box’: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">import</span>(‘./components/<span class=\"hljs-keyword\">async</span>/TweetBox’)<br>    &#125;<br>&#125;); <br></code></pre></td></tr></table></figure>\n\n<h2 id=\"http\"><a href=\"#http\" class=\"headerlink\" title=\"http\"></a>http</h2><p>1、HTTP有哪些请求方法？PUT 和 PATCH 有什么区别？</p>\n<ul>\n<li>GET, POST 和 HEAD方法；OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT</li>\n<li>PUT和PATCH都是更新资源，而PATCH用来对资源进行局部更新。</li>\n</ul>\n<p>2、http 状态码 403 是什么错误？</p>\n<ul>\n<li>403 forbidden，表示对请求资源的访问被服务器拒绝</li>\n</ul>\n<p>3、知道哪些 http 的缓存策略 ？控制缓存的请求头有哪些？</p>\n<ul>\n<li>HTTP缓存机制分为强制缓存和协商缓存两类。</li>\n<li>强制缓存的意思就是不要问了(不发起请求)，直接用缓存吧。</li>\n<li>强制缓存常见技术有Expires和Cache-Control。</li>\n<li>Expires的值是一个时间，表示这个时间前缓存都有效，都不需要发起请求。</li>\n<li>Cache-Control有很多属性值，常用属性max-age设置了缓存有效的时间长度，单位为秒，这个时间没到，都不用发起请求。</li>\n<li>immutable也是Cache-Control的一个属性，表示这个资源这辈子都不用再请求了，但是他兼容性不好，Cache-Control其他属性可以参考MDN的文档。</li>\n<li>Cache-Control的max-age优先级比Expires高。</li>\n<li>协商缓存是为了知道有没有更新，必须跟服务端沟通过才知道的。常见技术有ETag和Last-Modified。</li>\n<li>ETag其实就是给资源算一个hash值或者版本号，对应的常用request header为If-None-Match。</li>\n<li>Last-Modified其实就是加上资源修改的时间，对应的常用request header为If-Modified-Since，精度为秒。</li>\n<li>ETag每次修改都会改变，而Last-Modified的精度只到秒，所以ETag更准确，优先级更高，但是需要计算，所以服务端开销更大。</li>\n<li>强制缓存和协商缓存都存在的情况下，先判断强制缓存是否生效，如果生效，不用发起请求，直接用缓存。如果强制缓存不生效再发起请求判断协商缓存。</li>\n</ul>\n<blockquote>\n<p>Cache-Control，ETag，Last-Modified</p>\n</blockquote>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>1、有没有读过哪些源码？<br>2、最近开发的项目具体业务是怎么样的？介绍一下？</p>\n<h2 id=\"Devops-相关\"><a href=\"#Devops-相关\" class=\"headerlink\" title=\"Devops 相关\"></a>Devops 相关</h2><h3 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h3><ol>\n<li>谈谈一下对 nginx 的理解，项目中用到 nginx 的哪些功能？</li>\n</ol>\n<ul>\n<li>Nginx ，是一个 Web 服务器和反向代理服务器用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。</li>\n<li>主要功能如下：<br>  正向、反向代理 2、负载均衡、分流 3、虚拟主机（绑定host）</li>\n</ul>\n<p>2、正向代理和反向代理区别是什么？</p>\n<ul>\n<li>正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定原始服务器，然后代理向原始服务器转交请求并将获得的内容返回给客户端。代理服务器和客户端处于同一个局域网内。</li>\n<li>比如说fanqiang。我知道我要访问谷歌，于是我就告诉代理服务器让它帮我转发。</li>\n<li>反向代理实际运行方式是代理服务器接受网络上的连接请求。它将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给网络上请求连接的客户端 。代理服务器和原始服务器处于同一个局域网内。</li>\n<li>比如说我要访问taobao，对我来说不知道图片、json、css 是不是同一个服务器返回回来的，但是我不关心，是反向代理 处理的，我不知道原始服务器。</li>\n</ul>\n<p>3、nginx 如何来实现负载均衡？</p>\n<p>负载均衡的5种策略:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><br> 1.轮询（默认）<br> 每个请求按时间顺序逐一分配到不同的后端服务器<br><br> upstream backserver &#123;<br>    server 192.168.0.14;<br>    server 192.168.0.15;<br>&#125;<br><br>2.weight<br>指定轮询几率，weight和访问概率成正比<br><br>upstream backserver &#123;<br>    server 192.168.0.14 weight=3;<br>    server 192.168.0.15 weight=7;<br>&#125;<br><br>3.ip_hash<br>已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的.ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。<br><br>upstream backserver &#123;<br>    ip_hash;<br>    server 192.168.0.14:88;<br>    server 192.168.0.15:80;<br>&#125;<br><br>4.fair<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br><br>upstream backserver &#123;<br>    server server1;<br>    server server2;<br>    fair;<br>&#125;<br><br>5.url_hash<br>按访问url的<span class=\"hljs-built_in\">hash</span>结果来分配请求，使每个url定向到同一个（对应的）后端服务器，后端服务器为缓存时比较有效。<br><br>upstream backserver &#123;<br>    server squid1:3128;<br>    server squid2:3128;<br>    <span class=\"hljs-built_in\">hash</span> <span class=\"hljs-variable\">$request_uri</span>;<br>    hash_method crc32;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"docker\"><a href=\"#docker\" class=\"headerlink\" title=\"docker\"></a>docker</h3><p>1、什么是 Docker？</p>\n<ul>\n<li>Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。</li>\n</ul>\n<p>2、Dockerfile中最常见的指令是什么？</p>\n<ul>\n<li>FROM：指定基础镜像；LABEL：功能是为镜像指定标签；RUN：运行指定的命令；CMD：容器启动时要运行的命令。</li>\n</ul>\n<h3 id=\"k8s\"><a href=\"#k8s\" class=\"headerlink\" title=\"k8s\"></a>k8s</h3><p>1、k8s是什么？请说出你的了解？</p>\n<ul>\n<li>Kubernetes 是一个针对容器应用，进行自动部署，弹性伸缩和管理的开源系统。主要功能是生产环境中的容器编排。</li>\n</ul>\n<p>2、k8s 集群里面最小的单位是什么？</p>\n<ul>\n<li>pod 是最小单位。每个pod里边可以运行一个或多个container（容器）</li>\n</ul>\n<p>3、Service这种资源对象的作用是什么？</p>\n<ul>\n<li>用来给相同的多个pod对象提供一个固定的统一访问接口，常用于服务发现和服务访问。</li>\n</ul>\n<h3 id=\"openstack\"><a href=\"#openstack\" class=\"headerlink\" title=\"openstack\"></a>openstack</h3><p>1、openstack 里 KeyStone 组件是用于提供什么服务的？Nova 组件是做什么用？</p>\n<ul>\n<li>认证服务（KeyStone）<br>Nova – 用于在计算级别管理虚拟机，并在计算或管理程序级别执行其他计算任务。</li>\n</ul>\n<h3 id=\"linux-基本命令\"><a href=\"#linux-基本命令\" class=\"headerlink\" title=\"linux 基本命令\"></a>linux 基本命令</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">sudo<br>ls<br><span class=\"hljs-built_in\">cd</span><br>mkdir<br>rm<br>apt-get<br>grep<br>cat<br></code></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl06jlx2i0001l03lgp85747h","category_id":"cl06jlx2o0004l03ldttr0o2g","_id":"cl06jlx2u000dl03lb3k902ub"},{"post_id":"cl06jlx2m0003l03l0eezf0v4","category_id":"cl06jlx2t000al03l6fmhbofc","_id":"cl06jlx2u000hl03laehxaxqj"},{"post_id":"cl06jlx2r0007l03ld1ooazb4","category_id":"cl06jlx2u000el03ldvukdtpg","_id":"cl06jlx2v000ll03lad0ae4xk"},{"post_id":"cl06jlx2s0008l03lf61n6kla","category_id":"cl06jlx2u000il03l31tjddg7","_id":"cl06jlx2x000pl03l88fsfe0i"},{"post_id":"cl06jlx2t0009l03la0gthw2t","category_id":"cl06jlx2u000el03ldvukdtpg","_id":"cl06jlx2y000rl03l8np63evh"},{"post_id":"cl06jlx38000tl03leslh4jbo","category_id":"cl06jlx2u000il03l31tjddg7","_id":"cl06jlx3b000zl03l4uad6a28"},{"post_id":"cl06jlx3a000xl03l1umdf853","category_id":"cl06jlx39000ul03l2shb3hga","_id":"cl06jlx3d0013l03l89d61og0"},{"post_id":"cl06jlx35000sl03l9o4e2zh0","category_id":"cl06jlx39000ul03l2shb3hga","_id":"cl06jlx3e0015l03l9du4hbok"},{"post_id":"cl06jlx3b000yl03l8e5c8tlz","category_id":"cl06jlx39000ul03l2shb3hga","_id":"cl06jlx3e0017l03l2x61a6cr"},{"post_id":"cl06jlx3b0012l03l1ypjer70","category_id":"cl06jlx2u000el03ldvukdtpg","_id":"cl06jlx3f001al03lcl114gkx"},{"post_id":"cl06jlx39000wl03lfrm2drg4","category_id":"cl06jlx3b0010l03la3ciadjc","_id":"cl06jlx3f001cl03lf4gt1y9p"}],"PostTag":[{"post_id":"cl06jlx2i0001l03lgp85747h","tag_id":"cl06jlx2p0005l03lcw1z54z5","_id":"cl06jlx2u000cl03lfj2v72bu"},{"post_id":"cl06jlx2m0003l03l0eezf0v4","tag_id":"cl06jlx2t000bl03l19786f4z","_id":"cl06jlx2u000gl03lb47vcv9z"},{"post_id":"cl06jlx2r0007l03ld1ooazb4","tag_id":"cl06jlx2u000fl03l88uz5uir","_id":"cl06jlx2v000kl03l31zh3dkf"},{"post_id":"cl06jlx2s0008l03lf61n6kla","tag_id":"cl06jlx2u000jl03l6s53fwly","_id":"cl06jlx2x000ol03la10v1keo"},{"post_id":"cl06jlx2t0009l03la0gthw2t","tag_id":"cl06jlx2v000nl03lgyv03zpc","_id":"cl06jlx2y000ql03lfu6a6uaf"},{"post_id":"cl06jlx35000sl03l9o4e2zh0","tag_id":"cl06jlx39000vl03l2x4iegwe","_id":"cl06jlx3e0016l03l6y210k5w"},{"post_id":"cl06jlx35000sl03l9o4e2zh0","tag_id":"cl06jlx3b0011l03leaw54ekl","_id":"cl06jlx3e0018l03l2yxl0rj6"},{"post_id":"cl06jlx38000tl03leslh4jbo","tag_id":"cl06jlx3d0014l03l30k0fh7l","_id":"cl06jlx3f001bl03l6ky9gtzr"},{"post_id":"cl06jlx39000wl03lfrm2drg4","tag_id":"cl06jlx3e0019l03lhnyu7k8m","_id":"cl06jlx3f001el03l381d4c87"},{"post_id":"cl06jlx3a000xl03l1umdf853","tag_id":"cl06jlx3b0011l03leaw54ekl","_id":"cl06jlx3g001gl03l7jkn9dbs"},{"post_id":"cl06jlx3b000yl03l8e5c8tlz","tag_id":"cl06jlx3b0011l03leaw54ekl","_id":"cl06jlx3g001il03lggg8hsix"},{"post_id":"cl06jlx3b0012l03l1ypjer70","tag_id":"cl06jlx3g001hl03lg5hmhmnj","_id":"cl06jlx3g001jl03leadj2gce"}],"Tag":[{"name":"Mobx","_id":"cl06jlx2p0005l03lcw1z54z5"},{"name":"webpack","_id":"cl06jlx2t000bl03l19786f4z"},{"name":"前端实习生","_id":"cl06jlx2u000fl03l88uz5uir"},{"name":"Bad&Good","_id":"cl06jlx2u000jl03l6s53fwly"},{"name":"前端","_id":"cl06jlx2v000nl03lgyv03zpc"},{"name":"React","_id":"cl06jlx39000vl03l2x4iegwe"},{"name":"HooK","_id":"cl06jlx3b0011l03leaw54ekl"},{"name":"map","_id":"cl06jlx3d0014l03l30k0fh7l"},{"name":"Vue3","_id":"cl06jlx3e0019l03lhnyu7k8m"},{"name":"面试","_id":"cl06jlx3g001hl03lg5hmhmnj"}]}}