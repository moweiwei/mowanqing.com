{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"source/img/2021-12-01-1.png","path":"img/2021-12-01-1.png","modified":1,"renderable":0},{"_id":"source/img/2021-12-15-1.png","path":"img/2021-12-15-1.png","modified":1,"renderable":0},{"_id":"source/img/2021-12-22-1.png","path":"img/2021-12-22-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-01-1.jpeg","path":"img/2022-01-01-1.jpeg","modified":1,"renderable":0},{"_id":"source/img/2022-01-13-1.png","path":"img/2022-01-13-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-14-1.png","path":"img/2022-01-14-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-14-2.png","path":"img/2022-01-14-2.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-14-3.png","path":"img/2022-01-14-3.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-22-1.jpeg","path":"img/2022-01-22-1.jpeg","modified":1,"renderable":0},{"_id":"source/img/2022-01-24-1.png","path":"img/2022-01-24-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-24-2.png","path":"img/2022-01-24-2.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-24-3.png","path":"img/2022-01-24-3.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-24-4.png","path":"img/2022-01-24-4.png","modified":1,"renderable":0},{"_id":"source/img/2022-02-06-1.png","path":"img/2022-02-06-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-02-08-1.jpeg","path":"img/2022-02-08-1.jpeg","modified":1,"renderable":0},{"_id":"source/img/2022-02-16-1.jpeg","path":"img/2022-02-16-1.jpeg","modified":1,"renderable":0},{"_id":"source/img/2022-02-22-1.jpeg","path":"img/2022-02-22-1.jpeg","modified":1,"renderable":0},{"_id":"source/img/2022-03-07-1.png","path":"img/2022-03-07-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-03-16-1.png","path":"img/2022-03-16-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-03-20-1.webp","path":"img/2022-03-20-1.webp","modified":1,"renderable":0},{"_id":"source/img/2022-04-07-1.png","path":"img/2022-04-07-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-04-14-1.png","path":"img/2022-04-14-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-04-18-1.png","path":"img/2022-04-18-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-04-29-1.png","path":"img/2022-04-29-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-04-29-2.png","path":"img/2022-04-29-2.png","modified":1,"renderable":0},{"_id":"source/img/2022-04-29-3.png","path":"img/2022-04-29-3.png","modified":1,"renderable":0},{"_id":"source/img/2022-04-30-2.png","path":"img/2022-04-30-2.png","modified":1,"renderable":0},{"_id":"source/img/2022-05-01-1.png","path":"img/2022-05-01-1.png","modified":1,"renderable":0},{"_id":"source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":0},{"_id":"source/img/default.jpg","path":"img/default.jpg","modified":1,"renderable":0},{"_id":"source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":0},{"_id":"source/img/index-img.png","path":"img/index-img.png","modified":1,"renderable":0},{"_id":"source/img/miaomiao.JPG","path":"img/miaomiao.JPG","modified":1,"renderable":0},{"_id":"source/img/about/1.JPG","path":"img/about/1.JPG","modified":1,"renderable":0},{"_id":"source/img/about/2.png","path":"img/about/2.png","modified":1,"renderable":0},{"_id":"source/img/about/3.png","path":"img/about/3.png","modified":1,"renderable":0},{"_id":"source/img/about/4.jpg","path":"img/about/4.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/_drafts/1.大厂面试题.md","hash":"fd4284b048aafa13541be933b82d187970e30f14","modified":1661221163470},{"_id":"source/.DS_Store","hash":"50d1825e933d74f89492175ccb19c6b1e8760b3b","modified":1652929996056},{"_id":"source/_drafts/0.实习生前端工程师面试题.md","hash":"55c34a212c304e3c773cb80003e54a24b3f4c6fb","modified":1661221163471},{"_id":"source/_drafts/2.每日 3+1.md","hash":"a0633e0c3119497eedc6fc5c3312cfe27acc1d33","modified":1661221163472},{"_id":"source/_drafts/3.优秀文章合集.md","hash":"7bdfef7060bed605082e00bf0d4799091a2e6b47","modified":1651242217177},{"_id":"source/_drafts/4.Mobx 原理分析.md","hash":"42c5d20f744fb4925dfdf62752a7e3c441812c91","modified":1661221163473},{"_id":"source/_drafts/7.React + TypeScript.md","hash":"dec201cf295fe29d60655a8edf8eabbc5c6684fc","modified":1661221163469},{"_id":"source/_drafts/5.Webpack 原理分析.md","hash":"f31d636ace044498e854a9b077ea0434a868c1db","modified":1661221163469},{"_id":"source/_posts/0.前端工程师面试题.md","hash":"06e79f908417687f54ba95bc14793ceb258f42e2","modified":1661221163468},{"_id":"source/_posts/10.React 中常用 TS 类型.md","hash":"deefaa8ff5da75dd82af1f01e4a23f341e158465","modified":1650016738516},{"_id":"source/_posts/1.FE-Interview.md","hash":"ce9f8928917f639046377e5973f82c482b3b9243","modified":1661221163471},{"_id":"source/_posts/11.React Hooks 之 useEffect.md","hash":"04dbd9538ea132eedf3c6080b046b3f8215308bd","modified":1661221163472},{"_id":"source/_posts/14.Antd 源码分析之 useMountMergeState.md","hash":"3aa3814858bc75412ba3f2e94418eab8bc062f2a","modified":1661221163474},{"_id":"source/_posts/15.常用 hooks 分析.md","hash":"ae705130a047729dced78cd7295717ef0c772d6f","modified":1661221163473},{"_id":"source/_posts/13.Antd 源码分析之 useMergedState.md","hash":"3d48e961cddf3456f9556b7e7b6a4690d85cefb2","modified":1661221163472},{"_id":"source/_posts/12.React Hooks 之 useCallback.md","hash":"18bdeb9de9afa68004cf9b2fcf9183aa0d5dc826","modified":1661221163470},{"_id":"source/_posts/2.日常使用的容器镜像操作命令.md","hash":"4a545a1fba32b2e52d8a2a5ff5ab54f662499874","modified":1661221163470},{"_id":"source/_posts/16.Antd 源码分析之 useFetchData.md","hash":"4ca7892d3b402859dee763ab3bd5e0b9e23108a7","modified":1661221163473},{"_id":"source/_posts/3.使用 useRef 跨生命周期保存变量.md","hash":"fefbd1dc673760bec2a5a04901ce02e58f4f8814","modified":1661221163470},{"_id":"source/_posts/4.useState 引用类型数据更新不触发重新渲染问题.md","hash":"409b366aacddcc28247cf2d0c42cd052f872a04a","modified":1661221163471},{"_id":"source/_posts/5.如何在 class 组件中使用 hooks.md","hash":"e3874d0e529cf24b0ce5498be262a04a4a8e1f8a","modified":1661221163469},{"_id":"source/_posts/6.map 到底改不改变原数组.md","hash":"6d168e7c2ff0d1223827995e601fb8ca8fd82e06","modified":1661221163468},{"_id":"source/_posts/17.utils 工具函数.md","hash":"57ae13929606891097ff2dc58bf6c69bc3996861","modified":1651453163308},{"_id":"source/_posts/18.React Hooks 之闭包.md","hash":"b80d7f07535f990daf1912273541c5692a0e0d93","modified":1651714335422},{"_id":"source/_posts/8.VS Code 配置.md","hash":"57604cf3e21d132ebc064adfacd42a27470e9d80","modified":1661221163472},{"_id":"source/_posts/7.Vue3 学习笔记.md","hash":"0b606da58266e415eaaca51353353af4c02320e6","modified":1661221163470},{"_id":"source/about/index.md","hash":"5fb6e1e37b794b28b983b4f55ecb355bc6c58d69","modified":1661221163468},{"_id":"source/css/custom.css","hash":"f24fec7800ead60a19749e06b7f7f64c00a4633d","modified":1645772214842},{"_id":"source/_posts/9.TypeScript 笔记.md","hash":"2485a0a287632f3e36434b2bb140aedba3b53a6c","modified":1661221163474},{"_id":"source/img/.DS_Store","hash":"257b78747eb849d52d717ad6bc77278a12be0bac","modified":1652929996803},{"_id":"source/img/2021-12-01-1.png","hash":"62808e649d5dd5c68db4bad0bc894d3e8158e784","modified":1646102636847},{"_id":"source/img/2021-12-15-1.png","hash":"0bb7c1fe8c45832813e1b155a1b93859bdb64d6c","modified":1646015938987},{"_id":"source/img/2022-01-13-1.png","hash":"ca711c0f3099cc42172cb5b0e72a322d7f6d3eae","modified":1646015981781},{"_id":"source/img/2022-01-14-2.png","hash":"1b573758b98a28cb7b9f276413152c4ff826ea38","modified":1646016169557},{"_id":"source/img/2022-01-14-1.png","hash":"457563e3b79c3c5f22d065b8bb966b58ed413e77","modified":1646016128450},{"_id":"source/img/2022-01-24-1.png","hash":"7cac7a9aef2c512af1e8b8b1cc8a8b20cac94745","modified":1646016262776},{"_id":"source/img/2022-01-01-1.jpeg","hash":"637bfc4c59e0448a36da0992dab88b32449bacc2","modified":1646014956663},{"_id":"source/img/2022-01-22-1.jpeg","hash":"104465a44f28ae47be6bb42740896883fc6e9d97","modified":1646016233814},{"_id":"source/img/2022-01-14-3.png","hash":"038e34cdfb8ee37c9b12ce22a931c3f54b765756","modified":1646016196232},{"_id":"source/img/2022-01-24-2.png","hash":"6fa5684418ffd50020153e1173830e3d8ee71327","modified":1646016305143},{"_id":"source/img/2022-01-24-3.png","hash":"30f86b353805b575ed8516fccb258143fa79d01e","modified":1646016394604},{"_id":"source/img/2022-02-06-1.png","hash":"86b9a8a41e2c853053e909387d6ec33e4877366b","modified":1647477386463},{"_id":"source/img/2022-02-08-1.jpeg","hash":"3e4ed33f30d6f54d5bf437062ec55c6348a4fc66","modified":1646016830499},{"_id":"source/img/2022-01-24-4.png","hash":"868d8a69b778000e352ab17d22aa72c3b8eed312","modified":1646016437004},{"_id":"source/img/2022-02-22-1.jpeg","hash":"e34dc1856ace7e149c338048fbc92d21d21d8cd1","modified":1646016746310},{"_id":"source/img/2022-02-16-1.jpeg","hash":"c049a498846cbc8d2bf6e45be0b43c97fd3d9edf","modified":1646016606165},{"_id":"source/img/2022-03-16-1.png","hash":"3836172c33012b8886c54ed062bc0857e8cca93e","modified":1647445910122},{"_id":"source/img/2022-03-20-1.webp","hash":"f95a32645c06b594bf0e9e8d01cba118f9a6caa8","modified":1647768265159},{"_id":"source/img/2022-03-07-1.png","hash":"563d429ae97eac009674098dd57517551c37e03f","modified":1647445868249},{"_id":"source/img/2022-04-07-1.png","hash":"22a729b5064126094b4985f989b3f402ed8f1286","modified":1649342157397},{"_id":"source/img/2022-04-29-3.png","hash":"0e6b740160ccc23df17c8c0867b84e7188feb7be","modified":1651456307541},{"_id":"source/img/avatar.png","hash":"7ba2b5e584fdcff16ac464c31012e0717df0e154","modified":1642143447663},{"_id":"source/img/favicon.png","hash":"7ba2b5e584fdcff16ac464c31012e0717df0e154","modified":1642143447663},{"_id":"source/js/custom.js","hash":"038c6dc73f8c0638456353e0f56e57b99cefb1be","modified":1646647368657},{"_id":"source/img/miaomiao.JPG","hash":"60b94fd56002070d8be535b35adfef67f0b4be6c","modified":1642146142925},{"_id":"source/img/2021-12-22-1.png","hash":"023912be2857823f083116c0bb43078f83cb9c2a","modified":1646014018177},{"_id":"source/img/2022-04-18-1.png","hash":"0525d8a00579950752409c5c23d4b046f97ce5f6","modified":1650250230589},{"_id":"source/img/2022-04-29-2.png","hash":"77fe8e98341fcf7f46f04c2cb336b8e557dc121c","modified":1651457381123},{"_id":"source/img/about/1.JPG","hash":"5ef7106f2c124a0d5066407e1972927b885eff2f","modified":1652928729048},{"_id":"source/_posts/0_1前端工程师面试题2-md.md","hash":"1be6caa89ae7036a165822e6130e8df90bd5f745","modified":1661222068755},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"source/img/2022-04-29-1.png","hash":"11a197e18f9d8f6335c5976855764388c7246a71","modified":1651456916472},{"_id":"source/img/2022-05-01-1.png","hash":"fed31ed0ab7d71b0cc185f228818764a275ab22f","modified":1651416258528},{"_id":"source/img/index-img.png","hash":"f7314828a14a3e236deecbe33816f99d0f65c5cf","modified":1646016966643},{"_id":"node_modules/hexo-theme-fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"df5b54be535593d5442cebafbea34eb9bd69b987","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"ee5f90b4642735bb42161c389e4b86b00bc4fac5","modified":1642149993961},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"03cfa8e5f149514b57ef80dcb84eb7fea261370d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README_en.md","hash":"ca8fd19a4948de1f253616a62c0e8a7d81f692f5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"8a7f1534c228538e2ab56249d5a65829650170ed","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"13a6a799415fc2f6f69ebd1a399fb44426a5d641","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a0c7984495d4f2d33b64adfa33adebbf768a5ac3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"1a6d415446da11dee5c5f400e7d67544fbe743ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"ad6fed7b646d3ca961db83db0fbe020e3a5d42ad","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"472d0813ca5b88000a7bc6039f33b7e27b5a3216","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"58291dfec65c36889dfce0ddc603540b67e4c598","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"f3ae4395e751c4a02d5895e07856b1e8edfdda08","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"20c2a195a109d2a263b5fa6e79cbcc62932508ad","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7f566edf750241e62d7c54abfbb0c504fdab850a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"0ad89eb7c92a822980fa9a85285e6d94ad845d1d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"2a7b49f0f9aecf07550b5a0b99242aab5654cf2b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"1014b901d396f4fc445cb1ffc938d5380d894d71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"79e3679a7069351a6172c281b9d09f59d7580484","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"16d33eb89ecf90f4046720fde5395d972c7ba1fd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"af977ed0792508bb0766ea8afe82d34ef1e8fb3c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/beian.ejs","hash":"58b4bbe36386de4305a8da5ffd7d56802df23049","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/archive-list.ejs","hash":"53a4f6029373a40394a87aba9284696a71610f90","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/css.ejs","hash":"c363829a4b80f74fc1c565e41f6dab41c95006ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/footer.ejs","hash":"a62278c38a310da495d96c39abacacef266945cb","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/head.ejs","hash":"f7f3494ed001e8cdcdc3e8a1d2cd1195cff2ded5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/post-meta.ejs","hash":"32a17edadeed40da6db21d2d8031bd47d2fc9bf4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/nav.ejs","hash":"e71b3c4aa263163597d31b1f91e5a1a877084cfd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/scripts.ejs","hash":"0ee838b6fcd895d21a29d9d67dbb99b752d623d1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/toc.ejs","hash":"3d2fb5552f373e5a0c56bc356702d807bcbcb411","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"44faef3e77ab08b91e4c5c6f1cd9087a9faff443","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"6c37e9f1ac1d6d00b3c32794e02e244dba942cd9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"649457796374c79e49a19bd541e4ad8e78fe8995","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"cde964c8cd3217268a231de5e018a62c53c2e047","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"3aa5b4ea879cd34d3a32468d88da18d72cbcc8e0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"b917b893b1777e6ffcb53188f9f5644510e5f20d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"f1fdd512f3ef92ff5db4a49f5a3143d5ddea9858","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"53987b7a668ea0623370eb83ed5311766221b557","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"633f0142c657805359b0197f287e12ae4bcde731","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"d058f30bd09b28769c4d8313428ff23dfc8d52dd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"4a43f2700e91937650bef511fd438825b001c4c6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/twikoo.ejs","hash":"1af53bc0be642610a3a4d4e7c05287854a821508","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/valine.ejs","hash":"4052ab2a8f78efa92f0fe17abe8f66135943390a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/utterances.ejs","hash":"e1ed6530dfd7310f91060a75766a93ac3c39be3a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/waline.ejs","hash":"21e00443054802e893aac1f668b69d5bb4b39b3a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/math.ejs","hash":"df6941bd3b860180d01fd39ee859ed2d42f4d1f0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"b5fd5a2d9c463eb59318af0f47c591c485b6ad27","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/typed.ejs","hash":"e8e01c5db46b383748855452aecd70fcda99f598","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"28e186c32576eb3d5d923273471a001c47fe8071","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"fd5fcb6a61ad865197a778eeae889b80484227dd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"c1db1a4f9eca6e36b660530641e3a4fb6a30c8d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"08b455b848b21d57e0563b87071c4bae2b63bafe","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"c2d8bfd04bf0734b387c049402b46a06a05fc582","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"80098e8354069631bde8edcd1181a53091a92949","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"d547ab0b91f84eb0acd0bc0c5d716ce17c30361a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/rewrite.styl","hash":"a2993f23701de9a83e3f428300e62c5c52b4ff4b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"616c1f7147078c3d532dd1cfd2af09c0c3a816f0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"7e32a3268accf3d524209c213e15e2d5d5e2e1a6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/tag_plugin.styl","hash":"b89b96c8a6a433a6f372b42710554b05cab85a24","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post.styl","hash":"5e86487de0f16c30ca3e16460ab94b57620e31c5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"30f8fab95a5214d79df0ccc02b937df8bd885676","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"9f932ca3f9625c13aa5353f58319881e62c0c653","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"0ce7552dc4993926426019398d73e817cfd841a1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"d8011325756eb6e4ce619b3e7b4d6d80c2de8a57","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"55e10a6965462f8f62f85e75fd5e143af02a4b44","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":499162500000},{"_id":"source/img/2022-04-14-1.png","hash":"dc1114f39492c5587c84f855a3be5fe8cbf7e537","modified":1651539987201},{"_id":"source/img/default.jpg","hash":"d48e1d1c2a174a0286776448c0e74f95aaa5fa5e","modified":1645520847967},{"_id":"source/img/2022-04-30-2.png","hash":"7db617903908bdc688f6b8e13f15ae02fbfd008d","modified":1651422319598},{"_id":"source/img/about/4.jpg","hash":"5e6229797fe84190ad334237e0e8a6bb29ba5a05","modified":1652930146311},{"_id":"source/img/about/3.png","hash":"6c7cf3a59b617bdea67548bad1b634b9746c245a","modified":1652928766517},{"_id":"source/img/about/2.png","hash":"6b760a31252392d54c9ba548ee2a1e3dd25d621e","modified":1652928767845},{"_id":"public/js/custom.js","hash":"038c6dc73f8c0638456353e0f56e57b99cefb1be","modified":1661222087938},{"_id":"public/css/custom.css","hash":"f24fec7800ead60a19749e06b7f7f64c00a4633d","modified":1661222087938},{"_id":"public/baidusitemap.xml","hash":"1b572058bb99d866a724aff624f2649e0084554e","modified":1661222087938},{"_id":"public/atom.xml","hash":"ab8c86fe2d4d8ee491e87f6d47f45944c290970c","modified":1661222087938},{"_id":"public/sitemap.xml","hash":"6100a4712ac937e0c652f4a0dda48c27502a3f99","modified":1661222087938},{"_id":"public/local-search.xml","hash":"5e54f5d00cbff5ca0a92f1004ada4bd40c519d8e","modified":1661222087938},{"_id":"public/about/index.html","hash":"67e19dfcc9262621e2631528fdb507f2d885a96b","modified":1661222087938},{"_id":"public/archives/index.html","hash":"3ed6fc948298734aa392d584526e601065e432d9","modified":1661222087938},{"_id":"public/archives/page/2/index.html","hash":"7fb61fddb06713b48abb008ba105b4f05bab55cf","modified":1661222087938},{"_id":"public/archives/2021/index.html","hash":"4a3a7dea34e1fca57d905af9ca99ffa6aac7650c","modified":1661222087938},{"_id":"public/archives/2021/12/index.html","hash":"0f87865f8f29e1bb4a25f9a81485bccabb8292da","modified":1661222087938},{"_id":"public/archives/2022/index.html","hash":"6d39f6870136ec0167d477357e439a396954a6b7","modified":1661222087938},{"_id":"public/archives/2022/page/2/index.html","hash":"2be7b1df27f6e6b012878b8dc00c61ec0ecfb86f","modified":1661222087938},{"_id":"public/archives/2022/01/index.html","hash":"4b03d0d24468cc748c2caff92d3a199908ccd4a5","modified":1661222087938},{"_id":"public/archives/2022/02/index.html","hash":"34ba39eedc59b33866114d2a00872b9ff499f5d4","modified":1661222087938},{"_id":"public/archives/2022/03/index.html","hash":"278f6955522db9be30a1006fb1b69e487de59bb0","modified":1661222087938},{"_id":"public/archives/2022/04/index.html","hash":"98f6bd7e2541f43a2b3618168f5f152e981158e0","modified":1661222087938},{"_id":"public/archives/2022/05/index.html","hash":"f5948c96b1dd1754d92798d8cd4c497738db563c","modified":1661222087938},{"_id":"public/categories/面试/index.html","hash":"234b88f2e7ddbfd90bb6b5e5a71906437faef942","modified":1661222087938},{"_id":"public/categories/React/index.html","hash":"e068ef32a180f10c6668e8e200c0132a3e1661d2","modified":1661222087938},{"_id":"public/categories/React-Hook/index.html","hash":"b79f4b1f9b5f2eb9ea98b52023036fa193e8fed8","modified":1661222087938},{"_id":"public/categories/JS/index.html","hash":"ab889d12fb1040e49878ee4c29f7a8b175b93f5a","modified":1661222087938},{"_id":"public/categories/vscode/index.html","hash":"6d92ad604f533529392bd7178c1334ca6852b0f9","modified":1661222087938},{"_id":"public/categories/Vue/index.html","hash":"c577bfd40540919f0ffaae803dd6d144650f19bd","modified":1661222087938},{"_id":"public/categories/TypeScript/index.html","hash":"e83f4447c8c45122a3f7655e5ac8ca0c82d99047","modified":1661222087938},{"_id":"public/tags/前端/index.html","hash":"e971e5dc46a2dae4281544863d5bfb4cac05c30a","modified":1661222087938},{"_id":"public/tags/React-TypeScript/index.html","hash":"c85bf743fa38252515f97c3aa4916746f7c0a255","modified":1661222087938},{"_id":"public/tags/useEffect/index.html","hash":"40b044b654563062e536cd3481e9eac90b3d65d4","modified":1661222087938},{"_id":"public/tags/useCallback/index.html","hash":"c8ddb4729531fc127238a7ee00879bb762a05c53","modified":1661222087938},{"_id":"public/tags/Hook/index.html","hash":"e867da4f9877b63fe36c6d27a66544bc1bce98e1","modified":1661222087938},{"_id":"public/tags/utils/index.html","hash":"acc19d0b15cdec9e5a4321ecefa880613486b175","modified":1661222087938},{"_id":"public/tags/闭包/index.html","hash":"a7be1f4cfc576a42594baf6cd10371635f83d9bb","modified":1661222087938},{"_id":"public/tags/React/index.html","hash":"af710120613626ca66b952164c9d4c9771b4f259","modified":1661222087938},{"_id":"public/tags/HooK/index.html","hash":"d194ed7310c7903efd0a3c67b7448cc1862e6503","modified":1661222087938},{"_id":"public/tags/map/index.html","hash":"dcbdf4140d9487f7d260bdce707c68021e81788d","modified":1661222087938},{"_id":"public/tags/vscode/index.html","hash":"da90907095c9152e1d0a30a130f93d781d8fef4b","modified":1661222087938},{"_id":"public/tags/Vue3/index.html","hash":"447e1a3b8ca1433047084e6e7e0509b500ad4568","modified":1661222087938},{"_id":"public/tags/TypeScript/index.html","hash":"6d7d16a3dc36a6834f6483980780927edcb50eb4","modified":1661222087938},{"_id":"public/404.html","hash":"7593add168bbbd4bbd5399e701f96405fa68715d","modified":1661222087938},{"_id":"public/tags/index.html","hash":"140b188bd1ad5ffecc2994c104834ac2379e1749","modified":1661222087938},{"_id":"public/links/index.html","hash":"074a93b33f617a3e507b3c89a04a37a2f34913ad","modified":1661222087938},{"_id":"public/posts/c7d2847c/index.html","hash":"f07268a143fd73972dc3a7f78559e3635276d483","modified":1661222087938},{"_id":"public/posts/8cb39ba1/index.html","hash":"1b0544766fe880300cc9b0d0f29740482e1d99ca","modified":1661222087938},{"_id":"public/posts/e509b107/index.html","hash":"81a305b1ed915a9e7b432a285e8b4c61f0c15ae4","modified":1661222087938},{"_id":"public/posts/f806f23d/index.html","hash":"a53f1d0be74d67907b5b74d84882b8d252f46d65","modified":1661222087938},{"_id":"public/posts/e6886795/index.html","hash":"736b7d174cf31835e786ec3e376df77d76a1d55b","modified":1661222087938},{"_id":"public/posts/b3515e96/index.html","hash":"4333f1c46fa721c8f08de34f799c915b7042b1fd","modified":1661222087938},{"_id":"public/posts/44dd3b46/index.html","hash":"e381115fbfb9ef33253e979ce0943011bc142203","modified":1661222087938},{"_id":"public/posts/0/index.html","hash":"20a5b42b15dbadde29ea0ec9b2861203b81812b7","modified":1661222087938},{"_id":"public/posts/25e26362/index.html","hash":"01d0b133720c0475e5ba4c133d67c4e480712473","modified":1661222087938},{"_id":"public/posts/81dvefb9/index.html","hash":"0ce0b5e0b8883bde6c2a8012a37f5ca4e30e7ad3","modified":1661222087938},{"_id":"public/posts/a18c0ac9/index.html","hash":"37bf2f6126d5e5a1f20e7c64a9eff91c0a8cdccc","modified":1661222087938},{"_id":"public/posts/vdfge343/index.html","hash":"f315add535b3db251f8e407119f52d7b32d46293","modified":1661222087938},{"_id":"public/posts/1ad5be0d/index.html","hash":"62caec0958707f1501e8f2990e9c953b53b9c4e5","modified":1661222087938},{"_id":"public/posts/e372be48/index.html","hash":"8de0ca2dda84259c600572b1b9059239ae17eadc","modified":1661222087938},{"_id":"public/posts/d177e434/index.html","hash":"709c9aa64274bb867ace651d521f3387faea3c8b","modified":1661222087938},{"_id":"public/posts/ee7a9294/index.html","hash":"b2322417d4841394dd02be71a45e41bb3bfad39b","modified":1661222087938},{"_id":"public/posts/b195fb80/index.html","hash":"340ceb359f645a00cbc41ef9dfe08907b3a921f8","modified":1661222087938},{"_id":"public/posts/bb88c12/index.html","hash":"1cb2b6e6423a2fc7c8a141fabeb3e1b33dd662f6","modified":1661222087938},{"_id":"public/posts/12d2438b/index.html","hash":"53b81eb4bac3c062096c248d5885c288a7dc3699","modified":1661222087938},{"_id":"public/posts/25d325e2/index.html","hash":"a189ac453dee738e86cd33e148ed3ec34d8078a1","modified":1661222087938},{"_id":"public/index.html","hash":"1af1dd28f2a766d22a3460f2c8c9f4b90586c2f3","modified":1661222087938},{"_id":"public/page/2/index.html","hash":"bd17e36aa6d40dd83bf4d84aba5c68db0fe2e3ae","modified":1661222087938},{"_id":"public/categories/index.html","hash":"530b387ef46ce62987e2e946c90925de747e3a78","modified":1661222087938},{"_id":"public/img/avatar.png","hash":"7ba2b5e584fdcff16ac464c31012e0717df0e154","modified":1661222087938},{"_id":"public/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1661222087938},{"_id":"public/img/favicon.png","hash":"7ba2b5e584fdcff16ac464c31012e0717df0e154","modified":1661222087938},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1661222087938},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1661222087938},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1661222087938},{"_id":"public/img/2021-12-15-1.png","hash":"0bb7c1fe8c45832813e1b155a1b93859bdb64d6c","modified":1661222087938},{"_id":"public/img/2021-12-01-1.png","hash":"62808e649d5dd5c68db4bad0bc894d3e8158e784","modified":1661222087938},{"_id":"public/img/2022-01-01-1.jpeg","hash":"637bfc4c59e0448a36da0992dab88b32449bacc2","modified":1661222087938},{"_id":"public/img/2022-01-13-1.png","hash":"ca711c0f3099cc42172cb5b0e72a322d7f6d3eae","modified":1661222087938},{"_id":"public/img/2022-01-14-1.png","hash":"457563e3b79c3c5f22d065b8bb966b58ed413e77","modified":1661222087938},{"_id":"public/img/2022-01-14-3.png","hash":"038e34cdfb8ee37c9b12ce22a931c3f54b765756","modified":1661222087938},{"_id":"public/img/2022-01-14-2.png","hash":"1b573758b98a28cb7b9f276413152c4ff826ea38","modified":1661222087938},{"_id":"public/img/2022-01-22-1.jpeg","hash":"104465a44f28ae47be6bb42740896883fc6e9d97","modified":1661222087938},{"_id":"public/img/2022-01-24-1.png","hash":"7cac7a9aef2c512af1e8b8b1cc8a8b20cac94745","modified":1661222087938},{"_id":"public/img/2022-01-24-2.png","hash":"6fa5684418ffd50020153e1173830e3d8ee71327","modified":1661222087938},{"_id":"public/img/2022-01-24-3.png","hash":"30f86b353805b575ed8516fccb258143fa79d01e","modified":1661222087938},{"_id":"public/img/2022-01-24-4.png","hash":"868d8a69b778000e352ab17d22aa72c3b8eed312","modified":1661222087938},{"_id":"public/img/2022-02-06-1.png","hash":"86b9a8a41e2c853053e909387d6ec33e4877366b","modified":1661222087938},{"_id":"public/img/2022-02-08-1.jpeg","hash":"3e4ed33f30d6f54d5bf437062ec55c6348a4fc66","modified":1661222087938},{"_id":"public/img/2022-02-16-1.jpeg","hash":"c049a498846cbc8d2bf6e45be0b43c97fd3d9edf","modified":1661222087938},{"_id":"public/img/2022-02-22-1.jpeg","hash":"e34dc1856ace7e149c338048fbc92d21d21d8cd1","modified":1661222087938},{"_id":"public/img/2022-03-07-1.png","hash":"563d429ae97eac009674098dd57517551c37e03f","modified":1661222087938},{"_id":"public/img/2022-03-16-1.png","hash":"3836172c33012b8886c54ed062bc0857e8cca93e","modified":1661222087938},{"_id":"public/img/2022-03-20-1.webp","hash":"f95a32645c06b594bf0e9e8d01cba118f9a6caa8","modified":1661222087938},{"_id":"public/img/2022-04-07-1.png","hash":"22a729b5064126094b4985f989b3f402ed8f1286","modified":1661222087938},{"_id":"public/img/2022-04-29-3.png","hash":"0e6b740160ccc23df17c8c0867b84e7188feb7be","modified":1661222087938},{"_id":"public/img/miaomiao.JPG","hash":"60b94fd56002070d8be535b35adfef67f0b4be6c","modified":1661222087938},{"_id":"public/img/2021-12-22-1.png","hash":"023912be2857823f083116c0bb43078f83cb9c2a","modified":1661222087938},{"_id":"public/img/2022-04-18-1.png","hash":"0525d8a00579950752409c5c23d4b046f97ce5f6","modified":1661222087938},{"_id":"public/img/2022-04-29-2.png","hash":"77fe8e98341fcf7f46f04c2cb336b8e557dc121c","modified":1661222087938},{"_id":"public/img/about/1.JPG","hash":"5ef7106f2c124a0d5066407e1972927b885eff2f","modified":1661222087938},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1661222087938},{"_id":"public/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":1661222087938},{"_id":"public/js/color-schema.js","hash":"f1fdd512f3ef92ff5db4a49f5a3143d5ddea9858","modified":1661222087938},{"_id":"public/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":1661222087938},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1661222087938},{"_id":"public/js/leancloud.js","hash":"53987b7a668ea0623370eb83ed5311766221b557","modified":1661222087938},{"_id":"public/js/local-search.js","hash":"633f0142c657805359b0197f287e12ae4bcde731","modified":1661222087938},{"_id":"public/js/plugins.js","hash":"d058f30bd09b28769c4d8313428ff23dfc8d52dd","modified":1661222087938},{"_id":"public/js/utils.js","hash":"4a43f2700e91937650bef511fd438825b001c4c6","modified":1661222087938},{"_id":"public/css/main.css","hash":"63bc59b8ca4b03afa2b93883143c349d461b1052","modified":1661222087938},{"_id":"public/img/2022-04-29-1.png","hash":"11a197e18f9d8f6335c5976855764388c7246a71","modified":1661222087938},{"_id":"public/img/2022-05-01-1.png","hash":"fed31ed0ab7d71b0cc185f228818764a275ab22f","modified":1661222087938},{"_id":"public/img/index-img.png","hash":"f7314828a14a3e236deecbe33816f99d0f65c5cf","modified":1661222087938},{"_id":"public/img/2022-04-14-1.png","hash":"dc1114f39492c5587c84f855a3be5fe8cbf7e537","modified":1661222087938},{"_id":"public/img/default.jpg","hash":"d48e1d1c2a174a0286776448c0e74f95aaa5fa5e","modified":1661222087938},{"_id":"public/img/2022-04-30-2.png","hash":"7db617903908bdc688f6b8e13f15ae02fbfd008d","modified":1661222087938},{"_id":"public/img/about/4.jpg","hash":"5e6229797fe84190ad334237e0e8a6bb29ba5a05","modified":1661222087938},{"_id":"public/img/about/2.png","hash":"6b760a31252392d54c9ba548ee2a1e3dd25d621e","modified":1661222087938},{"_id":"public/img/about/3.png","hash":"6c7cf3a59b617bdea67548bad1b634b9746c245a","modified":1661222087938}],"Category":[{"name":"面试","_id":"cl75kqn310004yu3l42zyecob"},{"name":"Mobx","_id":"cl75kqn3h000fyu3l8xy6ffol"},{"name":"webpack","_id":"cl75kqn3m000nyu3l4kmne2v2"},{"name":"React","_id":"cl75kqn3v000uyu3lal1ehi7o"},{"name":"React Hook","_id":"cl75kqn3w0010yu3l4r3bdnsj"},{"name":"JS","_id":"cl75kqn42001lyu3l4fhlcqrn"},{"name":"vscode","_id":"cl75kqn4f002kyu3lb0xb02m0"},{"name":"Vue","_id":"cl75kqn4j002oyu3lcbtq4o3s"},{"name":"TypeScript","_id":"cl75kqn4m002xyu3l9hdicbbk"}],"Data":[],"Page":[{"title":"about","date":"2022-01-12T15:32:19.000Z","layout":"about","_content":"\n1、关于我\n\n```text\n前端开发一枚、家有贤妻、女儿奴、有只蓝白，叫喵喵。\n```\n\n2、职业技能\n\n- 前端主流技术栈、框架\n- HTML、CSS、JS、TS\n- React 技术栈\n- Vue 技术栈\n- Node\n- Kubernetes、Docker 简单概念，日常操作, CKA\n\n3、工作状况\n\n- 目前就职于九州云\n- 容器云相关\n\n4、学习计划\n\n- 深入学习 React\n\n5、联系我\n\n- Email: moweiwei6@gmail.com\n- GitHub: <https://github.com/moweiwei>\n\n6、END\n\n- Stay hungry. Stay foolish.\n- 知人者智，自知者明。胜人者有力，自胜者强。\n\n<center>\n  <figure>\n    <img src=\"/img/about/1.JPG\" width=\"220\">\n    <img src=\"/img/about/2.png\" width=\"220\">\n    <img src=\"/img/about/4.jpg\" width=\"220\" height=\"293\">\n    <img src=\"/img/about/3.png\" width=\"220\">\n  </figure>\n</center>\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2022-01-12 23:32:19\nlayout: about\n---\n\n1、关于我\n\n```text\n前端开发一枚、家有贤妻、女儿奴、有只蓝白，叫喵喵。\n```\n\n2、职业技能\n\n- 前端主流技术栈、框架\n- HTML、CSS、JS、TS\n- React 技术栈\n- Vue 技术栈\n- Node\n- Kubernetes、Docker 简单概念，日常操作, CKA\n\n3、工作状况\n\n- 目前就职于九州云\n- 容器云相关\n\n4、学习计划\n\n- 深入学习 React\n\n5、联系我\n\n- Email: moweiwei6@gmail.com\n- GitHub: <https://github.com/moweiwei>\n\n6、END\n\n- Stay hungry. Stay foolish.\n- 知人者智，自知者明。胜人者有力，自胜者强。\n\n<center>\n  <figure>\n    <img src=\"/img/about/1.JPG\" width=\"220\">\n    <img src=\"/img/about/2.png\" width=\"220\">\n    <img src=\"/img/about/4.jpg\" width=\"220\" height=\"293\">\n    <img src=\"/img/about/3.png\" width=\"220\">\n  </figure>\n</center>\n","updated":"2022-08-23T02:19:23.468Z","path":"about/index.html","comments":1,"_id":"cl75kqn2q0000yu3l6lz2apfr","content":"<p>1、关于我</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs text\">前端开发一枚、家有贤妻、女儿奴、有只蓝白，叫喵喵。</code></pre></div>\n\n<p>2、职业技能</p>\n<ul>\n<li>前端主流技术栈、框架</li>\n<li>HTML、CSS、JS、TS</li>\n<li>React 技术栈</li>\n<li>Vue 技术栈</li>\n<li>Node</li>\n<li>Kubernetes、Docker 简单概念，日常操作, CKA</li>\n</ul>\n<p>3、工作状况</p>\n<ul>\n<li>目前就职于九州云</li>\n<li>容器云相关</li>\n</ul>\n<p>4、学习计划</p>\n<ul>\n<li>深入学习 React</li>\n</ul>\n<p>5、联系我</p>\n<ul>\n<li>Email: <a href=\"mailto:&#x6d;&#111;&#119;&#101;&#x69;&#119;&#101;&#105;&#54;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;\">&#x6d;&#111;&#119;&#101;&#x69;&#119;&#101;&#105;&#54;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;</a></li>\n<li>GitHub: <a href=\"https://github.com/moweiwei\">https://github.com/moweiwei</a></li>\n</ul>\n<p>6、END</p>\n<ul>\n<li>Stay hungry. Stay foolish.</li>\n<li>知人者智，自知者明。胜人者有力，自胜者强。</li>\n</ul>\n<center>\n  <figure>\n    <img src=\"/img/about/1.JPG\" width=\"220\">\n    <img src=\"/img/about/2.png\" width=\"220\">\n    <img src=\"/img/about/4.jpg\" width=\"220\" height=\"293\">\n    <img src=\"/img/about/3.png\" width=\"220\">\n  </figure>\n</center>\n","site":{"data":{}},"wordcount":347,"excerpt":"","more":"<p>1、关于我</p>\n<pre><code class=\"hljs text\">前端开发一枚、家有贤妻、女儿奴、有只蓝白，叫喵喵。</code></pre>\n\n<p>2、职业技能</p>\n<ul>\n<li>前端主流技术栈、框架</li>\n<li>HTML、CSS、JS、TS</li>\n<li>React 技术栈</li>\n<li>Vue 技术栈</li>\n<li>Node</li>\n<li>Kubernetes、Docker 简单概念，日常操作, CKA</li>\n</ul>\n<p>3、工作状况</p>\n<ul>\n<li>目前就职于九州云</li>\n<li>容器云相关</li>\n</ul>\n<p>4、学习计划</p>\n<ul>\n<li>深入学习 React</li>\n</ul>\n<p>5、联系我</p>\n<ul>\n<li>Email: <a href=\"mailto:&#x6d;&#111;&#119;&#101;&#x69;&#119;&#101;&#105;&#54;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;\">&#x6d;&#111;&#119;&#101;&#x69;&#119;&#101;&#105;&#54;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;</a></li>\n<li>GitHub: <a href=\"https://github.com/moweiwei\">https://github.com/moweiwei</a></li>\n</ul>\n<p>6、END</p>\n<ul>\n<li>Stay hungry. Stay foolish.</li>\n<li>知人者智，自知者明。胜人者有力，自胜者强。</li>\n</ul>\n<center>\n  <figure>\n    <img src=\"/img/about/1.JPG\" width=\"220\">\n    <img src=\"/img/about/2.png\" width=\"220\">\n    <img src=\"/img/about/4.jpg\" width=\"220\" height=\"293\">\n    <img src=\"/img/about/3.png\" width=\"220\">\n  </figure>\n</center>\n"},{"_content":"// 代码语言标准形式（这里应该有更合理的解决方式，但是我不会写）\nvar code_language = {\n  txt: \"\",\n  md: \"Markdown\",\n  markdwon: \"Markdown\",\n\n  yml: \"YAML\",\n  yaml: \"YAML\",\n  json: \"JSON\",\n\n  xml: \"XML\",\n  html: \"HTML\",\n  css: \"CSS\",\n  styl: \"Stylus\",\n  stylus: \"Stylus\",\n\n  js: \"JavaScript\",\n  javascript: \"JavaScript\",\n  ts: \"TypeScript\",\n  typescript: \"TypeScript\",\n  py: \"Python\",\n  python: \"Python\",\n\n  c: \"C\",\n  \"c++\": \"C++\",\n  cpp: \"C++\",\n  cxx: \"C++\",\n  \"c#\": \"C#\",\n  cs: \"C#\",\n  csharp: \"C#\",\n  java: \"Java\"\n};\n\n// 代码语言格式化\nfunction getLanguage(lang) {\n  var lang_lower = lang.toLowerCase();\n  return lang_lower in code_language ? code_language[lang_lower] : lang;\n}\n\n// 获取唯一 ID\nfunction getUuiD() {\n  return Math.random().toString(36).substring(2, 8) + Date.now().toString(36);\n}\n\nfunction addLanguage() {\n  // 获取所有 figure.highlight 元素\n  var hs = $(\"figure.highlight\");\n  for (var i = 0; i < hs.length; i++) {\n    // 获取代码语言\n    var lang = hs[i].firstChild.firstChild.firstChild.lastChild.firstChild.firstChild.firstChild.classList[1];\n\n    // 折叠块的 id\n    var id = `kiyan-collapse-${getUuiD()}`;\n    // 前面折叠按钮，这里我使用了 FAS 图标\n    // 注意：这里是 bootstrap 的 collapse 功能的简略代码，使用时会自动补全，补全后的 HTML 可以通过浏览器 F12 查看，此外也可查看官方文档\n    var btn = `<i class=\"iconfont .icon-arrowdown\" type=\"button\" data-toggle=\"collapse\" data-target=\"#${id}\"></i>`;\n    // 代码语言\n    var span = `<span>${getLanguage(lang)}</span>`;\n    // 折叠块包裹原来的内容\n    var div = `<div class=\"collapse show\" id=\"${id}\">${hs[i].innerHTML}</div>`;\n    hs[i].innerHTML = btn + span + div;\n  }\n}\n\nfunction init() {\n  addLanguage();\n}\n\n$(document).ready(init);\n","source":"js/custom.js","raw":"// 代码语言标准形式（这里应该有更合理的解决方式，但是我不会写）\nvar code_language = {\n  txt: \"\",\n  md: \"Markdown\",\n  markdwon: \"Markdown\",\n\n  yml: \"YAML\",\n  yaml: \"YAML\",\n  json: \"JSON\",\n\n  xml: \"XML\",\n  html: \"HTML\",\n  css: \"CSS\",\n  styl: \"Stylus\",\n  stylus: \"Stylus\",\n\n  js: \"JavaScript\",\n  javascript: \"JavaScript\",\n  ts: \"TypeScript\",\n  typescript: \"TypeScript\",\n  py: \"Python\",\n  python: \"Python\",\n\n  c: \"C\",\n  \"c++\": \"C++\",\n  cpp: \"C++\",\n  cxx: \"C++\",\n  \"c#\": \"C#\",\n  cs: \"C#\",\n  csharp: \"C#\",\n  java: \"Java\"\n};\n\n// 代码语言格式化\nfunction getLanguage(lang) {\n  var lang_lower = lang.toLowerCase();\n  return lang_lower in code_language ? code_language[lang_lower] : lang;\n}\n\n// 获取唯一 ID\nfunction getUuiD() {\n  return Math.random().toString(36).substring(2, 8) + Date.now().toString(36);\n}\n\nfunction addLanguage() {\n  // 获取所有 figure.highlight 元素\n  var hs = $(\"figure.highlight\");\n  for (var i = 0; i < hs.length; i++) {\n    // 获取代码语言\n    var lang = hs[i].firstChild.firstChild.firstChild.lastChild.firstChild.firstChild.firstChild.classList[1];\n\n    // 折叠块的 id\n    var id = `kiyan-collapse-${getUuiD()}`;\n    // 前面折叠按钮，这里我使用了 FAS 图标\n    // 注意：这里是 bootstrap 的 collapse 功能的简略代码，使用时会自动补全，补全后的 HTML 可以通过浏览器 F12 查看，此外也可查看官方文档\n    var btn = `<i class=\"iconfont .icon-arrowdown\" type=\"button\" data-toggle=\"collapse\" data-target=\"#${id}\"></i>`;\n    // 代码语言\n    var span = `<span>${getLanguage(lang)}</span>`;\n    // 折叠块包裹原来的内容\n    var div = `<div class=\"collapse show\" id=\"${id}\">${hs[i].innerHTML}</div>`;\n    hs[i].innerHTML = btn + span + div;\n  }\n}\n\nfunction init() {\n  addLanguage();\n}\n\n$(document).ready(init);\n","date":"2022-05-13T13:22:27.195Z","updated":"2022-03-07T10:02:48.657Z","path":"js/custom.js","layout":"false","title":"","comments":1,"_id":"cl75kqn2y0002yu3laxz8fwio","content":"// 代码语言标准形式（这里应该有更合理的解决方式，但是我不会写）\nvar code_language = {\n  txt: \"\",\n  md: \"Markdown\",\n  markdwon: \"Markdown\",\n\n  yml: \"YAML\",\n  yaml: \"YAML\",\n  json: \"JSON\",\n\n  xml: \"XML\",\n  html: \"HTML\",\n  css: \"CSS\",\n  styl: \"Stylus\",\n  stylus: \"Stylus\",\n\n  js: \"JavaScript\",\n  javascript: \"JavaScript\",\n  ts: \"TypeScript\",\n  typescript: \"TypeScript\",\n  py: \"Python\",\n  python: \"Python\",\n\n  c: \"C\",\n  \"c++\": \"C++\",\n  cpp: \"C++\",\n  cxx: \"C++\",\n  \"c#\": \"C#\",\n  cs: \"C#\",\n  csharp: \"C#\",\n  java: \"Java\"\n};\n\n// 代码语言格式化\nfunction getLanguage(lang) {\n  var lang_lower = lang.toLowerCase();\n  return lang_lower in code_language ? code_language[lang_lower] : lang;\n}\n\n// 获取唯一 ID\nfunction getUuiD() {\n  return Math.random().toString(36).substring(2, 8) + Date.now().toString(36);\n}\n\nfunction addLanguage() {\n  // 获取所有 figure.highlight 元素\n  var hs = $(\"figure.highlight\");\n  for (var i = 0; i < hs.length; i++) {\n    // 获取代码语言\n    var lang = hs[i].firstChild.firstChild.firstChild.lastChild.firstChild.firstChild.firstChild.classList[1];\n\n    // 折叠块的 id\n    var id = `kiyan-collapse-${getUuiD()}`;\n    // 前面折叠按钮，这里我使用了 FAS 图标\n    // 注意：这里是 bootstrap 的 collapse 功能的简略代码，使用时会自动补全，补全后的 HTML 可以通过浏览器 F12 查看，此外也可查看官方文档\n    var btn = `<i class=\"iconfont .icon-arrowdown\" type=\"button\" data-toggle=\"collapse\" data-target=\"#${id}\"></i>`;\n    // 代码语言\n    var span = `<span>${getLanguage(lang)}</span>`;\n    // 折叠块包裹原来的内容\n    var div = `<div class=\"collapse show\" id=\"${id}\">${hs[i].innerHTML}</div>`;\n    hs[i].innerHTML = btn + span + div;\n  }\n}\n\nfunction init() {\n  addLanguage();\n}\n\n$(document).ready(init);\n","site":{"data":{}},"wordcount":1131,"excerpt":"","more":"// 代码语言标准形式（这里应该有更合理的解决方式，但是我不会写）\nvar code_language = {\n  txt: \"\",\n  md: \"Markdown\",\n  markdwon: \"Markdown\",\n\n  yml: \"YAML\",\n  yaml: \"YAML\",\n  json: \"JSON\",\n\n  xml: \"XML\",\n  html: \"HTML\",\n  css: \"CSS\",\n  styl: \"Stylus\",\n  stylus: \"Stylus\",\n\n  js: \"JavaScript\",\n  javascript: \"JavaScript\",\n  ts: \"TypeScript\",\n  typescript: \"TypeScript\",\n  py: \"Python\",\n  python: \"Python\",\n\n  c: \"C\",\n  \"c++\": \"C++\",\n  cpp: \"C++\",\n  cxx: \"C++\",\n  \"c#\": \"C#\",\n  cs: \"C#\",\n  csharp: \"C#\",\n  java: \"Java\"\n};\n\n// 代码语言格式化\nfunction getLanguage(lang) {\n  var lang_lower = lang.toLowerCase();\n  return lang_lower in code_language ? code_language[lang_lower] : lang;\n}\n\n// 获取唯一 ID\nfunction getUuiD() {\n  return Math.random().toString(36).substring(2, 8) + Date.now().toString(36);\n}\n\nfunction addLanguage() {\n  // 获取所有 figure.highlight 元素\n  var hs = $(\"figure.highlight\");\n  for (var i = 0; i < hs.length; i++) {\n    // 获取代码语言\n    var lang = hs[i].firstChild.firstChild.firstChild.lastChild.firstChild.firstChild.firstChild.classList[1];\n\n    // 折叠块的 id\n    var id = `kiyan-collapse-${getUuiD()}`;\n    // 前面折叠按钮，这里我使用了 FAS 图标\n    // 注意：这里是 bootstrap 的 collapse 功能的简略代码，使用时会自动补全，补全后的 HTML 可以通过浏览器 F12 查看，此外也可查看官方文档\n    var btn = `<i class=\"iconfont .icon-arrowdown\" type=\"button\" data-toggle=\"collapse\" data-target=\"#${id}\"></i>`;\n    // 代码语言\n    var span = `<span>${getLanguage(lang)}</span>`;\n    // 折叠块包裹原来的内容\n    var div = `<div class=\"collapse show\" id=\"${id}\">${hs[i].innerHTML}</div>`;\n    hs[i].innerHTML = btn + span + div;\n  }\n}\n\nfunction init() {\n  addLanguage();\n}\n\n$(document).ready(init);\n"},{"_content":"/* 代码块折叠 */\nfigure.highlight {\n  background: #21252b;\n  border-radius: 0.5rem;\n}\nfigure.highlight table {\n  border-radius: 0 0 0.5rem 0.5rem;\n}\nfigure.highlight > i {\n  color: #777;\n  margin-left: 10px;\n  line-height: 2rem;\n  transform: rotate(90deg);\n  transition: transform 0.2s ease-in-out;\n}\nfigure.highlight > i.collapsed {\n  transform: rotate(0deg);\n}\nfigure.highlight > span {\n  color: #777;\n  margin-left: 5px;\n  font-size: 0.875rem;\n}\nfigure.highlight td:first-child {\n  position: sticky;\n  left: 0;\n  z-index: 1;\n}\nfigure.highlight > i:before {\n  content: \"\\f2c3\";\n}\n\n/* 复制 */\n.copy-btn {\n  top: 5px;\n  font-size: 0.875rem;\n}\n.copy-btn > i {\n  font-size: 0.875rem;\n}\n.copy-btn-dark {\n  color: #2f4f4f;\n}\n","source":"css/custom.css","raw":"/* 代码块折叠 */\nfigure.highlight {\n  background: #21252b;\n  border-radius: 0.5rem;\n}\nfigure.highlight table {\n  border-radius: 0 0 0.5rem 0.5rem;\n}\nfigure.highlight > i {\n  color: #777;\n  margin-left: 10px;\n  line-height: 2rem;\n  transform: rotate(90deg);\n  transition: transform 0.2s ease-in-out;\n}\nfigure.highlight > i.collapsed {\n  transform: rotate(0deg);\n}\nfigure.highlight > span {\n  color: #777;\n  margin-left: 5px;\n  font-size: 0.875rem;\n}\nfigure.highlight td:first-child {\n  position: sticky;\n  left: 0;\n  z-index: 1;\n}\nfigure.highlight > i:before {\n  content: \"\\f2c3\";\n}\n\n/* 复制 */\n.copy-btn {\n  top: 5px;\n  font-size: 0.875rem;\n}\n.copy-btn > i {\n  font-size: 0.875rem;\n}\n.copy-btn-dark {\n  color: #2f4f4f;\n}\n","date":"2022-05-13T13:22:27.186Z","updated":"2022-02-25T06:56:54.842Z","path":"css/custom.css","layout":"false","title":"","comments":1,"_id":"cl75kqn330006yu3l8r8o7dlj","content":"/* 代码块折叠 */\nfigure.highlight {\n  background: #21252b;\n  border-radius: 0.5rem;\n}\nfigure.highlight table {\n  border-radius: 0 0 0.5rem 0.5rem;\n}\nfigure.highlight > i {\n  color: #777;\n  margin-left: 10px;\n  line-height: 2rem;\n  transform: rotate(90deg);\n  transition: transform 0.2s ease-in-out;\n}\nfigure.highlight > i.collapsed {\n  transform: rotate(0deg);\n}\nfigure.highlight > span {\n  color: #777;\n  margin-left: 5px;\n  font-size: 0.875rem;\n}\nfigure.highlight td:first-child {\n  position: sticky;\n  left: 0;\n  z-index: 1;\n}\nfigure.highlight > i:before {\n  content: \"\\f2c3\";\n}\n\n/* 复制 */\n.copy-btn {\n  top: 5px;\n  font-size: 0.875rem;\n}\n.copy-btn > i {\n  font-size: 0.875rem;\n}\n.copy-btn-dark {\n  color: #2f4f4f;\n}\n","site":{"data":{}},"wordcount":580,"excerpt":"","more":"/* 代码块折叠 */\nfigure.highlight {\n  background: #21252b;\n  border-radius: 0.5rem;\n}\nfigure.highlight table {\n  border-radius: 0 0 0.5rem 0.5rem;\n}\nfigure.highlight > i {\n  color: #777;\n  margin-left: 10px;\n  line-height: 2rem;\n  transform: rotate(90deg);\n  transition: transform 0.2s ease-in-out;\n}\nfigure.highlight > i.collapsed {\n  transform: rotate(0deg);\n}\nfigure.highlight > span {\n  color: #777;\n  margin-left: 5px;\n  font-size: 0.875rem;\n}\nfigure.highlight td:first-child {\n  position: sticky;\n  left: 0;\n  z-index: 1;\n}\nfigure.highlight > i:before {\n  content: \"\\f2c3\";\n}\n\n/* 复制 */\n.copy-btn {\n  top: 5px;\n  font-size: 0.875rem;\n}\n.copy-btn > i {\n  font-size: 0.875rem;\n}\n.copy-btn-dark {\n  color: #2f4f4f;\n}\n"}],"Post":[{"title":"实习生前端工程师面试题","index_img":"/img/2022-02-22-1.jpeg","date":"2022-02-22T10:03:22.000Z","_content":"\n## CSS\n\n- 介绍下 BFC 及其应用\n\n  BFC（Block Format Context）块级格式化上下文，是页面盒模型中的一种 `CSS` 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。\n\n  创建 `BFC` 的方式有：\n\n  1. `html` 根元素\n  2. `float` 浮动\n  3. 绝对定位\n  4. `overflow` 不为 `visible`\n  5. `display` 为表格布局或者弹性布局；\n\n  `BFC` 主要的作用是：\n\n  1. 清除浮动\n  2. 防止同一 `BFC` 容器中的相邻元素间的外边距重叠问题\n\n- 怎么让一个 div 水平垂直居中？\n\n  ```html\n  <div class=\"parent\">\n    <div class=\"child\"></div>\n  </div>\n  ```\n\n  ```css\n  <!-- 1 -->\n  div.parent {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n  <!-- 2 -->\n  div.parent {\n    position: relative;\n  }\n  div.child {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%);\n  }\n  <!-- 3 -->\n  div.parent {\n    display: grid;\n  }\n  div.child {\n    justify-self: center;\n    align-self: center;\n  }\n  <!-- 4 -->\n  div.parent {\n    font-size: 0;\n    text-align: center;\n    &::before {\n      content: \"\";\n      display: inline-block;\n      width: 0;\n      height: 100%;\n      vertical-align: middle;\n    }\n  }\n  div.child {\n    display: inline-block;\n    vertical-align: middle;\n  }\n  ```\n\n- 简述 Rem 及其转换原理\n\n  `rem` 是 CSS3 新增的相对长度单位，是指相对于根元素 `html` 的 `font-size` 计算值的大小。\n\n  默认根元素的 `font-size` 都是 `16px`的。如果想要设置 `12px` 的字体大小也就是 `12px/16px = 0.75rem`。\n\n  - 由于 `px` 是相对固定单位，字号大小直接被定死，无法随着浏览器进行缩放；\n  - `rem` 直接相对于根元素 `html`，避开层级关系，移动端新型浏览器对其支持较好；\n\n  个人用 `vw` + 百分比布局用的比较多，可以使用 `webpack` 的 `postcss-loader` 的一个插件 `postcss-px-to-viewport` 实现对 `px` 到\n  `vw` 的自动转换，非常适合开发。\n\n- 简述伪类和伪元素\n\n  - 伪类\n\n  伪类用于当已有元素处于某种状态时，为其添加对应的样式，这个状态是根据用户行为变化而变化的。比如说 `:hover`。它只有处于 dom 树无法描述的状态才能为元素添加样式，所以称为伪类。\n\n  - 伪元素\n\n  伪元素用于创建一些原本不在文档树中的元素，并为其添加样式，比如说 `::before`。虽然用户可以看到这些内容，但是其实他不在文档树中。\n\n  - 区别\n\n  伪类的操作对象是文档树中已存在的元素，而伪元素是创建一个文档树外的元素。\n\n  css 规范中用双冒号 `::` 表示伪元素，用一个冒号 `:` 表示伪类。\n\n## JS\n\n### JS 中数据类型有哪些？\n\n数值（number）、字符串（string）、布尔值（boolean）、undefined、null、对象（object）\n","source":"_drafts/0.实习生前端工程师面试题.md","raw":"---\ntitle: 实习生前端工程师面试题\nindex_img: /img/2022-02-22-1.jpeg\ndate: 2022-02-22 18:03:22\ntags: 前端实习生\ncategories: 面试\n---\n\n## CSS\n\n- 介绍下 BFC 及其应用\n\n  BFC（Block Format Context）块级格式化上下文，是页面盒模型中的一种 `CSS` 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。\n\n  创建 `BFC` 的方式有：\n\n  1. `html` 根元素\n  2. `float` 浮动\n  3. 绝对定位\n  4. `overflow` 不为 `visible`\n  5. `display` 为表格布局或者弹性布局；\n\n  `BFC` 主要的作用是：\n\n  1. 清除浮动\n  2. 防止同一 `BFC` 容器中的相邻元素间的外边距重叠问题\n\n- 怎么让一个 div 水平垂直居中？\n\n  ```html\n  <div class=\"parent\">\n    <div class=\"child\"></div>\n  </div>\n  ```\n\n  ```css\n  <!-- 1 -->\n  div.parent {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n  <!-- 2 -->\n  div.parent {\n    position: relative;\n  }\n  div.child {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%);\n  }\n  <!-- 3 -->\n  div.parent {\n    display: grid;\n  }\n  div.child {\n    justify-self: center;\n    align-self: center;\n  }\n  <!-- 4 -->\n  div.parent {\n    font-size: 0;\n    text-align: center;\n    &::before {\n      content: \"\";\n      display: inline-block;\n      width: 0;\n      height: 100%;\n      vertical-align: middle;\n    }\n  }\n  div.child {\n    display: inline-block;\n    vertical-align: middle;\n  }\n  ```\n\n- 简述 Rem 及其转换原理\n\n  `rem` 是 CSS3 新增的相对长度单位，是指相对于根元素 `html` 的 `font-size` 计算值的大小。\n\n  默认根元素的 `font-size` 都是 `16px`的。如果想要设置 `12px` 的字体大小也就是 `12px/16px = 0.75rem`。\n\n  - 由于 `px` 是相对固定单位，字号大小直接被定死，无法随着浏览器进行缩放；\n  - `rem` 直接相对于根元素 `html`，避开层级关系，移动端新型浏览器对其支持较好；\n\n  个人用 `vw` + 百分比布局用的比较多，可以使用 `webpack` 的 `postcss-loader` 的一个插件 `postcss-px-to-viewport` 实现对 `px` 到\n  `vw` 的自动转换，非常适合开发。\n\n- 简述伪类和伪元素\n\n  - 伪类\n\n  伪类用于当已有元素处于某种状态时，为其添加对应的样式，这个状态是根据用户行为变化而变化的。比如说 `:hover`。它只有处于 dom 树无法描述的状态才能为元素添加样式，所以称为伪类。\n\n  - 伪元素\n\n  伪元素用于创建一些原本不在文档树中的元素，并为其添加样式，比如说 `::before`。虽然用户可以看到这些内容，但是其实他不在文档树中。\n\n  - 区别\n\n  伪类的操作对象是文档树中已存在的元素，而伪元素是创建一个文档树外的元素。\n\n  css 规范中用双冒号 `::` 表示伪元素，用一个冒号 `:` 表示伪类。\n\n## JS\n\n### JS 中数据类型有哪些？\n\n数值（number）、字符串（string）、布尔值（boolean）、undefined、null、对象（object）\n","slug":"0-实习生前端工程师面试题","published":0,"updated":"2022-08-23T02:19:23.471Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn2t0001yu3l4ulu2aat","content":"<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><ul>\n<li><p>介绍下 BFC 及其应用</p>\n<p>BFC（Block Format Context）块级格式化上下文，是页面盒模型中的一种 <code>CSS</code> 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。</p>\n<p>创建 <code>BFC</code> 的方式有：</p>\n<ol>\n<li><code>html</code> 根元素</li>\n<li><code>float</code> 浮动</li>\n<li>绝对定位</li>\n<li><code>overflow</code> 不为 <code>visible</code></li>\n<li><code>display</code> 为表格布局或者弹性布局；</li>\n</ol>\n<p><code>BFC</code> 主要的作用是：</p>\n<ol>\n<li>清除浮动</li>\n<li>防止同一 <code>BFC</code> 容器中的相邻元素间的外边距重叠问题</li>\n</ol>\n</li>\n<li><p>怎么让一个 div 水平垂直居中？</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;parent&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;child&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre></div>\n\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs css\">&lt;!-- <span class=\"hljs-number\">1</span> --&gt;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;\n  <span class=\"hljs-attribute\">display</span>: flex;\n  <span class=\"hljs-attribute\">justify-content</span>: center;\n  <span class=\"hljs-attribute\">align-items</span>: center;\n&#125;\n&lt;!-- <span class=\"hljs-number\">2</span> --&gt;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;\n  <span class=\"hljs-attribute\">position</span>: relative;\n&#125;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.child</span> &#123;\n  <span class=\"hljs-attribute\">position</span>: absolute;\n  <span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">50%</span>;\n  <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">50%</span>;\n  <span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-built_in\">translate</span>(-<span class=\"hljs-number\">50%</span>, -<span class=\"hljs-number\">50%</span>);\n&#125;\n&lt;!-- <span class=\"hljs-number\">3</span> --&gt;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;\n  <span class=\"hljs-attribute\">display</span>: grid;\n&#125;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.child</span> &#123;\n  justify-self: center;\n  <span class=\"hljs-attribute\">align-self</span>: center;\n&#125;\n&lt;!-- <span class=\"hljs-number\">4</span> --&gt;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;\n  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-attribute\">text-align</span>: center;\n  &amp;<span class=\"hljs-selector-pseudo\">::before</span> &#123;\n    <span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">&quot;&quot;</span>;\n    <span class=\"hljs-attribute\">display</span>: inline-block;\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100%</span>;\n    <span class=\"hljs-attribute\">vertical-align</span>: middle;\n  &#125;\n&#125;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.child</span> &#123;\n  <span class=\"hljs-attribute\">display</span>: inline-block;\n  <span class=\"hljs-attribute\">vertical-align</span>: middle;\n&#125;</code></pre></div></li>\n<li><p>简述 Rem 及其转换原理</p>\n<p><code>rem</code> 是 CSS3 新增的相对长度单位，是指相对于根元素 <code>html</code> 的 <code>font-size</code> 计算值的大小。</p>\n<p>默认根元素的 <code>font-size</code> 都是 <code>16px</code>的。如果想要设置 <code>12px</code> 的字体大小也就是 <code>12px/16px = 0.75rem</code>。</p>\n<ul>\n<li>由于 <code>px</code> 是相对固定单位，字号大小直接被定死，无法随着浏览器进行缩放；</li>\n<li><code>rem</code> 直接相对于根元素 <code>html</code>，避开层级关系，移动端新型浏览器对其支持较好；</li>\n</ul>\n<p>个人用 <code>vw</code> + 百分比布局用的比较多，可以使用 <code>webpack</code> 的 <code>postcss-loader</code> 的一个插件 <code>postcss-px-to-viewport</code> 实现对 <code>px</code> 到<br><code>vw</code> 的自动转换，非常适合开发。</p>\n</li>\n<li><p>简述伪类和伪元素</p>\n<ul>\n<li>伪类</li>\n</ul>\n<p>伪类用于当已有元素处于某种状态时，为其添加对应的样式，这个状态是根据用户行为变化而变化的。比如说 <code>:hover</code>。它只有处于 dom 树无法描述的状态才能为元素添加样式，所以称为伪类。</p>\n<ul>\n<li>伪元素</li>\n</ul>\n<p>伪元素用于创建一些原本不在文档树中的元素，并为其添加样式，比如说 <code>::before</code>。虽然用户可以看到这些内容，但是其实他不在文档树中。</p>\n<ul>\n<li>区别</li>\n</ul>\n<p>伪类的操作对象是文档树中已存在的元素，而伪元素是创建一个文档树外的元素。</p>\n<p>css 规范中用双冒号 <code>::</code> 表示伪元素，用一个冒号 <code>:</code> 表示伪类。</p>\n</li>\n</ul>\n<h2 id=\"JS\"><a href=\"#JS\" class=\"headerlink\" title=\"JS\"></a>JS</h2><h3 id=\"JS-中数据类型有哪些？\"><a href=\"#JS-中数据类型有哪些？\" class=\"headerlink\" title=\"JS 中数据类型有哪些？\"></a>JS 中数据类型有哪些？</h3><p>数值（number）、字符串（string）、布尔值（boolean）、undefined、null、对象（object）</p>\n","site":{"data":{}},"wordcount":1468,"excerpt":"","more":"<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><ul>\n<li><p>介绍下 BFC 及其应用</p>\n<p>BFC（Block Format Context）块级格式化上下文，是页面盒模型中的一种 <code>CSS</code> 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。</p>\n<p>创建 <code>BFC</code> 的方式有：</p>\n<ol>\n<li><code>html</code> 根元素</li>\n<li><code>float</code> 浮动</li>\n<li>绝对定位</li>\n<li><code>overflow</code> 不为 <code>visible</code></li>\n<li><code>display</code> 为表格布局或者弹性布局；</li>\n</ol>\n<p><code>BFC</code> 主要的作用是：</p>\n<ol>\n<li>清除浮动</li>\n<li>防止同一 <code>BFC</code> 容器中的相邻元素间的外边距重叠问题</li>\n</ol>\n</li>\n<li><p>怎么让一个 div 水平垂直居中？</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;parent&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;child&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n\n<pre><code class=\"hljs css\">&lt;!-- <span class=\"hljs-number\">1</span> --&gt;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;\n  <span class=\"hljs-attribute\">display</span>: flex;\n  <span class=\"hljs-attribute\">justify-content</span>: center;\n  <span class=\"hljs-attribute\">align-items</span>: center;\n&#125;\n&lt;!-- <span class=\"hljs-number\">2</span> --&gt;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;\n  <span class=\"hljs-attribute\">position</span>: relative;\n&#125;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.child</span> &#123;\n  <span class=\"hljs-attribute\">position</span>: absolute;\n  <span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">50%</span>;\n  <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">50%</span>;\n  <span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-built_in\">translate</span>(-<span class=\"hljs-number\">50%</span>, -<span class=\"hljs-number\">50%</span>);\n&#125;\n&lt;!-- <span class=\"hljs-number\">3</span> --&gt;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;\n  <span class=\"hljs-attribute\">display</span>: grid;\n&#125;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.child</span> &#123;\n  justify-self: center;\n  <span class=\"hljs-attribute\">align-self</span>: center;\n&#125;\n&lt;!-- <span class=\"hljs-number\">4</span> --&gt;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;\n  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-attribute\">text-align</span>: center;\n  &amp;<span class=\"hljs-selector-pseudo\">::before</span> &#123;\n    <span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">&quot;&quot;</span>;\n    <span class=\"hljs-attribute\">display</span>: inline-block;\n    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100%</span>;\n    <span class=\"hljs-attribute\">vertical-align</span>: middle;\n  &#125;\n&#125;\n<span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.child</span> &#123;\n  <span class=\"hljs-attribute\">display</span>: inline-block;\n  <span class=\"hljs-attribute\">vertical-align</span>: middle;\n&#125;</code></pre></li>\n<li><p>简述 Rem 及其转换原理</p>\n<p><code>rem</code> 是 CSS3 新增的相对长度单位，是指相对于根元素 <code>html</code> 的 <code>font-size</code> 计算值的大小。</p>\n<p>默认根元素的 <code>font-size</code> 都是 <code>16px</code>的。如果想要设置 <code>12px</code> 的字体大小也就是 <code>12px/16px = 0.75rem</code>。</p>\n<ul>\n<li>由于 <code>px</code> 是相对固定单位，字号大小直接被定死，无法随着浏览器进行缩放；</li>\n<li><code>rem</code> 直接相对于根元素 <code>html</code>，避开层级关系，移动端新型浏览器对其支持较好；</li>\n</ul>\n<p>个人用 <code>vw</code> + 百分比布局用的比较多，可以使用 <code>webpack</code> 的 <code>postcss-loader</code> 的一个插件 <code>postcss-px-to-viewport</code> 实现对 <code>px</code> 到<br><code>vw</code> 的自动转换，非常适合开发。</p>\n</li>\n<li><p>简述伪类和伪元素</p>\n<ul>\n<li>伪类</li>\n</ul>\n<p>伪类用于当已有元素处于某种状态时，为其添加对应的样式，这个状态是根据用户行为变化而变化的。比如说 <code>:hover</code>。它只有处于 dom 树无法描述的状态才能为元素添加样式，所以称为伪类。</p>\n<ul>\n<li>伪元素</li>\n</ul>\n<p>伪元素用于创建一些原本不在文档树中的元素，并为其添加样式，比如说 <code>::before</code>。虽然用户可以看到这些内容，但是其实他不在文档树中。</p>\n<ul>\n<li>区别</li>\n</ul>\n<p>伪类的操作对象是文档树中已存在的元素，而伪元素是创建一个文档树外的元素。</p>\n<p>css 规范中用双冒号 <code>::</code> 表示伪元素，用一个冒号 <code>:</code> 表示伪类。</p>\n</li>\n</ul>\n<h2 id=\"JS\"><a href=\"#JS\" class=\"headerlink\" title=\"JS\"></a>JS</h2><h3 id=\"JS-中数据类型有哪些？\"><a href=\"#JS-中数据类型有哪些？\" class=\"headerlink\" title=\"JS 中数据类型有哪些？\"></a>JS 中数据类型有哪些？</h3><p>数值（number）、字符串（string）、布尔值（boolean）、undefined、null、对象（object）</p>\n"},{"title":"大厂面试题","index_img":"/img/2022-03-07-1.png","abbrlink":"83dcefb7","date":"2022-03-07T07:52:23.000Z","_content":"\n腾讯 一面\n\n1. 写一个 LRU 缓存函数\n2. 写个防抖和节流函数\n3. 你们服务是怎么部署的?Node Agent 做了什么工作?\n4. Grpc 的优缺点?\n5. http2 的相关特性?\n6. viewport 和移动端布局方案\n7. 实现一个 compose 函数\n8. 开发中有遇到过比较难定位的问题吗?Node 内存泄露有遇到过 吗? 二面\n9. react ssr 是在什么场景下做的?\n10. react ssr 双端怎么做构建的?区别在哪里?\n11. 有没有做过同构组件?服务端和客户端怎么同步状态的?\n12. render 和 renderToString 的底层实现上的区别?\n13. 客户端怎么处理 JS 事件失效的问题?客户端不重新加载 JS 的 情况下怎么实现?\n14. 做服务端渲染的时候有没有遇到过比较难的点?\n15. react ssr 和 ejs 性能的差异?\n16. 服务回滚是怎么做的?上线流程是怎样的?k8s 回滚、拉取以前的 镜像\n17. webpack plugin 的原理是什么?\n18. plugin 中有异步请求会阻塞后面的 plugin 吗? 11.做过哪些 webpack 的性能优化?\n19. hard-source-webpack-plugin 是怎么做缓存的?修改文件后会 怎么样?\n20. parallel 的原理是什么?多个子进程怎么通信? 14.你们 webpack 是怎么做拆包的? 15.服务端监控是怎么做的?服务有上报过什么指标?\n21. Node 服务怎么去定位 CPU 占用暴涨的情况?怎么去定位内存泄 露? 17.编写 grpc 服务和 http 服务的区别? 18.做过哪些 react 相关的优化?函数组件怎么实现\n    shouldComponentUpdate? 19.如果有一个非常大的 react 页面，我想优先渲染某一部分，这该怎 么做?\n22. react 函数组件和 class 组件里面 state 的区别?\n23. react useEffect 对应 class 组件的哪些生命周期? 22.前端的监控是怎么做的?除了 sentry 还做了其他异常处理吗? 三面\n24. 讲一下你做的比较复杂的项目?以及你在项目中担当了什么角色?\n25. 你是怎么看待现在各种造轮子的?\n26. 有一个一亿长度的字符串，怎么存储设计可以让它更好去查询、修 改?\n27. 怎么优化 H5 让它可以在 300ms 之内打开?\n28. 你们 WebView 加载一般耗时多久?\n29. 你们为什么从 Python 重构到 Node?好处是什么?\n\n30. 你是怎么看待做后台管理系统的?很多人觉得它没有难点，你觉得 呢?(问这个问题是因为我现在在做后台管理系统) 总监面(有点儿记不清了)\n31. 新加坡和深圳内网是怎么连通的?\n32. 未来的职业规划是什么样的?\n33. 对当前新的技术有了解吗?\n34. 对客户端知识有了解吗?\n35. 为什么要离职?拒了，岗位不是很喜欢\n\n拼多多 一面\n\n1. 有没有做过比较复杂的页面?携程的 React-imvc 做了什么?\n2. 使用 Redux 的好处，以及和 Mobx 的区别\n3. 对 React 最新特性有了解吗?class 组件和函数组件的区别?\n4. useState 为什么不能放到条件语句里面?\n5. 实现一个 Promise.all\n6. React SSR 是怎么实现的?\n7. 有用过代码规范相关的吗?Eslint 和 Prettier 冲突怎么解决?\n8. 实现一个数组转树形结构的函数 二面\n9. 说几个你觉得足够复杂的项目?\n10. 你是怎么去做 React SSR 的?\n11. 有没有做过性能优化相关的?\n12. 实现一个深拷贝\n13. 实现一个二叉搜索树转链表的方法 拒了，不想去卖命 商汤 一面\n14. 在工作中，主要是做什么内容?\n15. 有用过 lerna 吗?多个项目之间共用的东西怎么共享?\n16. 讲一讲微前端是怎么做的?怎么独立部署?子应用通信怎么做?\n17. webpack 构建流程是怎样的?\n18. webpack loader 和 plugin 的原理和区别?\n19. webpack 热更新原理?\n20. webpack 怎么做分包?\n21. 做过 webpack 性能优化吗?有用过 rollup 吗?\n22. react-imvc 是什么?它做了什么?\n23. react 和\n24. redux 和 mobx 的区别和优劣?用过 react-dom 的区别是什么? redux-saga 吗? 的复杂度，以及 react diff 的原理\n25. react diff\n26. react class 组件和 hooks 的区别? 14.什么是 TS 泛型? 15.从输入 url 到页面展示经过了哪些步骤? 16.讲一下重绘和回流 17.知道 BFC\n    吗?使用场景有哪些? 18.怎么判断是否为数组? 19.页面卡顿怎么去定位? 20.数组有 10 万个数据，取第一个和取第 10 万个的耗时多久? 21.有用过 canvas 相关的吗?\n27. JS 垃圾回收机制?怎么定位 Node 内存泄露问题? 23.你是怎么理解前端的? 24.工作中遇到过最难的问题?有没有什么让你自豪的项目? 25.周末你都在做什么?学习前端的途径是什么?\n\n蚂蚁 一面\n\n1. React setState 怎么获取到更新后的值?异步函数中为什么 setState 会立即更新?\n2. 做过离线包吗?H5 离线包的原理?客户端根据什么拦截静态资源 请求?\n3. JS Bridge 的原理?你们这套方案的 s 优缺点?\n4. 怎么判断 webview 是否加载完成?\n5. 怎么实现 App 头部和页面的背景渐变?\n6. PC 端做过比较有意义的项目?\n7. 微前端子应用之间怎么通信?有没有了解过业界的一些方案? 二面\n8. 你们部署的 Jenkins 是怎么做的?\n9. JS Bridge 原理?有没有安全漏洞?\n10. 有没有做过和安全相关的?waf 主要做了什么?\n11. 有没有做过埋点和性能上报相关?\n12. 如果你们用一个第三方的上报库，但页面加载这个 JS 失败了，还 想上报该怎么办?\n13. 实现两个大数相加\n14. 实现 DOM 字符串转虚拟 DOM 对象(不能用 DOM 相关的 api)\n15. 有木有做过你觉得比较困难的项目? 三面\n16. 管理系统都做了哪些业务?有没有做一些提高开发效率的东西?\n17. 常用的组件是哪个?解决了什么问题?\n18. 平时 Node 都用来做什么?怎么实现的?\n19. SSR 的实现原理是什么?\n20. 项目中遇到的技术难点有哪些?\n21. 你觉得你们比 lazada 做得更好是哪些原因?\n","source":"_drafts/1.大厂面试题.md","raw":"---\ntitle: 大厂面试题\nindex_img: /img/2022-03-07-1.png\nabbrlink: 83dcefb7\ndate: 2022-03-07 15:52:23\ntags: 前端\ncategories: 面试\n---\n\n腾讯 一面\n\n1. 写一个 LRU 缓存函数\n2. 写个防抖和节流函数\n3. 你们服务是怎么部署的?Node Agent 做了什么工作?\n4. Grpc 的优缺点?\n5. http2 的相关特性?\n6. viewport 和移动端布局方案\n7. 实现一个 compose 函数\n8. 开发中有遇到过比较难定位的问题吗?Node 内存泄露有遇到过 吗? 二面\n9. react ssr 是在什么场景下做的?\n10. react ssr 双端怎么做构建的?区别在哪里?\n11. 有没有做过同构组件?服务端和客户端怎么同步状态的?\n12. render 和 renderToString 的底层实现上的区别?\n13. 客户端怎么处理 JS 事件失效的问题?客户端不重新加载 JS 的 情况下怎么实现?\n14. 做服务端渲染的时候有没有遇到过比较难的点?\n15. react ssr 和 ejs 性能的差异?\n16. 服务回滚是怎么做的?上线流程是怎样的?k8s 回滚、拉取以前的 镜像\n17. webpack plugin 的原理是什么?\n18. plugin 中有异步请求会阻塞后面的 plugin 吗? 11.做过哪些 webpack 的性能优化?\n19. hard-source-webpack-plugin 是怎么做缓存的?修改文件后会 怎么样?\n20. parallel 的原理是什么?多个子进程怎么通信? 14.你们 webpack 是怎么做拆包的? 15.服务端监控是怎么做的?服务有上报过什么指标?\n21. Node 服务怎么去定位 CPU 占用暴涨的情况?怎么去定位内存泄 露? 17.编写 grpc 服务和 http 服务的区别? 18.做过哪些 react 相关的优化?函数组件怎么实现\n    shouldComponentUpdate? 19.如果有一个非常大的 react 页面，我想优先渲染某一部分，这该怎 么做?\n22. react 函数组件和 class 组件里面 state 的区别?\n23. react useEffect 对应 class 组件的哪些生命周期? 22.前端的监控是怎么做的?除了 sentry 还做了其他异常处理吗? 三面\n24. 讲一下你做的比较复杂的项目?以及你在项目中担当了什么角色?\n25. 你是怎么看待现在各种造轮子的?\n26. 有一个一亿长度的字符串，怎么存储设计可以让它更好去查询、修 改?\n27. 怎么优化 H5 让它可以在 300ms 之内打开?\n28. 你们 WebView 加载一般耗时多久?\n29. 你们为什么从 Python 重构到 Node?好处是什么?\n\n30. 你是怎么看待做后台管理系统的?很多人觉得它没有难点，你觉得 呢?(问这个问题是因为我现在在做后台管理系统) 总监面(有点儿记不清了)\n31. 新加坡和深圳内网是怎么连通的?\n32. 未来的职业规划是什么样的?\n33. 对当前新的技术有了解吗?\n34. 对客户端知识有了解吗?\n35. 为什么要离职?拒了，岗位不是很喜欢\n\n拼多多 一面\n\n1. 有没有做过比较复杂的页面?携程的 React-imvc 做了什么?\n2. 使用 Redux 的好处，以及和 Mobx 的区别\n3. 对 React 最新特性有了解吗?class 组件和函数组件的区别?\n4. useState 为什么不能放到条件语句里面?\n5. 实现一个 Promise.all\n6. React SSR 是怎么实现的?\n7. 有用过代码规范相关的吗?Eslint 和 Prettier 冲突怎么解决?\n8. 实现一个数组转树形结构的函数 二面\n9. 说几个你觉得足够复杂的项目?\n10. 你是怎么去做 React SSR 的?\n11. 有没有做过性能优化相关的?\n12. 实现一个深拷贝\n13. 实现一个二叉搜索树转链表的方法 拒了，不想去卖命 商汤 一面\n14. 在工作中，主要是做什么内容?\n15. 有用过 lerna 吗?多个项目之间共用的东西怎么共享?\n16. 讲一讲微前端是怎么做的?怎么独立部署?子应用通信怎么做?\n17. webpack 构建流程是怎样的?\n18. webpack loader 和 plugin 的原理和区别?\n19. webpack 热更新原理?\n20. webpack 怎么做分包?\n21. 做过 webpack 性能优化吗?有用过 rollup 吗?\n22. react-imvc 是什么?它做了什么?\n23. react 和\n24. redux 和 mobx 的区别和优劣?用过 react-dom 的区别是什么? redux-saga 吗? 的复杂度，以及 react diff 的原理\n25. react diff\n26. react class 组件和 hooks 的区别? 14.什么是 TS 泛型? 15.从输入 url 到页面展示经过了哪些步骤? 16.讲一下重绘和回流 17.知道 BFC\n    吗?使用场景有哪些? 18.怎么判断是否为数组? 19.页面卡顿怎么去定位? 20.数组有 10 万个数据，取第一个和取第 10 万个的耗时多久? 21.有用过 canvas 相关的吗?\n27. JS 垃圾回收机制?怎么定位 Node 内存泄露问题? 23.你是怎么理解前端的? 24.工作中遇到过最难的问题?有没有什么让你自豪的项目? 25.周末你都在做什么?学习前端的途径是什么?\n\n蚂蚁 一面\n\n1. React setState 怎么获取到更新后的值?异步函数中为什么 setState 会立即更新?\n2. 做过离线包吗?H5 离线包的原理?客户端根据什么拦截静态资源 请求?\n3. JS Bridge 的原理?你们这套方案的 s 优缺点?\n4. 怎么判断 webview 是否加载完成?\n5. 怎么实现 App 头部和页面的背景渐变?\n6. PC 端做过比较有意义的项目?\n7. 微前端子应用之间怎么通信?有没有了解过业界的一些方案? 二面\n8. 你们部署的 Jenkins 是怎么做的?\n9. JS Bridge 原理?有没有安全漏洞?\n10. 有没有做过和安全相关的?waf 主要做了什么?\n11. 有没有做过埋点和性能上报相关?\n12. 如果你们用一个第三方的上报库，但页面加载这个 JS 失败了，还 想上报该怎么办?\n13. 实现两个大数相加\n14. 实现 DOM 字符串转虚拟 DOM 对象(不能用 DOM 相关的 api)\n15. 有木有做过你觉得比较困难的项目? 三面\n16. 管理系统都做了哪些业务?有没有做一些提高开发效率的东西?\n17. 常用的组件是哪个?解决了什么问题?\n18. 平时 Node 都用来做什么?怎么实现的?\n19. SSR 的实现原理是什么?\n20. 项目中遇到的技术难点有哪些?\n21. 你觉得你们比 lazada 做得更好是哪些原因?\n","slug":"1-大厂面试题","published":0,"updated":"2022-08-23T02:19:23.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn2z0003yu3l5sb834w5","content":"<p>腾讯 一面</p>\n<ol>\n<li><p>写一个 LRU 缓存函数</p>\n</li>\n<li><p>写个防抖和节流函数</p>\n</li>\n<li><p>你们服务是怎么部署的?Node Agent 做了什么工作?</p>\n</li>\n<li><p>Grpc 的优缺点?</p>\n</li>\n<li><p>http2 的相关特性?</p>\n</li>\n<li><p>viewport 和移动端布局方案</p>\n</li>\n<li><p>实现一个 compose 函数</p>\n</li>\n<li><p>开发中有遇到过比较难定位的问题吗?Node 内存泄露有遇到过 吗? 二面</p>\n</li>\n<li><p>react ssr 是在什么场景下做的?</p>\n</li>\n<li><p>react ssr 双端怎么做构建的?区别在哪里?</p>\n</li>\n<li><p>有没有做过同构组件?服务端和客户端怎么同步状态的?</p>\n</li>\n<li><p>render 和 renderToString 的底层实现上的区别?</p>\n</li>\n<li><p>客户端怎么处理 JS 事件失效的问题?客户端不重新加载 JS 的 情况下怎么实现?</p>\n</li>\n<li><p>做服务端渲染的时候有没有遇到过比较难的点?</p>\n</li>\n<li><p>react ssr 和 ejs 性能的差异?</p>\n</li>\n<li><p>服务回滚是怎么做的?上线流程是怎样的?k8s 回滚、拉取以前的 镜像</p>\n</li>\n<li><p>webpack plugin 的原理是什么?</p>\n</li>\n<li><p>plugin 中有异步请求会阻塞后面的 plugin 吗? 11.做过哪些 webpack 的性能优化?</p>\n</li>\n<li><p>hard-source-webpack-plugin 是怎么做缓存的?修改文件后会 怎么样?</p>\n</li>\n<li><p>parallel 的原理是什么?多个子进程怎么通信? 14.你们 webpack 是怎么做拆包的? 15.服务端监控是怎么做的?服务有上报过什么指标?</p>\n</li>\n<li><p>Node 服务怎么去定位 CPU 占用暴涨的情况?怎么去定位内存泄 露? 17.编写 grpc 服务和 http 服务的区别? 18.做过哪些 react 相关的优化?函数组件怎么实现<br>shouldComponentUpdate? 19.如果有一个非常大的 react 页面，我想优先渲染某一部分，这该怎 么做?</p>\n</li>\n<li><p>react 函数组件和 class 组件里面 state 的区别?</p>\n</li>\n<li><p>react useEffect 对应 class 组件的哪些生命周期? 22.前端的监控是怎么做的?除了 sentry 还做了其他异常处理吗? 三面</p>\n</li>\n<li><p>讲一下你做的比较复杂的项目?以及你在项目中担当了什么角色?</p>\n</li>\n<li><p>你是怎么看待现在各种造轮子的?</p>\n</li>\n<li><p>有一个一亿长度的字符串，怎么存储设计可以让它更好去查询、修 改?</p>\n</li>\n<li><p>怎么优化 H5 让它可以在 300ms 之内打开?</p>\n</li>\n<li><p>你们 WebView 加载一般耗时多久?</p>\n</li>\n<li><p>你们为什么从 Python 重构到 Node?好处是什么?</p>\n</li>\n<li><p>你是怎么看待做后台管理系统的?很多人觉得它没有难点，你觉得 呢?(问这个问题是因为我现在在做后台管理系统) 总监面(有点儿记不清了)</p>\n</li>\n<li><p>新加坡和深圳内网是怎么连通的?</p>\n</li>\n<li><p>未来的职业规划是什么样的?</p>\n</li>\n<li><p>对当前新的技术有了解吗?</p>\n</li>\n<li><p>对客户端知识有了解吗?</p>\n</li>\n<li><p>为什么要离职?拒了，岗位不是很喜欢</p>\n</li>\n</ol>\n<p>拼多多 一面</p>\n<ol>\n<li>有没有做过比较复杂的页面?携程的 React-imvc 做了什么?</li>\n<li>使用 Redux 的好处，以及和 Mobx 的区别</li>\n<li>对 React 最新特性有了解吗?class 组件和函数组件的区别?</li>\n<li>useState 为什么不能放到条件语句里面?</li>\n<li>实现一个 Promise.all</li>\n<li>React SSR 是怎么实现的?</li>\n<li>有用过代码规范相关的吗?Eslint 和 Prettier 冲突怎么解决?</li>\n<li>实现一个数组转树形结构的函数 二面</li>\n<li>说几个你觉得足够复杂的项目?</li>\n<li>你是怎么去做 React SSR 的?</li>\n<li>有没有做过性能优化相关的?</li>\n<li>实现一个深拷贝</li>\n<li>实现一个二叉搜索树转链表的方法 拒了，不想去卖命 商汤 一面</li>\n<li>在工作中，主要是做什么内容?</li>\n<li>有用过 lerna 吗?多个项目之间共用的东西怎么共享?</li>\n<li>讲一讲微前端是怎么做的?怎么独立部署?子应用通信怎么做?</li>\n<li>webpack 构建流程是怎样的?</li>\n<li>webpack loader 和 plugin 的原理和区别?</li>\n<li>webpack 热更新原理?</li>\n<li>webpack 怎么做分包?</li>\n<li>做过 webpack 性能优化吗?有用过 rollup 吗?</li>\n<li>react-imvc 是什么?它做了什么?</li>\n<li>react 和</li>\n<li>redux 和 mobx 的区别和优劣?用过 react-dom 的区别是什么? redux-saga 吗? 的复杂度，以及 react diff 的原理</li>\n<li>react diff</li>\n<li>react class 组件和 hooks 的区别? 14.什么是 TS 泛型? 15.从输入 url 到页面展示经过了哪些步骤? 16.讲一下重绘和回流 17.知道 BFC<br>吗?使用场景有哪些? 18.怎么判断是否为数组? 19.页面卡顿怎么去定位? 20.数组有 10 万个数据，取第一个和取第 10 万个的耗时多久? 21.有用过 canvas 相关的吗?</li>\n<li>JS 垃圾回收机制?怎么定位 Node 内存泄露问题? 23.你是怎么理解前端的? 24.工作中遇到过最难的问题?有没有什么让你自豪的项目? 25.周末你都在做什么?学习前端的途径是什么?</li>\n</ol>\n<p>蚂蚁 一面</p>\n<ol>\n<li>React setState 怎么获取到更新后的值?异步函数中为什么 setState 会立即更新?</li>\n<li>做过离线包吗?H5 离线包的原理?客户端根据什么拦截静态资源 请求?</li>\n<li>JS Bridge 的原理?你们这套方案的 s 优缺点?</li>\n<li>怎么判断 webview 是否加载完成?</li>\n<li>怎么实现 App 头部和页面的背景渐变?</li>\n<li>PC 端做过比较有意义的项目?</li>\n<li>微前端子应用之间怎么通信?有没有了解过业界的一些方案? 二面</li>\n<li>你们部署的 Jenkins 是怎么做的?</li>\n<li>JS Bridge 原理?有没有安全漏洞?</li>\n<li>有没有做过和安全相关的?waf 主要做了什么?</li>\n<li>有没有做过埋点和性能上报相关?</li>\n<li>如果你们用一个第三方的上报库，但页面加载这个 JS 失败了，还 想上报该怎么办?</li>\n<li>实现两个大数相加</li>\n<li>实现 DOM 字符串转虚拟 DOM 对象(不能用 DOM 相关的 api)</li>\n<li>有木有做过你觉得比较困难的项目? 三面</li>\n<li>管理系统都做了哪些业务?有没有做一些提高开发效率的东西?</li>\n<li>常用的组件是哪个?解决了什么问题?</li>\n<li>平时 Node 都用来做什么?怎么实现的?</li>\n<li>SSR 的实现原理是什么?</li>\n<li>项目中遇到的技术难点有哪些?</li>\n<li>你觉得你们比 lazada 做得更好是哪些原因?</li>\n</ol>\n","site":{"data":{}},"wordcount":2261,"excerpt":"","more":"<p>腾讯 一面</p>\n<ol>\n<li><p>写一个 LRU 缓存函数</p>\n</li>\n<li><p>写个防抖和节流函数</p>\n</li>\n<li><p>你们服务是怎么部署的?Node Agent 做了什么工作?</p>\n</li>\n<li><p>Grpc 的优缺点?</p>\n</li>\n<li><p>http2 的相关特性?</p>\n</li>\n<li><p>viewport 和移动端布局方案</p>\n</li>\n<li><p>实现一个 compose 函数</p>\n</li>\n<li><p>开发中有遇到过比较难定位的问题吗?Node 内存泄露有遇到过 吗? 二面</p>\n</li>\n<li><p>react ssr 是在什么场景下做的?</p>\n</li>\n<li><p>react ssr 双端怎么做构建的?区别在哪里?</p>\n</li>\n<li><p>有没有做过同构组件?服务端和客户端怎么同步状态的?</p>\n</li>\n<li><p>render 和 renderToString 的底层实现上的区别?</p>\n</li>\n<li><p>客户端怎么处理 JS 事件失效的问题?客户端不重新加载 JS 的 情况下怎么实现?</p>\n</li>\n<li><p>做服务端渲染的时候有没有遇到过比较难的点?</p>\n</li>\n<li><p>react ssr 和 ejs 性能的差异?</p>\n</li>\n<li><p>服务回滚是怎么做的?上线流程是怎样的?k8s 回滚、拉取以前的 镜像</p>\n</li>\n<li><p>webpack plugin 的原理是什么?</p>\n</li>\n<li><p>plugin 中有异步请求会阻塞后面的 plugin 吗? 11.做过哪些 webpack 的性能优化?</p>\n</li>\n<li><p>hard-source-webpack-plugin 是怎么做缓存的?修改文件后会 怎么样?</p>\n</li>\n<li><p>parallel 的原理是什么?多个子进程怎么通信? 14.你们 webpack 是怎么做拆包的? 15.服务端监控是怎么做的?服务有上报过什么指标?</p>\n</li>\n<li><p>Node 服务怎么去定位 CPU 占用暴涨的情况?怎么去定位内存泄 露? 17.编写 grpc 服务和 http 服务的区别? 18.做过哪些 react 相关的优化?函数组件怎么实现<br>shouldComponentUpdate? 19.如果有一个非常大的 react 页面，我想优先渲染某一部分，这该怎 么做?</p>\n</li>\n<li><p>react 函数组件和 class 组件里面 state 的区别?</p>\n</li>\n<li><p>react useEffect 对应 class 组件的哪些生命周期? 22.前端的监控是怎么做的?除了 sentry 还做了其他异常处理吗? 三面</p>\n</li>\n<li><p>讲一下你做的比较复杂的项目?以及你在项目中担当了什么角色?</p>\n</li>\n<li><p>你是怎么看待现在各种造轮子的?</p>\n</li>\n<li><p>有一个一亿长度的字符串，怎么存储设计可以让它更好去查询、修 改?</p>\n</li>\n<li><p>怎么优化 H5 让它可以在 300ms 之内打开?</p>\n</li>\n<li><p>你们 WebView 加载一般耗时多久?</p>\n</li>\n<li><p>你们为什么从 Python 重构到 Node?好处是什么?</p>\n</li>\n<li><p>你是怎么看待做后台管理系统的?很多人觉得它没有难点，你觉得 呢?(问这个问题是因为我现在在做后台管理系统) 总监面(有点儿记不清了)</p>\n</li>\n<li><p>新加坡和深圳内网是怎么连通的?</p>\n</li>\n<li><p>未来的职业规划是什么样的?</p>\n</li>\n<li><p>对当前新的技术有了解吗?</p>\n</li>\n<li><p>对客户端知识有了解吗?</p>\n</li>\n<li><p>为什么要离职?拒了，岗位不是很喜欢</p>\n</li>\n</ol>\n<p>拼多多 一面</p>\n<ol>\n<li>有没有做过比较复杂的页面?携程的 React-imvc 做了什么?</li>\n<li>使用 Redux 的好处，以及和 Mobx 的区别</li>\n<li>对 React 最新特性有了解吗?class 组件和函数组件的区别?</li>\n<li>useState 为什么不能放到条件语句里面?</li>\n<li>实现一个 Promise.all</li>\n<li>React SSR 是怎么实现的?</li>\n<li>有用过代码规范相关的吗?Eslint 和 Prettier 冲突怎么解决?</li>\n<li>实现一个数组转树形结构的函数 二面</li>\n<li>说几个你觉得足够复杂的项目?</li>\n<li>你是怎么去做 React SSR 的?</li>\n<li>有没有做过性能优化相关的?</li>\n<li>实现一个深拷贝</li>\n<li>实现一个二叉搜索树转链表的方法 拒了，不想去卖命 商汤 一面</li>\n<li>在工作中，主要是做什么内容?</li>\n<li>有用过 lerna 吗?多个项目之间共用的东西怎么共享?</li>\n<li>讲一讲微前端是怎么做的?怎么独立部署?子应用通信怎么做?</li>\n<li>webpack 构建流程是怎样的?</li>\n<li>webpack loader 和 plugin 的原理和区别?</li>\n<li>webpack 热更新原理?</li>\n<li>webpack 怎么做分包?</li>\n<li>做过 webpack 性能优化吗?有用过 rollup 吗?</li>\n<li>react-imvc 是什么?它做了什么?</li>\n<li>react 和</li>\n<li>redux 和 mobx 的区别和优劣?用过 react-dom 的区别是什么? redux-saga 吗? 的复杂度，以及 react diff 的原理</li>\n<li>react diff</li>\n<li>react class 组件和 hooks 的区别? 14.什么是 TS 泛型? 15.从输入 url 到页面展示经过了哪些步骤? 16.讲一下重绘和回流 17.知道 BFC<br>吗?使用场景有哪些? 18.怎么判断是否为数组? 19.页面卡顿怎么去定位? 20.数组有 10 万个数据，取第一个和取第 10 万个的耗时多久? 21.有用过 canvas 相关的吗?</li>\n<li>JS 垃圾回收机制?怎么定位 Node 内存泄露问题? 23.你是怎么理解前端的? 24.工作中遇到过最难的问题?有没有什么让你自豪的项目? 25.周末你都在做什么?学习前端的途径是什么?</li>\n</ol>\n<p>蚂蚁 一面</p>\n<ol>\n<li>React setState 怎么获取到更新后的值?异步函数中为什么 setState 会立即更新?</li>\n<li>做过离线包吗?H5 离线包的原理?客户端根据什么拦截静态资源 请求?</li>\n<li>JS Bridge 的原理?你们这套方案的 s 优缺点?</li>\n<li>怎么判断 webview 是否加载完成?</li>\n<li>怎么实现 App 头部和页面的背景渐变?</li>\n<li>PC 端做过比较有意义的项目?</li>\n<li>微前端子应用之间怎么通信?有没有了解过业界的一些方案? 二面</li>\n<li>你们部署的 Jenkins 是怎么做的?</li>\n<li>JS Bridge 原理?有没有安全漏洞?</li>\n<li>有没有做过和安全相关的?waf 主要做了什么?</li>\n<li>有没有做过埋点和性能上报相关?</li>\n<li>如果你们用一个第三方的上报库，但页面加载这个 JS 失败了，还 想上报该怎么办?</li>\n<li>实现两个大数相加</li>\n<li>实现 DOM 字符串转虚拟 DOM 对象(不能用 DOM 相关的 api)</li>\n<li>有木有做过你觉得比较困难的项目? 三面</li>\n<li>管理系统都做了哪些业务?有没有做一些提高开发效率的东西?</li>\n<li>常用的组件是哪个?解决了什么问题?</li>\n<li>平时 Node 都用来做什么?怎么实现的?</li>\n<li>SSR 的实现原理是什么?</li>\n<li>项目中遇到的技术难点有哪些?</li>\n<li>你觉得你们比 lazada 做得更好是哪些原因?</li>\n</ol>\n"},{"title":"1","index_img":"/img/index-img.png","date":"2022-04-18T02:12:38.000Z","_content":"\n## 面试题\n\n- [面试分享：两年工作经验成功面试阿里P6总结](https://juejin.cn/post/6844903928442667015)\n- [在阿里我是如何当面试官的](https://juejin.cn/post/6844904093425598471#heading-39)\n\n## React Table 设计参考\n\n- [https://gitee.com/yanhuakang/use-table](https://gitee.com/yanhuakang/use-table)\n","source":"_drafts/3.优秀文章合集.md","raw":"---\ntitle: 1\nindex_img: /img/index-img.png\ndate: 2022-04-18 10:12:38\ntags:\ncategories:\n---\n\n## 面试题\n\n- [面试分享：两年工作经验成功面试阿里P6总结](https://juejin.cn/post/6844903928442667015)\n- [在阿里我是如何当面试官的](https://juejin.cn/post/6844904093425598471#heading-39)\n\n## React Table 设计参考\n\n- [https://gitee.com/yanhuakang/use-table](https://gitee.com/yanhuakang/use-table)\n","slug":"3-优秀文章合集","published":0,"updated":"2022-04-29T14:23:37.177Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn330007yu3lgjaedrlw","content":"<h2 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h2><ul>\n<li><a href=\"https://juejin.cn/post/6844903928442667015\">面试分享：两年工作经验成功面试阿里P6总结</a></li>\n<li><a href=\"https://juejin.cn/post/6844904093425598471#heading-39\">在阿里我是如何当面试官的</a></li>\n</ul>\n<h2 id=\"React-Table-设计参考\"><a href=\"#React-Table-设计参考\" class=\"headerlink\" title=\"React Table 设计参考\"></a>React Table 设计参考</h2><ul>\n<li><a href=\"https://gitee.com/yanhuakang/use-table\">https://gitee.com/yanhuakang/use-table</a></li>\n</ul>\n","site":{"data":{}},"wordcount":88,"excerpt":"","more":"<h2 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h2><ul>\n<li><a href=\"https://juejin.cn/post/6844903928442667015\">面试分享：两年工作经验成功面试阿里P6总结</a></li>\n<li><a href=\"https://juejin.cn/post/6844904093425598471#heading-39\">在阿里我是如何当面试官的</a></li>\n</ul>\n<h2 id=\"React-Table-设计参考\"><a href=\"#React-Table-设计参考\" class=\"headerlink\" title=\"React Table 设计参考\"></a>React Table 设计参考</h2><ul>\n<li><a href=\"https://gitee.com/yanhuakang/use-table\">https://gitee.com/yanhuakang/use-table</a></li>\n</ul>\n"},{"title":"Mobx 原理分析","index_img":"/img/2021-12-22-1.png","date":"2021-12-22T15:12:17.000Z","_content":"","source":"_drafts/4.Mobx 原理分析.md","raw":"---\ntitle: Mobx 原理分析\nindex_img: /img/2021-12-22-1.png\ndate: 2021-12-22 23:12:17\ntags: Mobx\ncategories: Mobx\n---\n","slug":"4-Mobx-原理分析","published":0,"updated":"2022-08-23T02:19:23.473Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn350008yu3l38b1a4gq","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""},{"title":"Webpack 原理分析","index_img":"/img/2022-02-08-1.jpeg","date":"2022-02-08T02:29:04.000Z","_content":"","source":"_drafts/5.Webpack 原理分析.md","raw":"---\ntitle: Webpack 原理分析\nindex_img: /img/2022-02-08-1.jpeg\ndate: 2022-02-08 10:29:04\ntags: webpack\ncategories: webpack\n---\n","slug":"5-Webpack-原理分析","published":0,"updated":"2022-08-23T02:19:23.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn350009yu3l8ugc35cq","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""},{"title":"1","index_img":"/img/index-img.png","date":"2022-03-15T10:09:33.000Z","_content":"\n- [React + TypeScript 实践](https://mp.weixin.qq.com/s/mUblBpj6pmdxz9mLKEDJTw)\n","source":"_drafts/7.React + TypeScript.md","raw":"---\ntitle: 1\nindex_img: /img/index-img.png\ndate: 2022-03-15 18:09:33\ntags:\ncategories:\n---\n\n- [React + TypeScript 实践](https://mp.weixin.qq.com/s/mUblBpj6pmdxz9mLKEDJTw)\n","slug":"7-React-TypeScript","published":0,"updated":"2022-08-23T02:19:23.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn3c000dyu3l20pm2ntl","content":"<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/mUblBpj6pmdxz9mLKEDJTw\">React + TypeScript 实践</a></li>\n</ul>\n","site":{"data":{}},"wordcount":18,"excerpt":"","more":"<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/mUblBpj6pmdxz9mLKEDJTw\">React + TypeScript 实践</a></li>\n</ul>\n"},{"title":"FE-Interview","index_img":"/img/2022-01-01-1.jpeg","abbrlink":"12d2438b","date":"2022-01-01T15:28:37.000Z","_content":"\n---\n\n第 1 天（2022.2.28）\n\n## 1. 什么时候使用状态管理器？\n\n1. 组件状态要在多个组件共享时\n2. 某个组件状态需要在任何地方可以拿到\n3. 一个组件需要改变全局状态时\n4. 一个组件需要改变另一个组件状态时\n5. 组件状态提升提升不能满足需求时，层级过多时。\n\n## 2. render 函数中 return 如果没有使用()会有什么问题？\n\n避免遇到自动插入分号陷阱。\n\n我们在使用 JSX 语法书写 react 代码时，babel 会将 JSX 语法编译成 js，同时会在每行自动添加分号（；），如果 return 后换行了，那么就会变成 return；\n一般情况下会报错：\n\nNothing was returned from render. This usually means a return statement is missing. Or, to render\nnothing, return null. 上面这段英文翻译成中文：\n\n渲染没有返回任何内容。这通常意味着缺少 return 语句。或者，为了不渲染，返回 null。 为了代码可读性我们一般会在 return 后面添加括号这样代码可以折行书写，否则就在 return\n后面紧跟着语句，这样也是可以的。\n\n举两个正确的书写例子：\n\n```jsx\nconst Nav = () => {\n  return (\n    <nav className=\"c_navbar\">\n      { some jsx magic here }\n    </nav>\n    )\n  }\n\nconst Nav = () => {\nreturn <nav className=\"c_navbar\">\n    { some jsx magic here }\n  </nav>\n}\n```\n\n错误的写法：\n\n```jsx\nconst Nav = () => {\n  return\n    <nav className=\"c_navbar\">\n      { some jsx magic here }\n    </nav>\n}\n```\n\n## 3. componentWillUpdate 可以直接修改 state 的值吗？\n\n直接修改不可以，但是加上条件就可以。\n\n文档原文：“你也可以在 componentDidUpdate() 中直接调用\nsetState()，但请注意它必须被包裹在一个条件语句里，正如上述的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。”\n\ncomponentWillReceiveProps 同理\n\n## 4. 说说你对 React 的渲染原理的理解\n\n1. React 会调用 React.render()构建一颗 DOM 树，生成虚拟 dom。\n2. 通过改变 state 或 props 触发更新。\n3. 对比新旧虚拟 dom，diff 算法，深度优先，将实际需要改变的反应到真实 dom。\n\n---\n\n第 2 天（2022.3.1）\n\n## 5. 什么渲染劫持？\n\n一般和高阶组件（HOC）一起解释。\n\n高阶组件在 render 的时候可以做其他操作，从而控制原组件的渲染输出，这种改变原组件渲染的方式称为 渲染劫持。\n\n在高阶组件中，组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可实现渲染劫持，还可以增强原组件 render 函数。\n\n除了 HOC，当新写一个组件，继承自一个已有的组件，可以随便修改 render 函数，使用 state、props 等改变原组件的渲染，都叫渲染劫持。\n\nPS: HOC 反向继承\n\nTODO：\n\n## 6. React Intl是什么原理？\n\nReact Intl 用途是国际化库，提供组件、日期等国际化方法。\n\n做国际化就类似于字体文件，通过切换语言，加载不同语言包到本地.\n\n最外层包一个Provider。调用库中方法，完成国际化。\n\n前端国际化核心步骤有两步：\n\n- 创建资源文件，以 key-value 方式存储\n- 加载资源文件，将页面上 key 的内容替换为相关 value\n\n## 7. 怎么实现React组件的国际化呢？\n\n使用 i18next 以及 react-i18next 配合 i18next-scanner，通过 grunt 跑 task 自动扫描生成 json 文件。\n\n现在大厂比较常用的方案是，使用AST，每次开发完新版本，通过AST去扫描所有的代码，找出代码中的中文，以中文为key，调用智能翻译服务，去帮项目自动生成json文件。这样，再也不需要人为去维护json文件，一切都依赖工具进行自动化。\n\n---\n\n第 3 天（2022.3.2）\n\n## 8. 说说Context有哪些属性？\n\ncontext属于一种解决组件间层级过多传递数据的问题，避免了层层嵌套的通过props传递的形式，同时对于不需要使用到redux时，是一种解决方案。\n\nContext.Provider：生产者，数据提供方；通过value属性来定义需要被传递的数据\nContext.Consumer：消费者，数据获取方；根据是函数组件还是class组件，有不同的使用形式；class组件可以指定contextType来确定要使用哪一个context对象的值，函数组件需要使用回调函数的形式来获取context的值；需要显示的指定context对象；\n\n## 9. 怎么使用Context开发组件？\n\n```jsx\nconst themes = {\n  light: {\n    foreground: \"#000000\",\n    background: \"#eeeeee\"\n  },\n  dark: {\n    foreground: \"#ffffff\",\n    background: \"#222222\"\n  }\n};\n// 首先创建一个 context 对象这里命名为：ThemeContext\nconst ThemeContext = React.createContext(themes.light);\n\n// 创建一个祖先组件组件 内部使用Provier 这个对象创建一个组件 其中 value 属性是真实传递的属性\nfunction App() {\n  return (\n    <ThemeContext.Provider value={themes.dark}>\n      <Toolbar />\n    </ThemeContext.Provider>\n  );\n}\n\n// 渲染 button 组件的外层包裹的属性\nfunction Toolbar(props) {\n  return (\n    <div>\n      <ThemedButton />\n    </div>\n  );\n}\n\n// 在 Toolbar 中渲染的button 组件 使用 useContext，将 value 值跨组件传递给 // ThemeButton 组件\nfunction ThemedButton() {\n  const theme = useContext(ThemeContext);\n  return (\n    <button style={{ background: theme.background, color: theme.foreground }}>\n      I am styled by theme context!\n    </button>\n  );\n}\n```\n\n## 10. 为什么React并不推荐我们优先考虑使用Context？\n\n1、Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。\n2、尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context\n3、对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。\n4、context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如\nshouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注。\n\n---\n\n第 4 天（2022.3.3）\n\n## 11. childContextTypes是什么？它有什么用？\n\nchildContextTypes用来定义context数据类型，该api从16.3开始已被废弃\n\n使用方式\n\n```jsx\nclass MessageList extends React.Component {\n  getChildContext() {\n    return {color: \"purple\"};\n  }\n\n  render() {\n    return <div>MessageList</div>;\n  }\n}\n\nMessageList.childContextTypes = {\n  color: PropTypes.string\n};\n```\n\n## 12. Consumer向上找不到Provider的时候怎么办？\n\n当consumer向上层找不到provider时，此时就会取创建context时传给createContext的那个值，也就是当前context对象的默认值，在定义provider时的value中的值不是默认值，而是表示需要被传递的值.\n\n---\n\n第 5 天（2022.3.4）\n\n## 13. 说说你对windowing的了解\n\n展示长列表\n如果你的应用会渲染大量的列表数据，我们建议使用一种称为‘windowing’的技术，这种技术下在任何给定的时间内只会渲染一小部分数据列表，并可以减少列表项的重复渲染（即再次渲染已经渲染过的数据）。\n\nreact-window和react-virtualized都是流行的使用windowing技术的库，他们都提供了一系列可重用的组件，这些组件能够帮助你以最好的性能展示列表以及表格数据\n\n## 14. 举例说明React的 portal 有哪些运用场景？\n\nportal可以将内容插入到除了父节点的dom之外的地方去渲染，所以modal是一个通过portal实现的典型例子；并且对于事件绑定，因为使用了事件冒泡，所以并不用担心被渲染到父组件结构之外的内容，不能去监听事件\n\n## 15. 你有用过React的插槽(Portals)吗？怎么用？\n\n1、首先简单的介绍下react中的插槽（Portals），通过ReactDOM.createPortal(child,\ncontainer)创建，是ReactDOM提供的接口，可以实现将子节点渲染到父组件DOM层次结构之外的DOM节点。 2、第一个参数（child）是任何可渲染的 React\n子元素，例如一个元素，字符串或 片段(fragment)。第二个参数（container）则是一个 DOM 元素。 3、对于 portal 的一个典型用例是当父组件有 overflow: hidden\n或 z-index 样式，但你需要子组件能够在视觉上 “跳出(break out)” 其容器。例如，对话框、hovercards以及提示框。所以一般react组件里的模态框，就是这样实现的。\n\n如果一个子组件的真实DOM结构必须渲染到当前组件外，但又想保留这两者的父子关系，就可以用Protals。\n\n```jsx\nconst Modal = (props) => {\n  const modal = document.body.createElement('div');\n  document.appendChild(modal);\n  useEffect(() => {\n    return () => {\n      document.body.removeChild(modal);\n    }\n  }, []);\n  return React.createPortal(this.props.children, modal);\n}\nconst Parent = () => {\n  const [sum, setSum] = useState(0);\n  const add = () => setSum(sum + 1);\n  return <div onClick={add}>\n    <Modal>加一</Modal>\n  </div>\n}\n```\n\n---\n\n第 6 天（2022.3.5）\n\n## 16. React的严格模式有什么用处？\n\nStrictMode 目前有助于：\n\n- 识别不安全的生命周期\n- 关于使用过时字符串 ref API 的警告\n- 关于使用废弃的 findDOMNode 方法的警告\n- 检测意外的副作用\n- 检测过时的 context API\n\n可以为程序的任何部分使用严格模式\n\n```jsx\nimport React from 'react';\n\nfunction ExampleApplication() {\n  return (\n    <div>\n      <Header />\n      <React.StrictMode>\n        <div>\n          <ComponentOne />\n          <ComponentTwo />\n        </div>\n      </React.StrictMode>\n      <Footer />\n    </div>\n  );\n}\n// 不会对 Header 和 Footer 组件运行严格模式检查。但是，ComponentOne 和 ComponentTwo 以及它们的所有后代元素都将进行检查。\n```\n\n## 17. React如何进行代码拆分？拆分的原则是什么？\n\nreact的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。\n\n在我们的react项目中： 1、在 api 层面我们单独封装，对外暴露http请求的结果。 2、数据层我们使用的react-redux 异步中间件使用的是redux-thunk\n分装处理异步请求，合业务逻辑处理。 3、视图层，尽量使用 redux 层面的传递过来的数据，修改逻辑 也是重新触发action 更改props。 4、静态类型的资源单独放置\n5、公共组件、高阶组件、插件单独放置 6、工具类文件单独放置\n\n## 18. React组件的构造函数有什么作用？\n\n官网中，构造函数仅用于以下两种情况：\n\n- 通过给 this.state 赋值对象来初始化内部 state。\n- 为事件处理函数绑定实例\n\n```jsx\nconstructor(props) {\n  super(props);\n  // 不要在这里调用 this.setState()\n  this.state = { counter: 0 };\n  this.handleClick = this.handleClick.bind(this);\n}\n```\n\n避免将 props 的值复制给 state！这是一个常见的错误：\n\n```jsx\nconstructor(props) {\n super(props);\n // 不要这样做\n this.state = { color: props.color };\n}\n```\n\n如此做毫无必要（你可以直接使用 this.props.color），同时还产生了 bug（更新 prop 中的 color 时，并不会影响 state）。\n\n## 19. React组件的构造函数是必须的吗？\n\nfunction组件不用考虑构造函数； 对于class组件，如果不写构造函数，默认会被隐式调用.\n\n对于无状态组件，内部没有维护自己的state，只接收外部传入的props 是不需要声明构造函数的.\n\n---\n\n第 7 天（2022.3.6）\n\n## 20. React中在哪捕获错误？\n\n可以使用错误边界组件来捕获异常；这样可以使用替代ui来代替错误位置的渲染；而不是让程序崩溃； 主要来捕获生命周期异常，渲染中的异常\n\n使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息\n\n定义错误边界当做常规组件包裹ui组件, 官网例子：\n\n```jsx\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    // 更新 state 使下一次渲染能够显示降级后的 UI\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // 你同样可以将错误日志上报给服务器\n    logErrorToMyService(error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // 你可以自定义降级后的 UI 并渲染\n      return <h1>Something went wrong.</h1>;\n    }\n\n    return this.props.children; \n  }\n}\n```\n\n```jsx\n<ErrorBoundary>\n  <MyWidget />\n</ErrorBoundary>\n```\n\n但是错误边界不会捕获 :\n\n```jsx\ntry{}catch(err){}\n///异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）\n///服务端渲染\n///它自身抛出来的错误（并非它的子组件)\n```\n\n## 21. React怎样引入svg的文件？\n\n方法1： 这种写法会由webpack转为url方式引入。\n\n```jsx\n// svg png等类型图片\nimport logo from './logo.svg';\n//...\n<img src={logo} className=\"App-logo\" alt=\"logo\" />\n//...\n```\n\n方法2： 这种方式仅对SVG图片生效，将svg看作组件导入：\n\n```jsx\n// ...\nimport { ReactComponent as Logo } from './logo.svg'\n// ...\n<Logo />\n```\n\n## 22. 在React中你有经常使用常量吗？\n\n在redux的action文件里面定义不同的行为可能会使用常量的形式。\n\n---\n\n第 8 天（2022.3.7）\n\n## 23. 为什么说React中的props是只读的？\n\n往单向数据流上答： 保证react的单向数据流的设计模式，使状态更可预测。\n如果允许自组件修改，那么一个父组件将状态传递给好几个子组件，这几个子组件随意修改，就完全不可预测，不知道在什么地方修改了状态。 所以我们必须像纯函数一样保护 props 不被修改\n\n## 24. 如果组件的属性没有传值，那么它的默认值是什么？\n\n[官网](https://zh-hans.reactjs.org/docs/jsx-in-depth.html#props-default-to-true)，如果你没给 prop 赋值，它的默认值是\ntrue。以下两个 JSX 表达式是等价的：\n\n```jsx\n<MyTextBox autocomplete />\n\n<MyTextBox autocomplete={true} />\n```\n\n通常，我们不建议不传递 value 给 prop，因为这可能与 ES6 对象简写混淆，{foo} 是 {foo: foo} 的简写，而不是 {foo: true}。这样实现只是为了保持和 HTML\n中标签属性的行为一致。\n\n## 25. `super()`和`super(props)`有什么区别？\n\nreact 中的class 是基于es6的规范实现的, 继承是使用extends关键字实现继承的，子类必须在constructor()中调用super() 方法否则新建实例就会报错，报错的原因是\n子类是没有自己的this对象的，它只能继承父类的this对象，然后对其进行加工，而super()就是将父类中的this对象继承给子类的，没有super() 子类就得不到this对象。\n\n如果你使用了constructor就必须写super() 这个是用来初始化this的，可以绑定事件到this上 如果你想要在constructor中使用this.props,就必须给super添加参数\nsuper(props) 注意，无论有没有 constructor，在render中的this.props都是可以使用的，这是react自动附带的 如果没有用到constructor\n是可以不写的，react会默认添加一个空的constroctor.\n\nsuper 指的是父类（即超类）的构造函数。\n\n在调用父类的构造函数之前，你是不能在 constructor 中使用 this 关键字的.\n\n参考 [why-do-we-write-super-props](https://overreacted.io/zh-hans/why-do-we-write-super-props/)\n","source":"_posts/1.FE-Interview.md","raw":"---\ntitle: FE-Interview\nindex_img: /img/2022-01-01-1.jpeg\ntags: 前端\ncategories: 面试\nabbrlink: 12d2438b\ndate: 2022-01-01 23:28:37\n---\n\n---\n\n第 1 天（2022.2.28）\n\n## 1. 什么时候使用状态管理器？\n\n1. 组件状态要在多个组件共享时\n2. 某个组件状态需要在任何地方可以拿到\n3. 一个组件需要改变全局状态时\n4. 一个组件需要改变另一个组件状态时\n5. 组件状态提升提升不能满足需求时，层级过多时。\n\n## 2. render 函数中 return 如果没有使用()会有什么问题？\n\n避免遇到自动插入分号陷阱。\n\n我们在使用 JSX 语法书写 react 代码时，babel 会将 JSX 语法编译成 js，同时会在每行自动添加分号（；），如果 return 后换行了，那么就会变成 return；\n一般情况下会报错：\n\nNothing was returned from render. This usually means a return statement is missing. Or, to render\nnothing, return null. 上面这段英文翻译成中文：\n\n渲染没有返回任何内容。这通常意味着缺少 return 语句。或者，为了不渲染，返回 null。 为了代码可读性我们一般会在 return 后面添加括号这样代码可以折行书写，否则就在 return\n后面紧跟着语句，这样也是可以的。\n\n举两个正确的书写例子：\n\n```jsx\nconst Nav = () => {\n  return (\n    <nav className=\"c_navbar\">\n      { some jsx magic here }\n    </nav>\n    )\n  }\n\nconst Nav = () => {\nreturn <nav className=\"c_navbar\">\n    { some jsx magic here }\n  </nav>\n}\n```\n\n错误的写法：\n\n```jsx\nconst Nav = () => {\n  return\n    <nav className=\"c_navbar\">\n      { some jsx magic here }\n    </nav>\n}\n```\n\n## 3. componentWillUpdate 可以直接修改 state 的值吗？\n\n直接修改不可以，但是加上条件就可以。\n\n文档原文：“你也可以在 componentDidUpdate() 中直接调用\nsetState()，但请注意它必须被包裹在一个条件语句里，正如上述的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。”\n\ncomponentWillReceiveProps 同理\n\n## 4. 说说你对 React 的渲染原理的理解\n\n1. React 会调用 React.render()构建一颗 DOM 树，生成虚拟 dom。\n2. 通过改变 state 或 props 触发更新。\n3. 对比新旧虚拟 dom，diff 算法，深度优先，将实际需要改变的反应到真实 dom。\n\n---\n\n第 2 天（2022.3.1）\n\n## 5. 什么渲染劫持？\n\n一般和高阶组件（HOC）一起解释。\n\n高阶组件在 render 的时候可以做其他操作，从而控制原组件的渲染输出，这种改变原组件渲染的方式称为 渲染劫持。\n\n在高阶组件中，组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可实现渲染劫持，还可以增强原组件 render 函数。\n\n除了 HOC，当新写一个组件，继承自一个已有的组件，可以随便修改 render 函数，使用 state、props 等改变原组件的渲染，都叫渲染劫持。\n\nPS: HOC 反向继承\n\nTODO：\n\n## 6. React Intl是什么原理？\n\nReact Intl 用途是国际化库，提供组件、日期等国际化方法。\n\n做国际化就类似于字体文件，通过切换语言，加载不同语言包到本地.\n\n最外层包一个Provider。调用库中方法，完成国际化。\n\n前端国际化核心步骤有两步：\n\n- 创建资源文件，以 key-value 方式存储\n- 加载资源文件，将页面上 key 的内容替换为相关 value\n\n## 7. 怎么实现React组件的国际化呢？\n\n使用 i18next 以及 react-i18next 配合 i18next-scanner，通过 grunt 跑 task 自动扫描生成 json 文件。\n\n现在大厂比较常用的方案是，使用AST，每次开发完新版本，通过AST去扫描所有的代码，找出代码中的中文，以中文为key，调用智能翻译服务，去帮项目自动生成json文件。这样，再也不需要人为去维护json文件，一切都依赖工具进行自动化。\n\n---\n\n第 3 天（2022.3.2）\n\n## 8. 说说Context有哪些属性？\n\ncontext属于一种解决组件间层级过多传递数据的问题，避免了层层嵌套的通过props传递的形式，同时对于不需要使用到redux时，是一种解决方案。\n\nContext.Provider：生产者，数据提供方；通过value属性来定义需要被传递的数据\nContext.Consumer：消费者，数据获取方；根据是函数组件还是class组件，有不同的使用形式；class组件可以指定contextType来确定要使用哪一个context对象的值，函数组件需要使用回调函数的形式来获取context的值；需要显示的指定context对象；\n\n## 9. 怎么使用Context开发组件？\n\n```jsx\nconst themes = {\n  light: {\n    foreground: \"#000000\",\n    background: \"#eeeeee\"\n  },\n  dark: {\n    foreground: \"#ffffff\",\n    background: \"#222222\"\n  }\n};\n// 首先创建一个 context 对象这里命名为：ThemeContext\nconst ThemeContext = React.createContext(themes.light);\n\n// 创建一个祖先组件组件 内部使用Provier 这个对象创建一个组件 其中 value 属性是真实传递的属性\nfunction App() {\n  return (\n    <ThemeContext.Provider value={themes.dark}>\n      <Toolbar />\n    </ThemeContext.Provider>\n  );\n}\n\n// 渲染 button 组件的外层包裹的属性\nfunction Toolbar(props) {\n  return (\n    <div>\n      <ThemedButton />\n    </div>\n  );\n}\n\n// 在 Toolbar 中渲染的button 组件 使用 useContext，将 value 值跨组件传递给 // ThemeButton 组件\nfunction ThemedButton() {\n  const theme = useContext(ThemeContext);\n  return (\n    <button style={{ background: theme.background, color: theme.foreground }}>\n      I am styled by theme context!\n    </button>\n  );\n}\n```\n\n## 10. 为什么React并不推荐我们优先考虑使用Context？\n\n1、Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。\n2、尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context\n3、对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。\n4、context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如\nshouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注。\n\n---\n\n第 4 天（2022.3.3）\n\n## 11. childContextTypes是什么？它有什么用？\n\nchildContextTypes用来定义context数据类型，该api从16.3开始已被废弃\n\n使用方式\n\n```jsx\nclass MessageList extends React.Component {\n  getChildContext() {\n    return {color: \"purple\"};\n  }\n\n  render() {\n    return <div>MessageList</div>;\n  }\n}\n\nMessageList.childContextTypes = {\n  color: PropTypes.string\n};\n```\n\n## 12. Consumer向上找不到Provider的时候怎么办？\n\n当consumer向上层找不到provider时，此时就会取创建context时传给createContext的那个值，也就是当前context对象的默认值，在定义provider时的value中的值不是默认值，而是表示需要被传递的值.\n\n---\n\n第 5 天（2022.3.4）\n\n## 13. 说说你对windowing的了解\n\n展示长列表\n如果你的应用会渲染大量的列表数据，我们建议使用一种称为‘windowing’的技术，这种技术下在任何给定的时间内只会渲染一小部分数据列表，并可以减少列表项的重复渲染（即再次渲染已经渲染过的数据）。\n\nreact-window和react-virtualized都是流行的使用windowing技术的库，他们都提供了一系列可重用的组件，这些组件能够帮助你以最好的性能展示列表以及表格数据\n\n## 14. 举例说明React的 portal 有哪些运用场景？\n\nportal可以将内容插入到除了父节点的dom之外的地方去渲染，所以modal是一个通过portal实现的典型例子；并且对于事件绑定，因为使用了事件冒泡，所以并不用担心被渲染到父组件结构之外的内容，不能去监听事件\n\n## 15. 你有用过React的插槽(Portals)吗？怎么用？\n\n1、首先简单的介绍下react中的插槽（Portals），通过ReactDOM.createPortal(child,\ncontainer)创建，是ReactDOM提供的接口，可以实现将子节点渲染到父组件DOM层次结构之外的DOM节点。 2、第一个参数（child）是任何可渲染的 React\n子元素，例如一个元素，字符串或 片段(fragment)。第二个参数（container）则是一个 DOM 元素。 3、对于 portal 的一个典型用例是当父组件有 overflow: hidden\n或 z-index 样式，但你需要子组件能够在视觉上 “跳出(break out)” 其容器。例如，对话框、hovercards以及提示框。所以一般react组件里的模态框，就是这样实现的。\n\n如果一个子组件的真实DOM结构必须渲染到当前组件外，但又想保留这两者的父子关系，就可以用Protals。\n\n```jsx\nconst Modal = (props) => {\n  const modal = document.body.createElement('div');\n  document.appendChild(modal);\n  useEffect(() => {\n    return () => {\n      document.body.removeChild(modal);\n    }\n  }, []);\n  return React.createPortal(this.props.children, modal);\n}\nconst Parent = () => {\n  const [sum, setSum] = useState(0);\n  const add = () => setSum(sum + 1);\n  return <div onClick={add}>\n    <Modal>加一</Modal>\n  </div>\n}\n```\n\n---\n\n第 6 天（2022.3.5）\n\n## 16. React的严格模式有什么用处？\n\nStrictMode 目前有助于：\n\n- 识别不安全的生命周期\n- 关于使用过时字符串 ref API 的警告\n- 关于使用废弃的 findDOMNode 方法的警告\n- 检测意外的副作用\n- 检测过时的 context API\n\n可以为程序的任何部分使用严格模式\n\n```jsx\nimport React from 'react';\n\nfunction ExampleApplication() {\n  return (\n    <div>\n      <Header />\n      <React.StrictMode>\n        <div>\n          <ComponentOne />\n          <ComponentTwo />\n        </div>\n      </React.StrictMode>\n      <Footer />\n    </div>\n  );\n}\n// 不会对 Header 和 Footer 组件运行严格模式检查。但是，ComponentOne 和 ComponentTwo 以及它们的所有后代元素都将进行检查。\n```\n\n## 17. React如何进行代码拆分？拆分的原则是什么？\n\nreact的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。\n\n在我们的react项目中： 1、在 api 层面我们单独封装，对外暴露http请求的结果。 2、数据层我们使用的react-redux 异步中间件使用的是redux-thunk\n分装处理异步请求，合业务逻辑处理。 3、视图层，尽量使用 redux 层面的传递过来的数据，修改逻辑 也是重新触发action 更改props。 4、静态类型的资源单独放置\n5、公共组件、高阶组件、插件单独放置 6、工具类文件单独放置\n\n## 18. React组件的构造函数有什么作用？\n\n官网中，构造函数仅用于以下两种情况：\n\n- 通过给 this.state 赋值对象来初始化内部 state。\n- 为事件处理函数绑定实例\n\n```jsx\nconstructor(props) {\n  super(props);\n  // 不要在这里调用 this.setState()\n  this.state = { counter: 0 };\n  this.handleClick = this.handleClick.bind(this);\n}\n```\n\n避免将 props 的值复制给 state！这是一个常见的错误：\n\n```jsx\nconstructor(props) {\n super(props);\n // 不要这样做\n this.state = { color: props.color };\n}\n```\n\n如此做毫无必要（你可以直接使用 this.props.color），同时还产生了 bug（更新 prop 中的 color 时，并不会影响 state）。\n\n## 19. React组件的构造函数是必须的吗？\n\nfunction组件不用考虑构造函数； 对于class组件，如果不写构造函数，默认会被隐式调用.\n\n对于无状态组件，内部没有维护自己的state，只接收外部传入的props 是不需要声明构造函数的.\n\n---\n\n第 7 天（2022.3.6）\n\n## 20. React中在哪捕获错误？\n\n可以使用错误边界组件来捕获异常；这样可以使用替代ui来代替错误位置的渲染；而不是让程序崩溃； 主要来捕获生命周期异常，渲染中的异常\n\n使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息\n\n定义错误边界当做常规组件包裹ui组件, 官网例子：\n\n```jsx\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    // 更新 state 使下一次渲染能够显示降级后的 UI\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // 你同样可以将错误日志上报给服务器\n    logErrorToMyService(error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // 你可以自定义降级后的 UI 并渲染\n      return <h1>Something went wrong.</h1>;\n    }\n\n    return this.props.children; \n  }\n}\n```\n\n```jsx\n<ErrorBoundary>\n  <MyWidget />\n</ErrorBoundary>\n```\n\n但是错误边界不会捕获 :\n\n```jsx\ntry{}catch(err){}\n///异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）\n///服务端渲染\n///它自身抛出来的错误（并非它的子组件)\n```\n\n## 21. React怎样引入svg的文件？\n\n方法1： 这种写法会由webpack转为url方式引入。\n\n```jsx\n// svg png等类型图片\nimport logo from './logo.svg';\n//...\n<img src={logo} className=\"App-logo\" alt=\"logo\" />\n//...\n```\n\n方法2： 这种方式仅对SVG图片生效，将svg看作组件导入：\n\n```jsx\n// ...\nimport { ReactComponent as Logo } from './logo.svg'\n// ...\n<Logo />\n```\n\n## 22. 在React中你有经常使用常量吗？\n\n在redux的action文件里面定义不同的行为可能会使用常量的形式。\n\n---\n\n第 8 天（2022.3.7）\n\n## 23. 为什么说React中的props是只读的？\n\n往单向数据流上答： 保证react的单向数据流的设计模式，使状态更可预测。\n如果允许自组件修改，那么一个父组件将状态传递给好几个子组件，这几个子组件随意修改，就完全不可预测，不知道在什么地方修改了状态。 所以我们必须像纯函数一样保护 props 不被修改\n\n## 24. 如果组件的属性没有传值，那么它的默认值是什么？\n\n[官网](https://zh-hans.reactjs.org/docs/jsx-in-depth.html#props-default-to-true)，如果你没给 prop 赋值，它的默认值是\ntrue。以下两个 JSX 表达式是等价的：\n\n```jsx\n<MyTextBox autocomplete />\n\n<MyTextBox autocomplete={true} />\n```\n\n通常，我们不建议不传递 value 给 prop，因为这可能与 ES6 对象简写混淆，{foo} 是 {foo: foo} 的简写，而不是 {foo: true}。这样实现只是为了保持和 HTML\n中标签属性的行为一致。\n\n## 25. `super()`和`super(props)`有什么区别？\n\nreact 中的class 是基于es6的规范实现的, 继承是使用extends关键字实现继承的，子类必须在constructor()中调用super() 方法否则新建实例就会报错，报错的原因是\n子类是没有自己的this对象的，它只能继承父类的this对象，然后对其进行加工，而super()就是将父类中的this对象继承给子类的，没有super() 子类就得不到this对象。\n\n如果你使用了constructor就必须写super() 这个是用来初始化this的，可以绑定事件到this上 如果你想要在constructor中使用this.props,就必须给super添加参数\nsuper(props) 注意，无论有没有 constructor，在render中的this.props都是可以使用的，这是react自动附带的 如果没有用到constructor\n是可以不写的，react会默认添加一个空的constroctor.\n\nsuper 指的是父类（即超类）的构造函数。\n\n在调用父类的构造函数之前，你是不能在 constructor 中使用 this 关键字的.\n\n参考 [why-do-we-write-super-props](https://overreacted.io/zh-hans/why-do-we-write-super-props/)\n","slug":"1-FE-Interview","published":1,"updated":"2022-08-23T02:19:23.471Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn3f000eyu3l41yp1zmk","content":"<hr>\n<p>第 1 天（2022.2.28）</p>\n<h2 id=\"1-什么时候使用状态管理器？\"><a href=\"#1-什么时候使用状态管理器？\" class=\"headerlink\" title=\"1. 什么时候使用状态管理器？\"></a>1. 什么时候使用状态管理器？</h2><ol>\n<li>组件状态要在多个组件共享时</li>\n<li>某个组件状态需要在任何地方可以拿到</li>\n<li>一个组件需要改变全局状态时</li>\n<li>一个组件需要改变另一个组件状态时</li>\n<li>组件状态提升提升不能满足需求时，层级过多时。</li>\n</ol>\n<h2 id=\"2-render-函数中-return-如果没有使用-会有什么问题？\"><a href=\"#2-render-函数中-return-如果没有使用-会有什么问题？\" class=\"headerlink\" title=\"2. render 函数中 return 如果没有使用()会有什么问题？\"></a>2. render 函数中 return 如果没有使用()会有什么问题？</h2><p>避免遇到自动插入分号陷阱。</p>\n<p>我们在使用 JSX 语法书写 react 代码时，babel 会将 JSX 语法编译成 js，同时会在每行自动添加分号（；），如果 return 后换行了，那么就会变成 return；<br>一般情况下会报错：</p>\n<p>Nothing was returned from render. This usually means a return statement is missing. Or, to render<br>nothing, return null. 上面这段英文翻译成中文：</p>\n<p>渲染没有返回任何内容。这通常意味着缺少 return 语句。或者，为了不渲染，返回 null。 为了代码可读性我们一般会在 return 后面添加括号这样代码可以折行书写，否则就在 return<br>后面紧跟着语句，这样也是可以的。</p>\n<p>举两个正确的书写例子：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Nav = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;c_navbar&quot;</span>&gt;</span></span>\n<span class=\"xml\">      &#123; some jsx magic here &#125;</span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span></span>\n    )\n  &#125;\n\n<span class=\"hljs-keyword\">const</span> Nav = <span class=\"hljs-function\">() =&gt;</span> &#123;\n<span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;c_navbar&quot;</span>&gt;</span></span>\n<span class=\"xml\">    &#123; some jsx magic here &#125;</span>\n<span class=\"xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span></span>\n&#125;</code></pre></div>\n\n<p>错误的写法：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Nav = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">return</span>\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;c_navbar&quot;</span>&gt;</span></span>\n<span class=\"xml\">      &#123; some jsx magic here &#125;</span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span></span>\n&#125;</code></pre></div>\n\n<h2 id=\"3-componentWillUpdate-可以直接修改-state-的值吗？\"><a href=\"#3-componentWillUpdate-可以直接修改-state-的值吗？\" class=\"headerlink\" title=\"3. componentWillUpdate 可以直接修改 state 的值吗？\"></a>3. componentWillUpdate 可以直接修改 state 的值吗？</h2><p>直接修改不可以，但是加上条件就可以。</p>\n<p>文档原文：“你也可以在 componentDidUpdate() 中直接调用<br>setState()，但请注意它必须被包裹在一个条件语句里，正如上述的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。”</p>\n<p>componentWillReceiveProps 同理</p>\n<h2 id=\"4-说说你对-React-的渲染原理的理解\"><a href=\"#4-说说你对-React-的渲染原理的理解\" class=\"headerlink\" title=\"4. 说说你对 React 的渲染原理的理解\"></a>4. 说说你对 React 的渲染原理的理解</h2><ol>\n<li>React 会调用 React.render()构建一颗 DOM 树，生成虚拟 dom。</li>\n<li>通过改变 state 或 props 触发更新。</li>\n<li>对比新旧虚拟 dom，diff 算法，深度优先，将实际需要改变的反应到真实 dom。</li>\n</ol>\n<hr>\n<p>第 2 天（2022.3.1）</p>\n<h2 id=\"5-什么渲染劫持？\"><a href=\"#5-什么渲染劫持？\" class=\"headerlink\" title=\"5. 什么渲染劫持？\"></a>5. 什么渲染劫持？</h2><p>一般和高阶组件（HOC）一起解释。</p>\n<p>高阶组件在 render 的时候可以做其他操作，从而控制原组件的渲染输出，这种改变原组件渲染的方式称为 渲染劫持。</p>\n<p>在高阶组件中，组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可实现渲染劫持，还可以增强原组件 render 函数。</p>\n<p>除了 HOC，当新写一个组件，继承自一个已有的组件，可以随便修改 render 函数，使用 state、props 等改变原组件的渲染，都叫渲染劫持。</p>\n<p>PS: HOC 反向继承</p>\n<p>TODO：</p>\n<h2 id=\"6-React-Intl是什么原理？\"><a href=\"#6-React-Intl是什么原理？\" class=\"headerlink\" title=\"6. React Intl是什么原理？\"></a>6. React Intl是什么原理？</h2><p>React Intl 用途是国际化库，提供组件、日期等国际化方法。</p>\n<p>做国际化就类似于字体文件，通过切换语言，加载不同语言包到本地.</p>\n<p>最外层包一个Provider。调用库中方法，完成国际化。</p>\n<p>前端国际化核心步骤有两步：</p>\n<ul>\n<li>创建资源文件，以 key-value 方式存储</li>\n<li>加载资源文件，将页面上 key 的内容替换为相关 value</li>\n</ul>\n<h2 id=\"7-怎么实现React组件的国际化呢？\"><a href=\"#7-怎么实现React组件的国际化呢？\" class=\"headerlink\" title=\"7. 怎么实现React组件的国际化呢？\"></a>7. 怎么实现React组件的国际化呢？</h2><p>使用 i18next 以及 react-i18next 配合 i18next-scanner，通过 grunt 跑 task 自动扫描生成 json 文件。</p>\n<p>现在大厂比较常用的方案是，使用AST，每次开发完新版本，通过AST去扫描所有的代码，找出代码中的中文，以中文为key，调用智能翻译服务，去帮项目自动生成json文件。这样，再也不需要人为去维护json文件，一切都依赖工具进行自动化。</p>\n<hr>\n<p>第 3 天（2022.3.2）</p>\n<h2 id=\"8-说说Context有哪些属性？\"><a href=\"#8-说说Context有哪些属性？\" class=\"headerlink\" title=\"8. 说说Context有哪些属性？\"></a>8. 说说Context有哪些属性？</h2><p>context属于一种解决组件间层级过多传递数据的问题，避免了层层嵌套的通过props传递的形式，同时对于不需要使用到redux时，是一种解决方案。</p>\n<p>Context.Provider：生产者，数据提供方；通过value属性来定义需要被传递的数据<br>Context.Consumer：消费者，数据获取方；根据是函数组件还是class组件，有不同的使用形式；class组件可以指定contextType来确定要使用哪一个context对象的值，函数组件需要使用回调函数的形式来获取context的值；需要显示的指定context对象；</p>\n<h2 id=\"9-怎么使用Context开发组件？\"><a href=\"#9-怎么使用Context开发组件？\" class=\"headerlink\" title=\"9. 怎么使用Context开发组件？\"></a>9. 怎么使用Context开发组件？</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> themes = &#123;\n  <span class=\"hljs-attr\">light</span>: &#123;\n    <span class=\"hljs-attr\">foreground</span>: <span class=\"hljs-string\">&quot;#000000&quot;</span>,\n    <span class=\"hljs-attr\">background</span>: <span class=\"hljs-string\">&quot;#eeeeee&quot;</span>\n  &#125;,\n  <span class=\"hljs-attr\">dark</span>: &#123;\n    <span class=\"hljs-attr\">foreground</span>: <span class=\"hljs-string\">&quot;#ffffff&quot;</span>,\n    <span class=\"hljs-attr\">background</span>: <span class=\"hljs-string\">&quot;#222222&quot;</span>\n  &#125;\n&#125;;\n<span class=\"hljs-comment\">// 首先创建一个 context 对象这里命名为：ThemeContext</span>\n<span class=\"hljs-keyword\">const</span> ThemeContext = React.createContext(themes.light);\n\n<span class=\"hljs-comment\">// 创建一个祖先组件组件 内部使用Provier 这个对象创建一个组件 其中 value 属性是真实传递的属性</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ThemeContext.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;themes.dark&#125;</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Toolbar</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ThemeContext.Provider</span>&gt;</span></span>\n  );\n&#125;\n\n<span class=\"hljs-comment\">// 渲染 button 组件的外层包裹的属性</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Toolbar</span>(<span class=\"hljs-params\">props</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ThemedButton</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;\n\n<span class=\"hljs-comment\">// 在 Toolbar 中渲染的button 组件 使用 useContext，将 value 值跨组件传递给 // ThemeButton 组件</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ThemedButton</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> theme = useContext(ThemeContext);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&#123;&#123;</span> <span class=\"hljs-attr\">background:</span> <span class=\"hljs-attr\">theme.background</span>, <span class=\"hljs-attr\">color:</span> <span class=\"hljs-attr\">theme.foreground</span> &#125;&#125;&gt;</span></span>\n<span class=\"xml\">      I am styled by theme context!</span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n  );\n&#125;</code></pre></div>\n\n<h2 id=\"10-为什么React并不推荐我们优先考虑使用Context？\"><a href=\"#10-为什么React并不推荐我们优先考虑使用Context？\" class=\"headerlink\" title=\"10. 为什么React并不推荐我们优先考虑使用Context？\"></a>10. 为什么React并不推荐我们优先考虑使用Context？</h2><p>1、Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。<br>2、尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context<br>3、对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。<br>4、context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如<br>shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注。</p>\n<hr>\n<p>第 4 天（2022.3.3）</p>\n<h2 id=\"11-childContextTypes是什么？它有什么用？\"><a href=\"#11-childContextTypes是什么？它有什么用？\" class=\"headerlink\" title=\"11. childContextTypes是什么？它有什么用？\"></a>11. childContextTypes是什么？它有什么用？</h2><p>childContextTypes用来定义context数据类型，该api从16.3开始已被废弃</p>\n<p>使用方式</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MessageList</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">getChildContext</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;purple&quot;</span>&#125;;\n  &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>MessageList<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n  &#125;\n&#125;\n\nMessageList.childContextTypes = &#123;\n  <span class=\"hljs-attr\">color</span>: PropTypes.string\n&#125;;</code></pre></div>\n\n<h2 id=\"12-Consumer向上找不到Provider的时候怎么办？\"><a href=\"#12-Consumer向上找不到Provider的时候怎么办？\" class=\"headerlink\" title=\"12. Consumer向上找不到Provider的时候怎么办？\"></a>12. Consumer向上找不到Provider的时候怎么办？</h2><p>当consumer向上层找不到provider时，此时就会取创建context时传给createContext的那个值，也就是当前context对象的默认值，在定义provider时的value中的值不是默认值，而是表示需要被传递的值.</p>\n<hr>\n<p>第 5 天（2022.3.4）</p>\n<h2 id=\"13-说说你对windowing的了解\"><a href=\"#13-说说你对windowing的了解\" class=\"headerlink\" title=\"13. 说说你对windowing的了解\"></a>13. 说说你对windowing的了解</h2><p>展示长列表<br>如果你的应用会渲染大量的列表数据，我们建议使用一种称为‘windowing’的技术，这种技术下在任何给定的时间内只会渲染一小部分数据列表，并可以减少列表项的重复渲染（即再次渲染已经渲染过的数据）。</p>\n<p>react-window和react-virtualized都是流行的使用windowing技术的库，他们都提供了一系列可重用的组件，这些组件能够帮助你以最好的性能展示列表以及表格数据</p>\n<h2 id=\"14-举例说明React的-portal-有哪些运用场景？\"><a href=\"#14-举例说明React的-portal-有哪些运用场景？\" class=\"headerlink\" title=\"14. 举例说明React的 portal 有哪些运用场景？\"></a>14. 举例说明React的 portal 有哪些运用场景？</h2><p>portal可以将内容插入到除了父节点的dom之外的地方去渲染，所以modal是一个通过portal实现的典型例子；并且对于事件绑定，因为使用了事件冒泡，所以并不用担心被渲染到父组件结构之外的内容，不能去监听事件</p>\n<h2 id=\"15-你有用过React的插槽-Portals-吗？怎么用？\"><a href=\"#15-你有用过React的插槽-Portals-吗？怎么用？\" class=\"headerlink\" title=\"15. 你有用过React的插槽(Portals)吗？怎么用？\"></a>15. 你有用过React的插槽(Portals)吗？怎么用？</h2><p>1、首先简单的介绍下react中的插槽（Portals），通过ReactDOM.createPortal(child,<br>container)创建，是ReactDOM提供的接口，可以实现将子节点渲染到父组件DOM层次结构之外的DOM节点。 2、第一个参数（child）是任何可渲染的 React<br>子元素，例如一个元素，字符串或 片段(fragment)。第二个参数（container）则是一个 DOM 元素。 3、对于 portal 的一个典型用例是当父组件有 overflow: hidden<br>或 z-index 样式，但你需要子组件能够在视觉上 “跳出(break out)” 其容器。例如，对话框、hovercards以及提示框。所以一般react组件里的模态框，就是这样实现的。</p>\n<p>如果一个子组件的真实DOM结构必须渲染到当前组件外，但又想保留这两者的父子关系，就可以用Protals。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Modal = <span class=\"hljs-function\">(<span class=\"hljs-params\">props</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> modal = <span class=\"hljs-built_in\">document</span>.body.createElement(<span class=\"hljs-string\">&#x27;div&#x27;</span>);\n  <span class=\"hljs-built_in\">document</span>.appendChild(modal);\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">document</span>.body.removeChild(modal);\n    &#125;\n  &#125;, []);\n  <span class=\"hljs-keyword\">return</span> React.createPortal(<span class=\"hljs-built_in\">this</span>.props.children, modal);\n&#125;\n<span class=\"hljs-keyword\">const</span> Parent = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> [sum, setSum] = useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\">() =&gt;</span> setSum(sum + <span class=\"hljs-number\">1</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;add&#125;</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Modal</span>&gt;</span>加一<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Modal</span>&gt;</span></span>\n<span class=\"xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n&#125;</code></pre></div>\n\n<hr>\n<p>第 6 天（2022.3.5）</p>\n<h2 id=\"16-React的严格模式有什么用处？\"><a href=\"#16-React的严格模式有什么用处？\" class=\"headerlink\" title=\"16. React的严格模式有什么用处？\"></a>16. React的严格模式有什么用处？</h2><p>StrictMode 目前有助于：</p>\n<ul>\n<li>识别不安全的生命周期</li>\n<li>关于使用过时字符串 ref API 的警告</li>\n<li>关于使用废弃的 findDOMNode 方法的警告</li>\n<li>检测意外的副作用</li>\n<li>检测过时的 context API</li>\n</ul>\n<p>可以为程序的任何部分使用严格模式</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ExampleApplication</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Header</span> /&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">React.StrictMode</span>&gt;</span></span>\n<span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ComponentOne</span> /&gt;</span></span>\n<span class=\"xml\">          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ComponentTwo</span> /&gt;</span></span>\n<span class=\"xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">React.StrictMode</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Footer</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;\n<span class=\"hljs-comment\">// 不会对 Header 和 Footer 组件运行严格模式检查。但是，ComponentOne 和 ComponentTwo 以及它们的所有后代元素都将进行检查。</span></code></pre></div>\n\n<h2 id=\"17-React如何进行代码拆分？拆分的原则是什么？\"><a href=\"#17-React如何进行代码拆分？拆分的原则是什么？\" class=\"headerlink\" title=\"17. React如何进行代码拆分？拆分的原则是什么？\"></a>17. React如何进行代码拆分？拆分的原则是什么？</h2><p>react的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。</p>\n<p>在我们的react项目中： 1、在 api 层面我们单独封装，对外暴露http请求的结果。 2、数据层我们使用的react-redux 异步中间件使用的是redux-thunk<br>分装处理异步请求，合业务逻辑处理。 3、视图层，尽量使用 redux 层面的传递过来的数据，修改逻辑 也是重新触发action 更改props。 4、静态类型的资源单独放置<br>5、公共组件、高阶组件、插件单独放置 6、工具类文件单独放置</p>\n<h2 id=\"18-React组件的构造函数有什么作用？\"><a href=\"#18-React组件的构造函数有什么作用？\" class=\"headerlink\" title=\"18. React组件的构造函数有什么作用？\"></a>18. React组件的构造函数有什么作用？</h2><p>官网中，构造函数仅用于以下两种情况：</p>\n<ul>\n<li>通过给 this.state 赋值对象来初始化内部 state。</li>\n<li>为事件处理函数绑定实例</li>\n</ul>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;\n  <span class=\"hljs-built_in\">super</span>(props);\n  <span class=\"hljs-comment\">// 不要在这里调用 this.setState()</span>\n  <span class=\"hljs-built_in\">this</span>.state = &#123; <span class=\"hljs-attr\">counter</span>: <span class=\"hljs-number\">0</span> &#125;;\n  <span class=\"hljs-built_in\">this</span>.handleClick = <span class=\"hljs-built_in\">this</span>.handleClick.bind(<span class=\"hljs-built_in\">this</span>);\n&#125;</code></pre></div>\n\n<p>避免将 props 的值复制给 state！这是一个常见的错误：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;\n <span class=\"hljs-built_in\">super</span>(props);\n <span class=\"hljs-comment\">// 不要这样做</span>\n <span class=\"hljs-built_in\">this</span>.state = &#123; <span class=\"hljs-attr\">color</span>: props.color &#125;;\n&#125;</code></pre></div>\n\n<p>如此做毫无必要（你可以直接使用 this.props.color），同时还产生了 bug（更新 prop 中的 color 时，并不会影响 state）。</p>\n<h2 id=\"19-React组件的构造函数是必须的吗？\"><a href=\"#19-React组件的构造函数是必须的吗？\" class=\"headerlink\" title=\"19. React组件的构造函数是必须的吗？\"></a>19. React组件的构造函数是必须的吗？</h2><p>function组件不用考虑构造函数； 对于class组件，如果不写构造函数，默认会被隐式调用.</p>\n<p>对于无状态组件，内部没有维护自己的state，只接收外部传入的props 是不需要声明构造函数的.</p>\n<hr>\n<p>第 7 天（2022.3.6）</p>\n<h2 id=\"20-React中在哪捕获错误？\"><a href=\"#20-React中在哪捕获错误？\" class=\"headerlink\" title=\"20. React中在哪捕获错误？\"></a>20. React中在哪捕获错误？</h2><p>可以使用错误边界组件来捕获异常；这样可以使用替代ui来代替错误位置的渲染；而不是让程序崩溃； 主要来捕获生命周期异常，渲染中的异常</p>\n<p>使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息</p>\n<p>定义错误边界当做常规组件包裹ui组件, 官网例子：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ErrorBoundary</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;\n    <span class=\"hljs-built_in\">super</span>(props);\n    <span class=\"hljs-built_in\">this</span>.state = &#123; <span class=\"hljs-attr\">hasError</span>: <span class=\"hljs-literal\">false</span> &#125;;\n  &#125;\n\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-function\"><span class=\"hljs-title\">getDerivedStateFromError</span>(<span class=\"hljs-params\">error</span>)</span> &#123;\n    <span class=\"hljs-comment\">// 更新 state 使下一次渲染能够显示降级后的 UI</span>\n    <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">hasError</span>: <span class=\"hljs-literal\">true</span> &#125;;\n  &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidCatch</span>(<span class=\"hljs-params\">error, errorInfo</span>)</span> &#123;\n    <span class=\"hljs-comment\">// 你同样可以将错误日志上报给服务器</span>\n    logErrorToMyService(error, errorInfo);\n  &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.state.hasError) &#123;\n      <span class=\"hljs-comment\">// 你可以自定义降级后的 UI 并渲染</span>\n      <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Something went wrong.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n    &#125;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.props.children; \n  &#125;\n&#125;</code></pre></div>\n\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\">&lt;ErrorBoundary&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyWidget</span> /&gt;</span></span>\n&lt;/ErrorBoundary&gt;</code></pre></div>\n\n<p>但是错误边界不会捕获 :</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">try</span>&#123;&#125;<span class=\"hljs-keyword\">catch</span>(err)&#123;&#125;\n<span class=\"hljs-comment\">///异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）</span>\n<span class=\"hljs-comment\">///服务端渲染</span>\n<span class=\"hljs-comment\">///它自身抛出来的错误（并非它的子组件)</span></code></pre></div>\n\n<h2 id=\"21-React怎样引入svg的文件？\"><a href=\"#21-React怎样引入svg的文件？\" class=\"headerlink\" title=\"21. React怎样引入svg的文件？\"></a>21. React怎样引入svg的文件？</h2><p>方法1： 这种写法会由webpack转为url方式引入。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// svg png等类型图片</span>\n<span class=\"hljs-keyword\">import</span> logo <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./logo.svg&#x27;</span>;\n<span class=\"hljs-comment\">//...</span>\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&#123;logo&#125;</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;App-logo&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;logo&quot;</span> /&gt;</span></span>\n<span class=\"hljs-comment\">//...</span></code></pre></div>\n\n<p>方法2： 这种方式仅对SVG图片生效，将svg看作组件导入：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-keyword\">import</span> &#123; ReactComponent <span class=\"hljs-keyword\">as</span> Logo &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./logo.svg&#x27;</span>\n<span class=\"hljs-comment\">// ...</span>\n&lt;Logo /&gt;</code></pre></div>\n\n<h2 id=\"22-在React中你有经常使用常量吗？\"><a href=\"#22-在React中你有经常使用常量吗？\" class=\"headerlink\" title=\"22. 在React中你有经常使用常量吗？\"></a>22. 在React中你有经常使用常量吗？</h2><p>在redux的action文件里面定义不同的行为可能会使用常量的形式。</p>\n<hr>\n<p>第 8 天（2022.3.7）</p>\n<h2 id=\"23-为什么说React中的props是只读的？\"><a href=\"#23-为什么说React中的props是只读的？\" class=\"headerlink\" title=\"23. 为什么说React中的props是只读的？\"></a>23. 为什么说React中的props是只读的？</h2><p>往单向数据流上答： 保证react的单向数据流的设计模式，使状态更可预测。<br>如果允许自组件修改，那么一个父组件将状态传递给好几个子组件，这几个子组件随意修改，就完全不可预测，不知道在什么地方修改了状态。 所以我们必须像纯函数一样保护 props 不被修改</p>\n<h2 id=\"24-如果组件的属性没有传值，那么它的默认值是什么？\"><a href=\"#24-如果组件的属性没有传值，那么它的默认值是什么？\" class=\"headerlink\" title=\"24. 如果组件的属性没有传值，那么它的默认值是什么？\"></a>24. 如果组件的属性没有传值，那么它的默认值是什么？</h2><p><a href=\"https://zh-hans.reactjs.org/docs/jsx-in-depth.html#props-default-to-true\">官网</a>，如果你没给 prop 赋值，它的默认值是<br>true。以下两个 JSX 表达式是等价的：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\">&lt;MyTextBox autocomplete /&gt;\n\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyTextBox</span> <span class=\"hljs-attr\">autocomplete</span>=<span class=\"hljs-string\">&#123;true&#125;</span> /&gt;</span></span></code></pre></div>\n\n<p>通常，我们不建议不传递 value 给 prop，因为这可能与 ES6 对象简写混淆，{foo} 是 {foo: foo} 的简写，而不是 {foo: true}。这样实现只是为了保持和 HTML<br>中标签属性的行为一致。</p>\n<h2 id=\"25-super-和super-props-有什么区别？\"><a href=\"#25-super-和super-props-有什么区别？\" class=\"headerlink\" title=\"25. super()和super(props)有什么区别？\"></a>25. <code>super()</code>和<code>super(props)</code>有什么区别？</h2><p>react 中的class 是基于es6的规范实现的, 继承是使用extends关键字实现继承的，子类必须在constructor()中调用super() 方法否则新建实例就会报错，报错的原因是<br>子类是没有自己的this对象的，它只能继承父类的this对象，然后对其进行加工，而super()就是将父类中的this对象继承给子类的，没有super() 子类就得不到this对象。</p>\n<p>如果你使用了constructor就必须写super() 这个是用来初始化this的，可以绑定事件到this上 如果你想要在constructor中使用this.props,就必须给super添加参数<br>super(props) 注意，无论有没有 constructor，在render中的this.props都是可以使用的，这是react自动附带的 如果没有用到constructor<br>是可以不写的，react会默认添加一个空的constroctor.</p>\n<p>super 指的是父类（即超类）的构造函数。</p>\n<p>在调用父类的构造函数之前，你是不能在 constructor 中使用 this 关键字的.</p>\n<p>参考 <a href=\"https://overreacted.io/zh-hans/why-do-we-write-super-props/\">why-do-we-write-super-props</a></p>\n","site":{"data":{}},"wordcount":8450,"excerpt":"","more":"<hr>\n<p>第 1 天（2022.2.28）</p>\n<h2 id=\"1-什么时候使用状态管理器？\"><a href=\"#1-什么时候使用状态管理器？\" class=\"headerlink\" title=\"1. 什么时候使用状态管理器？\"></a>1. 什么时候使用状态管理器？</h2><ol>\n<li>组件状态要在多个组件共享时</li>\n<li>某个组件状态需要在任何地方可以拿到</li>\n<li>一个组件需要改变全局状态时</li>\n<li>一个组件需要改变另一个组件状态时</li>\n<li>组件状态提升提升不能满足需求时，层级过多时。</li>\n</ol>\n<h2 id=\"2-render-函数中-return-如果没有使用-会有什么问题？\"><a href=\"#2-render-函数中-return-如果没有使用-会有什么问题？\" class=\"headerlink\" title=\"2. render 函数中 return 如果没有使用()会有什么问题？\"></a>2. render 函数中 return 如果没有使用()会有什么问题？</h2><p>避免遇到自动插入分号陷阱。</p>\n<p>我们在使用 JSX 语法书写 react 代码时，babel 会将 JSX 语法编译成 js，同时会在每行自动添加分号（；），如果 return 后换行了，那么就会变成 return；<br>一般情况下会报错：</p>\n<p>Nothing was returned from render. This usually means a return statement is missing. Or, to render<br>nothing, return null. 上面这段英文翻译成中文：</p>\n<p>渲染没有返回任何内容。这通常意味着缺少 return 语句。或者，为了不渲染，返回 null。 为了代码可读性我们一般会在 return 后面添加括号这样代码可以折行书写，否则就在 return<br>后面紧跟着语句，这样也是可以的。</p>\n<p>举两个正确的书写例子：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Nav = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;c_navbar&quot;</span>&gt;</span></span>\n<span class=\"xml\">      &#123; some jsx magic here &#125;</span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span></span>\n    )\n  &#125;\n\n<span class=\"hljs-keyword\">const</span> Nav = <span class=\"hljs-function\">() =&gt;</span> &#123;\n<span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;c_navbar&quot;</span>&gt;</span></span>\n<span class=\"xml\">    &#123; some jsx magic here &#125;</span>\n<span class=\"xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span></span>\n&#125;</code></pre>\n\n<p>错误的写法：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Nav = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">return</span>\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;c_navbar&quot;</span>&gt;</span></span>\n<span class=\"xml\">      &#123; some jsx magic here &#125;</span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span></span>\n&#125;</code></pre>\n\n<h2 id=\"3-componentWillUpdate-可以直接修改-state-的值吗？\"><a href=\"#3-componentWillUpdate-可以直接修改-state-的值吗？\" class=\"headerlink\" title=\"3. componentWillUpdate 可以直接修改 state 的值吗？\"></a>3. componentWillUpdate 可以直接修改 state 的值吗？</h2><p>直接修改不可以，但是加上条件就可以。</p>\n<p>文档原文：“你也可以在 componentDidUpdate() 中直接调用<br>setState()，但请注意它必须被包裹在一个条件语句里，正如上述的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。”</p>\n<p>componentWillReceiveProps 同理</p>\n<h2 id=\"4-说说你对-React-的渲染原理的理解\"><a href=\"#4-说说你对-React-的渲染原理的理解\" class=\"headerlink\" title=\"4. 说说你对 React 的渲染原理的理解\"></a>4. 说说你对 React 的渲染原理的理解</h2><ol>\n<li>React 会调用 React.render()构建一颗 DOM 树，生成虚拟 dom。</li>\n<li>通过改变 state 或 props 触发更新。</li>\n<li>对比新旧虚拟 dom，diff 算法，深度优先，将实际需要改变的反应到真实 dom。</li>\n</ol>\n<hr>\n<p>第 2 天（2022.3.1）</p>\n<h2 id=\"5-什么渲染劫持？\"><a href=\"#5-什么渲染劫持？\" class=\"headerlink\" title=\"5. 什么渲染劫持？\"></a>5. 什么渲染劫持？</h2><p>一般和高阶组件（HOC）一起解释。</p>\n<p>高阶组件在 render 的时候可以做其他操作，从而控制原组件的渲染输出，这种改变原组件渲染的方式称为 渲染劫持。</p>\n<p>在高阶组件中，组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可实现渲染劫持，还可以增强原组件 render 函数。</p>\n<p>除了 HOC，当新写一个组件，继承自一个已有的组件，可以随便修改 render 函数，使用 state、props 等改变原组件的渲染，都叫渲染劫持。</p>\n<p>PS: HOC 反向继承</p>\n<p>TODO：</p>\n<h2 id=\"6-React-Intl是什么原理？\"><a href=\"#6-React-Intl是什么原理？\" class=\"headerlink\" title=\"6. React Intl是什么原理？\"></a>6. React Intl是什么原理？</h2><p>React Intl 用途是国际化库，提供组件、日期等国际化方法。</p>\n<p>做国际化就类似于字体文件，通过切换语言，加载不同语言包到本地.</p>\n<p>最外层包一个Provider。调用库中方法，完成国际化。</p>\n<p>前端国际化核心步骤有两步：</p>\n<ul>\n<li>创建资源文件，以 key-value 方式存储</li>\n<li>加载资源文件，将页面上 key 的内容替换为相关 value</li>\n</ul>\n<h2 id=\"7-怎么实现React组件的国际化呢？\"><a href=\"#7-怎么实现React组件的国际化呢？\" class=\"headerlink\" title=\"7. 怎么实现React组件的国际化呢？\"></a>7. 怎么实现React组件的国际化呢？</h2><p>使用 i18next 以及 react-i18next 配合 i18next-scanner，通过 grunt 跑 task 自动扫描生成 json 文件。</p>\n<p>现在大厂比较常用的方案是，使用AST，每次开发完新版本，通过AST去扫描所有的代码，找出代码中的中文，以中文为key，调用智能翻译服务，去帮项目自动生成json文件。这样，再也不需要人为去维护json文件，一切都依赖工具进行自动化。</p>\n<hr>\n<p>第 3 天（2022.3.2）</p>\n<h2 id=\"8-说说Context有哪些属性？\"><a href=\"#8-说说Context有哪些属性？\" class=\"headerlink\" title=\"8. 说说Context有哪些属性？\"></a>8. 说说Context有哪些属性？</h2><p>context属于一种解决组件间层级过多传递数据的问题，避免了层层嵌套的通过props传递的形式，同时对于不需要使用到redux时，是一种解决方案。</p>\n<p>Context.Provider：生产者，数据提供方；通过value属性来定义需要被传递的数据<br>Context.Consumer：消费者，数据获取方；根据是函数组件还是class组件，有不同的使用形式；class组件可以指定contextType来确定要使用哪一个context对象的值，函数组件需要使用回调函数的形式来获取context的值；需要显示的指定context对象；</p>\n<h2 id=\"9-怎么使用Context开发组件？\"><a href=\"#9-怎么使用Context开发组件？\" class=\"headerlink\" title=\"9. 怎么使用Context开发组件？\"></a>9. 怎么使用Context开发组件？</h2><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> themes = &#123;\n  <span class=\"hljs-attr\">light</span>: &#123;\n    <span class=\"hljs-attr\">foreground</span>: <span class=\"hljs-string\">&quot;#000000&quot;</span>,\n    <span class=\"hljs-attr\">background</span>: <span class=\"hljs-string\">&quot;#eeeeee&quot;</span>\n  &#125;,\n  <span class=\"hljs-attr\">dark</span>: &#123;\n    <span class=\"hljs-attr\">foreground</span>: <span class=\"hljs-string\">&quot;#ffffff&quot;</span>,\n    <span class=\"hljs-attr\">background</span>: <span class=\"hljs-string\">&quot;#222222&quot;</span>\n  &#125;\n&#125;;\n<span class=\"hljs-comment\">// 首先创建一个 context 对象这里命名为：ThemeContext</span>\n<span class=\"hljs-keyword\">const</span> ThemeContext = React.createContext(themes.light);\n\n<span class=\"hljs-comment\">// 创建一个祖先组件组件 内部使用Provier 这个对象创建一个组件 其中 value 属性是真实传递的属性</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ThemeContext.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;themes.dark&#125;</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Toolbar</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ThemeContext.Provider</span>&gt;</span></span>\n  );\n&#125;\n\n<span class=\"hljs-comment\">// 渲染 button 组件的外层包裹的属性</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Toolbar</span>(<span class=\"hljs-params\">props</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ThemedButton</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;\n\n<span class=\"hljs-comment\">// 在 Toolbar 中渲染的button 组件 使用 useContext，将 value 值跨组件传递给 // ThemeButton 组件</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ThemedButton</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> theme = useContext(ThemeContext);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&#123;&#123;</span> <span class=\"hljs-attr\">background:</span> <span class=\"hljs-attr\">theme.background</span>, <span class=\"hljs-attr\">color:</span> <span class=\"hljs-attr\">theme.foreground</span> &#125;&#125;&gt;</span></span>\n<span class=\"xml\">      I am styled by theme context!</span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n  );\n&#125;</code></pre>\n\n<h2 id=\"10-为什么React并不推荐我们优先考虑使用Context？\"><a href=\"#10-为什么React并不推荐我们优先考虑使用Context？\" class=\"headerlink\" title=\"10. 为什么React并不推荐我们优先考虑使用Context？\"></a>10. 为什么React并不推荐我们优先考虑使用Context？</h2><p>1、Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。<br>2、尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context<br>3、对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。<br>4、context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如<br>shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注。</p>\n<hr>\n<p>第 4 天（2022.3.3）</p>\n<h2 id=\"11-childContextTypes是什么？它有什么用？\"><a href=\"#11-childContextTypes是什么？它有什么用？\" class=\"headerlink\" title=\"11. childContextTypes是什么？它有什么用？\"></a>11. childContextTypes是什么？它有什么用？</h2><p>childContextTypes用来定义context数据类型，该api从16.3开始已被废弃</p>\n<p>使用方式</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MessageList</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">getChildContext</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;purple&quot;</span>&#125;;\n  &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>MessageList<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n  &#125;\n&#125;\n\nMessageList.childContextTypes = &#123;\n  <span class=\"hljs-attr\">color</span>: PropTypes.string\n&#125;;</code></pre>\n\n<h2 id=\"12-Consumer向上找不到Provider的时候怎么办？\"><a href=\"#12-Consumer向上找不到Provider的时候怎么办？\" class=\"headerlink\" title=\"12. Consumer向上找不到Provider的时候怎么办？\"></a>12. Consumer向上找不到Provider的时候怎么办？</h2><p>当consumer向上层找不到provider时，此时就会取创建context时传给createContext的那个值，也就是当前context对象的默认值，在定义provider时的value中的值不是默认值，而是表示需要被传递的值.</p>\n<hr>\n<p>第 5 天（2022.3.4）</p>\n<h2 id=\"13-说说你对windowing的了解\"><a href=\"#13-说说你对windowing的了解\" class=\"headerlink\" title=\"13. 说说你对windowing的了解\"></a>13. 说说你对windowing的了解</h2><p>展示长列表<br>如果你的应用会渲染大量的列表数据，我们建议使用一种称为‘windowing’的技术，这种技术下在任何给定的时间内只会渲染一小部分数据列表，并可以减少列表项的重复渲染（即再次渲染已经渲染过的数据）。</p>\n<p>react-window和react-virtualized都是流行的使用windowing技术的库，他们都提供了一系列可重用的组件，这些组件能够帮助你以最好的性能展示列表以及表格数据</p>\n<h2 id=\"14-举例说明React的-portal-有哪些运用场景？\"><a href=\"#14-举例说明React的-portal-有哪些运用场景？\" class=\"headerlink\" title=\"14. 举例说明React的 portal 有哪些运用场景？\"></a>14. 举例说明React的 portal 有哪些运用场景？</h2><p>portal可以将内容插入到除了父节点的dom之外的地方去渲染，所以modal是一个通过portal实现的典型例子；并且对于事件绑定，因为使用了事件冒泡，所以并不用担心被渲染到父组件结构之外的内容，不能去监听事件</p>\n<h2 id=\"15-你有用过React的插槽-Portals-吗？怎么用？\"><a href=\"#15-你有用过React的插槽-Portals-吗？怎么用？\" class=\"headerlink\" title=\"15. 你有用过React的插槽(Portals)吗？怎么用？\"></a>15. 你有用过React的插槽(Portals)吗？怎么用？</h2><p>1、首先简单的介绍下react中的插槽（Portals），通过ReactDOM.createPortal(child,<br>container)创建，是ReactDOM提供的接口，可以实现将子节点渲染到父组件DOM层次结构之外的DOM节点。 2、第一个参数（child）是任何可渲染的 React<br>子元素，例如一个元素，字符串或 片段(fragment)。第二个参数（container）则是一个 DOM 元素。 3、对于 portal 的一个典型用例是当父组件有 overflow: hidden<br>或 z-index 样式，但你需要子组件能够在视觉上 “跳出(break out)” 其容器。例如，对话框、hovercards以及提示框。所以一般react组件里的模态框，就是这样实现的。</p>\n<p>如果一个子组件的真实DOM结构必须渲染到当前组件外，但又想保留这两者的父子关系，就可以用Protals。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Modal = <span class=\"hljs-function\">(<span class=\"hljs-params\">props</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> modal = <span class=\"hljs-built_in\">document</span>.body.createElement(<span class=\"hljs-string\">&#x27;div&#x27;</span>);\n  <span class=\"hljs-built_in\">document</span>.appendChild(modal);\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">document</span>.body.removeChild(modal);\n    &#125;\n  &#125;, []);\n  <span class=\"hljs-keyword\">return</span> React.createPortal(<span class=\"hljs-built_in\">this</span>.props.children, modal);\n&#125;\n<span class=\"hljs-keyword\">const</span> Parent = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> [sum, setSum] = useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\">() =&gt;</span> setSum(sum + <span class=\"hljs-number\">1</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;add&#125;</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Modal</span>&gt;</span>加一<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Modal</span>&gt;</span></span>\n<span class=\"xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n&#125;</code></pre>\n\n<hr>\n<p>第 6 天（2022.3.5）</p>\n<h2 id=\"16-React的严格模式有什么用处？\"><a href=\"#16-React的严格模式有什么用处？\" class=\"headerlink\" title=\"16. React的严格模式有什么用处？\"></a>16. React的严格模式有什么用处？</h2><p>StrictMode 目前有助于：</p>\n<ul>\n<li>识别不安全的生命周期</li>\n<li>关于使用过时字符串 ref API 的警告</li>\n<li>关于使用废弃的 findDOMNode 方法的警告</li>\n<li>检测意外的副作用</li>\n<li>检测过时的 context API</li>\n</ul>\n<p>可以为程序的任何部分使用严格模式</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ExampleApplication</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Header</span> /&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">React.StrictMode</span>&gt;</span></span>\n<span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ComponentOne</span> /&gt;</span></span>\n<span class=\"xml\">          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ComponentTwo</span> /&gt;</span></span>\n<span class=\"xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">React.StrictMode</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Footer</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;\n<span class=\"hljs-comment\">// 不会对 Header 和 Footer 组件运行严格模式检查。但是，ComponentOne 和 ComponentTwo 以及它们的所有后代元素都将进行检查。</span></code></pre>\n\n<h2 id=\"17-React如何进行代码拆分？拆分的原则是什么？\"><a href=\"#17-React如何进行代码拆分？拆分的原则是什么？\" class=\"headerlink\" title=\"17. React如何进行代码拆分？拆分的原则是什么？\"></a>17. React如何进行代码拆分？拆分的原则是什么？</h2><p>react的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。</p>\n<p>在我们的react项目中： 1、在 api 层面我们单独封装，对外暴露http请求的结果。 2、数据层我们使用的react-redux 异步中间件使用的是redux-thunk<br>分装处理异步请求，合业务逻辑处理。 3、视图层，尽量使用 redux 层面的传递过来的数据，修改逻辑 也是重新触发action 更改props。 4、静态类型的资源单独放置<br>5、公共组件、高阶组件、插件单独放置 6、工具类文件单独放置</p>\n<h2 id=\"18-React组件的构造函数有什么作用？\"><a href=\"#18-React组件的构造函数有什么作用？\" class=\"headerlink\" title=\"18. React组件的构造函数有什么作用？\"></a>18. React组件的构造函数有什么作用？</h2><p>官网中，构造函数仅用于以下两种情况：</p>\n<ul>\n<li>通过给 this.state 赋值对象来初始化内部 state。</li>\n<li>为事件处理函数绑定实例</li>\n</ul>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;\n  <span class=\"hljs-built_in\">super</span>(props);\n  <span class=\"hljs-comment\">// 不要在这里调用 this.setState()</span>\n  <span class=\"hljs-built_in\">this</span>.state = &#123; <span class=\"hljs-attr\">counter</span>: <span class=\"hljs-number\">0</span> &#125;;\n  <span class=\"hljs-built_in\">this</span>.handleClick = <span class=\"hljs-built_in\">this</span>.handleClick.bind(<span class=\"hljs-built_in\">this</span>);\n&#125;</code></pre>\n\n<p>避免将 props 的值复制给 state！这是一个常见的错误：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;\n <span class=\"hljs-built_in\">super</span>(props);\n <span class=\"hljs-comment\">// 不要这样做</span>\n <span class=\"hljs-built_in\">this</span>.state = &#123; <span class=\"hljs-attr\">color</span>: props.color &#125;;\n&#125;</code></pre>\n\n<p>如此做毫无必要（你可以直接使用 this.props.color），同时还产生了 bug（更新 prop 中的 color 时，并不会影响 state）。</p>\n<h2 id=\"19-React组件的构造函数是必须的吗？\"><a href=\"#19-React组件的构造函数是必须的吗？\" class=\"headerlink\" title=\"19. React组件的构造函数是必须的吗？\"></a>19. React组件的构造函数是必须的吗？</h2><p>function组件不用考虑构造函数； 对于class组件，如果不写构造函数，默认会被隐式调用.</p>\n<p>对于无状态组件，内部没有维护自己的state，只接收外部传入的props 是不需要声明构造函数的.</p>\n<hr>\n<p>第 7 天（2022.3.6）</p>\n<h2 id=\"20-React中在哪捕获错误？\"><a href=\"#20-React中在哪捕获错误？\" class=\"headerlink\" title=\"20. React中在哪捕获错误？\"></a>20. React中在哪捕获错误？</h2><p>可以使用错误边界组件来捕获异常；这样可以使用替代ui来代替错误位置的渲染；而不是让程序崩溃； 主要来捕获生命周期异常，渲染中的异常</p>\n<p>使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息</p>\n<p>定义错误边界当做常规组件包裹ui组件, 官网例子：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ErrorBoundary</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;\n    <span class=\"hljs-built_in\">super</span>(props);\n    <span class=\"hljs-built_in\">this</span>.state = &#123; <span class=\"hljs-attr\">hasError</span>: <span class=\"hljs-literal\">false</span> &#125;;\n  &#125;\n\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-function\"><span class=\"hljs-title\">getDerivedStateFromError</span>(<span class=\"hljs-params\">error</span>)</span> &#123;\n    <span class=\"hljs-comment\">// 更新 state 使下一次渲染能够显示降级后的 UI</span>\n    <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">hasError</span>: <span class=\"hljs-literal\">true</span> &#125;;\n  &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidCatch</span>(<span class=\"hljs-params\">error, errorInfo</span>)</span> &#123;\n    <span class=\"hljs-comment\">// 你同样可以将错误日志上报给服务器</span>\n    logErrorToMyService(error, errorInfo);\n  &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.state.hasError) &#123;\n      <span class=\"hljs-comment\">// 你可以自定义降级后的 UI 并渲染</span>\n      <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Something went wrong.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n    &#125;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.props.children; \n  &#125;\n&#125;</code></pre>\n\n<pre><code class=\"hljs jsx\">&lt;ErrorBoundary&gt;\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyWidget</span> /&gt;</span></span>\n&lt;/ErrorBoundary&gt;</code></pre>\n\n<p>但是错误边界不会捕获 :</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">try</span>&#123;&#125;<span class=\"hljs-keyword\">catch</span>(err)&#123;&#125;\n<span class=\"hljs-comment\">///异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）</span>\n<span class=\"hljs-comment\">///服务端渲染</span>\n<span class=\"hljs-comment\">///它自身抛出来的错误（并非它的子组件)</span></code></pre>\n\n<h2 id=\"21-React怎样引入svg的文件？\"><a href=\"#21-React怎样引入svg的文件？\" class=\"headerlink\" title=\"21. React怎样引入svg的文件？\"></a>21. React怎样引入svg的文件？</h2><p>方法1： 这种写法会由webpack转为url方式引入。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// svg png等类型图片</span>\n<span class=\"hljs-keyword\">import</span> logo <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./logo.svg&#x27;</span>;\n<span class=\"hljs-comment\">//...</span>\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&#123;logo&#125;</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;App-logo&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;logo&quot;</span> /&gt;</span></span>\n<span class=\"hljs-comment\">//...</span></code></pre>\n\n<p>方法2： 这种方式仅对SVG图片生效，将svg看作组件导入：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-keyword\">import</span> &#123; ReactComponent <span class=\"hljs-keyword\">as</span> Logo &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./logo.svg&#x27;</span>\n<span class=\"hljs-comment\">// ...</span>\n&lt;Logo /&gt;</code></pre>\n\n<h2 id=\"22-在React中你有经常使用常量吗？\"><a href=\"#22-在React中你有经常使用常量吗？\" class=\"headerlink\" title=\"22. 在React中你有经常使用常量吗？\"></a>22. 在React中你有经常使用常量吗？</h2><p>在redux的action文件里面定义不同的行为可能会使用常量的形式。</p>\n<hr>\n<p>第 8 天（2022.3.7）</p>\n<h2 id=\"23-为什么说React中的props是只读的？\"><a href=\"#23-为什么说React中的props是只读的？\" class=\"headerlink\" title=\"23. 为什么说React中的props是只读的？\"></a>23. 为什么说React中的props是只读的？</h2><p>往单向数据流上答： 保证react的单向数据流的设计模式，使状态更可预测。<br>如果允许自组件修改，那么一个父组件将状态传递给好几个子组件，这几个子组件随意修改，就完全不可预测，不知道在什么地方修改了状态。 所以我们必须像纯函数一样保护 props 不被修改</p>\n<h2 id=\"24-如果组件的属性没有传值，那么它的默认值是什么？\"><a href=\"#24-如果组件的属性没有传值，那么它的默认值是什么？\" class=\"headerlink\" title=\"24. 如果组件的属性没有传值，那么它的默认值是什么？\"></a>24. 如果组件的属性没有传值，那么它的默认值是什么？</h2><p><a href=\"https://zh-hans.reactjs.org/docs/jsx-in-depth.html#props-default-to-true\">官网</a>，如果你没给 prop 赋值，它的默认值是<br>true。以下两个 JSX 表达式是等价的：</p>\n<pre><code class=\"hljs jsx\">&lt;MyTextBox autocomplete /&gt;\n\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyTextBox</span> <span class=\"hljs-attr\">autocomplete</span>=<span class=\"hljs-string\">&#123;true&#125;</span> /&gt;</span></span></code></pre>\n\n<p>通常，我们不建议不传递 value 给 prop，因为这可能与 ES6 对象简写混淆，{foo} 是 {foo: foo} 的简写，而不是 {foo: true}。这样实现只是为了保持和 HTML<br>中标签属性的行为一致。</p>\n<h2 id=\"25-super-和super-props-有什么区别？\"><a href=\"#25-super-和super-props-有什么区别？\" class=\"headerlink\" title=\"25. super()和super(props)有什么区别？\"></a>25. <code>super()</code>和<code>super(props)</code>有什么区别？</h2><p>react 中的class 是基于es6的规范实现的, 继承是使用extends关键字实现继承的，子类必须在constructor()中调用super() 方法否则新建实例就会报错，报错的原因是<br>子类是没有自己的this对象的，它只能继承父类的this对象，然后对其进行加工，而super()就是将父类中的this对象继承给子类的，没有super() 子类就得不到this对象。</p>\n<p>如果你使用了constructor就必须写super() 这个是用来初始化this的，可以绑定事件到this上 如果你想要在constructor中使用this.props,就必须给super添加参数<br>super(props) 注意，无论有没有 constructor，在render中的this.props都是可以使用的，这是react自动附带的 如果没有用到constructor<br>是可以不写的，react会默认添加一个空的constroctor.</p>\n<p>super 指的是父类（即超类）的构造函数。</p>\n<p>在调用父类的构造函数之前，你是不能在 constructor 中使用 this 关键字的.</p>\n<p>参考 <a href=\"https://overreacted.io/zh-hans/why-do-we-write-super-props/\">why-do-we-write-super-props</a></p>\n"},{"title":"React 中常用 TS 类型","index_img":"/img/2022-03-20-1.webp","abbrlink":"25e26362","date":"2022-03-20T09:21:09.000Z","_content":"\n## 函数组件注解\n\n```ts\nconst Test = React.FC<Props>\n```\n\n## 类组件注解\n\n```ts\nclass Test extends React.Component<Props,States>\n```\n\n## 泛型 class 组件\n\n```ts\ninterface SelectProps<T> {\n  items: T[]\n}\n\nclass Select<T> extends React.Component<SelectProps<T>, {}> {\n  // ...\n}\n\nconst Form = () => <Select<string> items={['a', 'b']} />\n```\n","source":"_posts/10.React 中常用 TS 类型.md","raw":"---\ntitle: React 中常用 TS 类型\nindex_img: /img/2022-03-20-1.webp\ntags: React TypeScript\ncategories: React\nabbrlink: '25e26362'\ndate: 2022-03-20 17:21:09\n---\n\n## 函数组件注解\n\n```ts\nconst Test = React.FC<Props>\n```\n\n## 类组件注解\n\n```ts\nclass Test extends React.Component<Props,States>\n```\n\n## 泛型 class 组件\n\n```ts\ninterface SelectProps<T> {\n  items: T[]\n}\n\nclass Select<T> extends React.Component<SelectProps<T>, {}> {\n  // ...\n}\n\nconst Form = () => <Select<string> items={['a', 'b']} />\n```\n","slug":"10-React-中常用-TS-类型","published":1,"updated":"2022-04-15T09:58:58.516Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn3i000iyu3l9svhhi0v","content":"<h2 id=\"函数组件注解\"><a href=\"#函数组件注解\" class=\"headerlink\" title=\"函数组件注解\"></a>函数组件注解</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> Test = React.FC&lt;Props&gt;</code></pre></div>\n\n<h2 id=\"类组件注解\"><a href=\"#类组件注解\" class=\"headerlink\" title=\"类组件注解\"></a>类组件注解</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">Props</span>,<span class=\"hljs-title\">States</span>&gt;</span></code></pre></div>\n\n<h2 id=\"泛型-class-组件\"><a href=\"#泛型-class-组件\" class=\"headerlink\" title=\"泛型 class 组件\"></a>泛型 class 组件</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> SelectProps&lt;T&gt; &#123;\n  <span class=\"hljs-attr\">items</span>: T[]\n&#125;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Select</span>&lt;<span class=\"hljs-title\">T</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">SelectProps</span>&lt;<span class=\"hljs-title\">T</span>&gt;, </span>&#123;&#125;&gt; &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n\n<span class=\"hljs-keyword\">const</span> Form = <span class=\"hljs-function\">() =&gt;</span> &lt;Select&lt;<span class=\"hljs-built_in\">string</span>&gt; items=&#123;[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>]&#125; /&gt;</code></pre></div>\n","site":{"data":{}},"wordcount":345,"excerpt":"","more":"<h2 id=\"函数组件注解\"><a href=\"#函数组件注解\" class=\"headerlink\" title=\"函数组件注解\"></a>函数组件注解</h2><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> Test = React.FC&lt;Props&gt;</code></pre>\n\n<h2 id=\"类组件注解\"><a href=\"#类组件注解\" class=\"headerlink\" title=\"类组件注解\"></a>类组件注解</h2><pre><code class=\"hljs ts\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">Props</span>,<span class=\"hljs-title\">States</span>&gt;</span></code></pre>\n\n<h2 id=\"泛型-class-组件\"><a href=\"#泛型-class-组件\" class=\"headerlink\" title=\"泛型 class 组件\"></a>泛型 class 组件</h2><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> SelectProps&lt;T&gt; &#123;\n  <span class=\"hljs-attr\">items</span>: T[]\n&#125;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Select</span>&lt;<span class=\"hljs-title\">T</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">SelectProps</span>&lt;<span class=\"hljs-title\">T</span>&gt;, </span>&#123;&#125;&gt; &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n\n<span class=\"hljs-keyword\">const</span> Form = <span class=\"hljs-function\">() =&gt;</span> &lt;Select&lt;<span class=\"hljs-built_in\">string</span>&gt; items=&#123;[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>]&#125; /&gt;</code></pre>\n"},{"index_img":"/img/2022-04-07-1.png","abbrlink":"0","date":"2022-04-07T14:04:17.000Z","title":"React Hooks 之 useEffect","_content":"\nFunction Component 是更彻底的状态驱动抽象。要彻底理解 Hooks 需要忘掉 Class Component 生命周期,理解 FC 的思维方式。\n\n## 每次渲染都有他自己的 props 和 state\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\n`<p>You clicked {count} times</p>` 该行中的 count 如何理解？\n\n第一感觉是 count 是会“监听”状态变化自动更新。它不是 data binding、watcher、proxy。\n\n```jsx\nconst count = 42; // count 只是一个数字\n// ...\n<p>You clicked {count} times</p>\n// ...\n```\n\n组件第一次渲染，count 初始值是 0。 调用 setCount(1),react 再次渲染组件，这次 count 是 1。以此类推。。。\n\n```jsx\n// During first render\nfunction Counter() {\n  const count = 0; // Returned by useState()\n  // ...\n  <p>You clicked {count} times</p>\n  // ...\n}\n\n// After a click, our function is called again\nfunction Counter() {\n  const count = 1; // Returned by useState()\n  // ...\n  <p>You clicked {count} times</p>\n  // ...\n}\n\n// After another click, our function is called again\nfunction Counter() {\n  const count = 2; // Returned by useState()\n  // ...\n  <p>You clicked {count} times</p>\n  // ...\n}\n```\n\n每次状态更新，react 重新渲染组件。每一次的渲染中的 count 都是独立的值，这个状态值是函数中的一个常量。\n\n任意一次渲染中的count常量都不会随着时间改变。渲染输出会变是因为我们的组件被一次次调用，而每一次调用引起的渲染中，它包含的count值独立于其他渲染。\n\n## 每次渲染都有它自己的事件处理函数\n\n```jsx\nconst App = () => {\n  const [temp, setTemp] = React.useState(5);\n\n  const log = () => {\n    setTimeout(() => {\n      console.log(\"3 秒前 temp = 5，现在 temp =\", temp);\n    }, 3000);\n  };\n\n  return (\n    <div\n      onClick={() => {\n        log();\n        setTemp(3);\n        // 3 秒前 temp = 5，现在 temp = 5\n      }}\n    >\n      xyz\n    </div>\n  );\n};\n```\n\n上述代码输出 5，而不是 3\n\nlog 函数执行的那个 render 过程， temp 可以看作常量 5。执行 setTemp(3) 后会由一个全新的 render 渲染。所以不会执行 log 函数。而 3 秒后执行的内容是由\ntemp 为 5 的那个 render 发出的。所以结果为 5。\n\n## 每次 Render 都有自己的 Effects\n\nuseEffect 在 DOM 渲染完毕后执行， 也一样拿到的是某次渲染时的值。\n\n每次 render 过程，拿到的 count 都是固化的常量。\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  });\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  );\n}\n```\n\n## 单次渲染内，props 和 state 始终保持不变\n\n所以，每一个组件内的函数（包括事件处理函数，effects，定时器或者API调用等等）会捕获某次渲染中定义的props 和 state。\n\n下面两个例子是相等的：\n\n```jsx\nfunction Example(props) {\n  useEffect(() => {\n    setTimeout(() => {\n      console.log(props.counter);\n    }, 1000);\n  });\n  // ...\n}\n```\n\n```jsx\nfunction Example(props) {\n  const counter = props.counter;\n  useEffect(() => {\n    setTimeout(() => {\n      console.log(counter);\n    }, 1000);\n  });\n  // ...\n}\n```\n\n在组件内，什么时候读 props 和 state 都一样。在单次渲染内，他们始终保持不变。\n\n## 如何拿最新的值，而不是捕获的值\n\nuseRef 可以绕过 Capture Value 的特性。可以认为 ref 在所有 Render 过程中保持着唯一引用，因此所有对 ref 的赋值或取值，拿到的都只有一个最终状态，而不会在每个\nRender 间存在隔离。\n\n```jsx\nfunction Example() {\n  const [count, setCount] = useState(0);\n  const latestCount = useRef(count);\n\n  useEffect(() => {\n    // Set the mutable latest value\n    latestCount.current = count;\n    setTimeout(() => {\n      // Read the mutable latest value\n      console.log(`You clicked ${latestCount.current} times`);\n    }, 3000);\n  });\n  // ...\n```\n\n也可以认为，ref 是 Mutable 的，而 state 是 Immutable 的。\n\n## useEffect 回收机制\n\n```jsx\nuseEffect(() => {\n    ChatAPI.subscribeToFriendStatus(props.id, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(props.id, handleStatusChange);\n    };\n  });\n```\n\n假设第一次渲染的时候props是{id: 10}，第二次渲染的时候是{id: 20}。你可能认为顺序如下：\n\n- React 清除了 {id: 10}的effect。\n- React 渲染{id: 20}的UI。\n- React 运行{id: 20}的effect。\n\n实际上并不是这样，react 只会在浏览器绘制之后运行 useEffect。上一次的 effect 会在重新渲染后被清楚。\n\n- React 渲染{id: 20}的UI。\n- 浏览器绘制。我们在屏幕上看到{id: 20}的UI。\n- React 清除{id: 10}的effect。\n- React 运行{id: 20}的effect。\n\n那为什么清楚上一次的 effect 发生在 props 变为 {id: 20} 之后，却还能看到旧的 {id: 10} ？\n\neffect的清除并不会读取“最新”的props。它只能读取到定义它的那次渲染中的props值。由于 Capture Value 特性，每次 “注册” “回收” 拿到的都是成对的固定值。\n\n确切的说清除上一次的副作用发生在“每次重新渲染之后，副作用函数重新运行执行”。\n\n## 同步，而非生命周期\n\nReact会根据我们当前的props和state同步到DOM。“mount”和“update”之于渲染并没有什么区别。\n\n用相同的方式去思考effects。useEffect使你能够根据props和state同步React tree之外的东西。\n\n## 告诉 React 如何对比 Effect\n\nreact 在 DOM渲染时会 diff 内容，只对改变的部分做修改。但是对于 effect 却做不到这样。\n\n如何避免 effect 重复调用，需要给 effect 提供一个 deps，deps 内变量改变的时候才执行。\n\n```jsx\nuseEffect(() => {\n    document.title = 'Hello, ' + name;\n  }, [name]); // Our deps\n```\n\n## 依赖项不要撒谎\n\n```jsx\nfunction SearchResults() {\n  async function fetchData() {\n    // ...\n  }\n\n  useEffect(() => {\n    fetchData();\n  }, []); // Is this okay? Not always -- and there's a better way to write it.\n\n  // ...\n}\n```\n\n你设置了依赖项，effect中用到的所有组件内的值都要包含在依赖中。这包括 props，state，函数。\n\n这样做可能会遇到一些问题，比如会遇到重复渲染、无限请求等。解决问题的办法不是移除依赖性。后续再说。\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(count + 1);\n    }, 1000);\n    return () => clearInterval(id);\n  }, []);\n\n  return <h1>{count}</h1>;\n}\n```\n\nsetInterval 只想只想一次，依赖写为 []。\n\n但是，因为 useEffect 拿到的是那次渲染时候的值。count 值永远是 0。setCount 没产生作用。\n\n## 对依赖诚实的代价\n\n对依赖诚实，那就把 count 加到依赖中：\n\n```jsx\nuseEffect(() => {\n  const id = setInterval(() => {\n    setCount(count + 1);\n  }, 1000);\n  return () => clearInterval(id);\n}, [count]);\n```\n\n此时能够拿到最新的 count，但是有问题：\n\n- 每次变化都生成、销毁定时器，性能不好。\n- 每次重新定时，不准。\n\n## 让 useEffect 自给自足\n\n上述代码 对只想执行一次的 useEffect 里依赖了外部变量。\n\n解决办法就是 不依赖外部变量。\n\n```jsx\nuseEffect(() => {\n  const id = setInterval(() => {\n    setCount(c => c + 1);\n  }, 1000);\n  return () => clearInterval(id);\n}, []);\n```\n\nsetCount 回调写法，对旧值进行修改。此时 useEffect 只允许一次，count 也能拿到最新的值。\n\n## 解耦来自 Actions 的更新\n\nsetCount(c => c + 1) 并不能解决所有场景问题。如果我们有两个互相依赖的状态，或者我们想基于一个prop来计算下一次的state，它并不能做到。幸运的是， setCount(c =>\nc + 1)有一个更强大的姐妹模式，它的名字叫useReducer。\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const [step, setStep] = useState(1);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(c => c + step);\n    }, 1000);\n    return () => clearInterval(id);\n  }, [step]);\n\n  return (\n    <>\n      <h1>{count}</h1>\n      <input value={step} onChange={e => setStep(Number(e.target.value))} />\n    </>\n  );\n}\n```\n\n上述例子中没有依赖撒谎。但是 step 改变时，不想重启定时器怎么办？\n\n当你想更新一个状态，并且这个状态更新依赖于另一个状态的值时，你可能需要用useReducer去替换它们。\n\n利用 useReducer 函数，将更新与动作解耦：\n\n```jsx\nconst [state, dispatch] = useReducer(reducer, initialState);\nconst { count, step } = state;\n\nuseEffect(() => {\n  const id = setInterval(() => {\n    dispatch({ type: \"tick\" }); // Instead of setCount(c => c + step);\n  }, 1000);\n  return () => clearInterval(id);\n}, [dispatch]);\n```\n\nReact会保证 dispatc 在组件的声明周期内保持不变。\n\n## 依赖 props 计算状态\n\n前面介绍了如何移除effect的依赖，不管状态更新是依赖上一个状态还是依赖另一个状态。\n\n但假如我们需要依赖props去计算下一个状态呢。\n\n`<Counter step={1} />`，此时如何避免依赖 props.step 呢？\n\n把 reducer 函数放到组件内部去读取 props：\n\n```jsx\nfunction Counter({ step }) {\n  const [count, dispatch] = useReducer(reducer, 0);\n\n  function reducer(state, action) {\n    if (action.type === 'tick') {\n      return state + step;\n    } else {\n      throw new Error();\n    }\n  }\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      dispatch({ type: 'tick' });\n    }, 1000);\n    return () => clearInterval(id);\n  }, [dispatch]);\n\n  return <h1>{count}</h1>;\n}\n```\n\n此时 react 仍能保证 dispatch 在每次渲染中都是一样的。\n\n这可以帮助我移除不必需的依赖，避免不必要的effect调用。\n\n## 把函数移到 Effects 里\n\n如果某些函数仅在effect中调用，你可以把它们的定义移到effect中：\n\n```jsx\nfunction SearchResults() {\n  const [query, setQuery] = useState('react');\n\n  useEffect(() => {\n    function getFetchUrl() {\n      return 'https://hn.algolia.com/api/v1/search?query=' + query;\n    }\n\n    async function fetchData() {\n      const result = await axios(getFetchUrl());\n      setData(result.data);\n    }\n\n    fetchData();\n  }, [query]); // ✅ Deps are OK\n\n  // ...\n}\n```\n\n## 当函数不能放在 Effects 里\n\n有时函数不能放在 effects 里，如：\n\n- 组件内几个函数使用了相同的函数\n- 这个函数是一个 prop\n\n此时能忽略对函数的依赖么？最好不要，effects 对依赖不要撒谎。\n\n两种情况：\n\n- 1、函数内没有使用组件内的任何值，就提到组件外。\n\n```jsx\n/ ✅ Not affected by the data flow\nfunction getFetchUrl(query) {\n  return 'https://hn.algolia.com/api/v1/search?query=' + query;\n}\n\nfunction SearchResults() {\n  useEffect(() => {\n    const url = getFetchUrl('react');\n    // ... Fetch data and do something ...\n  }, []); // ✅ Deps are OK\n\n  useEffect(() => {\n    const url = getFetchUrl('redux');\n    // ... Fetch data and do something ...\n  }, []); // ✅ Deps are OK\n\n  // ...\n}\n```\n\n- 2、放组件内，用 useCallback 包装, 将函数添加到依赖\n\n```jsx\nfunction SearchResults() {\n  const [query, setQuery] = useState('react');\n\n  // ✅ Preserves identity until query changes\n  const getFetchUrl = useCallback(() => {\n    return 'https://hn.algolia.com/api/v1/search?query=' + query;\n  }, [query]);  // ✅ Callback deps are OK\n\n  useEffect(() => {\n    const url = getFetchUrl();\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ✅ Effect deps are OK\n\n  // ...\n}\n```\n\n使用 useCallback，因为如果query 保持不变，getFetchUrl也会保持不变，我们的effect也不会重新运行。\n\n父组件传入函数的情况，也适用该方法：\n\n```jsx\nfunction Parent() {\n  const [query, setQuery] = useState('react');\n\n  // ✅ Preserves identity until query changes\n  const fetchData = useCallback(() => {\n    const url = 'https://hn.algolia.com/api/v1/search?query=' + query;\n    // ... Fetch data and return it ...\n  }, [query]);  // ✅ Callback deps are OK\n\n  return <Child fetchData={fetchData} />\n}\n\nfunction Child({ fetchData }) {\n  let [data, setData] = useState(null);\n\n  useEffect(() => {\n    fetchData().then(setData);\n  }, [fetchData]); // ✅ Effect deps are OK\n\n  // ...\n}\n```\n\n避免到处使用 useCallback。\n\n当我们需要将函数传递下去并且函数会在子组件的effect中被调用的时候，useCallback 是很好的技巧且非常有用。或者你想试图减少对子组件的记忆负担，也不妨一试。\n\n- 3、更好的方式可能是把他抽成自定义 Hook，把 fetchData 放在 effect 里。\n\nuseEffect 只是底层 API，未来业务接触到的是更多封装后的上层 API，比如 useFetch 或者 useTheme，它们会更好用。\n\n```jsx\nimport React, { useState, useEffect, useReducer } from 'react'\n\nconst GITHUB_API = 'https://api.github.com/repos/chanshiyucx/blog/issues?page=10&per_page='\n\nexport default () => {\n  const [list, setList] = useState([])\n  const [page, setPage] = useState(1)\n\n  const { data, doFetch } = useDataApi(`${GITHUB_API}${page}`, [])\n  // 翻页时重新获取列表\n  useEffect(() => doFetch(`${GITHUB_API}${page}`), [page])\n  useEffect(() => setList(data), [data])\n\n  const handleNextPage = () => setPage(page + 1)\n\n  return (\n    <div>\n      <button onClick={handleNextPage}>NextPage</button>\n      <ul>\n        {list.map(o => (\n          <li key={o.id}>{o.title}</li>\n        ))}\n      </ul>\n\n      {isError && <div>Something went wrong ...</div>}\n      {isLoading && <div>Loading ...</div>}\n    </div>\n  )\n}\n```\n\nreducer:\n\n```jsx\nconst dataFetchReducer = (state, action) => {\n  switch (action.type) {\n    case 'FETCH_INIT':\n      return {\n        ...state,\n        isLoading: true,\n        isError: false\n      }\n    case 'FETCH_SUCCESS':\n      return {\n        ...state,\n        isLoading: false,\n        isError: false,\n        data: action.payload\n      }\n    case 'FETCH_FAILURE':\n      return {\n        ...state,\n        isLoading: false,\n        isError: true\n      }\n    default:\n      throw new Error()\n  }\n}\n```\n\n自定义 Hook：\n\n```jsx\nconst useDataApi = (initialUrl, initialData) => {\n  const [url, setUrl] = useState(initialUrl)\n\n  const [state, dispatch] = useReducer(dataFetchReducer, {\n    isLoading: false,\n    isError: false,\n    data: initialData\n  })\n\n  useEffect(() => {\n    let didCancel = false\n\n    const fetchData = async () => {\n      dispatch({ type: 'FETCH_INIT' })\n      try {\n        const response = await fetch(url)\n        const data = await response.json()\n        if (!didCancel) {\n          dispatch({ type: 'FETCH_SUCCESS', payload: data })\n        }\n      } catch (error) {\n        if (!didCancel) {\n          dispatch({ type: 'FETCH_FAILURE' })\n        }\n      }\n    }\n    fetchData()\n\n    return () => {\n      didCancel = true\n    }\n  }, [url])\n\n  const doFetch = url => {\n    setUrl(url)\n  }\n\n  return { ...state, doFetch }\n}\n```\n\n## 参考资料\n\n- [a-complete-guide-to-useeffect](https://overreacted.io/a-complete-guide-to-useeffect/)\n- [https://www.robinwieruch.de/react-hooks-fetch-data/](https://www.robinwieruch.de/react-hooks-fetch-data/)\n","source":"_posts/11.React Hooks 之 useEffect.md","raw":"---\nindex_img: /img/2022-04-07-1.png\nabbrlink: '0'\ndate: 2022-04-07 22:04:17\ntitle: React Hooks 之 useEffect\ntags: useEffect\ncategories:\n- [React Hook]\n- [React]\n---\n\nFunction Component 是更彻底的状态驱动抽象。要彻底理解 Hooks 需要忘掉 Class Component 生命周期,理解 FC 的思维方式。\n\n## 每次渲染都有他自己的 props 和 state\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\n`<p>You clicked {count} times</p>` 该行中的 count 如何理解？\n\n第一感觉是 count 是会“监听”状态变化自动更新。它不是 data binding、watcher、proxy。\n\n```jsx\nconst count = 42; // count 只是一个数字\n// ...\n<p>You clicked {count} times</p>\n// ...\n```\n\n组件第一次渲染，count 初始值是 0。 调用 setCount(1),react 再次渲染组件，这次 count 是 1。以此类推。。。\n\n```jsx\n// During first render\nfunction Counter() {\n  const count = 0; // Returned by useState()\n  // ...\n  <p>You clicked {count} times</p>\n  // ...\n}\n\n// After a click, our function is called again\nfunction Counter() {\n  const count = 1; // Returned by useState()\n  // ...\n  <p>You clicked {count} times</p>\n  // ...\n}\n\n// After another click, our function is called again\nfunction Counter() {\n  const count = 2; // Returned by useState()\n  // ...\n  <p>You clicked {count} times</p>\n  // ...\n}\n```\n\n每次状态更新，react 重新渲染组件。每一次的渲染中的 count 都是独立的值，这个状态值是函数中的一个常量。\n\n任意一次渲染中的count常量都不会随着时间改变。渲染输出会变是因为我们的组件被一次次调用，而每一次调用引起的渲染中，它包含的count值独立于其他渲染。\n\n## 每次渲染都有它自己的事件处理函数\n\n```jsx\nconst App = () => {\n  const [temp, setTemp] = React.useState(5);\n\n  const log = () => {\n    setTimeout(() => {\n      console.log(\"3 秒前 temp = 5，现在 temp =\", temp);\n    }, 3000);\n  };\n\n  return (\n    <div\n      onClick={() => {\n        log();\n        setTemp(3);\n        // 3 秒前 temp = 5，现在 temp = 5\n      }}\n    >\n      xyz\n    </div>\n  );\n};\n```\n\n上述代码输出 5，而不是 3\n\nlog 函数执行的那个 render 过程， temp 可以看作常量 5。执行 setTemp(3) 后会由一个全新的 render 渲染。所以不会执行 log 函数。而 3 秒后执行的内容是由\ntemp 为 5 的那个 render 发出的。所以结果为 5。\n\n## 每次 Render 都有自己的 Effects\n\nuseEffect 在 DOM 渲染完毕后执行， 也一样拿到的是某次渲染时的值。\n\n每次 render 过程，拿到的 count 都是固化的常量。\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  });\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  );\n}\n```\n\n## 单次渲染内，props 和 state 始终保持不变\n\n所以，每一个组件内的函数（包括事件处理函数，effects，定时器或者API调用等等）会捕获某次渲染中定义的props 和 state。\n\n下面两个例子是相等的：\n\n```jsx\nfunction Example(props) {\n  useEffect(() => {\n    setTimeout(() => {\n      console.log(props.counter);\n    }, 1000);\n  });\n  // ...\n}\n```\n\n```jsx\nfunction Example(props) {\n  const counter = props.counter;\n  useEffect(() => {\n    setTimeout(() => {\n      console.log(counter);\n    }, 1000);\n  });\n  // ...\n}\n```\n\n在组件内，什么时候读 props 和 state 都一样。在单次渲染内，他们始终保持不变。\n\n## 如何拿最新的值，而不是捕获的值\n\nuseRef 可以绕过 Capture Value 的特性。可以认为 ref 在所有 Render 过程中保持着唯一引用，因此所有对 ref 的赋值或取值，拿到的都只有一个最终状态，而不会在每个\nRender 间存在隔离。\n\n```jsx\nfunction Example() {\n  const [count, setCount] = useState(0);\n  const latestCount = useRef(count);\n\n  useEffect(() => {\n    // Set the mutable latest value\n    latestCount.current = count;\n    setTimeout(() => {\n      // Read the mutable latest value\n      console.log(`You clicked ${latestCount.current} times`);\n    }, 3000);\n  });\n  // ...\n```\n\n也可以认为，ref 是 Mutable 的，而 state 是 Immutable 的。\n\n## useEffect 回收机制\n\n```jsx\nuseEffect(() => {\n    ChatAPI.subscribeToFriendStatus(props.id, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(props.id, handleStatusChange);\n    };\n  });\n```\n\n假设第一次渲染的时候props是{id: 10}，第二次渲染的时候是{id: 20}。你可能认为顺序如下：\n\n- React 清除了 {id: 10}的effect。\n- React 渲染{id: 20}的UI。\n- React 运行{id: 20}的effect。\n\n实际上并不是这样，react 只会在浏览器绘制之后运行 useEffect。上一次的 effect 会在重新渲染后被清楚。\n\n- React 渲染{id: 20}的UI。\n- 浏览器绘制。我们在屏幕上看到{id: 20}的UI。\n- React 清除{id: 10}的effect。\n- React 运行{id: 20}的effect。\n\n那为什么清楚上一次的 effect 发生在 props 变为 {id: 20} 之后，却还能看到旧的 {id: 10} ？\n\neffect的清除并不会读取“最新”的props。它只能读取到定义它的那次渲染中的props值。由于 Capture Value 特性，每次 “注册” “回收” 拿到的都是成对的固定值。\n\n确切的说清除上一次的副作用发生在“每次重新渲染之后，副作用函数重新运行执行”。\n\n## 同步，而非生命周期\n\nReact会根据我们当前的props和state同步到DOM。“mount”和“update”之于渲染并没有什么区别。\n\n用相同的方式去思考effects。useEffect使你能够根据props和state同步React tree之外的东西。\n\n## 告诉 React 如何对比 Effect\n\nreact 在 DOM渲染时会 diff 内容，只对改变的部分做修改。但是对于 effect 却做不到这样。\n\n如何避免 effect 重复调用，需要给 effect 提供一个 deps，deps 内变量改变的时候才执行。\n\n```jsx\nuseEffect(() => {\n    document.title = 'Hello, ' + name;\n  }, [name]); // Our deps\n```\n\n## 依赖项不要撒谎\n\n```jsx\nfunction SearchResults() {\n  async function fetchData() {\n    // ...\n  }\n\n  useEffect(() => {\n    fetchData();\n  }, []); // Is this okay? Not always -- and there's a better way to write it.\n\n  // ...\n}\n```\n\n你设置了依赖项，effect中用到的所有组件内的值都要包含在依赖中。这包括 props，state，函数。\n\n这样做可能会遇到一些问题，比如会遇到重复渲染、无限请求等。解决问题的办法不是移除依赖性。后续再说。\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(count + 1);\n    }, 1000);\n    return () => clearInterval(id);\n  }, []);\n\n  return <h1>{count}</h1>;\n}\n```\n\nsetInterval 只想只想一次，依赖写为 []。\n\n但是，因为 useEffect 拿到的是那次渲染时候的值。count 值永远是 0。setCount 没产生作用。\n\n## 对依赖诚实的代价\n\n对依赖诚实，那就把 count 加到依赖中：\n\n```jsx\nuseEffect(() => {\n  const id = setInterval(() => {\n    setCount(count + 1);\n  }, 1000);\n  return () => clearInterval(id);\n}, [count]);\n```\n\n此时能够拿到最新的 count，但是有问题：\n\n- 每次变化都生成、销毁定时器，性能不好。\n- 每次重新定时，不准。\n\n## 让 useEffect 自给自足\n\n上述代码 对只想执行一次的 useEffect 里依赖了外部变量。\n\n解决办法就是 不依赖外部变量。\n\n```jsx\nuseEffect(() => {\n  const id = setInterval(() => {\n    setCount(c => c + 1);\n  }, 1000);\n  return () => clearInterval(id);\n}, []);\n```\n\nsetCount 回调写法，对旧值进行修改。此时 useEffect 只允许一次，count 也能拿到最新的值。\n\n## 解耦来自 Actions 的更新\n\nsetCount(c => c + 1) 并不能解决所有场景问题。如果我们有两个互相依赖的状态，或者我们想基于一个prop来计算下一次的state，它并不能做到。幸运的是， setCount(c =>\nc + 1)有一个更强大的姐妹模式，它的名字叫useReducer。\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const [step, setStep] = useState(1);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(c => c + step);\n    }, 1000);\n    return () => clearInterval(id);\n  }, [step]);\n\n  return (\n    <>\n      <h1>{count}</h1>\n      <input value={step} onChange={e => setStep(Number(e.target.value))} />\n    </>\n  );\n}\n```\n\n上述例子中没有依赖撒谎。但是 step 改变时，不想重启定时器怎么办？\n\n当你想更新一个状态，并且这个状态更新依赖于另一个状态的值时，你可能需要用useReducer去替换它们。\n\n利用 useReducer 函数，将更新与动作解耦：\n\n```jsx\nconst [state, dispatch] = useReducer(reducer, initialState);\nconst { count, step } = state;\n\nuseEffect(() => {\n  const id = setInterval(() => {\n    dispatch({ type: \"tick\" }); // Instead of setCount(c => c + step);\n  }, 1000);\n  return () => clearInterval(id);\n}, [dispatch]);\n```\n\nReact会保证 dispatc 在组件的声明周期内保持不变。\n\n## 依赖 props 计算状态\n\n前面介绍了如何移除effect的依赖，不管状态更新是依赖上一个状态还是依赖另一个状态。\n\n但假如我们需要依赖props去计算下一个状态呢。\n\n`<Counter step={1} />`，此时如何避免依赖 props.step 呢？\n\n把 reducer 函数放到组件内部去读取 props：\n\n```jsx\nfunction Counter({ step }) {\n  const [count, dispatch] = useReducer(reducer, 0);\n\n  function reducer(state, action) {\n    if (action.type === 'tick') {\n      return state + step;\n    } else {\n      throw new Error();\n    }\n  }\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      dispatch({ type: 'tick' });\n    }, 1000);\n    return () => clearInterval(id);\n  }, [dispatch]);\n\n  return <h1>{count}</h1>;\n}\n```\n\n此时 react 仍能保证 dispatch 在每次渲染中都是一样的。\n\n这可以帮助我移除不必需的依赖，避免不必要的effect调用。\n\n## 把函数移到 Effects 里\n\n如果某些函数仅在effect中调用，你可以把它们的定义移到effect中：\n\n```jsx\nfunction SearchResults() {\n  const [query, setQuery] = useState('react');\n\n  useEffect(() => {\n    function getFetchUrl() {\n      return 'https://hn.algolia.com/api/v1/search?query=' + query;\n    }\n\n    async function fetchData() {\n      const result = await axios(getFetchUrl());\n      setData(result.data);\n    }\n\n    fetchData();\n  }, [query]); // ✅ Deps are OK\n\n  // ...\n}\n```\n\n## 当函数不能放在 Effects 里\n\n有时函数不能放在 effects 里，如：\n\n- 组件内几个函数使用了相同的函数\n- 这个函数是一个 prop\n\n此时能忽略对函数的依赖么？最好不要，effects 对依赖不要撒谎。\n\n两种情况：\n\n- 1、函数内没有使用组件内的任何值，就提到组件外。\n\n```jsx\n/ ✅ Not affected by the data flow\nfunction getFetchUrl(query) {\n  return 'https://hn.algolia.com/api/v1/search?query=' + query;\n}\n\nfunction SearchResults() {\n  useEffect(() => {\n    const url = getFetchUrl('react');\n    // ... Fetch data and do something ...\n  }, []); // ✅ Deps are OK\n\n  useEffect(() => {\n    const url = getFetchUrl('redux');\n    // ... Fetch data and do something ...\n  }, []); // ✅ Deps are OK\n\n  // ...\n}\n```\n\n- 2、放组件内，用 useCallback 包装, 将函数添加到依赖\n\n```jsx\nfunction SearchResults() {\n  const [query, setQuery] = useState('react');\n\n  // ✅ Preserves identity until query changes\n  const getFetchUrl = useCallback(() => {\n    return 'https://hn.algolia.com/api/v1/search?query=' + query;\n  }, [query]);  // ✅ Callback deps are OK\n\n  useEffect(() => {\n    const url = getFetchUrl();\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ✅ Effect deps are OK\n\n  // ...\n}\n```\n\n使用 useCallback，因为如果query 保持不变，getFetchUrl也会保持不变，我们的effect也不会重新运行。\n\n父组件传入函数的情况，也适用该方法：\n\n```jsx\nfunction Parent() {\n  const [query, setQuery] = useState('react');\n\n  // ✅ Preserves identity until query changes\n  const fetchData = useCallback(() => {\n    const url = 'https://hn.algolia.com/api/v1/search?query=' + query;\n    // ... Fetch data and return it ...\n  }, [query]);  // ✅ Callback deps are OK\n\n  return <Child fetchData={fetchData} />\n}\n\nfunction Child({ fetchData }) {\n  let [data, setData] = useState(null);\n\n  useEffect(() => {\n    fetchData().then(setData);\n  }, [fetchData]); // ✅ Effect deps are OK\n\n  // ...\n}\n```\n\n避免到处使用 useCallback。\n\n当我们需要将函数传递下去并且函数会在子组件的effect中被调用的时候，useCallback 是很好的技巧且非常有用。或者你想试图减少对子组件的记忆负担，也不妨一试。\n\n- 3、更好的方式可能是把他抽成自定义 Hook，把 fetchData 放在 effect 里。\n\nuseEffect 只是底层 API，未来业务接触到的是更多封装后的上层 API，比如 useFetch 或者 useTheme，它们会更好用。\n\n```jsx\nimport React, { useState, useEffect, useReducer } from 'react'\n\nconst GITHUB_API = 'https://api.github.com/repos/chanshiyucx/blog/issues?page=10&per_page='\n\nexport default () => {\n  const [list, setList] = useState([])\n  const [page, setPage] = useState(1)\n\n  const { data, doFetch } = useDataApi(`${GITHUB_API}${page}`, [])\n  // 翻页时重新获取列表\n  useEffect(() => doFetch(`${GITHUB_API}${page}`), [page])\n  useEffect(() => setList(data), [data])\n\n  const handleNextPage = () => setPage(page + 1)\n\n  return (\n    <div>\n      <button onClick={handleNextPage}>NextPage</button>\n      <ul>\n        {list.map(o => (\n          <li key={o.id}>{o.title}</li>\n        ))}\n      </ul>\n\n      {isError && <div>Something went wrong ...</div>}\n      {isLoading && <div>Loading ...</div>}\n    </div>\n  )\n}\n```\n\nreducer:\n\n```jsx\nconst dataFetchReducer = (state, action) => {\n  switch (action.type) {\n    case 'FETCH_INIT':\n      return {\n        ...state,\n        isLoading: true,\n        isError: false\n      }\n    case 'FETCH_SUCCESS':\n      return {\n        ...state,\n        isLoading: false,\n        isError: false,\n        data: action.payload\n      }\n    case 'FETCH_FAILURE':\n      return {\n        ...state,\n        isLoading: false,\n        isError: true\n      }\n    default:\n      throw new Error()\n  }\n}\n```\n\n自定义 Hook：\n\n```jsx\nconst useDataApi = (initialUrl, initialData) => {\n  const [url, setUrl] = useState(initialUrl)\n\n  const [state, dispatch] = useReducer(dataFetchReducer, {\n    isLoading: false,\n    isError: false,\n    data: initialData\n  })\n\n  useEffect(() => {\n    let didCancel = false\n\n    const fetchData = async () => {\n      dispatch({ type: 'FETCH_INIT' })\n      try {\n        const response = await fetch(url)\n        const data = await response.json()\n        if (!didCancel) {\n          dispatch({ type: 'FETCH_SUCCESS', payload: data })\n        }\n      } catch (error) {\n        if (!didCancel) {\n          dispatch({ type: 'FETCH_FAILURE' })\n        }\n      }\n    }\n    fetchData()\n\n    return () => {\n      didCancel = true\n    }\n  }, [url])\n\n  const doFetch = url => {\n    setUrl(url)\n  }\n\n  return { ...state, doFetch }\n}\n```\n\n## 参考资料\n\n- [a-complete-guide-to-useeffect](https://overreacted.io/a-complete-guide-to-useeffect/)\n- [https://www.robinwieruch.de/react-hooks-fetch-data/](https://www.robinwieruch.de/react-hooks-fetch-data/)\n","slug":"11-React-Hooks-之-useEffect","published":1,"updated":"2022-08-23T02:19:23.472Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn3j000kyu3lcjd91mbx","content":"<p>Function Component 是更彻底的状态驱动抽象。要彻底理解 Hooks 需要忘掉 Class Component 生命周期,理解 FC 的思维方式。</p>\n<h2 id=\"每次渲染都有他自己的-props-和-state\"><a href=\"#每次渲染都有他自己的-props-和-state\" class=\"headerlink\" title=\"每次渲染都有他自己的 props 和 state\"></a>每次渲染都有他自己的 props 和 state</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span>\n<span class=\"xml\">        Click me</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;</code></pre></div>\n\n<p><code>&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</code> 该行中的 count 如何理解？</p>\n<p>第一感觉是 count 是会“监听”状态变化自动更新。它不是 data binding、watcher、proxy。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> count = <span class=\"hljs-number\">42</span>; <span class=\"hljs-comment\">// count 只是一个数字</span>\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n<span class=\"hljs-comment\">// ...</span></code></pre></div>\n\n<p>组件第一次渲染，count 初始值是 0。 调用 setCount(1),react 再次渲染组件，这次 count 是 1。以此类推。。。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// During first render</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> count = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// Returned by useState()</span>\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n\n<span class=\"hljs-comment\">// After a click, our function is called again</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> count = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// Returned by useState()</span>\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n\n<span class=\"hljs-comment\">// After another click, our function is called again</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> count = <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// Returned by useState()</span>\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre></div>\n\n<p>每次状态更新，react 重新渲染组件。每一次的渲染中的 count 都是独立的值，这个状态值是函数中的一个常量。</p>\n<p>任意一次渲染中的count常量都不会随着时间改变。渲染输出会变是因为我们的组件被一次次调用，而每一次调用引起的渲染中，它包含的count值独立于其他渲染。</p>\n<h2 id=\"每次渲染都有它自己的事件处理函数\"><a href=\"#每次渲染都有它自己的事件处理函数\" class=\"headerlink\" title=\"每次渲染都有它自己的事件处理函数\"></a>每次渲染都有它自己的事件处理函数</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> App = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> [temp, setTemp] = React.useState(<span class=\"hljs-number\">5</span>);\n\n  <span class=\"hljs-keyword\">const</span> log = <span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;3 秒前 temp = 5，现在 temp =&quot;</span>, temp);\n    &#125;, <span class=\"hljs-number\">3000</span>);\n  &#125;;\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span></span></span>\n<span class=\"hljs-tag\"><span class=\"xml\">      <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span>\n<span class=\"xml\">        log();</span>\n<span class=\"xml\">        setTemp(3);</span>\n<span class=\"xml\">        // 3 秒前 temp = 5，现在 temp = 5</span>\n<span class=\"xml\">      &#125;&#125;</span>\n<span class=\"xml\">    &gt;</span>\n<span class=\"xml\">      xyz</span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;;</code></pre></div>\n\n<p>上述代码输出 5，而不是 3</p>\n<p>log 函数执行的那个 render 过程， temp 可以看作常量 5。执行 setTemp(3) 后会由一个全新的 render 渲染。所以不会执行 log 函数。而 3 秒后执行的内容是由<br>temp 为 5 的那个 render 发出的。所以结果为 5。</p>\n<h2 id=\"每次-Render-都有自己的-Effects\"><a href=\"#每次-Render-都有自己的-Effects\" class=\"headerlink\" title=\"每次 Render 都有自己的 Effects\"></a>每次 Render 都有自己的 Effects</h2><p>useEffect 在 DOM 渲染完毕后执行， 也一样拿到的是某次渲染时的值。</p>\n<p>每次 render 过程，拿到的 count 都是固化的常量。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">document</span>.title = <span class=\"hljs-string\">`You clicked <span class=\"hljs-subst\">$&#123;count&#125;</span> times`</span>;\n  &#125;);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Click me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;</code></pre></div>\n\n<h2 id=\"单次渲染内，props-和-state-始终保持不变\"><a href=\"#单次渲染内，props-和-state-始终保持不变\" class=\"headerlink\" title=\"单次渲染内，props 和 state 始终保持不变\"></a>单次渲染内，props 和 state 始终保持不变</h2><p>所以，每一个组件内的函数（包括事件处理函数，effects，定时器或者API调用等等）会捕获某次渲染中定义的props 和 state。</p>\n<p>下面两个例子是相等的：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\">props</span>) </span>&#123;\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">console</span>.log(props.counter);\n    &#125;, <span class=\"hljs-number\">1000</span>);\n  &#125;);\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre></div>\n\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\">props</span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> counter = props.counter;\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">console</span>.log(counter);\n    &#125;, <span class=\"hljs-number\">1000</span>);\n  &#125;);\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre></div>\n\n<p>在组件内，什么时候读 props 和 state 都一样。在单次渲染内，他们始终保持不变。</p>\n<h2 id=\"如何拿最新的值，而不是捕获的值\"><a href=\"#如何拿最新的值，而不是捕获的值\" class=\"headerlink\" title=\"如何拿最新的值，而不是捕获的值\"></a>如何拿最新的值，而不是捕获的值</h2><p>useRef 可以绕过 Capture Value 的特性。可以认为 ref 在所有 Render 过程中保持着唯一引用，因此所有对 ref 的赋值或取值，拿到的都只有一个最终状态，而不会在每个<br>Render 间存在隔离。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">const</span> latestCount = useRef(count);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-comment\">// Set the mutable latest value</span>\n    latestCount.current = count;\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-comment\">// Read the mutable latest value</span>\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`You clicked <span class=\"hljs-subst\">$&#123;latestCount.current&#125;</span> times`</span>);\n    &#125;, <span class=\"hljs-number\">3000</span>);\n  &#125;);\n  <span class=\"hljs-comment\">// ...</span></code></pre></div>\n\n<p>也可以认为，ref 是 Mutable 的，而 state 是 Immutable 的。</p>\n<h2 id=\"useEffect-回收机制\"><a href=\"#useEffect-回收机制\" class=\"headerlink\" title=\"useEffect 回收机制\"></a>useEffect 回收机制</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\">useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    ChatAPI.subscribeToFriendStatus(props.id, handleStatusChange);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      ChatAPI.unsubscribeFromFriendStatus(props.id, handleStatusChange);\n    &#125;;\n  &#125;);</code></pre></div>\n\n<p>假设第一次渲染的时候props是{id: 10}，第二次渲染的时候是{id: 20}。你可能认为顺序如下：</p>\n<ul>\n<li>React 清除了 {id: 10}的effect。</li>\n<li>React 渲染{id: 20}的UI。</li>\n<li>React 运行{id: 20}的effect。</li>\n</ul>\n<p>实际上并不是这样，react 只会在浏览器绘制之后运行 useEffect。上一次的 effect 会在重新渲染后被清楚。</p>\n<ul>\n<li>React 渲染{id: 20}的UI。</li>\n<li>浏览器绘制。我们在屏幕上看到{id: 20}的UI。</li>\n<li>React 清除{id: 10}的effect。</li>\n<li>React 运行{id: 20}的effect。</li>\n</ul>\n<p>那为什么清楚上一次的 effect 发生在 props 变为 {id: 20} 之后，却还能看到旧的 {id: 10} ？</p>\n<p>effect的清除并不会读取“最新”的props。它只能读取到定义它的那次渲染中的props值。由于 Capture Value 特性，每次 “注册” “回收” 拿到的都是成对的固定值。</p>\n<p>确切的说清除上一次的副作用发生在“每次重新渲染之后，副作用函数重新运行执行”。</p>\n<h2 id=\"同步，而非生命周期\"><a href=\"#同步，而非生命周期\" class=\"headerlink\" title=\"同步，而非生命周期\"></a>同步，而非生命周期</h2><p>React会根据我们当前的props和state同步到DOM。“mount”和“update”之于渲染并没有什么区别。</p>\n<p>用相同的方式去思考effects。useEffect使你能够根据props和state同步React tree之外的东西。</p>\n<h2 id=\"告诉-React-如何对比-Effect\"><a href=\"#告诉-React-如何对比-Effect\" class=\"headerlink\" title=\"告诉 React 如何对比 Effect\"></a>告诉 React 如何对比 Effect</h2><p>react 在 DOM渲染时会 diff 内容，只对改变的部分做修改。但是对于 effect 却做不到这样。</p>\n<p>如何避免 effect 重复调用，需要给 effect 提供一个 deps，deps 内变量改变的时候才执行。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\">useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">document</span>.title = <span class=\"hljs-string\">&#x27;Hello, &#x27;</span> + name;\n  &#125;, [name]); <span class=\"hljs-comment\">// Our deps</span></code></pre></div>\n\n<h2 id=\"依赖项不要撒谎\"><a href=\"#依赖项不要撒谎\" class=\"headerlink\" title=\"依赖项不要撒谎\"></a>依赖项不要撒谎</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SearchResults</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fetchData</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    fetchData();\n  &#125;, []); <span class=\"hljs-comment\">// Is this okay? Not always -- and there&#x27;s a better way to write it.</span>\n\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre></div>\n\n<p>你设置了依赖项，effect中用到的所有组件内的值都要包含在依赖中。这包括 props，state，函数。</p>\n<p>这样做可能会遇到一些问题，比如会遇到重复渲染、无限请求等。解决问题的办法不是移除依赖性。后续再说。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      setCount(count + <span class=\"hljs-number\">1</span>);\n    &#125;, <span class=\"hljs-number\">1000</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(id);\n  &#125;, []);\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n&#125;</code></pre></div>\n\n<p>setInterval 只想只想一次，依赖写为 []。</p>\n<p>但是，因为 useEffect 拿到的是那次渲染时候的值。count 值永远是 0。setCount 没产生作用。</p>\n<h2 id=\"对依赖诚实的代价\"><a href=\"#对依赖诚实的代价\" class=\"headerlink\" title=\"对依赖诚实的代价\"></a>对依赖诚实的代价</h2><p>对依赖诚实，那就把 count 加到依赖中：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\">useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    setCount(count + <span class=\"hljs-number\">1</span>);\n  &#125;, <span class=\"hljs-number\">1000</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(id);\n&#125;, [count]);</code></pre></div>\n\n<p>此时能够拿到最新的 count，但是有问题：</p>\n<ul>\n<li>每次变化都生成、销毁定时器，性能不好。</li>\n<li>每次重新定时，不准。</li>\n</ul>\n<h2 id=\"让-useEffect-自给自足\"><a href=\"#让-useEffect-自给自足\" class=\"headerlink\" title=\"让 useEffect 自给自足\"></a>让 useEffect 自给自足</h2><p>上述代码 对只想执行一次的 useEffect 里依赖了外部变量。</p>\n<p>解决办法就是 不依赖外部变量。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\">useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    setCount(<span class=\"hljs-function\"><span class=\"hljs-params\">c</span> =&gt;</span> c + <span class=\"hljs-number\">1</span>);\n  &#125;, <span class=\"hljs-number\">1000</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(id);\n&#125;, []);</code></pre></div>\n\n<p>setCount 回调写法，对旧值进行修改。此时 useEffect 只允许一次，count 也能拿到最新的值。</p>\n<h2 id=\"解耦来自-Actions-的更新\"><a href=\"#解耦来自-Actions-的更新\" class=\"headerlink\" title=\"解耦来自 Actions 的更新\"></a>解耦来自 Actions 的更新</h2><p>setCount(c =&gt; c + 1) 并不能解决所有场景问题。如果我们有两个互相依赖的状态，或者我们想基于一个prop来计算下一次的state，它并不能做到。幸运的是， setCount(c =&gt;<br>c + 1)有一个更强大的姐妹模式，它的名字叫useReducer。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">const</span> [step, setStep] = useState(<span class=\"hljs-number\">1</span>);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      setCount(<span class=\"hljs-function\"><span class=\"hljs-params\">c</span> =&gt;</span> c + step);\n    &#125;, <span class=\"hljs-number\">1000</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(id);\n  &#125;, [step]);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;step&#125;</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">&#123;e</span> =&gt;</span> setStep(Number(e.target.value))&#125; /&gt;</span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n&#125;</code></pre></div>\n\n<p>上述例子中没有依赖撒谎。但是 step 改变时，不想重启定时器怎么办？</p>\n<p>当你想更新一个状态，并且这个状态更新依赖于另一个状态的值时，你可能需要用useReducer去替换它们。</p>\n<p>利用 useReducer 函数，将更新与动作解耦：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> [state, dispatch] = useReducer(reducer, initialState);\n<span class=\"hljs-keyword\">const</span> &#123; count, step &#125; = state;\n\nuseEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    dispatch(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;tick&quot;</span> &#125;); <span class=\"hljs-comment\">// Instead of setCount(c =&gt; c + step);</span>\n  &#125;, <span class=\"hljs-number\">1000</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(id);\n&#125;, [dispatch]);</code></pre></div>\n\n<p>React会保证 dispatc 在组件的声明周期内保持不变。</p>\n<h2 id=\"依赖-props-计算状态\"><a href=\"#依赖-props-计算状态\" class=\"headerlink\" title=\"依赖 props 计算状态\"></a>依赖 props 计算状态</h2><p>前面介绍了如何移除effect的依赖，不管状态更新是依赖上一个状态还是依赖另一个状态。</p>\n<p>但假如我们需要依赖props去计算下一个状态呢。</p>\n<p><code>&lt;Counter step=&#123;1&#125; /&gt;</code>，此时如何避免依赖 props.step 呢？</p>\n<p>把 reducer 函数放到组件内部去读取 props：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\">&#123; step &#125;</span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, dispatch] = useReducer(reducer, <span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reducer</span>(<span class=\"hljs-params\">state, action</span>) </span>&#123;\n    <span class=\"hljs-keyword\">if</span> (action.type === <span class=\"hljs-string\">&#x27;tick&#x27;</span>) &#123;\n      <span class=\"hljs-keyword\">return</span> state + step;\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>();\n    &#125;\n  &#125;\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      dispatch(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;tick&#x27;</span> &#125;);\n    &#125;, <span class=\"hljs-number\">1000</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(id);\n  &#125;, [dispatch]);\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n&#125;</code></pre></div>\n\n<p>此时 react 仍能保证 dispatch 在每次渲染中都是一样的。</p>\n<p>这可以帮助我移除不必需的依赖，避免不必要的effect调用。</p>\n<h2 id=\"把函数移到-Effects-里\"><a href=\"#把函数移到-Effects-里\" class=\"headerlink\" title=\"把函数移到 Effects 里\"></a>把函数移到 Effects 里</h2><p>如果某些函数仅在effect中调用，你可以把它们的定义移到effect中：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SearchResults</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [query, setQuery] = useState(<span class=\"hljs-string\">&#x27;react&#x27;</span>);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getFetchUrl</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;\n    &#125;\n\n    <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fetchData</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">await</span> axios(getFetchUrl());\n      setData(result.data);\n    &#125;\n\n    fetchData();\n  &#125;, [query]); <span class=\"hljs-comment\">// ✅ Deps are OK</span>\n\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre></div>\n\n<h2 id=\"当函数不能放在-Effects-里\"><a href=\"#当函数不能放在-Effects-里\" class=\"headerlink\" title=\"当函数不能放在 Effects 里\"></a>当函数不能放在 Effects 里</h2><p>有时函数不能放在 effects 里，如：</p>\n<ul>\n<li>组件内几个函数使用了相同的函数</li>\n<li>这个函数是一个 prop</li>\n</ul>\n<p>此时能忽略对函数的依赖么？最好不要，effects 对依赖不要撒谎。</p>\n<p>两种情况：</p>\n<ul>\n<li>1、函数内没有使用组件内的任何值，就提到组件外。</li>\n</ul>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\">/ ✅ Not affected by the data flow\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getFetchUrl</span>(<span class=\"hljs-params\">query</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SearchResults</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> url = getFetchUrl(<span class=\"hljs-string\">&#x27;react&#x27;</span>);\n    <span class=\"hljs-comment\">// ... Fetch data and do something ...</span>\n  &#125;, []); <span class=\"hljs-comment\">// ✅ Deps are OK</span>\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> url = getFetchUrl(<span class=\"hljs-string\">&#x27;redux&#x27;</span>);\n    <span class=\"hljs-comment\">// ... Fetch data and do something ...</span>\n  &#125;, []); <span class=\"hljs-comment\">// ✅ Deps are OK</span>\n\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre></div>\n\n<ul>\n<li>2、放组件内，用 useCallback 包装, 将函数添加到依赖</li>\n</ul>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SearchResults</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [query, setQuery] = useState(<span class=\"hljs-string\">&#x27;react&#x27;</span>);\n\n  <span class=\"hljs-comment\">// ✅ Preserves identity until query changes</span>\n  <span class=\"hljs-keyword\">const</span> getFetchUrl = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;\n  &#125;, [query]);  <span class=\"hljs-comment\">// ✅ Callback deps are OK</span>\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> url = getFetchUrl();\n    <span class=\"hljs-comment\">// ... Fetch data and do something ...</span>\n  &#125;, [getFetchUrl]); <span class=\"hljs-comment\">// ✅ Effect deps are OK</span>\n\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre></div>\n\n<p>使用 useCallback，因为如果query 保持不变，getFetchUrl也会保持不变，我们的effect也不会重新运行。</p>\n<p>父组件传入函数的情况，也适用该方法：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Parent</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [query, setQuery] = useState(<span class=\"hljs-string\">&#x27;react&#x27;</span>);\n\n  <span class=\"hljs-comment\">// ✅ Preserves identity until query changes</span>\n  <span class=\"hljs-keyword\">const</span> fetchData = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> url = <span class=\"hljs-string\">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;\n    <span class=\"hljs-comment\">// ... Fetch data and return it ...</span>\n  &#125;, [query]);  <span class=\"hljs-comment\">// ✅ Callback deps are OK</span>\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Child</span> <span class=\"hljs-attr\">fetchData</span>=<span class=\"hljs-string\">&#123;fetchData&#125;</span> /&gt;</span></span>\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Child</span>(<span class=\"hljs-params\">&#123; fetchData &#125;</span>) </span>&#123;\n  <span class=\"hljs-keyword\">let</span> [data, setData] = useState(<span class=\"hljs-literal\">null</span>);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    fetchData().then(setData);\n  &#125;, [fetchData]); <span class=\"hljs-comment\">// ✅ Effect deps are OK</span>\n\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre></div>\n\n<p>避免到处使用 useCallback。</p>\n<p>当我们需要将函数传递下去并且函数会在子组件的effect中被调用的时候，useCallback 是很好的技巧且非常有用。或者你想试图减少对子组件的记忆负担，也不妨一试。</p>\n<ul>\n<li>3、更好的方式可能是把他抽成自定义 Hook，把 fetchData 放在 effect 里。</li>\n</ul>\n<p>useEffect 只是底层 API，未来业务接触到的是更多封装后的上层 API，比如 useFetch 或者 useTheme，它们会更好用。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React, &#123; useState, useEffect, useReducer &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>\n\n<span class=\"hljs-keyword\">const</span> GITHUB_API = <span class=\"hljs-string\">&#x27;https://api.github.com/repos/chanshiyucx/blog/issues?page=10&amp;per_page=&#x27;</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> () =&gt; &#123;\n  <span class=\"hljs-keyword\">const</span> [list, setList] = useState([])\n  <span class=\"hljs-keyword\">const</span> [page, setPage] = useState(<span class=\"hljs-number\">1</span>)\n\n  <span class=\"hljs-keyword\">const</span> &#123; data, doFetch &#125; = useDataApi(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;GITHUB_API&#125;</span><span class=\"hljs-subst\">$&#123;page&#125;</span>`</span>, [])\n  <span class=\"hljs-comment\">// 翻页时重新获取列表</span>\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> doFetch(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;GITHUB_API&#125;</span><span class=\"hljs-subst\">$&#123;page&#125;</span>`</span>), [page])\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> setList(data), [data])\n\n  <span class=\"hljs-keyword\">const</span> handleNextPage = <span class=\"hljs-function\">() =&gt;</span> setPage(page + <span class=\"hljs-number\">1</span>)\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;handleNextPage&#125;</span>&gt;</span>NextPage<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span></span>\n<span class=\"xml\">        &#123;list.map(o =&gt; (</span>\n<span class=\"xml\">          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#123;o.id&#125;</span>&gt;</span>&#123;o.title&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span>\n<span class=\"xml\">        ))&#125;</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></span>\n<span class=\"xml\"></span>\n<span class=\"xml\">      &#123;isError &amp;&amp; <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Something went wrong ...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>&#125;</span>\n<span class=\"xml\">      &#123;isLoading &amp;&amp; <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Loading ...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>&#125;</span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  )\n&#125;</code></pre></div>\n\n<p>reducer:</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> dataFetchReducer = <span class=\"hljs-function\">(<span class=\"hljs-params\">state, action</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">switch</span> (action.type) &#123;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;FETCH_INIT&#x27;</span>:\n      <span class=\"hljs-keyword\">return</span> &#123;\n        ...state,\n        <span class=\"hljs-attr\">isLoading</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">isError</span>: <span class=\"hljs-literal\">false</span>\n      &#125;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;FETCH_SUCCESS&#x27;</span>:\n      <span class=\"hljs-keyword\">return</span> &#123;\n        ...state,\n        <span class=\"hljs-attr\">isLoading</span>: <span class=\"hljs-literal\">false</span>,\n        <span class=\"hljs-attr\">isError</span>: <span class=\"hljs-literal\">false</span>,\n        <span class=\"hljs-attr\">data</span>: action.payload\n      &#125;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;FETCH_FAILURE&#x27;</span>:\n      <span class=\"hljs-keyword\">return</span> &#123;\n        ...state,\n        <span class=\"hljs-attr\">isLoading</span>: <span class=\"hljs-literal\">false</span>,\n        <span class=\"hljs-attr\">isError</span>: <span class=\"hljs-literal\">true</span>\n      &#125;\n    <span class=\"hljs-attr\">default</span>:\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>()\n  &#125;\n&#125;</code></pre></div>\n\n<p>自定义 Hook：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> useDataApi = <span class=\"hljs-function\">(<span class=\"hljs-params\">initialUrl, initialData</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> [url, setUrl] = useState(initialUrl)\n\n  <span class=\"hljs-keyword\">const</span> [state, dispatch] = useReducer(dataFetchReducer, &#123;\n    <span class=\"hljs-attr\">isLoading</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">isError</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">data</span>: initialData\n  &#125;)\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">let</span> didCancel = <span class=\"hljs-literal\">false</span>\n\n    <span class=\"hljs-keyword\">const</span> fetchData = <span class=\"hljs-keyword\">async</span> () =&gt; &#123;\n      dispatch(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;FETCH_INIT&#x27;</span> &#125;)\n      <span class=\"hljs-keyword\">try</span> &#123;\n        <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> fetch(url)\n        <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> response.json()\n        <span class=\"hljs-keyword\">if</span> (!didCancel) &#123;\n          dispatch(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;FETCH_SUCCESS&#x27;</span>, <span class=\"hljs-attr\">payload</span>: data &#125;)\n        &#125;\n      &#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;\n        <span class=\"hljs-keyword\">if</span> (!didCancel) &#123;\n          dispatch(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;FETCH_FAILURE&#x27;</span> &#125;)\n        &#125;\n      &#125;\n    &#125;\n    fetchData()\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      didCancel = <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;, [url])\n\n  <span class=\"hljs-keyword\">const</span> doFetch = <span class=\"hljs-function\"><span class=\"hljs-params\">url</span> =&gt;</span> &#123;\n    setUrl(url)\n  &#125;\n\n  <span class=\"hljs-keyword\">return</span> &#123; ...state, doFetch &#125;\n&#125;</code></pre></div>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://overreacted.io/a-complete-guide-to-useeffect/\">a-complete-guide-to-useeffect</a></li>\n<li><a href=\"https://www.robinwieruch.de/react-hooks-fetch-data/\">https://www.robinwieruch.de/react-hooks-fetch-data/</a></li>\n</ul>\n","site":{"data":{}},"wordcount":10778,"excerpt":"","more":"<p>Function Component 是更彻底的状态驱动抽象。要彻底理解 Hooks 需要忘掉 Class Component 生命周期,理解 FC 的思维方式。</p>\n<h2 id=\"每次渲染都有他自己的-props-和-state\"><a href=\"#每次渲染都有他自己的-props-和-state\" class=\"headerlink\" title=\"每次渲染都有他自己的 props 和 state\"></a>每次渲染都有他自己的 props 和 state</h2><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span>\n<span class=\"xml\">        Click me</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;</code></pre>\n\n<p><code>&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</code> 该行中的 count 如何理解？</p>\n<p>第一感觉是 count 是会“监听”状态变化自动更新。它不是 data binding、watcher、proxy。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> count = <span class=\"hljs-number\">42</span>; <span class=\"hljs-comment\">// count 只是一个数字</span>\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n<span class=\"hljs-comment\">// ...</span></code></pre>\n\n<p>组件第一次渲染，count 初始值是 0。 调用 setCount(1),react 再次渲染组件，这次 count 是 1。以此类推。。。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// During first render</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> count = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// Returned by useState()</span>\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n\n<span class=\"hljs-comment\">// After a click, our function is called again</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> count = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// Returned by useState()</span>\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n\n<span class=\"hljs-comment\">// After another click, our function is called again</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> count = <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// Returned by useState()</span>\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n\n<p>每次状态更新，react 重新渲染组件。每一次的渲染中的 count 都是独立的值，这个状态值是函数中的一个常量。</p>\n<p>任意一次渲染中的count常量都不会随着时间改变。渲染输出会变是因为我们的组件被一次次调用，而每一次调用引起的渲染中，它包含的count值独立于其他渲染。</p>\n<h2 id=\"每次渲染都有它自己的事件处理函数\"><a href=\"#每次渲染都有它自己的事件处理函数\" class=\"headerlink\" title=\"每次渲染都有它自己的事件处理函数\"></a>每次渲染都有它自己的事件处理函数</h2><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> App = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> [temp, setTemp] = React.useState(<span class=\"hljs-number\">5</span>);\n\n  <span class=\"hljs-keyword\">const</span> log = <span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;3 秒前 temp = 5，现在 temp =&quot;</span>, temp);\n    &#125;, <span class=\"hljs-number\">3000</span>);\n  &#125;;\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span></span></span>\n<span class=\"hljs-tag\"><span class=\"xml\">      <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span>\n<span class=\"xml\">        log();</span>\n<span class=\"xml\">        setTemp(3);</span>\n<span class=\"xml\">        // 3 秒前 temp = 5，现在 temp = 5</span>\n<span class=\"xml\">      &#125;&#125;</span>\n<span class=\"xml\">    &gt;</span>\n<span class=\"xml\">      xyz</span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;;</code></pre>\n\n<p>上述代码输出 5，而不是 3</p>\n<p>log 函数执行的那个 render 过程， temp 可以看作常量 5。执行 setTemp(3) 后会由一个全新的 render 渲染。所以不会执行 log 函数。而 3 秒后执行的内容是由<br>temp 为 5 的那个 render 发出的。所以结果为 5。</p>\n<h2 id=\"每次-Render-都有自己的-Effects\"><a href=\"#每次-Render-都有自己的-Effects\" class=\"headerlink\" title=\"每次 Render 都有自己的 Effects\"></a>每次 Render 都有自己的 Effects</h2><p>useEffect 在 DOM 渲染完毕后执行， 也一样拿到的是某次渲染时的值。</p>\n<p>每次 render 过程，拿到的 count 都是固化的常量。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">document</span>.title = <span class=\"hljs-string\">`You clicked <span class=\"hljs-subst\">$&#123;count&#125;</span> times`</span>;\n  &#125;);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Click me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;</code></pre>\n\n<h2 id=\"单次渲染内，props-和-state-始终保持不变\"><a href=\"#单次渲染内，props-和-state-始终保持不变\" class=\"headerlink\" title=\"单次渲染内，props 和 state 始终保持不变\"></a>单次渲染内，props 和 state 始终保持不变</h2><p>所以，每一个组件内的函数（包括事件处理函数，effects，定时器或者API调用等等）会捕获某次渲染中定义的props 和 state。</p>\n<p>下面两个例子是相等的：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\">props</span>) </span>&#123;\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">console</span>.log(props.counter);\n    &#125;, <span class=\"hljs-number\">1000</span>);\n  &#125;);\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\">props</span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> counter = props.counter;\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">console</span>.log(counter);\n    &#125;, <span class=\"hljs-number\">1000</span>);\n  &#125;);\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n\n<p>在组件内，什么时候读 props 和 state 都一样。在单次渲染内，他们始终保持不变。</p>\n<h2 id=\"如何拿最新的值，而不是捕获的值\"><a href=\"#如何拿最新的值，而不是捕获的值\" class=\"headerlink\" title=\"如何拿最新的值，而不是捕获的值\"></a>如何拿最新的值，而不是捕获的值</h2><p>useRef 可以绕过 Capture Value 的特性。可以认为 ref 在所有 Render 过程中保持着唯一引用，因此所有对 ref 的赋值或取值，拿到的都只有一个最终状态，而不会在每个<br>Render 间存在隔离。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">const</span> latestCount = useRef(count);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-comment\">// Set the mutable latest value</span>\n    latestCount.current = count;\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-comment\">// Read the mutable latest value</span>\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`You clicked <span class=\"hljs-subst\">$&#123;latestCount.current&#125;</span> times`</span>);\n    &#125;, <span class=\"hljs-number\">3000</span>);\n  &#125;);\n  <span class=\"hljs-comment\">// ...</span></code></pre>\n\n<p>也可以认为，ref 是 Mutable 的，而 state 是 Immutable 的。</p>\n<h2 id=\"useEffect-回收机制\"><a href=\"#useEffect-回收机制\" class=\"headerlink\" title=\"useEffect 回收机制\"></a>useEffect 回收机制</h2><pre><code class=\"hljs jsx\">useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    ChatAPI.subscribeToFriendStatus(props.id, handleStatusChange);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      ChatAPI.unsubscribeFromFriendStatus(props.id, handleStatusChange);\n    &#125;;\n  &#125;);</code></pre>\n\n<p>假设第一次渲染的时候props是{id: 10}，第二次渲染的时候是{id: 20}。你可能认为顺序如下：</p>\n<ul>\n<li>React 清除了 {id: 10}的effect。</li>\n<li>React 渲染{id: 20}的UI。</li>\n<li>React 运行{id: 20}的effect。</li>\n</ul>\n<p>实际上并不是这样，react 只会在浏览器绘制之后运行 useEffect。上一次的 effect 会在重新渲染后被清楚。</p>\n<ul>\n<li>React 渲染{id: 20}的UI。</li>\n<li>浏览器绘制。我们在屏幕上看到{id: 20}的UI。</li>\n<li>React 清除{id: 10}的effect。</li>\n<li>React 运行{id: 20}的effect。</li>\n</ul>\n<p>那为什么清楚上一次的 effect 发生在 props 变为 {id: 20} 之后，却还能看到旧的 {id: 10} ？</p>\n<p>effect的清除并不会读取“最新”的props。它只能读取到定义它的那次渲染中的props值。由于 Capture Value 特性，每次 “注册” “回收” 拿到的都是成对的固定值。</p>\n<p>确切的说清除上一次的副作用发生在“每次重新渲染之后，副作用函数重新运行执行”。</p>\n<h2 id=\"同步，而非生命周期\"><a href=\"#同步，而非生命周期\" class=\"headerlink\" title=\"同步，而非生命周期\"></a>同步，而非生命周期</h2><p>React会根据我们当前的props和state同步到DOM。“mount”和“update”之于渲染并没有什么区别。</p>\n<p>用相同的方式去思考effects。useEffect使你能够根据props和state同步React tree之外的东西。</p>\n<h2 id=\"告诉-React-如何对比-Effect\"><a href=\"#告诉-React-如何对比-Effect\" class=\"headerlink\" title=\"告诉 React 如何对比 Effect\"></a>告诉 React 如何对比 Effect</h2><p>react 在 DOM渲染时会 diff 内容，只对改变的部分做修改。但是对于 effect 却做不到这样。</p>\n<p>如何避免 effect 重复调用，需要给 effect 提供一个 deps，deps 内变量改变的时候才执行。</p>\n<pre><code class=\"hljs jsx\">useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">document</span>.title = <span class=\"hljs-string\">&#x27;Hello, &#x27;</span> + name;\n  &#125;, [name]); <span class=\"hljs-comment\">// Our deps</span></code></pre>\n\n<h2 id=\"依赖项不要撒谎\"><a href=\"#依赖项不要撒谎\" class=\"headerlink\" title=\"依赖项不要撒谎\"></a>依赖项不要撒谎</h2><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SearchResults</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fetchData</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    fetchData();\n  &#125;, []); <span class=\"hljs-comment\">// Is this okay? Not always -- and there&#x27;s a better way to write it.</span>\n\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n\n<p>你设置了依赖项，effect中用到的所有组件内的值都要包含在依赖中。这包括 props，state，函数。</p>\n<p>这样做可能会遇到一些问题，比如会遇到重复渲染、无限请求等。解决问题的办法不是移除依赖性。后续再说。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      setCount(count + <span class=\"hljs-number\">1</span>);\n    &#125;, <span class=\"hljs-number\">1000</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(id);\n  &#125;, []);\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n&#125;</code></pre>\n\n<p>setInterval 只想只想一次，依赖写为 []。</p>\n<p>但是，因为 useEffect 拿到的是那次渲染时候的值。count 值永远是 0。setCount 没产生作用。</p>\n<h2 id=\"对依赖诚实的代价\"><a href=\"#对依赖诚实的代价\" class=\"headerlink\" title=\"对依赖诚实的代价\"></a>对依赖诚实的代价</h2><p>对依赖诚实，那就把 count 加到依赖中：</p>\n<pre><code class=\"hljs jsx\">useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    setCount(count + <span class=\"hljs-number\">1</span>);\n  &#125;, <span class=\"hljs-number\">1000</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(id);\n&#125;, [count]);</code></pre>\n\n<p>此时能够拿到最新的 count，但是有问题：</p>\n<ul>\n<li>每次变化都生成、销毁定时器，性能不好。</li>\n<li>每次重新定时，不准。</li>\n</ul>\n<h2 id=\"让-useEffect-自给自足\"><a href=\"#让-useEffect-自给自足\" class=\"headerlink\" title=\"让 useEffect 自给自足\"></a>让 useEffect 自给自足</h2><p>上述代码 对只想执行一次的 useEffect 里依赖了外部变量。</p>\n<p>解决办法就是 不依赖外部变量。</p>\n<pre><code class=\"hljs jsx\">useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    setCount(<span class=\"hljs-function\"><span class=\"hljs-params\">c</span> =&gt;</span> c + <span class=\"hljs-number\">1</span>);\n  &#125;, <span class=\"hljs-number\">1000</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(id);\n&#125;, []);</code></pre>\n\n<p>setCount 回调写法，对旧值进行修改。此时 useEffect 只允许一次，count 也能拿到最新的值。</p>\n<h2 id=\"解耦来自-Actions-的更新\"><a href=\"#解耦来自-Actions-的更新\" class=\"headerlink\" title=\"解耦来自 Actions 的更新\"></a>解耦来自 Actions 的更新</h2><p>setCount(c =&gt; c + 1) 并不能解决所有场景问题。如果我们有两个互相依赖的状态，或者我们想基于一个prop来计算下一次的state，它并不能做到。幸运的是， setCount(c =&gt;<br>c + 1)有一个更强大的姐妹模式，它的名字叫useReducer。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">const</span> [step, setStep] = useState(<span class=\"hljs-number\">1</span>);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      setCount(<span class=\"hljs-function\"><span class=\"hljs-params\">c</span> =&gt;</span> c + step);\n    &#125;, <span class=\"hljs-number\">1000</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(id);\n  &#125;, [step]);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;step&#125;</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">&#123;e</span> =&gt;</span> setStep(Number(e.target.value))&#125; /&gt;</span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n&#125;</code></pre>\n\n<p>上述例子中没有依赖撒谎。但是 step 改变时，不想重启定时器怎么办？</p>\n<p>当你想更新一个状态，并且这个状态更新依赖于另一个状态的值时，你可能需要用useReducer去替换它们。</p>\n<p>利用 useReducer 函数，将更新与动作解耦：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> [state, dispatch] = useReducer(reducer, initialState);\n<span class=\"hljs-keyword\">const</span> &#123; count, step &#125; = state;\n\nuseEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    dispatch(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;tick&quot;</span> &#125;); <span class=\"hljs-comment\">// Instead of setCount(c =&gt; c + step);</span>\n  &#125;, <span class=\"hljs-number\">1000</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(id);\n&#125;, [dispatch]);</code></pre>\n\n<p>React会保证 dispatc 在组件的声明周期内保持不变。</p>\n<h2 id=\"依赖-props-计算状态\"><a href=\"#依赖-props-计算状态\" class=\"headerlink\" title=\"依赖 props 计算状态\"></a>依赖 props 计算状态</h2><p>前面介绍了如何移除effect的依赖，不管状态更新是依赖上一个状态还是依赖另一个状态。</p>\n<p>但假如我们需要依赖props去计算下一个状态呢。</p>\n<p><code>&lt;Counter step=&#123;1&#125; /&gt;</code>，此时如何避免依赖 props.step 呢？</p>\n<p>把 reducer 函数放到组件内部去读取 props：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\">&#123; step &#125;</span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, dispatch] = useReducer(reducer, <span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reducer</span>(<span class=\"hljs-params\">state, action</span>) </span>&#123;\n    <span class=\"hljs-keyword\">if</span> (action.type === <span class=\"hljs-string\">&#x27;tick&#x27;</span>) &#123;\n      <span class=\"hljs-keyword\">return</span> state + step;\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>();\n    &#125;\n  &#125;\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      dispatch(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;tick&#x27;</span> &#125;);\n    &#125;, <span class=\"hljs-number\">1000</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(id);\n  &#125;, [dispatch]);\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n&#125;</code></pre>\n\n<p>此时 react 仍能保证 dispatch 在每次渲染中都是一样的。</p>\n<p>这可以帮助我移除不必需的依赖，避免不必要的effect调用。</p>\n<h2 id=\"把函数移到-Effects-里\"><a href=\"#把函数移到-Effects-里\" class=\"headerlink\" title=\"把函数移到 Effects 里\"></a>把函数移到 Effects 里</h2><p>如果某些函数仅在effect中调用，你可以把它们的定义移到effect中：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SearchResults</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [query, setQuery] = useState(<span class=\"hljs-string\">&#x27;react&#x27;</span>);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getFetchUrl</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;\n    &#125;\n\n    <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fetchData</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">await</span> axios(getFetchUrl());\n      setData(result.data);\n    &#125;\n\n    fetchData();\n  &#125;, [query]); <span class=\"hljs-comment\">// ✅ Deps are OK</span>\n\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n\n<h2 id=\"当函数不能放在-Effects-里\"><a href=\"#当函数不能放在-Effects-里\" class=\"headerlink\" title=\"当函数不能放在 Effects 里\"></a>当函数不能放在 Effects 里</h2><p>有时函数不能放在 effects 里，如：</p>\n<ul>\n<li>组件内几个函数使用了相同的函数</li>\n<li>这个函数是一个 prop</li>\n</ul>\n<p>此时能忽略对函数的依赖么？最好不要，effects 对依赖不要撒谎。</p>\n<p>两种情况：</p>\n<ul>\n<li>1、函数内没有使用组件内的任何值，就提到组件外。</li>\n</ul>\n<pre><code class=\"hljs jsx\">/ ✅ Not affected by the data flow\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getFetchUrl</span>(<span class=\"hljs-params\">query</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SearchResults</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> url = getFetchUrl(<span class=\"hljs-string\">&#x27;react&#x27;</span>);\n    <span class=\"hljs-comment\">// ... Fetch data and do something ...</span>\n  &#125;, []); <span class=\"hljs-comment\">// ✅ Deps are OK</span>\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> url = getFetchUrl(<span class=\"hljs-string\">&#x27;redux&#x27;</span>);\n    <span class=\"hljs-comment\">// ... Fetch data and do something ...</span>\n  &#125;, []); <span class=\"hljs-comment\">// ✅ Deps are OK</span>\n\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n\n<ul>\n<li>2、放组件内，用 useCallback 包装, 将函数添加到依赖</li>\n</ul>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">SearchResults</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [query, setQuery] = useState(<span class=\"hljs-string\">&#x27;react&#x27;</span>);\n\n  <span class=\"hljs-comment\">// ✅ Preserves identity until query changes</span>\n  <span class=\"hljs-keyword\">const</span> getFetchUrl = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;\n  &#125;, [query]);  <span class=\"hljs-comment\">// ✅ Callback deps are OK</span>\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> url = getFetchUrl();\n    <span class=\"hljs-comment\">// ... Fetch data and do something ...</span>\n  &#125;, [getFetchUrl]); <span class=\"hljs-comment\">// ✅ Effect deps are OK</span>\n\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n\n<p>使用 useCallback，因为如果query 保持不变，getFetchUrl也会保持不变，我们的effect也不会重新运行。</p>\n<p>父组件传入函数的情况，也适用该方法：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Parent</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [query, setQuery] = useState(<span class=\"hljs-string\">&#x27;react&#x27;</span>);\n\n  <span class=\"hljs-comment\">// ✅ Preserves identity until query changes</span>\n  <span class=\"hljs-keyword\">const</span> fetchData = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> url = <span class=\"hljs-string\">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;\n    <span class=\"hljs-comment\">// ... Fetch data and return it ...</span>\n  &#125;, [query]);  <span class=\"hljs-comment\">// ✅ Callback deps are OK</span>\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Child</span> <span class=\"hljs-attr\">fetchData</span>=<span class=\"hljs-string\">&#123;fetchData&#125;</span> /&gt;</span></span>\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Child</span>(<span class=\"hljs-params\">&#123; fetchData &#125;</span>) </span>&#123;\n  <span class=\"hljs-keyword\">let</span> [data, setData] = useState(<span class=\"hljs-literal\">null</span>);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    fetchData().then(setData);\n  &#125;, [fetchData]); <span class=\"hljs-comment\">// ✅ Effect deps are OK</span>\n\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n\n<p>避免到处使用 useCallback。</p>\n<p>当我们需要将函数传递下去并且函数会在子组件的effect中被调用的时候，useCallback 是很好的技巧且非常有用。或者你想试图减少对子组件的记忆负担，也不妨一试。</p>\n<ul>\n<li>3、更好的方式可能是把他抽成自定义 Hook，把 fetchData 放在 effect 里。</li>\n</ul>\n<p>useEffect 只是底层 API，未来业务接触到的是更多封装后的上层 API，比如 useFetch 或者 useTheme，它们会更好用。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React, &#123; useState, useEffect, useReducer &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>\n\n<span class=\"hljs-keyword\">const</span> GITHUB_API = <span class=\"hljs-string\">&#x27;https://api.github.com/repos/chanshiyucx/blog/issues?page=10&amp;per_page=&#x27;</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> () =&gt; &#123;\n  <span class=\"hljs-keyword\">const</span> [list, setList] = useState([])\n  <span class=\"hljs-keyword\">const</span> [page, setPage] = useState(<span class=\"hljs-number\">1</span>)\n\n  <span class=\"hljs-keyword\">const</span> &#123; data, doFetch &#125; = useDataApi(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;GITHUB_API&#125;</span><span class=\"hljs-subst\">$&#123;page&#125;</span>`</span>, [])\n  <span class=\"hljs-comment\">// 翻页时重新获取列表</span>\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> doFetch(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;GITHUB_API&#125;</span><span class=\"hljs-subst\">$&#123;page&#125;</span>`</span>), [page])\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> setList(data), [data])\n\n  <span class=\"hljs-keyword\">const</span> handleNextPage = <span class=\"hljs-function\">() =&gt;</span> setPage(page + <span class=\"hljs-number\">1</span>)\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;handleNextPage&#125;</span>&gt;</span>NextPage<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span></span>\n<span class=\"xml\">        &#123;list.map(o =&gt; (</span>\n<span class=\"xml\">          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#123;o.id&#125;</span>&gt;</span>&#123;o.title&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span>\n<span class=\"xml\">        ))&#125;</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></span>\n<span class=\"xml\"></span>\n<span class=\"xml\">      &#123;isError &amp;&amp; <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Something went wrong ...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>&#125;</span>\n<span class=\"xml\">      &#123;isLoading &amp;&amp; <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Loading ...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>&#125;</span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  )\n&#125;</code></pre>\n\n<p>reducer:</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> dataFetchReducer = <span class=\"hljs-function\">(<span class=\"hljs-params\">state, action</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">switch</span> (action.type) &#123;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;FETCH_INIT&#x27;</span>:\n      <span class=\"hljs-keyword\">return</span> &#123;\n        ...state,\n        <span class=\"hljs-attr\">isLoading</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">isError</span>: <span class=\"hljs-literal\">false</span>\n      &#125;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;FETCH_SUCCESS&#x27;</span>:\n      <span class=\"hljs-keyword\">return</span> &#123;\n        ...state,\n        <span class=\"hljs-attr\">isLoading</span>: <span class=\"hljs-literal\">false</span>,\n        <span class=\"hljs-attr\">isError</span>: <span class=\"hljs-literal\">false</span>,\n        <span class=\"hljs-attr\">data</span>: action.payload\n      &#125;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;FETCH_FAILURE&#x27;</span>:\n      <span class=\"hljs-keyword\">return</span> &#123;\n        ...state,\n        <span class=\"hljs-attr\">isLoading</span>: <span class=\"hljs-literal\">false</span>,\n        <span class=\"hljs-attr\">isError</span>: <span class=\"hljs-literal\">true</span>\n      &#125;\n    <span class=\"hljs-attr\">default</span>:\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>()\n  &#125;\n&#125;</code></pre>\n\n<p>自定义 Hook：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> useDataApi = <span class=\"hljs-function\">(<span class=\"hljs-params\">initialUrl, initialData</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> [url, setUrl] = useState(initialUrl)\n\n  <span class=\"hljs-keyword\">const</span> [state, dispatch] = useReducer(dataFetchReducer, &#123;\n    <span class=\"hljs-attr\">isLoading</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">isError</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">data</span>: initialData\n  &#125;)\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">let</span> didCancel = <span class=\"hljs-literal\">false</span>\n\n    <span class=\"hljs-keyword\">const</span> fetchData = <span class=\"hljs-keyword\">async</span> () =&gt; &#123;\n      dispatch(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;FETCH_INIT&#x27;</span> &#125;)\n      <span class=\"hljs-keyword\">try</span> &#123;\n        <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> fetch(url)\n        <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> response.json()\n        <span class=\"hljs-keyword\">if</span> (!didCancel) &#123;\n          dispatch(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;FETCH_SUCCESS&#x27;</span>, <span class=\"hljs-attr\">payload</span>: data &#125;)\n        &#125;\n      &#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;\n        <span class=\"hljs-keyword\">if</span> (!didCancel) &#123;\n          dispatch(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;FETCH_FAILURE&#x27;</span> &#125;)\n        &#125;\n      &#125;\n    &#125;\n    fetchData()\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      didCancel = <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;, [url])\n\n  <span class=\"hljs-keyword\">const</span> doFetch = <span class=\"hljs-function\"><span class=\"hljs-params\">url</span> =&gt;</span> &#123;\n    setUrl(url)\n  &#125;\n\n  <span class=\"hljs-keyword\">return</span> &#123; ...state, doFetch &#125;\n&#125;</code></pre>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://overreacted.io/a-complete-guide-to-useeffect/\">a-complete-guide-to-useeffect</a></li>\n<li><a href=\"https://www.robinwieruch.de/react-hooks-fetch-data/\">https://www.robinwieruch.de/react-hooks-fetch-data/</a></li>\n</ul>\n"},{"title":"React Hooks 之 useCallback","index_img":"/img/2022-04-18-1.png","abbrlink":"b3515e96","date":"2022-04-18T02:44:18.000Z","_content":"\n## 类组件，父组件传方法给子组件\n\n父组件：\n\n```jsx\nclass Parent extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  handleChildren() {\n    console.log(\"clicked Children\");\n  }\n\n  handleParent() {\n    console.log(\"clicked Parent\");\n    this.setState((preCount) => ({ count: preCount + 1 }));\n  }\n\n  render() {\n    return (\n      <div>\n        <div\n          onClick={() => {\n            this.handleParent();\n          }}\n        >\n          Parent{\" \"}\n        </div>\n\n        <Children\n          handleChildren={() => {\n            this.handleChildren();\n          }}\n        />\n      </div>\n    );\n  }\n}\n```\n\n子组件：\n\n```jsx\nclass Children extends PureComponent {\n  render() {\n    const { handleChildren } = this.props;\n    console.log(\"render Children\");\n    return <div onClick={handleChildren}>Children </div>;\n  }\n}\n```\n\n每次点击 Parent，都会打印 `render Children`，子组件都会重新渲染，虽然子组件用了 PureComponent。\n\n因为父组件 setState 改变后，render() 会重新渲染，Children 组件的 handleChildren prop\n采用的是(内联函数)匿名函数赋值，导致每次的引用地址不一样,PureComponent 优化无效。\n\n正确是写法如下：\n\n```jsx\n...\n <Children handleChildren={this.handleChildren}/>\n...\n```\n\n## 函数组件，useCallback 使用场景\n\nuseCallback 在依赖不变的时候，返回的回调函数保持同一个引用地址。useCallback 的真正目的是在于缓存每次渲染时内联函数的实例。\n\n```jsx\nconst Parent = () => {\n  const [count, setCount] = useState(0);\n\n  const handleParent = () => {\n    console.log(\"clicked Parent\");\n    setCount((preCount) => preCount + 1);\n  };\n\n  const handleChildren = useCallback(() => {\n    console.log(\"clicked Children\");\n  }, []);\n\n  return (\n    <div>\n      <div onClick={handleParent}>Parent (count:{count}) </div>\n      <Children handleChildren={handleChildren} />\n    </div>\n  );\n};\n\nconst Children = memo(({ handleChildren }) => {\n  console.log(\"Children rending\");\n  return <div onClick={handleChildren}>Children </div>;\n});\n```\n\n需要注意的是:\n\n- 单纯的 useCallback 包裹，并不能提升性能，反而会下降，useCallback 需要配合子组件优化（memo）成对使用，缺一性能都不升反降。\n\n      ```jsx\n      <!-- \n      不管是否使用useCallback，都无法避免重新创建内部函数\n      使用 useCallback，还增加了 useCallback 内部对依赖项变化的检测\n       -->\n      function A() {\n        // ...\n        const cb = () => {}/* 创建了 */;\n\n      }\n\n      function B() {\n        // ...\n        const cb = useCallback(() => {}/*还是创建了*/, [a, b]);\n      }\n      ```\n\n## [如何从 useCallback 读取一个经常变化的值？](https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback)\n\n有时候一个函数依赖于一个经常变化的 state ，内部函数必须经常重新创建，那缓存方法的作用就没什么意义。\n\n```jsx\nfunction Form() {\n  const [text, updateText] = useState(\"\");\n\n  const handleSubmit = useCallback(() => {\n    console.log(text);\n  }, [text]); // 每次 text 变化时 handleSubmit 都会变\n\n  return (\n    <>\n      <input value={text} onChange={(e) => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n\nfunction ExpensiveTree(props) {\n  return <div onClick={props.onSubmit}>Submit</div>;\n}\n```\n\n如果你想要记住的函数是一个事件处理器并且在渲染期间没有被用到，可以把 ref 当做实例变量来用，并手动把最后提交的值保存在它当中：\n\n```jsx\nfunction Form() {\n  const [text, updateText] = useState(\"\");\n  const textRef = useRef();\n\n  useEffect(() => {\n    textRef.current = text; // 把它写入 ref\n  });\n\n  const handleSubmit = useCallback(() => {\n    const currentText = textRef.current; // 从 ref 读取它\n    alert(currentText);\n  }, [textRef]); // 不要像 [text] 那样重新创建 handleSubmit\n\n  return (\n    <>\n      <input value={text} onChange={(e) => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n\nfunction ExpensiveTree(props) {\n  return <div onClick={props.onSubmit}>Submit</div>;\n}\n```\n\n上述方式可以用来达到优化的目的，但是更佳的方式是抽成自定义 Hook:\n\n```jsx\nfunction Form() {\n  const [text, updateText] = useState('');\n  // 即便 `text` 变了也会被记住:\n  const handleSubmit = useEventCallback(() => {\n    alert(text);\n  }, [text]);\n\n  return (\n    <>\n      <input value={text} onChange={e => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n\n// useEventCallback 使用了 ref 不变的特性，保证回调函数的引用永远不变。\n// 使用 useRef 来保存函数，避免 useCallback 所包裹的函数反复变化.\nfunction useEventCallback(fn, dependencies) {\n  const ref = useRef(() => {\n    throw new Error('Cannot call an event handler while rendering.');\n  });\n\n  // 根据依赖去更新 ref ，保证最终调用的函数是最新的\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn, ...dependencies]);\n\n  return useCallback(() => {\n    const fn = ref.current;\n    return fn();\n  }, [ref]);\n}\n```\n\n## 另一种方式，就是官方推荐在 context 中向下传递 dispatch 而非在 props 中使用独立的回调\n\nuseReducer返回的dispatch永远是不变的\n\n```jsx\nconst TodosDispatch = React.createContext(null);\n\nfunction TodosApp() {\n  // 提示：`dispatch` 不会在重新渲染之间变化\n  const [todos, dispatch] = useReducer(todosReducer);\n\n  return (\n    <TodosDispatch.Provider value={dispatch}>\n      <DeepTree todos={todos} />\n    </TodosDispatch.Provider>\n  );\n}\n```\n\n- [如何避免向下传递回调？](https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down)\n\n## Extra\n\nuseCallback(fn, deps) 写法可以理解为 useMemo(() => fn, deps)\n","source":"_posts/12.React Hooks 之 useCallback.md","raw":"---\ntitle: React Hooks 之 useCallback\nindex_img: /img/2022-04-18-1.png\nabbrlink: b3515e96\ndate: 2022-04-18 10:44:18\ntags: useCallback\ncategories:\n- [React Hook]\n- [React]\n---\n\n## 类组件，父组件传方法给子组件\n\n父组件：\n\n```jsx\nclass Parent extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  handleChildren() {\n    console.log(\"clicked Children\");\n  }\n\n  handleParent() {\n    console.log(\"clicked Parent\");\n    this.setState((preCount) => ({ count: preCount + 1 }));\n  }\n\n  render() {\n    return (\n      <div>\n        <div\n          onClick={() => {\n            this.handleParent();\n          }}\n        >\n          Parent{\" \"}\n        </div>\n\n        <Children\n          handleChildren={() => {\n            this.handleChildren();\n          }}\n        />\n      </div>\n    );\n  }\n}\n```\n\n子组件：\n\n```jsx\nclass Children extends PureComponent {\n  render() {\n    const { handleChildren } = this.props;\n    console.log(\"render Children\");\n    return <div onClick={handleChildren}>Children </div>;\n  }\n}\n```\n\n每次点击 Parent，都会打印 `render Children`，子组件都会重新渲染，虽然子组件用了 PureComponent。\n\n因为父组件 setState 改变后，render() 会重新渲染，Children 组件的 handleChildren prop\n采用的是(内联函数)匿名函数赋值，导致每次的引用地址不一样,PureComponent 优化无效。\n\n正确是写法如下：\n\n```jsx\n...\n <Children handleChildren={this.handleChildren}/>\n...\n```\n\n## 函数组件，useCallback 使用场景\n\nuseCallback 在依赖不变的时候，返回的回调函数保持同一个引用地址。useCallback 的真正目的是在于缓存每次渲染时内联函数的实例。\n\n```jsx\nconst Parent = () => {\n  const [count, setCount] = useState(0);\n\n  const handleParent = () => {\n    console.log(\"clicked Parent\");\n    setCount((preCount) => preCount + 1);\n  };\n\n  const handleChildren = useCallback(() => {\n    console.log(\"clicked Children\");\n  }, []);\n\n  return (\n    <div>\n      <div onClick={handleParent}>Parent (count:{count}) </div>\n      <Children handleChildren={handleChildren} />\n    </div>\n  );\n};\n\nconst Children = memo(({ handleChildren }) => {\n  console.log(\"Children rending\");\n  return <div onClick={handleChildren}>Children </div>;\n});\n```\n\n需要注意的是:\n\n- 单纯的 useCallback 包裹，并不能提升性能，反而会下降，useCallback 需要配合子组件优化（memo）成对使用，缺一性能都不升反降。\n\n      ```jsx\n      <!-- \n      不管是否使用useCallback，都无法避免重新创建内部函数\n      使用 useCallback，还增加了 useCallback 内部对依赖项变化的检测\n       -->\n      function A() {\n        // ...\n        const cb = () => {}/* 创建了 */;\n\n      }\n\n      function B() {\n        // ...\n        const cb = useCallback(() => {}/*还是创建了*/, [a, b]);\n      }\n      ```\n\n## [如何从 useCallback 读取一个经常变化的值？](https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback)\n\n有时候一个函数依赖于一个经常变化的 state ，内部函数必须经常重新创建，那缓存方法的作用就没什么意义。\n\n```jsx\nfunction Form() {\n  const [text, updateText] = useState(\"\");\n\n  const handleSubmit = useCallback(() => {\n    console.log(text);\n  }, [text]); // 每次 text 变化时 handleSubmit 都会变\n\n  return (\n    <>\n      <input value={text} onChange={(e) => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n\nfunction ExpensiveTree(props) {\n  return <div onClick={props.onSubmit}>Submit</div>;\n}\n```\n\n如果你想要记住的函数是一个事件处理器并且在渲染期间没有被用到，可以把 ref 当做实例变量来用，并手动把最后提交的值保存在它当中：\n\n```jsx\nfunction Form() {\n  const [text, updateText] = useState(\"\");\n  const textRef = useRef();\n\n  useEffect(() => {\n    textRef.current = text; // 把它写入 ref\n  });\n\n  const handleSubmit = useCallback(() => {\n    const currentText = textRef.current; // 从 ref 读取它\n    alert(currentText);\n  }, [textRef]); // 不要像 [text] 那样重新创建 handleSubmit\n\n  return (\n    <>\n      <input value={text} onChange={(e) => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n\nfunction ExpensiveTree(props) {\n  return <div onClick={props.onSubmit}>Submit</div>;\n}\n```\n\n上述方式可以用来达到优化的目的，但是更佳的方式是抽成自定义 Hook:\n\n```jsx\nfunction Form() {\n  const [text, updateText] = useState('');\n  // 即便 `text` 变了也会被记住:\n  const handleSubmit = useEventCallback(() => {\n    alert(text);\n  }, [text]);\n\n  return (\n    <>\n      <input value={text} onChange={e => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n\n// useEventCallback 使用了 ref 不变的特性，保证回调函数的引用永远不变。\n// 使用 useRef 来保存函数，避免 useCallback 所包裹的函数反复变化.\nfunction useEventCallback(fn, dependencies) {\n  const ref = useRef(() => {\n    throw new Error('Cannot call an event handler while rendering.');\n  });\n\n  // 根据依赖去更新 ref ，保证最终调用的函数是最新的\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn, ...dependencies]);\n\n  return useCallback(() => {\n    const fn = ref.current;\n    return fn();\n  }, [ref]);\n}\n```\n\n## 另一种方式，就是官方推荐在 context 中向下传递 dispatch 而非在 props 中使用独立的回调\n\nuseReducer返回的dispatch永远是不变的\n\n```jsx\nconst TodosDispatch = React.createContext(null);\n\nfunction TodosApp() {\n  // 提示：`dispatch` 不会在重新渲染之间变化\n  const [todos, dispatch] = useReducer(todosReducer);\n\n  return (\n    <TodosDispatch.Provider value={dispatch}>\n      <DeepTree todos={todos} />\n    </TodosDispatch.Provider>\n  );\n}\n```\n\n- [如何避免向下传递回调？](https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down)\n\n## Extra\n\nuseCallback(fn, deps) 写法可以理解为 useMemo(() => fn, deps)\n","slug":"12-React-Hooks-之-useCallback","published":1,"updated":"2022-08-23T02:19:23.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn3o000pyu3lfo2w0kgl","content":"<h2 id=\"类组件，父组件传方法给子组件\"><a href=\"#类组件，父组件传方法给子组件\" class=\"headerlink\" title=\"类组件，父组件传方法给子组件\"></a>类组件，父组件传方法给子组件</h2><p>父组件：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Parent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;\n    <span class=\"hljs-built_in\">super</span>(props);\n    <span class=\"hljs-built_in\">this</span>.state = &#123;\n      <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span>\n    &#125;;\n  &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">handleChildren</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;clicked Children&quot;</span>);\n  &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">handleParent</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;clicked Parent&quot;</span>);\n    <span class=\"hljs-built_in\">this</span>.setState(<span class=\"hljs-function\">(<span class=\"hljs-params\">preCount</span>) =&gt;</span> (&#123; <span class=\"hljs-attr\">count</span>: preCount + <span class=\"hljs-number\">1</span> &#125;));\n  &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span></span></span>\n<span class=\"hljs-tag\"><span class=\"xml\">          <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span>\n<span class=\"xml\">            this.handleParent();</span>\n<span class=\"xml\">          &#125;&#125;</span>\n<span class=\"xml\">        &gt;</span>\n<span class=\"xml\">          Parent&#123;&quot; &quot;&#125;</span>\n<span class=\"xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\"></span>\n<span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Children</span></span></span>\n<span class=\"hljs-tag\"><span class=\"xml\">          <span class=\"hljs-attr\">handleChildren</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span>\n<span class=\"xml\">            this.handleChildren();</span>\n<span class=\"xml\">          &#125;&#125;</span>\n<span class=\"xml\">        /&gt;</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n    );\n  &#125;\n&#125;</code></pre></div>\n\n<p>子组件：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Children</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">PureComponent</span> </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">const</span> &#123; handleChildren &#125; = <span class=\"hljs-built_in\">this</span>.props;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;render Children&quot;</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;handleChildren&#125;</span>&gt;</span>Children <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n  &#125;\n&#125;</code></pre></div>\n\n<p>每次点击 Parent，都会打印 <code>render Children</code>，子组件都会重新渲染，虽然子组件用了 PureComponent。</p>\n<p>因为父组件 setState 改变后，render() 会重新渲染，Children 组件的 handleChildren prop<br>采用的是(内联函数)匿名函数赋值，导致每次的引用地址不一样,PureComponent 优化无效。</p>\n<p>正确是写法如下：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\">...\n &lt;Children handleChildren=&#123;<span class=\"hljs-built_in\">this</span>.handleChildren&#125;/&gt;\n...</code></pre></div>\n\n<h2 id=\"函数组件，useCallback-使用场景\"><a href=\"#函数组件，useCallback-使用场景\" class=\"headerlink\" title=\"函数组件，useCallback 使用场景\"></a>函数组件，useCallback 使用场景</h2><p>useCallback 在依赖不变的时候，返回的回调函数保持同一个引用地址。useCallback 的真正目的是在于缓存每次渲染时内联函数的实例。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Parent = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">const</span> handleParent = <span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;clicked Parent&quot;</span>);\n    setCount(<span class=\"hljs-function\">(<span class=\"hljs-params\">preCount</span>) =&gt;</span> preCount + <span class=\"hljs-number\">1</span>);\n  &#125;;\n\n  <span class=\"hljs-keyword\">const</span> handleChildren = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;clicked Children&quot;</span>);\n  &#125;, []);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;handleParent&#125;</span>&gt;</span>Parent (count:&#123;count&#125;) <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Children</span> <span class=\"hljs-attr\">handleChildren</span>=<span class=\"hljs-string\">&#123;handleChildren&#125;</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;;\n\n<span class=\"hljs-keyword\">const</span> Children = memo(<span class=\"hljs-function\">(<span class=\"hljs-params\">&#123; handleChildren &#125;</span>) =&gt;</span> &#123;\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;Children rending&quot;</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;handleChildren&#125;</span>&gt;</span>Children <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n&#125;);</code></pre></div>\n\n<p>需要注意的是:</p>\n<ul>\n<li><p>单纯的 useCallback 包裹，并不能提升性能，反而会下降，useCallback 需要配合子组件优化（memo）成对使用，缺一性能都不升反降。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs\"><pre><code class=\"hljs jsx\">&lt;!-- \n不管是否使用useCallback，都无法避免重新创建内部函数\n使用 useCallback，还增加了 useCallback 内部对依赖项变化的检测\n --&gt;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">A</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-keyword\">const</span> cb = <span class=\"hljs-function\">() =&gt;</span> &#123;&#125;<span class=\"hljs-comment\">/* 创建了 */</span>;\n\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">B</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-keyword\">const</span> cb = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;&#125;<span class=\"hljs-comment\">/*还是创建了*/</span>, [a, b]);\n&#125;</code></pre></div>\n</code></pre>\n</li>\n</ul>\n<h2 id=\"如何从-useCallback-读取一个经常变化的值？\"><a href=\"#如何从-useCallback-读取一个经常变化的值？\" class=\"headerlink\" title=\"如何从 useCallback 读取一个经常变化的值？\"></a><a href=\"https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback\">如何从 useCallback 读取一个经常变化的值？</a></h2><p>有时候一个函数依赖于一个经常变化的 state ，内部函数必须经常重新创建，那缓存方法的作用就没什么意义。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Form</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [text, updateText] = useState(<span class=\"hljs-string\">&quot;&quot;</span>);\n\n  <span class=\"hljs-keyword\">const</span> handleSubmit = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(text);\n  &#125;, [text]); <span class=\"hljs-comment\">// 每次 text 变化时 handleSubmit 都会变</span>\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;text&#125;</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">&#123;(e)</span> =&gt;</span> updateText(e.target.value)&#125; /&gt;</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ExpensiveTree</span> <span class=\"hljs-attr\">onSubmit</span>=<span class=\"hljs-string\">&#123;handleSubmit&#125;</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ExpensiveTree</span>(<span class=\"hljs-params\">props</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;props.onSubmit&#125;</span>&gt;</span>Submit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n&#125;</code></pre></div>\n\n<p>如果你想要记住的函数是一个事件处理器并且在渲染期间没有被用到，可以把 ref 当做实例变量来用，并手动把最后提交的值保存在它当中：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Form</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [text, updateText] = useState(<span class=\"hljs-string\">&quot;&quot;</span>);\n  <span class=\"hljs-keyword\">const</span> textRef = useRef();\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    textRef.current = text; <span class=\"hljs-comment\">// 把它写入 ref</span>\n  &#125;);\n\n  <span class=\"hljs-keyword\">const</span> handleSubmit = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> currentText = textRef.current; <span class=\"hljs-comment\">// 从 ref 读取它</span>\n    alert(currentText);\n  &#125;, [textRef]); <span class=\"hljs-comment\">// 不要像 [text] 那样重新创建 handleSubmit</span>\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;text&#125;</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">&#123;(e)</span> =&gt;</span> updateText(e.target.value)&#125; /&gt;</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ExpensiveTree</span> <span class=\"hljs-attr\">onSubmit</span>=<span class=\"hljs-string\">&#123;handleSubmit&#125;</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ExpensiveTree</span>(<span class=\"hljs-params\">props</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;props.onSubmit&#125;</span>&gt;</span>Submit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n&#125;</code></pre></div>\n\n<p>上述方式可以用来达到优化的目的，但是更佳的方式是抽成自定义 Hook:</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Form</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [text, updateText] = useState(<span class=\"hljs-string\">&#x27;&#x27;</span>);\n  <span class=\"hljs-comment\">// 即便 `text` 变了也会被记住:</span>\n  <span class=\"hljs-keyword\">const</span> handleSubmit = useEventCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    alert(text);\n  &#125;, [text]);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;text&#125;</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">&#123;e</span> =&gt;</span> updateText(e.target.value)&#125; /&gt;</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ExpensiveTree</span> <span class=\"hljs-attr\">onSubmit</span>=<span class=\"hljs-string\">&#123;handleSubmit&#125;</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n&#125;\n\n<span class=\"hljs-comment\">// useEventCallback 使用了 ref 不变的特性，保证回调函数的引用永远不变。</span>\n<span class=\"hljs-comment\">// 使用 useRef 来保存函数，避免 useCallback 所包裹的函数反复变化.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useEventCallback</span>(<span class=\"hljs-params\">fn, dependencies</span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> ref = useRef(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;Cannot call an event handler while rendering.&#x27;</span>);\n  &#125;);\n\n  <span class=\"hljs-comment\">// 根据依赖去更新 ref ，保证最终调用的函数是最新的</span>\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    ref.current = fn;\n  &#125;, [fn, ...dependencies]);\n\n  <span class=\"hljs-keyword\">return</span> useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> fn = ref.current;\n    <span class=\"hljs-keyword\">return</span> fn();\n  &#125;, [ref]);\n&#125;</code></pre></div>\n\n<h2 id=\"另一种方式，就是官方推荐在-context-中向下传递-dispatch-而非在-props-中使用独立的回调\"><a href=\"#另一种方式，就是官方推荐在-context-中向下传递-dispatch-而非在-props-中使用独立的回调\" class=\"headerlink\" title=\"另一种方式，就是官方推荐在 context 中向下传递 dispatch 而非在 props 中使用独立的回调\"></a>另一种方式，就是官方推荐在 context 中向下传递 dispatch 而非在 props 中使用独立的回调</h2><p>useReducer返回的dispatch永远是不变的</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> TodosDispatch = React.createContext(<span class=\"hljs-literal\">null</span>);\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">TodosApp</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// 提示：`dispatch` 不会在重新渲染之间变化</span>\n  <span class=\"hljs-keyword\">const</span> [todos, dispatch] = useReducer(todosReducer);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TodosDispatch.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;dispatch&#125;</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">DeepTree</span> <span class=\"hljs-attr\">todos</span>=<span class=\"hljs-string\">&#123;todos&#125;</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">TodosDispatch.Provider</span>&gt;</span></span>\n  );\n&#125;</code></pre></div>\n\n<ul>\n<li><a href=\"https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down\">如何避免向下传递回调？</a></li>\n</ul>\n<h2 id=\"Extra\"><a href=\"#Extra\" class=\"headerlink\" title=\"Extra\"></a>Extra</h2><p>useCallback(fn, deps) 写法可以理解为 useMemo(() =&gt; fn, deps)</p>\n","site":{"data":{}},"wordcount":4465,"excerpt":"","more":"<h2 id=\"类组件，父组件传方法给子组件\"><a href=\"#类组件，父组件传方法给子组件\" class=\"headerlink\" title=\"类组件，父组件传方法给子组件\"></a>类组件，父组件传方法给子组件</h2><p>父组件：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Parent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;\n    <span class=\"hljs-built_in\">super</span>(props);\n    <span class=\"hljs-built_in\">this</span>.state = &#123;\n      <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span>\n    &#125;;\n  &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">handleChildren</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;clicked Children&quot;</span>);\n  &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">handleParent</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;clicked Parent&quot;</span>);\n    <span class=\"hljs-built_in\">this</span>.setState(<span class=\"hljs-function\">(<span class=\"hljs-params\">preCount</span>) =&gt;</span> (&#123; <span class=\"hljs-attr\">count</span>: preCount + <span class=\"hljs-number\">1</span> &#125;));\n  &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span></span></span>\n<span class=\"hljs-tag\"><span class=\"xml\">          <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span>\n<span class=\"xml\">            this.handleParent();</span>\n<span class=\"xml\">          &#125;&#125;</span>\n<span class=\"xml\">        &gt;</span>\n<span class=\"xml\">          Parent&#123;&quot; &quot;&#125;</span>\n<span class=\"xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\"></span>\n<span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Children</span></span></span>\n<span class=\"hljs-tag\"><span class=\"xml\">          <span class=\"hljs-attr\">handleChildren</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span>\n<span class=\"xml\">            this.handleChildren();</span>\n<span class=\"xml\">          &#125;&#125;</span>\n<span class=\"xml\">        /&gt;</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n    );\n  &#125;\n&#125;</code></pre>\n\n<p>子组件：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Children</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">PureComponent</span> </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">const</span> &#123; handleChildren &#125; = <span class=\"hljs-built_in\">this</span>.props;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;render Children&quot;</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;handleChildren&#125;</span>&gt;</span>Children <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n  &#125;\n&#125;</code></pre>\n\n<p>每次点击 Parent，都会打印 <code>render Children</code>，子组件都会重新渲染，虽然子组件用了 PureComponent。</p>\n<p>因为父组件 setState 改变后，render() 会重新渲染，Children 组件的 handleChildren prop<br>采用的是(内联函数)匿名函数赋值，导致每次的引用地址不一样,PureComponent 优化无效。</p>\n<p>正确是写法如下：</p>\n<pre><code class=\"hljs jsx\">...\n &lt;Children handleChildren=&#123;<span class=\"hljs-built_in\">this</span>.handleChildren&#125;/&gt;\n...</code></pre>\n\n<h2 id=\"函数组件，useCallback-使用场景\"><a href=\"#函数组件，useCallback-使用场景\" class=\"headerlink\" title=\"函数组件，useCallback 使用场景\"></a>函数组件，useCallback 使用场景</h2><p>useCallback 在依赖不变的时候，返回的回调函数保持同一个引用地址。useCallback 的真正目的是在于缓存每次渲染时内联函数的实例。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Parent = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">const</span> handleParent = <span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;clicked Parent&quot;</span>);\n    setCount(<span class=\"hljs-function\">(<span class=\"hljs-params\">preCount</span>) =&gt;</span> preCount + <span class=\"hljs-number\">1</span>);\n  &#125;;\n\n  <span class=\"hljs-keyword\">const</span> handleChildren = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;clicked Children&quot;</span>);\n  &#125;, []);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;handleParent&#125;</span>&gt;</span>Parent (count:&#123;count&#125;) <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Children</span> <span class=\"hljs-attr\">handleChildren</span>=<span class=\"hljs-string\">&#123;handleChildren&#125;</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;;\n\n<span class=\"hljs-keyword\">const</span> Children = memo(<span class=\"hljs-function\">(<span class=\"hljs-params\">&#123; handleChildren &#125;</span>) =&gt;</span> &#123;\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;Children rending&quot;</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;handleChildren&#125;</span>&gt;</span>Children <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n&#125;);</code></pre>\n\n<p>需要注意的是:</p>\n<ul>\n<li><p>单纯的 useCallback 包裹，并不能提升性能，反而会下降，useCallback 需要配合子组件优化（memo）成对使用，缺一性能都不升反降。</p>\n<pre><code><pre><code class=\"hljs jsx\">&lt;!-- \n不管是否使用useCallback，都无法避免重新创建内部函数\n使用 useCallback，还增加了 useCallback 内部对依赖项变化的检测\n --&gt;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">A</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-keyword\">const</span> cb = <span class=\"hljs-function\">() =&gt;</span> &#123;&#125;<span class=\"hljs-comment\">/* 创建了 */</span>;\n\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">B</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-keyword\">const</span> cb = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;&#125;<span class=\"hljs-comment\">/*还是创建了*/</span>, [a, b]);\n&#125;</code></pre>\n</code></pre>\n</li>\n</ul>\n<h2 id=\"如何从-useCallback-读取一个经常变化的值？\"><a href=\"#如何从-useCallback-读取一个经常变化的值？\" class=\"headerlink\" title=\"如何从 useCallback 读取一个经常变化的值？\"></a><a href=\"https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback\">如何从 useCallback 读取一个经常变化的值？</a></h2><p>有时候一个函数依赖于一个经常变化的 state ，内部函数必须经常重新创建，那缓存方法的作用就没什么意义。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Form</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [text, updateText] = useState(<span class=\"hljs-string\">&quot;&quot;</span>);\n\n  <span class=\"hljs-keyword\">const</span> handleSubmit = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(text);\n  &#125;, [text]); <span class=\"hljs-comment\">// 每次 text 变化时 handleSubmit 都会变</span>\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;text&#125;</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">&#123;(e)</span> =&gt;</span> updateText(e.target.value)&#125; /&gt;</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ExpensiveTree</span> <span class=\"hljs-attr\">onSubmit</span>=<span class=\"hljs-string\">&#123;handleSubmit&#125;</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ExpensiveTree</span>(<span class=\"hljs-params\">props</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;props.onSubmit&#125;</span>&gt;</span>Submit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n&#125;</code></pre>\n\n<p>如果你想要记住的函数是一个事件处理器并且在渲染期间没有被用到，可以把 ref 当做实例变量来用，并手动把最后提交的值保存在它当中：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Form</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [text, updateText] = useState(<span class=\"hljs-string\">&quot;&quot;</span>);\n  <span class=\"hljs-keyword\">const</span> textRef = useRef();\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    textRef.current = text; <span class=\"hljs-comment\">// 把它写入 ref</span>\n  &#125;);\n\n  <span class=\"hljs-keyword\">const</span> handleSubmit = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> currentText = textRef.current; <span class=\"hljs-comment\">// 从 ref 读取它</span>\n    alert(currentText);\n  &#125;, [textRef]); <span class=\"hljs-comment\">// 不要像 [text] 那样重新创建 handleSubmit</span>\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;text&#125;</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">&#123;(e)</span> =&gt;</span> updateText(e.target.value)&#125; /&gt;</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ExpensiveTree</span> <span class=\"hljs-attr\">onSubmit</span>=<span class=\"hljs-string\">&#123;handleSubmit&#125;</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ExpensiveTree</span>(<span class=\"hljs-params\">props</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;props.onSubmit&#125;</span>&gt;</span>Submit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n&#125;</code></pre>\n\n<p>上述方式可以用来达到优化的目的，但是更佳的方式是抽成自定义 Hook:</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Form</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [text, updateText] = useState(<span class=\"hljs-string\">&#x27;&#x27;</span>);\n  <span class=\"hljs-comment\">// 即便 `text` 变了也会被记住:</span>\n  <span class=\"hljs-keyword\">const</span> handleSubmit = useEventCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    alert(text);\n  &#125;, [text]);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;text&#125;</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">&#123;e</span> =&gt;</span> updateText(e.target.value)&#125; /&gt;</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ExpensiveTree</span> <span class=\"hljs-attr\">onSubmit</span>=<span class=\"hljs-string\">&#123;handleSubmit&#125;</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n&#125;\n\n<span class=\"hljs-comment\">// useEventCallback 使用了 ref 不变的特性，保证回调函数的引用永远不变。</span>\n<span class=\"hljs-comment\">// 使用 useRef 来保存函数，避免 useCallback 所包裹的函数反复变化.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useEventCallback</span>(<span class=\"hljs-params\">fn, dependencies</span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> ref = useRef(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;Cannot call an event handler while rendering.&#x27;</span>);\n  &#125;);\n\n  <span class=\"hljs-comment\">// 根据依赖去更新 ref ，保证最终调用的函数是最新的</span>\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    ref.current = fn;\n  &#125;, [fn, ...dependencies]);\n\n  <span class=\"hljs-keyword\">return</span> useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> fn = ref.current;\n    <span class=\"hljs-keyword\">return</span> fn();\n  &#125;, [ref]);\n&#125;</code></pre>\n\n<h2 id=\"另一种方式，就是官方推荐在-context-中向下传递-dispatch-而非在-props-中使用独立的回调\"><a href=\"#另一种方式，就是官方推荐在-context-中向下传递-dispatch-而非在-props-中使用独立的回调\" class=\"headerlink\" title=\"另一种方式，就是官方推荐在 context 中向下传递 dispatch 而非在 props 中使用独立的回调\"></a>另一种方式，就是官方推荐在 context 中向下传递 dispatch 而非在 props 中使用独立的回调</h2><p>useReducer返回的dispatch永远是不变的</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> TodosDispatch = React.createContext(<span class=\"hljs-literal\">null</span>);\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">TodosApp</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// 提示：`dispatch` 不会在重新渲染之间变化</span>\n  <span class=\"hljs-keyword\">const</span> [todos, dispatch] = useReducer(todosReducer);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TodosDispatch.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;dispatch&#125;</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">DeepTree</span> <span class=\"hljs-attr\">todos</span>=<span class=\"hljs-string\">&#123;todos&#125;</span> /&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">TodosDispatch.Provider</span>&gt;</span></span>\n  );\n&#125;</code></pre>\n\n<ul>\n<li><a href=\"https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down\">如何避免向下传递回调？</a></li>\n</ul>\n<h2 id=\"Extra\"><a href=\"#Extra\" class=\"headerlink\" title=\"Extra\"></a>Extra</h2><p>useCallback(fn, deps) 写法可以理解为 useMemo(() =&gt; fn, deps)</p>\n"},{"title":"Antd 源码分析之 useMergedState.md","index_img":"/img/2022-04-29-2.png","abbrlink":"e6886795","date":"2022-04-28T15:55:06.000Z","_content":"\n用法与 useState 类似，区别是 如果 props 提供 value 值，将会用 value 值来初始化 state 状态。\n\n## 用法\n\n```ts\nconst [innerChecked, setInnerChecked] = useMergedState<boolean>(false, {\n      value: checked,\n      defaultValue: defaultChecked,\n    });\n```\n\n## 源码分析\n\n```ts\nimport * as React, { useState } from 'react';\n\n/**\n* Similar to `useState` but will use props value if provided.\n */\nexport default function useMergedState<T, R = T>(\n  defaultStateValue: T | (() => T),\n  option?: {\n    defaultValue?: T | (() => T);\n    value?: T;\n    onChange?: (value: T, prevValue: T) => void;\n    postState?: (value: T) => T;\n  },\n): [R, (value: T, ignoreDestroy?: boolean) => void] {\n  const { defaultValue, value, onChange, postState } = option || {};\n  // 声明内部 value 值\n  const [innerValue, setInnerValue] = useState<T>(() => {\n    // value 存在，用 value 初始化 innerValue 的值\n    if (value !== undefined) {\n      return value;\n    }\n    // 同上\n    if (defaultValue !== undefined) {\n      return typeof defaultValue === 'function'\n        ? (defaultValue as any)()\n        : defaultValue;\n    }\n    // defaultStateValue 优先级最低\n    return typeof defaultStateValue === 'function'\n      ? (defaultStateValue as any)()\n      : defaultStateValue;\n  });\n\n  let mergedValue = value !== undefined ? value : innerValue;\n  if (postState) {\n    // 数据处理\n    mergedValue = postState(mergedValue);\n  }\n\n  // 封装内部的 setState\n  const onChangeRef = React.useRef(onChange);\n  onChangeRef.current = onChange;\n\n  const triggerChange = React.useCallback(\n    (newValue: T, ignoreDestroy?: boolean) => {\n      setInnerValue(newValue, ignoreDestroy);\n      if (mergedValue !== newValue && onChangeRef.current) {\n        onChangeRef.current(newValue, mergedValue);\n      }\n    },\n    [mergedValue, onChangeRef],\n  );\n\n  // Effect of reset value to `undefined`\n  const prevValueRef = React.useRef(value);\n  React.useEffect(() => {\n    if (value === undefined && value !== prevValueRef.current) {\n      setInnerValue(value);\n    }\n\n    prevValueRef.current = value;\n  }, [value]);\n\n  return [mergedValue as unknown as R, triggerChange];\n}\n```\n","source":"_posts/13.Antd 源码分析之 useMergedState.md","raw":"---\ntitle: Antd 源码分析之 useMergedState.md\nindex_img: /img/2022-04-29-2.png\nabbrlink: e6886795\ndate: 2022-04-28 23:55:06\ntags: Hook\ncategories: React\n---\n\n用法与 useState 类似，区别是 如果 props 提供 value 值，将会用 value 值来初始化 state 状态。\n\n## 用法\n\n```ts\nconst [innerChecked, setInnerChecked] = useMergedState<boolean>(false, {\n      value: checked,\n      defaultValue: defaultChecked,\n    });\n```\n\n## 源码分析\n\n```ts\nimport * as React, { useState } from 'react';\n\n/**\n* Similar to `useState` but will use props value if provided.\n */\nexport default function useMergedState<T, R = T>(\n  defaultStateValue: T | (() => T),\n  option?: {\n    defaultValue?: T | (() => T);\n    value?: T;\n    onChange?: (value: T, prevValue: T) => void;\n    postState?: (value: T) => T;\n  },\n): [R, (value: T, ignoreDestroy?: boolean) => void] {\n  const { defaultValue, value, onChange, postState } = option || {};\n  // 声明内部 value 值\n  const [innerValue, setInnerValue] = useState<T>(() => {\n    // value 存在，用 value 初始化 innerValue 的值\n    if (value !== undefined) {\n      return value;\n    }\n    // 同上\n    if (defaultValue !== undefined) {\n      return typeof defaultValue === 'function'\n        ? (defaultValue as any)()\n        : defaultValue;\n    }\n    // defaultStateValue 优先级最低\n    return typeof defaultStateValue === 'function'\n      ? (defaultStateValue as any)()\n      : defaultStateValue;\n  });\n\n  let mergedValue = value !== undefined ? value : innerValue;\n  if (postState) {\n    // 数据处理\n    mergedValue = postState(mergedValue);\n  }\n\n  // 封装内部的 setState\n  const onChangeRef = React.useRef(onChange);\n  onChangeRef.current = onChange;\n\n  const triggerChange = React.useCallback(\n    (newValue: T, ignoreDestroy?: boolean) => {\n      setInnerValue(newValue, ignoreDestroy);\n      if (mergedValue !== newValue && onChangeRef.current) {\n        onChangeRef.current(newValue, mergedValue);\n      }\n    },\n    [mergedValue, onChangeRef],\n  );\n\n  // Effect of reset value to `undefined`\n  const prevValueRef = React.useRef(value);\n  React.useEffect(() => {\n    if (value === undefined && value !== prevValueRef.current) {\n      setInnerValue(value);\n    }\n\n    prevValueRef.current = value;\n  }, [value]);\n\n  return [mergedValue as unknown as R, triggerChange];\n}\n```\n","slug":"13-Antd-源码分析之-useMergedState","published":1,"updated":"2022-08-23T02:19:23.472Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn3u000syu3l7k1a10v1","content":"<p>用法与 useState 类似，区别是 如果 props 提供 value 值，将会用 value 值来初始化 state 状态。</p>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> [innerChecked, setInnerChecked] = useMergedState&lt;<span class=\"hljs-built_in\">boolean</span>&gt;(<span class=\"hljs-literal\">false</span>, &#123;\n      <span class=\"hljs-attr\">value</span>: checked,\n      <span class=\"hljs-attr\">defaultValue</span>: defaultChecked,\n    &#125;);</code></pre></div>\n\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> React, &#123; useState &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n\n<span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">* Similar to `useState` but will use props value if provided.</span>\n<span class=\"hljs-comment\"> */</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useMergedState</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">R</span> = <span class=\"hljs-title\">T</span>&gt;(<span class=\"hljs-params\"></span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">  defaultStateValue: T | (() =&gt; T),</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">  option?: &#123;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    defaultValue?: T | (() =&gt; T);</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    value?: T;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    onChange?: (value: T, prevValue: T) =&gt; <span class=\"hljs-built_in\">void</span>;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    postState?: (value: T) =&gt; T;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">  &#125;,</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\"></span>): [<span class=\"hljs-title\">R</span>, (<span class=\"hljs-params\">value: T, ignoreDestroy?: <span class=\"hljs-built_in\">boolean</span></span>) =&gt; <span class=\"hljs-title\">void</span>] </span>&#123;\n  <span class=\"hljs-keyword\">const</span> &#123; defaultValue, value, onChange, postState &#125; = option || &#123;&#125;;\n  <span class=\"hljs-comment\">// 声明内部 value 值</span>\n  <span class=\"hljs-keyword\">const</span> [innerValue, setInnerValue] = useState&lt;T&gt;(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-comment\">// value 存在，用 value 初始化 innerValue 的值</span>\n    <span class=\"hljs-keyword\">if</span> (value !== <span class=\"hljs-literal\">undefined</span>) &#123;\n      <span class=\"hljs-keyword\">return</span> value;\n    &#125;\n    <span class=\"hljs-comment\">// 同上</span>\n    <span class=\"hljs-keyword\">if</span> (defaultValue !== <span class=\"hljs-literal\">undefined</span>) &#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> defaultValue === <span class=\"hljs-string\">&#x27;function&#x27;</span>\n        ? (defaultValue <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>)()\n        : defaultValue;\n    &#125;\n    <span class=\"hljs-comment\">// defaultStateValue 优先级最低</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> defaultStateValue === <span class=\"hljs-string\">&#x27;function&#x27;</span>\n      ? (defaultStateValue <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>)()\n      : defaultStateValue;\n  &#125;);\n\n  <span class=\"hljs-keyword\">let</span> mergedValue = value !== <span class=\"hljs-literal\">undefined</span> ? value : innerValue;\n  <span class=\"hljs-keyword\">if</span> (postState) &#123;\n    <span class=\"hljs-comment\">// 数据处理</span>\n    mergedValue = postState(mergedValue);\n  &#125;\n\n  <span class=\"hljs-comment\">// 封装内部的 setState</span>\n  <span class=\"hljs-keyword\">const</span> onChangeRef = React.useRef(onChange);\n  onChangeRef.current = onChange;\n\n  <span class=\"hljs-keyword\">const</span> triggerChange = React.useCallback(\n    <span class=\"hljs-function\">(<span class=\"hljs-params\">newValue: T, ignoreDestroy?: <span class=\"hljs-built_in\">boolean</span></span>) =&gt;</span> &#123;\n      setInnerValue(newValue, ignoreDestroy);\n      <span class=\"hljs-keyword\">if</span> (mergedValue !== newValue &amp;&amp; onChangeRef.current) &#123;\n        onChangeRef.current(newValue, mergedValue);\n      &#125;\n    &#125;,\n    [mergedValue, onChangeRef],\n  );\n\n  <span class=\"hljs-comment\">// Effect of reset value to `undefined`</span>\n  <span class=\"hljs-keyword\">const</span> prevValueRef = React.useRef(value);\n  React.useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">if</span> (value === <span class=\"hljs-literal\">undefined</span> &amp;&amp; value !== prevValueRef.current) &#123;\n      setInnerValue(value);\n    &#125;\n\n    prevValueRef.current = value;\n  &#125;, [value]);\n\n  <span class=\"hljs-keyword\">return</span> [mergedValue <span class=\"hljs-keyword\">as</span> unknown <span class=\"hljs-keyword\">as</span> R, triggerChange];\n&#125;</code></pre></div>\n","site":{"data":{}},"wordcount":1795,"excerpt":"","more":"<p>用法与 useState 类似，区别是 如果 props 提供 value 值，将会用 value 值来初始化 state 状态。</p>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> [innerChecked, setInnerChecked] = useMergedState&lt;<span class=\"hljs-built_in\">boolean</span>&gt;(<span class=\"hljs-literal\">false</span>, &#123;\n      <span class=\"hljs-attr\">value</span>: checked,\n      <span class=\"hljs-attr\">defaultValue</span>: defaultChecked,\n    &#125;);</code></pre>\n\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> React, &#123; useState &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n\n<span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">* Similar to `useState` but will use props value if provided.</span>\n<span class=\"hljs-comment\"> */</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useMergedState</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">R</span> = <span class=\"hljs-title\">T</span>&gt;(<span class=\"hljs-params\"></span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">  defaultStateValue: T | (() =&gt; T),</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">  option?: &#123;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    defaultValue?: T | (() =&gt; T);</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    value?: T;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    onChange?: (value: T, prevValue: T) =&gt; <span class=\"hljs-built_in\">void</span>;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    postState?: (value: T) =&gt; T;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">  &#125;,</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\"></span>): [<span class=\"hljs-title\">R</span>, (<span class=\"hljs-params\">value: T, ignoreDestroy?: <span class=\"hljs-built_in\">boolean</span></span>) =&gt; <span class=\"hljs-title\">void</span>] </span>&#123;\n  <span class=\"hljs-keyword\">const</span> &#123; defaultValue, value, onChange, postState &#125; = option || &#123;&#125;;\n  <span class=\"hljs-comment\">// 声明内部 value 值</span>\n  <span class=\"hljs-keyword\">const</span> [innerValue, setInnerValue] = useState&lt;T&gt;(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-comment\">// value 存在，用 value 初始化 innerValue 的值</span>\n    <span class=\"hljs-keyword\">if</span> (value !== <span class=\"hljs-literal\">undefined</span>) &#123;\n      <span class=\"hljs-keyword\">return</span> value;\n    &#125;\n    <span class=\"hljs-comment\">// 同上</span>\n    <span class=\"hljs-keyword\">if</span> (defaultValue !== <span class=\"hljs-literal\">undefined</span>) &#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> defaultValue === <span class=\"hljs-string\">&#x27;function&#x27;</span>\n        ? (defaultValue <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>)()\n        : defaultValue;\n    &#125;\n    <span class=\"hljs-comment\">// defaultStateValue 优先级最低</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> defaultStateValue === <span class=\"hljs-string\">&#x27;function&#x27;</span>\n      ? (defaultStateValue <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>)()\n      : defaultStateValue;\n  &#125;);\n\n  <span class=\"hljs-keyword\">let</span> mergedValue = value !== <span class=\"hljs-literal\">undefined</span> ? value : innerValue;\n  <span class=\"hljs-keyword\">if</span> (postState) &#123;\n    <span class=\"hljs-comment\">// 数据处理</span>\n    mergedValue = postState(mergedValue);\n  &#125;\n\n  <span class=\"hljs-comment\">// 封装内部的 setState</span>\n  <span class=\"hljs-keyword\">const</span> onChangeRef = React.useRef(onChange);\n  onChangeRef.current = onChange;\n\n  <span class=\"hljs-keyword\">const</span> triggerChange = React.useCallback(\n    <span class=\"hljs-function\">(<span class=\"hljs-params\">newValue: T, ignoreDestroy?: <span class=\"hljs-built_in\">boolean</span></span>) =&gt;</span> &#123;\n      setInnerValue(newValue, ignoreDestroy);\n      <span class=\"hljs-keyword\">if</span> (mergedValue !== newValue &amp;&amp; onChangeRef.current) &#123;\n        onChangeRef.current(newValue, mergedValue);\n      &#125;\n    &#125;,\n    [mergedValue, onChangeRef],\n  );\n\n  <span class=\"hljs-comment\">// Effect of reset value to `undefined`</span>\n  <span class=\"hljs-keyword\">const</span> prevValueRef = React.useRef(value);\n  React.useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">if</span> (value === <span class=\"hljs-literal\">undefined</span> &amp;&amp; value !== prevValueRef.current) &#123;\n      setInnerValue(value);\n    &#125;\n\n    prevValueRef.current = value;\n  &#125;, [value]);\n\n  <span class=\"hljs-keyword\">return</span> [mergedValue <span class=\"hljs-keyword\">as</span> unknown <span class=\"hljs-keyword\">as</span> R, triggerChange];\n&#125;</code></pre>\n"},{"title":"Antd 源码分析之 useMountMergeState.md","index_img":"/img/2022-04-29-1.png","abbrlink":"f806f23d","date":"2022-04-28T16:51:59.000Z","_content":"\n接上篇 `useMergeState`, `useMountMergeState` 是组件挂载后再声明 state。\n\n## 用法\n\n```ts\nconst [list, setList] = useMountMergeState<any[] | undefined>(defaultData, {\n    value: options?.dataSource,\n    onChange: options?.onDataSourceChange,\n  });\n```\n\n## 源码分析\n\n```ts\nimport useMergedState from './useMergedState';\nimport { useEffect, useRef } from 'react';\n\ntype Dispatch<A> = (value: A) => void;\n\nexport default function useMountMergeState<S>(\n  initialState: S | (() => S),\n  option?: {\n    defaultValue?: S;\n    value?: S;\n    onChange?: (value: S, prevValue: S) => void;\n    postState?: (value: S) => S;\n  },\n): [S, Dispatch<S>] {\n  const mountRef = useRef<boolean>(false);\n  const frame = useRef<number | undefined>(undefined);\n\n  useEffect(() => {\n    mountRef.current = true;\n    return () => {\n      clearTimeout(frame.current);\n      mountRef.current = false;\n    };\n  }, []);\n\n  const [state, setState] = useMergedState<S>(initialState, option);\n  const mountSetState: Dispatch<S> = (prevState: S) => {\n    clearTimeout(frame.current);\n    frame.current = window.setTimeout(() => {\n      if (mountRef.current) {\n        setState(prevState);\n      }\n    }, 16);\n  };\n  return [state, mountSetState];\n}\n```\n","source":"_posts/14.Antd 源码分析之 useMountMergeState.md","raw":"---\ntitle: Antd 源码分析之 useMountMergeState.md\nindex_img: /img/2022-04-29-1.png\nabbrlink: f806f23d\ndate: 2022-04-29 00:51:59\ntags: Hook\ncategories: React\n---\n\n接上篇 `useMergeState`, `useMountMergeState` 是组件挂载后再声明 state。\n\n## 用法\n\n```ts\nconst [list, setList] = useMountMergeState<any[] | undefined>(defaultData, {\n    value: options?.dataSource,\n    onChange: options?.onDataSourceChange,\n  });\n```\n\n## 源码分析\n\n```ts\nimport useMergedState from './useMergedState';\nimport { useEffect, useRef } from 'react';\n\ntype Dispatch<A> = (value: A) => void;\n\nexport default function useMountMergeState<S>(\n  initialState: S | (() => S),\n  option?: {\n    defaultValue?: S;\n    value?: S;\n    onChange?: (value: S, prevValue: S) => void;\n    postState?: (value: S) => S;\n  },\n): [S, Dispatch<S>] {\n  const mountRef = useRef<boolean>(false);\n  const frame = useRef<number | undefined>(undefined);\n\n  useEffect(() => {\n    mountRef.current = true;\n    return () => {\n      clearTimeout(frame.current);\n      mountRef.current = false;\n    };\n  }, []);\n\n  const [state, setState] = useMergedState<S>(initialState, option);\n  const mountSetState: Dispatch<S> = (prevState: S) => {\n    clearTimeout(frame.current);\n    frame.current = window.setTimeout(() => {\n      if (mountRef.current) {\n        setState(prevState);\n      }\n    }, 16);\n  };\n  return [state, mountSetState];\n}\n```\n","slug":"14-Antd-源码分析之-useMountMergeState","published":1,"updated":"2022-08-23T02:19:23.474Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn3v000wyu3lg6mz1gml","content":"<p>接上篇 <code>useMergeState</code>, <code>useMountMergeState</code> 是组件挂载后再声明 state。</p>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> [list, setList] = useMountMergeState&lt;<span class=\"hljs-built_in\">any</span>[] | <span class=\"hljs-literal\">undefined</span>&gt;(defaultData, &#123;\n    <span class=\"hljs-attr\">value</span>: options?.dataSource,\n    <span class=\"hljs-attr\">onChange</span>: options?.onDataSourceChange,\n  &#125;);</code></pre></div>\n\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> useMergedState <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./useMergedState&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> &#123; useEffect, useRef &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n\n<span class=\"hljs-keyword\">type</span> Dispatch&lt;A&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">value: A</span>) =&gt;</span> <span class=\"hljs-built_in\">void</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useMountMergeState</span>&lt;<span class=\"hljs-title\">S</span>&gt;(<span class=\"hljs-params\"></span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">  initialState: S | (() =&gt; S),</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">  option?: &#123;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    defaultValue?: S;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    value?: S;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    onChange?: (value: S, prevValue: S) =&gt; <span class=\"hljs-built_in\">void</span>;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    postState?: (value: S) =&gt; S;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">  &#125;,</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\"></span>): [<span class=\"hljs-title\">S</span>, <span class=\"hljs-title\">Dispatch</span>&lt;<span class=\"hljs-title\">S</span>&gt;] </span>&#123;\n  <span class=\"hljs-keyword\">const</span> mountRef = useRef&lt;<span class=\"hljs-built_in\">boolean</span>&gt;(<span class=\"hljs-literal\">false</span>);\n  <span class=\"hljs-keyword\">const</span> frame = useRef&lt;<span class=\"hljs-built_in\">number</span> | <span class=\"hljs-literal\">undefined</span>&gt;(<span class=\"hljs-literal\">undefined</span>);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    mountRef.current = <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">clearTimeout</span>(frame.current);\n      mountRef.current = <span class=\"hljs-literal\">false</span>;\n    &#125;;\n  &#125;, []);\n\n  <span class=\"hljs-keyword\">const</span> [state, setState] = useMergedState&lt;S&gt;(initialState, option);\n  <span class=\"hljs-keyword\">const</span> mountSetState: Dispatch&lt;S&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">prevState: S</span>) =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">clearTimeout</span>(frame.current);\n    frame.current = <span class=\"hljs-built_in\">window</span>.setTimeout(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-keyword\">if</span> (mountRef.current) &#123;\n        setState(prevState);\n      &#125;\n    &#125;, <span class=\"hljs-number\">16</span>);\n  &#125;;\n  <span class=\"hljs-keyword\">return</span> [state, mountSetState];\n&#125;</code></pre></div>\n","site":{"data":{}},"wordcount":1109,"excerpt":"","more":"<p>接上篇 <code>useMergeState</code>, <code>useMountMergeState</code> 是组件挂载后再声明 state。</p>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> [list, setList] = useMountMergeState&lt;<span class=\"hljs-built_in\">any</span>[] | <span class=\"hljs-literal\">undefined</span>&gt;(defaultData, &#123;\n    <span class=\"hljs-attr\">value</span>: options?.dataSource,\n    <span class=\"hljs-attr\">onChange</span>: options?.onDataSourceChange,\n  &#125;);</code></pre>\n\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> useMergedState <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./useMergedState&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> &#123; useEffect, useRef &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n\n<span class=\"hljs-keyword\">type</span> Dispatch&lt;A&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">value: A</span>) =&gt;</span> <span class=\"hljs-built_in\">void</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useMountMergeState</span>&lt;<span class=\"hljs-title\">S</span>&gt;(<span class=\"hljs-params\"></span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">  initialState: S | (() =&gt; S),</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">  option?: &#123;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    defaultValue?: S;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    value?: S;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    onChange?: (value: S, prevValue: S) =&gt; <span class=\"hljs-built_in\">void</span>;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">    postState?: (value: S) =&gt; S;</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\">  &#125;,</span></span>\n<span class=\"hljs-params\"><span class=\"hljs-function\"></span>): [<span class=\"hljs-title\">S</span>, <span class=\"hljs-title\">Dispatch</span>&lt;<span class=\"hljs-title\">S</span>&gt;] </span>&#123;\n  <span class=\"hljs-keyword\">const</span> mountRef = useRef&lt;<span class=\"hljs-built_in\">boolean</span>&gt;(<span class=\"hljs-literal\">false</span>);\n  <span class=\"hljs-keyword\">const</span> frame = useRef&lt;<span class=\"hljs-built_in\">number</span> | <span class=\"hljs-literal\">undefined</span>&gt;(<span class=\"hljs-literal\">undefined</span>);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    mountRef.current = <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">clearTimeout</span>(frame.current);\n      mountRef.current = <span class=\"hljs-literal\">false</span>;\n    &#125;;\n  &#125;, []);\n\n  <span class=\"hljs-keyword\">const</span> [state, setState] = useMergedState&lt;S&gt;(initialState, option);\n  <span class=\"hljs-keyword\">const</span> mountSetState: Dispatch&lt;S&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">prevState: S</span>) =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">clearTimeout</span>(frame.current);\n    frame.current = <span class=\"hljs-built_in\">window</span>.setTimeout(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-keyword\">if</span> (mountRef.current) &#123;\n        setState(prevState);\n      &#125;\n    &#125;, <span class=\"hljs-number\">16</span>);\n  &#125;;\n  <span class=\"hljs-keyword\">return</span> [state, mountSetState];\n&#125;</code></pre>\n"},{"title":"Antd 源码分析之常用 hooks 分析","index_img":"/img/2022-04-29-3.png","abbrlink":"e509b107","date":"2022-04-28T17:01:04.000Z","_content":"\n## usePrevious\n\n上一步更新状态值\n\n```ts\nimport { useEffect, useRef } from 'react';\n\nconst usePrevious = <T>(state: T): T | undefined => {\n  const ref = useRef<T>();\n\n  useEffect(() => {\n    ref.current = state;\n  });\n\n  return ref.current;\n};\n\nexport default usePrevious;\n```\n\n## useEventCallback\n\n保持事件类型函数引用\n\n你可能会需要用 useCallback 记住一个回调，但由于内部函数必须经常重新创建，记忆效果不是很好。如果你想要记住的函数是一个事件处理器并且在渲染期间没有被用到.\n\n```ts\nfunction useEventCallback(fn, dependencies) {\n  const ref = useRef(() => {\n    throw new Error('Cannot call an event handler while rendering.');\n  });\n\n  // 根据依赖去更新 ref ，保证最终调用的函数是最新的\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn, ...dependencies]);\n\n  return useCallback(() => {\n    const fn = ref.current;\n    return fn();\n  }, [ref]);\n}\n```\n\n## useDebounceFn\n\n调用函数防抖\n\n```ts\nfunction useDebounceFn<T extends any[], U = any>(fn: (...args: T) => Promise<any>, wait?: number) {\n  const callback = useRefFunction(fn);\n\n  const timer = useRef<any>();\n\n  const cancel = useCallback(() => {\n    if (timer.current) {\n      clearTimeout(timer.current);\n      timer.current = null;\n    }\n  }, []);\n\n  const run = useCallback(\n    async (...args: any): Promise<U | undefined> => {\n      if (wait === 0 || wait === undefined) {\n        return callback(...args);\n      }\n      cancel();\n      return new Promise<U>((resolve) => {\n        timer.current = setTimeout(async () => {\n          resolve(await callback(...args));\n        }, wait);\n      });\n    },\n    [callback, cancel, wait],\n  );\n\n  useEffect(() => {\n    return cancel;\n  }, [cancel]);\n\n  return {\n    run,\n    cancel,\n  };\n}\n```\n\n## useLatest\n\n用于在异步回调中获取最新的 props 或 state 值。\n\n源码：\n\n```ts\nconst useLatest = <T>(value: T): { readonly current: T } => {\n  const ref = useRef(value);\n  ref.current = value;\n  return ref;\n};\n```\n\n用法：\n\n```jsx\nimport { useLatest } from 'react-use';\n\nconst Demo = () => {\n  const [count, setCount] = React.useState(0);\n  const latestCount = useLatest(count);\n\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert(`Latest count value: ${latestCount.current}`);\n    }, 3000);\n  }\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n      <button onClick={handleAlertClick}>Show alert</button>\n    </div>\n  );\n};\n```\n\n```ts\nconst propsRef = useLatest(props);\n\n  const onValueChange = useCallback(() => {\n    // ...\n  }, [propsRef])\n```\n\n## useRefFunction\n\n- 缓存函数\n- 方法需要作为其他 hook 依赖时使用 useRefFunction\n\n不是完全理解，记录下，该 hook 在 antd procomponent 中使用较多。\n\n源码：\n\n```ts\nconst useRefFunction = <T extends (...args: any) => any>(reFunction: T) => {\n  const ref = useRef<any>(null);\n  // 方法的引用\n  ref.current = reFunction;\n  // 让返回函数不发生变化\n  return useCallback((...rest: Parameters<T>): ReturnType<T> => {\n    return ref.current?.(...(rest as any));\n  }, []);\n};\n```\n\n用法：\n\n```ts\nconst prePage = useRefFunction(() => {\n    if (step < 1) return;\n    setStep(step - 1);\n  });\n```\n\n```ts\nconst fieldSetOnChange = useRefFunction((fileValue: any, index: number) => {\n    const newValues = [...value];\n    newValues[index] = defaultGetValueFromEvent(valuePropName || 'value', fileValue);\n\n    onChange?.(newValues);\n    fieldProps?.onChange?.(newValues);\n  });\n```\n\nstack overflow 提问后，回答如下：\n\nIt returns a memoized function which acts as a proxy for the function you provide as the argument.\nYou would only need this when you need to update/recreate the function, but also retain a stable\nobject identity for use elsewhere (e.g. a useEffect dependency array).\n","source":"_posts/15.常用 hooks 分析.md","raw":"---\ntitle: Antd 源码分析之常用 hooks 分析\nindex_img: /img/2022-04-29-3.png\nabbrlink: e509b107\ndate: 2022-04-29 01:01:04\ntags: Hook\ncategories: React\n---\n\n## usePrevious\n\n上一步更新状态值\n\n```ts\nimport { useEffect, useRef } from 'react';\n\nconst usePrevious = <T>(state: T): T | undefined => {\n  const ref = useRef<T>();\n\n  useEffect(() => {\n    ref.current = state;\n  });\n\n  return ref.current;\n};\n\nexport default usePrevious;\n```\n\n## useEventCallback\n\n保持事件类型函数引用\n\n你可能会需要用 useCallback 记住一个回调，但由于内部函数必须经常重新创建，记忆效果不是很好。如果你想要记住的函数是一个事件处理器并且在渲染期间没有被用到.\n\n```ts\nfunction useEventCallback(fn, dependencies) {\n  const ref = useRef(() => {\n    throw new Error('Cannot call an event handler while rendering.');\n  });\n\n  // 根据依赖去更新 ref ，保证最终调用的函数是最新的\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn, ...dependencies]);\n\n  return useCallback(() => {\n    const fn = ref.current;\n    return fn();\n  }, [ref]);\n}\n```\n\n## useDebounceFn\n\n调用函数防抖\n\n```ts\nfunction useDebounceFn<T extends any[], U = any>(fn: (...args: T) => Promise<any>, wait?: number) {\n  const callback = useRefFunction(fn);\n\n  const timer = useRef<any>();\n\n  const cancel = useCallback(() => {\n    if (timer.current) {\n      clearTimeout(timer.current);\n      timer.current = null;\n    }\n  }, []);\n\n  const run = useCallback(\n    async (...args: any): Promise<U | undefined> => {\n      if (wait === 0 || wait === undefined) {\n        return callback(...args);\n      }\n      cancel();\n      return new Promise<U>((resolve) => {\n        timer.current = setTimeout(async () => {\n          resolve(await callback(...args));\n        }, wait);\n      });\n    },\n    [callback, cancel, wait],\n  );\n\n  useEffect(() => {\n    return cancel;\n  }, [cancel]);\n\n  return {\n    run,\n    cancel,\n  };\n}\n```\n\n## useLatest\n\n用于在异步回调中获取最新的 props 或 state 值。\n\n源码：\n\n```ts\nconst useLatest = <T>(value: T): { readonly current: T } => {\n  const ref = useRef(value);\n  ref.current = value;\n  return ref;\n};\n```\n\n用法：\n\n```jsx\nimport { useLatest } from 'react-use';\n\nconst Demo = () => {\n  const [count, setCount] = React.useState(0);\n  const latestCount = useLatest(count);\n\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert(`Latest count value: ${latestCount.current}`);\n    }, 3000);\n  }\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n      <button onClick={handleAlertClick}>Show alert</button>\n    </div>\n  );\n};\n```\n\n```ts\nconst propsRef = useLatest(props);\n\n  const onValueChange = useCallback(() => {\n    // ...\n  }, [propsRef])\n```\n\n## useRefFunction\n\n- 缓存函数\n- 方法需要作为其他 hook 依赖时使用 useRefFunction\n\n不是完全理解，记录下，该 hook 在 antd procomponent 中使用较多。\n\n源码：\n\n```ts\nconst useRefFunction = <T extends (...args: any) => any>(reFunction: T) => {\n  const ref = useRef<any>(null);\n  // 方法的引用\n  ref.current = reFunction;\n  // 让返回函数不发生变化\n  return useCallback((...rest: Parameters<T>): ReturnType<T> => {\n    return ref.current?.(...(rest as any));\n  }, []);\n};\n```\n\n用法：\n\n```ts\nconst prePage = useRefFunction(() => {\n    if (step < 1) return;\n    setStep(step - 1);\n  });\n```\n\n```ts\nconst fieldSetOnChange = useRefFunction((fileValue: any, index: number) => {\n    const newValues = [...value];\n    newValues[index] = defaultGetValueFromEvent(valuePropName || 'value', fileValue);\n\n    onChange?.(newValues);\n    fieldProps?.onChange?.(newValues);\n  });\n```\n\nstack overflow 提问后，回答如下：\n\nIt returns a memoized function which acts as a proxy for the function you provide as the argument.\nYou would only need this when you need to update/recreate the function, but also retain a stable\nobject identity for use elsewhere (e.g. a useEffect dependency array).\n","slug":"15-常用-hooks-分析","published":1,"updated":"2022-08-23T02:19:23.473Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn3w000yyu3l9dcz9dtr","content":"<h2 id=\"usePrevious\"><a href=\"#usePrevious\" class=\"headerlink\" title=\"usePrevious\"></a>usePrevious</h2><p>上一步更新状态值</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> &#123; useEffect, useRef &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> usePrevious = &lt;T&gt;(state: T): T | <span class=\"hljs-function\"><span class=\"hljs-params\">undefined</span> =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> ref = useRef&lt;T&gt;();\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    ref.current = state;\n  &#125;);\n\n  <span class=\"hljs-keyword\">return</span> ref.current;\n&#125;;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> usePrevious;</code></pre></div>\n\n<h2 id=\"useEventCallback\"><a href=\"#useEventCallback\" class=\"headerlink\" title=\"useEventCallback\"></a>useEventCallback</h2><p>保持事件类型函数引用</p>\n<p>你可能会需要用 useCallback 记住一个回调，但由于内部函数必须经常重新创建，记忆效果不是很好。如果你想要记住的函数是一个事件处理器并且在渲染期间没有被用到.</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useEventCallback</span>(<span class=\"hljs-params\">fn, dependencies</span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> ref = useRef(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;Cannot call an event handler while rendering.&#x27;</span>);\n  &#125;);\n\n  <span class=\"hljs-comment\">// 根据依赖去更新 ref ，保证最终调用的函数是最新的</span>\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    ref.current = fn;\n  &#125;, [fn, ...dependencies]);\n\n  <span class=\"hljs-keyword\">return</span> useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> fn = ref.current;\n    <span class=\"hljs-keyword\">return</span> fn();\n  &#125;, [ref]);\n&#125;</code></pre></div>\n\n<h2 id=\"useDebounceFn\"><a href=\"#useDebounceFn\" class=\"headerlink\" title=\"useDebounceFn\"></a>useDebounceFn</h2><p>调用函数防抖</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useDebounceFn</span>&lt;<span class=\"hljs-title\">T</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">any</span>[], <span class=\"hljs-title\">U</span> = <span class=\"hljs-title\">any</span>&gt;(<span class=\"hljs-params\">fn: (...args: T) =&gt; <span class=\"hljs-built_in\">Promise</span>&lt;<span class=\"hljs-built_in\">any</span>&gt;, wait?: <span class=\"hljs-built_in\">number</span></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> callback = useRefFunction(fn);\n\n  <span class=\"hljs-keyword\">const</span> timer = useRef&lt;<span class=\"hljs-built_in\">any</span>&gt;();\n\n  <span class=\"hljs-keyword\">const</span> cancel = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">if</span> (timer.current) &#123;\n      <span class=\"hljs-built_in\">clearTimeout</span>(timer.current);\n      timer.current = <span class=\"hljs-literal\">null</span>;\n    &#125;\n  &#125;, []);\n\n  <span class=\"hljs-keyword\">const</span> run = useCallback(\n    <span class=\"hljs-keyword\">async</span> (...args: <span class=\"hljs-built_in\">any</span>): <span class=\"hljs-built_in\">Promise</span>&lt;U | <span class=\"hljs-literal\">undefined</span>&gt; =&gt; &#123;\n      <span class=\"hljs-keyword\">if</span> (wait === <span class=\"hljs-number\">0</span> || wait === <span class=\"hljs-literal\">undefined</span>) &#123;\n        <span class=\"hljs-keyword\">return</span> callback(...args);\n      &#125;\n      cancel();\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>&lt;U&gt;(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> &#123;\n        timer.current = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">async</span> () =&gt; &#123;\n          resolve(<span class=\"hljs-keyword\">await</span> callback(...args));\n        &#125;, wait);\n      &#125;);\n    &#125;,\n    [callback, cancel, wait],\n  );\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">return</span> cancel;\n  &#125;, [cancel]);\n\n  <span class=\"hljs-keyword\">return</span> &#123;\n    run,\n    cancel,\n  &#125;;\n&#125;</code></pre></div>\n\n<h2 id=\"useLatest\"><a href=\"#useLatest\" class=\"headerlink\" title=\"useLatest\"></a>useLatest</h2><p>用于在异步回调中获取最新的 props 或 state 值。</p>\n<p>源码：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> useLatest = &lt;T&gt;(value: T): &#123; <span class=\"hljs-keyword\">readonly</span> current: T &#125; =&gt; &#123;\n  <span class=\"hljs-keyword\">const</span> ref = useRef(value);\n  ref.current = value;\n  <span class=\"hljs-keyword\">return</span> ref;\n&#125;;</code></pre></div>\n\n<p>用法：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; useLatest &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-use&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> Demo = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = React.useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">const</span> latestCount = useLatest(count);\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">handleAlertClick</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      alert(<span class=\"hljs-string\">`Latest count value: <span class=\"hljs-subst\">$&#123;latestCount.current&#125;</span>`</span>);\n    &#125;, <span class=\"hljs-number\">3000</span>);\n  &#125;\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Click me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;handleAlertClick&#125;</span>&gt;</span>Show alert<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;;</code></pre></div>\n\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> propsRef = useLatest(props);\n\n  <span class=\"hljs-keyword\">const</span> onValueChange = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;, [propsRef])</code></pre></div>\n\n<h2 id=\"useRefFunction\"><a href=\"#useRefFunction\" class=\"headerlink\" title=\"useRefFunction\"></a>useRefFunction</h2><ul>\n<li>缓存函数</li>\n<li>方法需要作为其他 hook 依赖时使用 useRefFunction</li>\n</ul>\n<p>不是完全理解，记录下，该 hook 在 antd procomponent 中使用较多。</p>\n<p>源码：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> useRefFunction = &lt;T extends (...args: any) =&gt; any&gt;(reFunction: T) =&gt; &#123;\n  const ref = useRef&lt;any&gt;(null);\n  // 方法的引用\n  ref.current = reFunction;\n  // 让返回函数不发生变化\n  return useCallback((...rest: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt; &#123;\n    return ref.current?.(...(rest as any));\n  &#125;, []);\n&#125;;</code></pre></div>\n\n<p>用法：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> prePage = useRefFunction(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">if</span> (step &lt; <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span>;\n    setStep(step - <span class=\"hljs-number\">1</span>);\n  &#125;);</code></pre></div>\n\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> fieldSetOnChange = useRefFunction(<span class=\"hljs-function\">(<span class=\"hljs-params\">fileValue: <span class=\"hljs-built_in\">any</span>, index: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> newValues = [...value];\n    newValues[index] = defaultGetValueFromEvent(valuePropName || <span class=\"hljs-string\">&#x27;value&#x27;</span>, fileValue);\n\n    onChange?.(newValues);\n    fieldProps?.onChange?.(newValues);\n  &#125;);</code></pre></div>\n\n<p>stack overflow 提问后，回答如下：</p>\n<p>It returns a memoized function which acts as a proxy for the function you provide as the argument.<br>You would only need this when you need to update/recreate the function, but also retain a stable<br>object identity for use elsewhere (e.g. a useEffect dependency array).</p>\n","site":{"data":{}},"wordcount":3183,"excerpt":"","more":"<h2 id=\"usePrevious\"><a href=\"#usePrevious\" class=\"headerlink\" title=\"usePrevious\"></a>usePrevious</h2><p>上一步更新状态值</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> &#123; useEffect, useRef &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> usePrevious = &lt;T&gt;(state: T): T | <span class=\"hljs-function\"><span class=\"hljs-params\">undefined</span> =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> ref = useRef&lt;T&gt;();\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    ref.current = state;\n  &#125;);\n\n  <span class=\"hljs-keyword\">return</span> ref.current;\n&#125;;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> usePrevious;</code></pre>\n\n<h2 id=\"useEventCallback\"><a href=\"#useEventCallback\" class=\"headerlink\" title=\"useEventCallback\"></a>useEventCallback</h2><p>保持事件类型函数引用</p>\n<p>你可能会需要用 useCallback 记住一个回调，但由于内部函数必须经常重新创建，记忆效果不是很好。如果你想要记住的函数是一个事件处理器并且在渲染期间没有被用到.</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useEventCallback</span>(<span class=\"hljs-params\">fn, dependencies</span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> ref = useRef(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;Cannot call an event handler while rendering.&#x27;</span>);\n  &#125;);\n\n  <span class=\"hljs-comment\">// 根据依赖去更新 ref ，保证最终调用的函数是最新的</span>\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    ref.current = fn;\n  &#125;, [fn, ...dependencies]);\n\n  <span class=\"hljs-keyword\">return</span> useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> fn = ref.current;\n    <span class=\"hljs-keyword\">return</span> fn();\n  &#125;, [ref]);\n&#125;</code></pre>\n\n<h2 id=\"useDebounceFn\"><a href=\"#useDebounceFn\" class=\"headerlink\" title=\"useDebounceFn\"></a>useDebounceFn</h2><p>调用函数防抖</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useDebounceFn</span>&lt;<span class=\"hljs-title\">T</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">any</span>[], <span class=\"hljs-title\">U</span> = <span class=\"hljs-title\">any</span>&gt;(<span class=\"hljs-params\">fn: (...args: T) =&gt; <span class=\"hljs-built_in\">Promise</span>&lt;<span class=\"hljs-built_in\">any</span>&gt;, wait?: <span class=\"hljs-built_in\">number</span></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> callback = useRefFunction(fn);\n\n  <span class=\"hljs-keyword\">const</span> timer = useRef&lt;<span class=\"hljs-built_in\">any</span>&gt;();\n\n  <span class=\"hljs-keyword\">const</span> cancel = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">if</span> (timer.current) &#123;\n      <span class=\"hljs-built_in\">clearTimeout</span>(timer.current);\n      timer.current = <span class=\"hljs-literal\">null</span>;\n    &#125;\n  &#125;, []);\n\n  <span class=\"hljs-keyword\">const</span> run = useCallback(\n    <span class=\"hljs-keyword\">async</span> (...args: <span class=\"hljs-built_in\">any</span>): <span class=\"hljs-built_in\">Promise</span>&lt;U | <span class=\"hljs-literal\">undefined</span>&gt; =&gt; &#123;\n      <span class=\"hljs-keyword\">if</span> (wait === <span class=\"hljs-number\">0</span> || wait === <span class=\"hljs-literal\">undefined</span>) &#123;\n        <span class=\"hljs-keyword\">return</span> callback(...args);\n      &#125;\n      cancel();\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>&lt;U&gt;(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> &#123;\n        timer.current = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">async</span> () =&gt; &#123;\n          resolve(<span class=\"hljs-keyword\">await</span> callback(...args));\n        &#125;, wait);\n      &#125;);\n    &#125;,\n    [callback, cancel, wait],\n  );\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">return</span> cancel;\n  &#125;, [cancel]);\n\n  <span class=\"hljs-keyword\">return</span> &#123;\n    run,\n    cancel,\n  &#125;;\n&#125;</code></pre>\n\n<h2 id=\"useLatest\"><a href=\"#useLatest\" class=\"headerlink\" title=\"useLatest\"></a>useLatest</h2><p>用于在异步回调中获取最新的 props 或 state 值。</p>\n<p>源码：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> useLatest = &lt;T&gt;(value: T): &#123; <span class=\"hljs-keyword\">readonly</span> current: T &#125; =&gt; &#123;\n  <span class=\"hljs-keyword\">const</span> ref = useRef(value);\n  ref.current = value;\n  <span class=\"hljs-keyword\">return</span> ref;\n&#125;;</code></pre>\n\n<p>用法：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; useLatest &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-use&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> Demo = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = React.useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">const</span> latestCount = useLatest(count);\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">handleAlertClick</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      alert(<span class=\"hljs-string\">`Latest count value: <span class=\"hljs-subst\">$&#123;latestCount.current&#125;</span>`</span>);\n    &#125;, <span class=\"hljs-number\">3000</span>);\n  &#125;\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>You clicked &#123;count&#125; times<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Click me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;handleAlertClick&#125;</span>&gt;</span>Show alert<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;;</code></pre>\n\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> propsRef = useLatest(props);\n\n  <span class=\"hljs-keyword\">const</span> onValueChange = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;, [propsRef])</code></pre>\n\n<h2 id=\"useRefFunction\"><a href=\"#useRefFunction\" class=\"headerlink\" title=\"useRefFunction\"></a>useRefFunction</h2><ul>\n<li>缓存函数</li>\n<li>方法需要作为其他 hook 依赖时使用 useRefFunction</li>\n</ul>\n<p>不是完全理解，记录下，该 hook 在 antd procomponent 中使用较多。</p>\n<p>源码：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> useRefFunction = &lt;T extends (...args: any) =&gt; any&gt;(reFunction: T) =&gt; &#123;\n  const ref = useRef&lt;any&gt;(null);\n  // 方法的引用\n  ref.current = reFunction;\n  // 让返回函数不发生变化\n  return useCallback((...rest: Parameters&lt;T&gt;): ReturnType&lt;T&gt; =&gt; &#123;\n    return ref.current?.(...(rest as any));\n  &#125;, []);\n&#125;;</code></pre>\n\n<p>用法：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> prePage = useRefFunction(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">if</span> (step &lt; <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span>;\n    setStep(step - <span class=\"hljs-number\">1</span>);\n  &#125;);</code></pre>\n\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> fieldSetOnChange = useRefFunction(<span class=\"hljs-function\">(<span class=\"hljs-params\">fileValue: <span class=\"hljs-built_in\">any</span>, index: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> newValues = [...value];\n    newValues[index] = defaultGetValueFromEvent(valuePropName || <span class=\"hljs-string\">&#x27;value&#x27;</span>, fileValue);\n\n    onChange?.(newValues);\n    fieldProps?.onChange?.(newValues);\n  &#125;);</code></pre>\n\n<p>stack overflow 提问后，回答如下：</p>\n<p>It returns a memoized function which acts as a proxy for the function you provide as the argument.<br>You would only need this when you need to update/recreate the function, but also retain a stable<br>object identity for use elsewhere (e.g. a useEffect dependency array).</p>\n"},{"title":"Antd Pro 源码分析之 useFetchData","index_img":"/img/2022-04-30-2.png","abbrlink":"8cb39ba1","date":"2022-04-30T08:01:55.000Z","_content":"\n## 源码分析\n\n```ts\n/**\n * 合并用户配置的分页参数和默认值\n *\n * @param param0\n */\nconst mergeOptionAndPageInfo = ({ pageInfo }: UseFetchProps) => {\n  if (pageInfo) {\n    const { current, defaultCurrent, pageSize, defaultPageSize } = pageInfo;\n    return {\n      current: current || defaultCurrent || 1,\n      total: 0,\n      pageSize: pageSize || defaultPageSize || 20,\n    };\n  }\n  return { current: 1, total: 0, pageSize: 20 };\n};\n```\n\n```ts\nconst useFetchData = (\n  getData: undefined | ((params?: { pageSize: number; current: number }) => Promise<T>), // 即 protable 中的的 fetchData，即 request\n  defaultData: any[] | undefined, // 表格默认数据\n  options: UseFetchProps,\n): UseFetchDataAction => {\n  // 组件卸载标记， true 表示组件已卸载\n  const umountRef = useRef<boolean>(false);\n\n  const { onLoad, manual, polling, onRequestError, debounceTime = 20 } = options || {};\n\n  /** 是否首次加载的指示器 */\n  const manualRequestRef = useRef<boolean>(manual);\n\n  /** 轮询的setTime ID 存储 */\n  const pollingSetTimeRef = useRef<any>();\n  // useMountMergeState 类似 useState, props 提供值，用 props 值来初始化 state。而且挂载后执行。\n  const [list, setList] = useMountMergeState<any[] | undefined>(defaultData, {\n    value: options?.dataSource,\n    onChange: options?.onDataSourceChange,\n  });\n\n  // 表格 loading 状态\n  const [tableLoading, setLoading] = useMountMergeState<UseFetchDataAction['loading']>(false, {\n    value: options?.loading,\n    onChange: options?.onLoadingChange,\n  });\n\n  // 是否正在请求进行中标记\n  const requesting = useRef(false);\n\n  const [pageInfo, setPageInfoState] = useMountMergeState<PageInfo>(\n    () => mergeOptionAndPageInfo(options),\n    {\n      onChange: options?.onPageInfoChange,\n    },\n  );\n\n  // useRefFunction 保持函数引用，避免重复声明\n  const setPageInfo = useRefFunction((changePageInfo: PageInfo) => {\n    if (\n      changePageInfo.current !== pageInfo.current ||\n      changePageInfo.pageSize !== pageInfo.pageSize ||\n      changePageInfo.total !== pageInfo.total\n    ) {\n      setPageInfoState(changePageInfo);\n    }\n  });\n\n  // 轮询 loading 状态\n  const [pollingLoading, setPollingLoading] = useMountMergeState(false);\n\n  // Batching update  https://github.com/facebook/react/issues/14259\n  const setDataAndLoading = (newData: T[], dataTotal: number) => {\n    setList(newData);\n\n    if (pageInfo?.total !== dataTotal) {\n      setPageInfo({\n        ...pageInfo,\n        total: dataTotal || newData.length,\n      });\n    }\n  };\n\n  // pre state\n  const prePage = usePrevious(pageInfo?.current);\n  const prePageSize = usePrevious(pageInfo?.pageSize);\n  const prePolling = usePrevious(polling);\n\n  // params、filter、sort 等查询参数相关\n  const { effects = [] } = options || {};\n\n  /**\n   * 不这样做会导致状态不更新\n   *\n   * https://github.com/ant-design/pro-components/issues/4390\n   */\n  const requestFinally = useRefFunction(() => {\n    requestAnimationFrame(() => {\n      setLoading(false);\n      setPollingLoading(false);\n    });\n  });\n  /** 请求数据 */\n  const fetchList = async (isPolling: boolean) => {\n    if (tableLoading || requesting.current || !getData) {\n      return [];\n    }\n\n    // 需要手动触发的首次请求\n    if (manualRequestRef.current) {\n      manualRequestRef.current = false;\n      return [];\n    }\n    if (!isPolling) {\n      setLoading(true);\n    } else {\n      setPollingLoading(true);\n    }\n\n    requesting.current = true;\n    const { pageSize, current } = pageInfo || {};\n    try {\n      const pageParams =\n        options?.pageInfo !== false\n          ? {\n              current,\n              pageSize,\n            }\n          : undefined;\n\n      const { data = [], success, total = 0, ...rest } = (await getData(pageParams)) || {};\n      // 如果失败了，直接返回，不走剩下的逻辑了\n      if (success === false) return [];\n\n      const responseData = postDataPipeline<T[]>(\n        data!,\n        [options.postData].filter((item) => item) as any,\n      );\n      setDataAndLoading(responseData, total);\n      onLoad?.(responseData, rest);\n      return responseData;\n    } catch (e) {\n      // 如果没有传递这个方法的话，需要把错误抛出去，以免吞掉错误\n      if (onRequestError === undefined) throw new Error(e as string);\n      if (list === undefined) setList([]);\n      onRequestError(e as Error);\n    } finally {\n      requesting.current = false;\n      requestFinally();\n    }\n\n    return [];\n  };\n\n  const fetchListDebounce = useDebounceFn(async (isPolling: boolean) => {\n    if (pollingSetTimeRef.current) {\n      clearTimeout(pollingSetTimeRef.current);\n    }\n    const msg = await fetchList(isPolling);\n\n    // 把判断要不要轮询的逻辑放到后面来这样可以保证数据是根据当前来\n    // 放到请求前面会导致数据是上一次的\n    const needPolling = runFunction(polling, msg);\n\n    // 如果需要轮询，搞个一段时间后执行\n    // 如果解除了挂载，删除一下\n    if (needPolling && !umountRef.current) {\n      pollingSetTimeRef.current = setTimeout(() => {\n        fetchListDebounce.run(needPolling);\n        // 这里判断最小要2000ms，不然一直loading\n      }, Math.max(needPolling, 2000));\n    }\n    return msg;\n  }, debounceTime || 10);\n\n  // 如果轮询结束了，直接销毁定时器\n  useEffect(() => {\n    if (!polling) {\n      clearTimeout(pollingSetTimeRef.current);\n    }\n    if (!prePolling && polling) {\n      fetchListDebounce.run(true);\n    }\n    return () => {\n      clearTimeout(pollingSetTimeRef.current);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [polling]);\n\n  useLayoutEffect(() => {\n    umountRef.current = false;\n\n    return () => {\n      umountRef.current = true;\n    };\n  }, []);\n\n  /** PageIndex 改变的时候自动刷新 */\n  useEffect(() => {\n    const { current, pageSize } = pageInfo || {};\n    // 如果上次的页码为空或者两次页码等于是没必要查询的\n    // 如果 pageSize 发生变化是需要查询的，所以又加了 prePageSize\n    if ((!prePage || prePage === current) && (!prePageSize || prePageSize === pageSize)) {\n      return;\n    }\n\n    if ((options.pageInfo && list && list?.length > pageSize) || 0) {\n      return;\n    }\n\n    // 如果 list 的长度大于 pageSize 的长度\n    // 说明是一个假分页\n    // (pageIndex - 1 || 1) 至少要第一页\n    // 在第一页大于 10\n    // 第二页也应该是大于 10\n    if (current !== undefined && list && list.length <= pageSize) {\n      fetchListDebounce.run(false);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [pageInfo?.current]);\n\n  // pageSize 修改后返回第一页\n  useEffect(() => {\n    if (!prePageSize) {\n      return;\n    }\n    fetchListDebounce.run(false);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [pageInfo?.pageSize]);\n\n  // 深比较，参数变化重新触发请求\n  useDeepCompareEffect(() => {\n    fetchListDebounce.run(false);\n    if (!manual) {\n      manualRequestRef.current = false;\n    }\n    return () => {\n      fetchListDebounce.cancel();\n    };\n  }, [...effects, manual]);\n\n  return {\n    dataSource: list!,\n    setDataSource: setList,\n    loading: tableLoading,\n    reload: async () => {\n      await fetchListDebounce.run(false);\n    },\n    pageInfo,\n    pollingLoading,\n    reset: async () => {\n      const { pageInfo: optionPageInfo } = options || {};\n      const { defaultCurrent = 1, defaultPageSize = 20 } = optionPageInfo || {};\n      const initialPageInfo = {\n        current: defaultCurrent,\n        total: 0,\n        pageSize: defaultPageSize,\n      };\n      setPageInfo(initialPageInfo);\n    },\n    setPageInfo: async (info) => {\n      setPageInfo({\n        ...pageInfo,\n        ...info,\n      });\n    },\n  };\n};\n\nexport default useFetchData;\n```\n","source":"_posts/16.Antd 源码分析之 useFetchData.md","raw":"---\ntitle: Antd Pro 源码分析之 useFetchData\nindex_img: /img/2022-04-30-2.png\ntags: Hook\ncategories: React\nabbrlink: 8cb39ba1\ndate: 2022-04-30 16:01:55\n---\n\n## 源码分析\n\n```ts\n/**\n * 合并用户配置的分页参数和默认值\n *\n * @param param0\n */\nconst mergeOptionAndPageInfo = ({ pageInfo }: UseFetchProps) => {\n  if (pageInfo) {\n    const { current, defaultCurrent, pageSize, defaultPageSize } = pageInfo;\n    return {\n      current: current || defaultCurrent || 1,\n      total: 0,\n      pageSize: pageSize || defaultPageSize || 20,\n    };\n  }\n  return { current: 1, total: 0, pageSize: 20 };\n};\n```\n\n```ts\nconst useFetchData = (\n  getData: undefined | ((params?: { pageSize: number; current: number }) => Promise<T>), // 即 protable 中的的 fetchData，即 request\n  defaultData: any[] | undefined, // 表格默认数据\n  options: UseFetchProps,\n): UseFetchDataAction => {\n  // 组件卸载标记， true 表示组件已卸载\n  const umountRef = useRef<boolean>(false);\n\n  const { onLoad, manual, polling, onRequestError, debounceTime = 20 } = options || {};\n\n  /** 是否首次加载的指示器 */\n  const manualRequestRef = useRef<boolean>(manual);\n\n  /** 轮询的setTime ID 存储 */\n  const pollingSetTimeRef = useRef<any>();\n  // useMountMergeState 类似 useState, props 提供值，用 props 值来初始化 state。而且挂载后执行。\n  const [list, setList] = useMountMergeState<any[] | undefined>(defaultData, {\n    value: options?.dataSource,\n    onChange: options?.onDataSourceChange,\n  });\n\n  // 表格 loading 状态\n  const [tableLoading, setLoading] = useMountMergeState<UseFetchDataAction['loading']>(false, {\n    value: options?.loading,\n    onChange: options?.onLoadingChange,\n  });\n\n  // 是否正在请求进行中标记\n  const requesting = useRef(false);\n\n  const [pageInfo, setPageInfoState] = useMountMergeState<PageInfo>(\n    () => mergeOptionAndPageInfo(options),\n    {\n      onChange: options?.onPageInfoChange,\n    },\n  );\n\n  // useRefFunction 保持函数引用，避免重复声明\n  const setPageInfo = useRefFunction((changePageInfo: PageInfo) => {\n    if (\n      changePageInfo.current !== pageInfo.current ||\n      changePageInfo.pageSize !== pageInfo.pageSize ||\n      changePageInfo.total !== pageInfo.total\n    ) {\n      setPageInfoState(changePageInfo);\n    }\n  });\n\n  // 轮询 loading 状态\n  const [pollingLoading, setPollingLoading] = useMountMergeState(false);\n\n  // Batching update  https://github.com/facebook/react/issues/14259\n  const setDataAndLoading = (newData: T[], dataTotal: number) => {\n    setList(newData);\n\n    if (pageInfo?.total !== dataTotal) {\n      setPageInfo({\n        ...pageInfo,\n        total: dataTotal || newData.length,\n      });\n    }\n  };\n\n  // pre state\n  const prePage = usePrevious(pageInfo?.current);\n  const prePageSize = usePrevious(pageInfo?.pageSize);\n  const prePolling = usePrevious(polling);\n\n  // params、filter、sort 等查询参数相关\n  const { effects = [] } = options || {};\n\n  /**\n   * 不这样做会导致状态不更新\n   *\n   * https://github.com/ant-design/pro-components/issues/4390\n   */\n  const requestFinally = useRefFunction(() => {\n    requestAnimationFrame(() => {\n      setLoading(false);\n      setPollingLoading(false);\n    });\n  });\n  /** 请求数据 */\n  const fetchList = async (isPolling: boolean) => {\n    if (tableLoading || requesting.current || !getData) {\n      return [];\n    }\n\n    // 需要手动触发的首次请求\n    if (manualRequestRef.current) {\n      manualRequestRef.current = false;\n      return [];\n    }\n    if (!isPolling) {\n      setLoading(true);\n    } else {\n      setPollingLoading(true);\n    }\n\n    requesting.current = true;\n    const { pageSize, current } = pageInfo || {};\n    try {\n      const pageParams =\n        options?.pageInfo !== false\n          ? {\n              current,\n              pageSize,\n            }\n          : undefined;\n\n      const { data = [], success, total = 0, ...rest } = (await getData(pageParams)) || {};\n      // 如果失败了，直接返回，不走剩下的逻辑了\n      if (success === false) return [];\n\n      const responseData = postDataPipeline<T[]>(\n        data!,\n        [options.postData].filter((item) => item) as any,\n      );\n      setDataAndLoading(responseData, total);\n      onLoad?.(responseData, rest);\n      return responseData;\n    } catch (e) {\n      // 如果没有传递这个方法的话，需要把错误抛出去，以免吞掉错误\n      if (onRequestError === undefined) throw new Error(e as string);\n      if (list === undefined) setList([]);\n      onRequestError(e as Error);\n    } finally {\n      requesting.current = false;\n      requestFinally();\n    }\n\n    return [];\n  };\n\n  const fetchListDebounce = useDebounceFn(async (isPolling: boolean) => {\n    if (pollingSetTimeRef.current) {\n      clearTimeout(pollingSetTimeRef.current);\n    }\n    const msg = await fetchList(isPolling);\n\n    // 把判断要不要轮询的逻辑放到后面来这样可以保证数据是根据当前来\n    // 放到请求前面会导致数据是上一次的\n    const needPolling = runFunction(polling, msg);\n\n    // 如果需要轮询，搞个一段时间后执行\n    // 如果解除了挂载，删除一下\n    if (needPolling && !umountRef.current) {\n      pollingSetTimeRef.current = setTimeout(() => {\n        fetchListDebounce.run(needPolling);\n        // 这里判断最小要2000ms，不然一直loading\n      }, Math.max(needPolling, 2000));\n    }\n    return msg;\n  }, debounceTime || 10);\n\n  // 如果轮询结束了，直接销毁定时器\n  useEffect(() => {\n    if (!polling) {\n      clearTimeout(pollingSetTimeRef.current);\n    }\n    if (!prePolling && polling) {\n      fetchListDebounce.run(true);\n    }\n    return () => {\n      clearTimeout(pollingSetTimeRef.current);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [polling]);\n\n  useLayoutEffect(() => {\n    umountRef.current = false;\n\n    return () => {\n      umountRef.current = true;\n    };\n  }, []);\n\n  /** PageIndex 改变的时候自动刷新 */\n  useEffect(() => {\n    const { current, pageSize } = pageInfo || {};\n    // 如果上次的页码为空或者两次页码等于是没必要查询的\n    // 如果 pageSize 发生变化是需要查询的，所以又加了 prePageSize\n    if ((!prePage || prePage === current) && (!prePageSize || prePageSize === pageSize)) {\n      return;\n    }\n\n    if ((options.pageInfo && list && list?.length > pageSize) || 0) {\n      return;\n    }\n\n    // 如果 list 的长度大于 pageSize 的长度\n    // 说明是一个假分页\n    // (pageIndex - 1 || 1) 至少要第一页\n    // 在第一页大于 10\n    // 第二页也应该是大于 10\n    if (current !== undefined && list && list.length <= pageSize) {\n      fetchListDebounce.run(false);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [pageInfo?.current]);\n\n  // pageSize 修改后返回第一页\n  useEffect(() => {\n    if (!prePageSize) {\n      return;\n    }\n    fetchListDebounce.run(false);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [pageInfo?.pageSize]);\n\n  // 深比较，参数变化重新触发请求\n  useDeepCompareEffect(() => {\n    fetchListDebounce.run(false);\n    if (!manual) {\n      manualRequestRef.current = false;\n    }\n    return () => {\n      fetchListDebounce.cancel();\n    };\n  }, [...effects, manual]);\n\n  return {\n    dataSource: list!,\n    setDataSource: setList,\n    loading: tableLoading,\n    reload: async () => {\n      await fetchListDebounce.run(false);\n    },\n    pageInfo,\n    pollingLoading,\n    reset: async () => {\n      const { pageInfo: optionPageInfo } = options || {};\n      const { defaultCurrent = 1, defaultPageSize = 20 } = optionPageInfo || {};\n      const initialPageInfo = {\n        current: defaultCurrent,\n        total: 0,\n        pageSize: defaultPageSize,\n      };\n      setPageInfo(initialPageInfo);\n    },\n    setPageInfo: async (info) => {\n      setPageInfo({\n        ...pageInfo,\n        ...info,\n      });\n    },\n  };\n};\n\nexport default useFetchData;\n```\n","slug":"16-Antd-源码分析之-useFetchData","published":1,"updated":"2022-08-23T02:19:23.473Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn3x0011yu3l4uglah2n","content":"<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\"> * 合并用户配置的分页参数和默认值</span>\n<span class=\"hljs-comment\"> *</span>\n<span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param <span class=\"hljs-variable\">param0</span></span></span>\n<span class=\"hljs-comment\"> */</span>\n<span class=\"hljs-keyword\">const</span> mergeOptionAndPageInfo = <span class=\"hljs-function\">(<span class=\"hljs-params\">&#123; pageInfo &#125;: UseFetchProps</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">if</span> (pageInfo) &#123;\n    <span class=\"hljs-keyword\">const</span> &#123; current, defaultCurrent, pageSize, defaultPageSize &#125; = pageInfo;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">current</span>: current || defaultCurrent || <span class=\"hljs-number\">1</span>,\n      <span class=\"hljs-attr\">total</span>: <span class=\"hljs-number\">0</span>,\n      <span class=\"hljs-attr\">pageSize</span>: pageSize || defaultPageSize || <span class=\"hljs-number\">20</span>,\n    &#125;;\n  &#125;\n  <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">current</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">total</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">pageSize</span>: <span class=\"hljs-number\">20</span> &#125;;\n&#125;;</code></pre></div>\n\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> useFetchData = (\n  getData: <span class=\"hljs-literal\">undefined</span> | (<span class=\"hljs-function\">(<span class=\"hljs-params\">params?: &#123; pageSize: <span class=\"hljs-built_in\">number</span>; current: <span class=\"hljs-built_in\">number</span> &#125;</span>) =&gt;</span> <span class=\"hljs-built_in\">Promise</span>&lt;T&gt;), <span class=\"hljs-comment\">// 即 protable 中的的 fetchData，即 request</span>\n  <span class=\"hljs-attr\">defaultData</span>: <span class=\"hljs-built_in\">any</span>[] | <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-comment\">// 表格默认数据</span>\n  <span class=\"hljs-attr\">options</span>: UseFetchProps,\n): <span class=\"hljs-function\"><span class=\"hljs-params\">UseFetchDataAction</span> =&gt;</span> &#123;\n  <span class=\"hljs-comment\">// 组件卸载标记， true 表示组件已卸载</span>\n  <span class=\"hljs-keyword\">const</span> umountRef = useRef&lt;<span class=\"hljs-built_in\">boolean</span>&gt;(<span class=\"hljs-literal\">false</span>);\n\n  <span class=\"hljs-keyword\">const</span> &#123; onLoad, manual, polling, onRequestError, debounceTime = <span class=\"hljs-number\">20</span> &#125; = options || &#123;&#125;;\n\n  <span class=\"hljs-comment\">/** 是否首次加载的指示器 */</span>\n  <span class=\"hljs-keyword\">const</span> manualRequestRef = useRef&lt;<span class=\"hljs-built_in\">boolean</span>&gt;(manual);\n\n  <span class=\"hljs-comment\">/** 轮询的setTime ID 存储 */</span>\n  <span class=\"hljs-keyword\">const</span> pollingSetTimeRef = useRef&lt;<span class=\"hljs-built_in\">any</span>&gt;();\n  <span class=\"hljs-comment\">// useMountMergeState 类似 useState, props 提供值，用 props 值来初始化 state。而且挂载后执行。</span>\n  <span class=\"hljs-keyword\">const</span> [list, setList] = useMountMergeState&lt;<span class=\"hljs-built_in\">any</span>[] | <span class=\"hljs-literal\">undefined</span>&gt;(defaultData, &#123;\n    <span class=\"hljs-attr\">value</span>: options?.dataSource,\n    <span class=\"hljs-attr\">onChange</span>: options?.onDataSourceChange,\n  &#125;);\n\n  <span class=\"hljs-comment\">// 表格 loading 状态</span>\n  <span class=\"hljs-keyword\">const</span> [tableLoading, setLoading] = useMountMergeState&lt;UseFetchDataAction[<span class=\"hljs-string\">&#x27;loading&#x27;</span>]&gt;(<span class=\"hljs-literal\">false</span>, &#123;\n    <span class=\"hljs-attr\">value</span>: options?.loading,\n    <span class=\"hljs-attr\">onChange</span>: options?.onLoadingChange,\n  &#125;);\n\n  <span class=\"hljs-comment\">// 是否正在请求进行中标记</span>\n  <span class=\"hljs-keyword\">const</span> requesting = useRef(<span class=\"hljs-literal\">false</span>);\n\n  <span class=\"hljs-keyword\">const</span> [pageInfo, setPageInfoState] = useMountMergeState&lt;PageInfo&gt;(\n    <span class=\"hljs-function\">() =&gt;</span> mergeOptionAndPageInfo(options),\n    &#123;\n      <span class=\"hljs-attr\">onChange</span>: options?.onPageInfoChange,\n    &#125;,\n  );\n\n  <span class=\"hljs-comment\">// useRefFunction 保持函数引用，避免重复声明</span>\n  <span class=\"hljs-keyword\">const</span> setPageInfo = useRefFunction(<span class=\"hljs-function\">(<span class=\"hljs-params\">changePageInfo: PageInfo</span>) =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">if</span> (\n      changePageInfo.current !== pageInfo.current ||\n      changePageInfo.pageSize !== pageInfo.pageSize ||\n      changePageInfo.total !== pageInfo.total\n    ) &#123;\n      setPageInfoState(changePageInfo);\n    &#125;\n  &#125;);\n\n  <span class=\"hljs-comment\">// 轮询 loading 状态</span>\n  <span class=\"hljs-keyword\">const</span> [pollingLoading, setPollingLoading] = useMountMergeState(<span class=\"hljs-literal\">false</span>);\n\n  <span class=\"hljs-comment\">// Batching update  https://github.com/facebook/react/issues/14259</span>\n  <span class=\"hljs-keyword\">const</span> setDataAndLoading = <span class=\"hljs-function\">(<span class=\"hljs-params\">newData: T[], dataTotal: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> &#123;\n    setList(newData);\n\n    <span class=\"hljs-keyword\">if</span> (pageInfo?.total !== dataTotal) &#123;\n      setPageInfo(&#123;\n        ...pageInfo,\n        <span class=\"hljs-attr\">total</span>: dataTotal || newData.length,\n      &#125;);\n    &#125;\n  &#125;;\n\n  <span class=\"hljs-comment\">// pre state</span>\n  <span class=\"hljs-keyword\">const</span> prePage = usePrevious(pageInfo?.current);\n  <span class=\"hljs-keyword\">const</span> prePageSize = usePrevious(pageInfo?.pageSize);\n  <span class=\"hljs-keyword\">const</span> prePolling = usePrevious(polling);\n\n  <span class=\"hljs-comment\">// params、filter、sort 等查询参数相关</span>\n  <span class=\"hljs-keyword\">const</span> &#123; effects = [] &#125; = options || &#123;&#125;;\n\n  <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">   * 不这样做会导致状态不更新</span>\n<span class=\"hljs-comment\">   *</span>\n<span class=\"hljs-comment\">   * https://github.com/ant-design/pro-components/issues/4390</span>\n<span class=\"hljs-comment\">   */</span>\n  <span class=\"hljs-keyword\">const</span> requestFinally = useRefFunction(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    requestAnimationFrame(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      setLoading(<span class=\"hljs-literal\">false</span>);\n      setPollingLoading(<span class=\"hljs-literal\">false</span>);\n    &#125;);\n  &#125;);\n  <span class=\"hljs-comment\">/** 请求数据 */</span>\n  <span class=\"hljs-keyword\">const</span> fetchList = <span class=\"hljs-keyword\">async</span> (isPolling: <span class=\"hljs-built_in\">boolean</span>) =&gt; &#123;\n    <span class=\"hljs-keyword\">if</span> (tableLoading || requesting.current || !getData) &#123;\n      <span class=\"hljs-keyword\">return</span> [];\n    &#125;\n\n    <span class=\"hljs-comment\">// 需要手动触发的首次请求</span>\n    <span class=\"hljs-keyword\">if</span> (manualRequestRef.current) &#123;\n      manualRequestRef.current = <span class=\"hljs-literal\">false</span>;\n      <span class=\"hljs-keyword\">return</span> [];\n    &#125;\n    <span class=\"hljs-keyword\">if</span> (!isPolling) &#123;\n      setLoading(<span class=\"hljs-literal\">true</span>);\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n      setPollingLoading(<span class=\"hljs-literal\">true</span>);\n    &#125;\n\n    requesting.current = <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-keyword\">const</span> &#123; pageSize, current &#125; = pageInfo || &#123;&#125;;\n    <span class=\"hljs-keyword\">try</span> &#123;\n      <span class=\"hljs-keyword\">const</span> pageParams =\n        options?.pageInfo !== <span class=\"hljs-literal\">false</span>\n          ? &#123;\n              current,\n              pageSize,\n            &#125;\n          : <span class=\"hljs-literal\">undefined</span>;\n\n      <span class=\"hljs-keyword\">const</span> &#123; data = [], success, total = <span class=\"hljs-number\">0</span>, ...rest &#125; = (<span class=\"hljs-keyword\">await</span> getData(pageParams)) || &#123;&#125;;\n      <span class=\"hljs-comment\">// 如果失败了，直接返回，不走剩下的逻辑了</span>\n      <span class=\"hljs-keyword\">if</span> (success === <span class=\"hljs-literal\">false</span>) <span class=\"hljs-keyword\">return</span> [];\n\n      <span class=\"hljs-keyword\">const</span> responseData = postDataPipeline&lt;T[]&gt;(\n        data!,\n        [options.postData].filter(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> item) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>,\n      );\n      setDataAndLoading(responseData, total);\n      onLoad?.(responseData, rest);\n      <span class=\"hljs-keyword\">return</span> responseData;\n    &#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;\n      <span class=\"hljs-comment\">// 如果没有传递这个方法的话，需要把错误抛出去，以免吞掉错误</span>\n      <span class=\"hljs-keyword\">if</span> (onRequestError === <span class=\"hljs-literal\">undefined</span>) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(e <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">string</span>);\n      <span class=\"hljs-keyword\">if</span> (list === <span class=\"hljs-literal\">undefined</span>) setList([]);\n      onRequestError(e <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">Error</span>);\n    &#125; <span class=\"hljs-keyword\">finally</span> &#123;\n      requesting.current = <span class=\"hljs-literal\">false</span>;\n      requestFinally();\n    &#125;\n\n    <span class=\"hljs-keyword\">return</span> [];\n  &#125;;\n\n  <span class=\"hljs-keyword\">const</span> fetchListDebounce = useDebounceFn(<span class=\"hljs-keyword\">async</span> (isPolling: <span class=\"hljs-built_in\">boolean</span>) =&gt; &#123;\n    <span class=\"hljs-keyword\">if</span> (pollingSetTimeRef.current) &#123;\n      <span class=\"hljs-built_in\">clearTimeout</span>(pollingSetTimeRef.current);\n    &#125;\n    <span class=\"hljs-keyword\">const</span> msg = <span class=\"hljs-keyword\">await</span> fetchList(isPolling);\n\n    <span class=\"hljs-comment\">// 把判断要不要轮询的逻辑放到后面来这样可以保证数据是根据当前来</span>\n    <span class=\"hljs-comment\">// 放到请求前面会导致数据是上一次的</span>\n    <span class=\"hljs-keyword\">const</span> needPolling = runFunction(polling, msg);\n\n    <span class=\"hljs-comment\">// 如果需要轮询，搞个一段时间后执行</span>\n    <span class=\"hljs-comment\">// 如果解除了挂载，删除一下</span>\n    <span class=\"hljs-keyword\">if</span> (needPolling &amp;&amp; !umountRef.current) &#123;\n      pollingSetTimeRef.current = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n        fetchListDebounce.run(needPolling);\n        <span class=\"hljs-comment\">// 这里判断最小要2000ms，不然一直loading</span>\n      &#125;, <span class=\"hljs-built_in\">Math</span>.max(needPolling, <span class=\"hljs-number\">2000</span>));\n    &#125;\n    <span class=\"hljs-keyword\">return</span> msg;\n  &#125;, debounceTime || <span class=\"hljs-number\">10</span>);\n\n  <span class=\"hljs-comment\">// 如果轮询结束了，直接销毁定时器</span>\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">if</span> (!polling) &#123;\n      <span class=\"hljs-built_in\">clearTimeout</span>(pollingSetTimeRef.current);\n    &#125;\n    <span class=\"hljs-keyword\">if</span> (!prePolling &amp;&amp; polling) &#123;\n      fetchListDebounce.run(<span class=\"hljs-literal\">true</span>);\n    &#125;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">clearTimeout</span>(pollingSetTimeRef.current);\n    &#125;;\n    <span class=\"hljs-comment\">// eslint-disable-next-line react-hooks/exhaustive-deps</span>\n  &#125;, [polling]);\n\n  useLayoutEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    umountRef.current = <span class=\"hljs-literal\">false</span>;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      umountRef.current = <span class=\"hljs-literal\">true</span>;\n    &#125;;\n  &#125;, []);\n\n  <span class=\"hljs-comment\">/** PageIndex 改变的时候自动刷新 */</span>\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> &#123; current, pageSize &#125; = pageInfo || &#123;&#125;;\n    <span class=\"hljs-comment\">// 如果上次的页码为空或者两次页码等于是没必要查询的</span>\n    <span class=\"hljs-comment\">// 如果 pageSize 发生变化是需要查询的，所以又加了 prePageSize</span>\n    <span class=\"hljs-keyword\">if</span> ((!prePage || prePage === current) &amp;&amp; (!prePageSize || prePageSize === pageSize)) &#123;\n      <span class=\"hljs-keyword\">return</span>;\n    &#125;\n\n    <span class=\"hljs-keyword\">if</span> ((options.pageInfo &amp;&amp; list &amp;&amp; list?.length &gt; pageSize) || <span class=\"hljs-number\">0</span>) &#123;\n      <span class=\"hljs-keyword\">return</span>;\n    &#125;\n\n    <span class=\"hljs-comment\">// 如果 list 的长度大于 pageSize 的长度</span>\n    <span class=\"hljs-comment\">// 说明是一个假分页</span>\n    <span class=\"hljs-comment\">// (pageIndex - 1 || 1) 至少要第一页</span>\n    <span class=\"hljs-comment\">// 在第一页大于 10</span>\n    <span class=\"hljs-comment\">// 第二页也应该是大于 10</span>\n    <span class=\"hljs-keyword\">if</span> (current !== <span class=\"hljs-literal\">undefined</span> &amp;&amp; list &amp;&amp; list.length &lt;= pageSize) &#123;\n      fetchListDebounce.run(<span class=\"hljs-literal\">false</span>);\n    &#125;\n    <span class=\"hljs-comment\">// eslint-disable-next-line react-hooks/exhaustive-deps</span>\n  &#125;, [pageInfo?.current]);\n\n  <span class=\"hljs-comment\">// pageSize 修改后返回第一页</span>\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">if</span> (!prePageSize) &#123;\n      <span class=\"hljs-keyword\">return</span>;\n    &#125;\n    fetchListDebounce.run(<span class=\"hljs-literal\">false</span>);\n    <span class=\"hljs-comment\">// eslint-disable-next-line react-hooks/exhaustive-deps</span>\n  &#125;, [pageInfo?.pageSize]);\n\n  <span class=\"hljs-comment\">// 深比较，参数变化重新触发请求</span>\n  useDeepCompareEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    fetchListDebounce.run(<span class=\"hljs-literal\">false</span>);\n    <span class=\"hljs-keyword\">if</span> (!manual) &#123;\n      manualRequestRef.current = <span class=\"hljs-literal\">false</span>;\n    &#125;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      fetchListDebounce.cancel();\n    &#125;;\n  &#125;, [...effects, manual]);\n\n  <span class=\"hljs-keyword\">return</span> &#123;\n    <span class=\"hljs-attr\">dataSource</span>: list!,\n    setDataSource: setList,\n    <span class=\"hljs-attr\">loading</span>: tableLoading,\n    <span class=\"hljs-attr\">reload</span>: <span class=\"hljs-keyword\">async</span> () =&gt; &#123;\n      <span class=\"hljs-keyword\">await</span> fetchListDebounce.run(<span class=\"hljs-literal\">false</span>);\n    &#125;,\n    pageInfo,\n    pollingLoading,\n    <span class=\"hljs-attr\">reset</span>: <span class=\"hljs-keyword\">async</span> () =&gt; &#123;\n      <span class=\"hljs-keyword\">const</span> &#123; <span class=\"hljs-attr\">pageInfo</span>: optionPageInfo &#125; = options || &#123;&#125;;\n      <span class=\"hljs-keyword\">const</span> &#123; defaultCurrent = <span class=\"hljs-number\">1</span>, defaultPageSize = <span class=\"hljs-number\">20</span> &#125; = optionPageInfo || &#123;&#125;;\n      <span class=\"hljs-keyword\">const</span> initialPageInfo = &#123;\n        <span class=\"hljs-attr\">current</span>: defaultCurrent,\n        <span class=\"hljs-attr\">total</span>: <span class=\"hljs-number\">0</span>,\n        <span class=\"hljs-attr\">pageSize</span>: defaultPageSize,\n      &#125;;\n      setPageInfo(initialPageInfo);\n    &#125;,\n    <span class=\"hljs-attr\">setPageInfo</span>: <span class=\"hljs-keyword\">async</span> (info) =&gt; &#123;\n      setPageInfo(&#123;\n        ...pageInfo,\n        ...info,\n      &#125;);\n    &#125;,\n  &#125;;\n&#125;;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> useFetchData;</code></pre></div>\n","site":{"data":{}},"wordcount":6185,"excerpt":"","more":"<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\"> * 合并用户配置的分页参数和默认值</span>\n<span class=\"hljs-comment\"> *</span>\n<span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param <span class=\"hljs-variable\">param0</span></span></span>\n<span class=\"hljs-comment\"> */</span>\n<span class=\"hljs-keyword\">const</span> mergeOptionAndPageInfo = <span class=\"hljs-function\">(<span class=\"hljs-params\">&#123; pageInfo &#125;: UseFetchProps</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">if</span> (pageInfo) &#123;\n    <span class=\"hljs-keyword\">const</span> &#123; current, defaultCurrent, pageSize, defaultPageSize &#125; = pageInfo;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">current</span>: current || defaultCurrent || <span class=\"hljs-number\">1</span>,\n      <span class=\"hljs-attr\">total</span>: <span class=\"hljs-number\">0</span>,\n      <span class=\"hljs-attr\">pageSize</span>: pageSize || defaultPageSize || <span class=\"hljs-number\">20</span>,\n    &#125;;\n  &#125;\n  <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">current</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">total</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">pageSize</span>: <span class=\"hljs-number\">20</span> &#125;;\n&#125;;</code></pre>\n\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> useFetchData = (\n  getData: <span class=\"hljs-literal\">undefined</span> | (<span class=\"hljs-function\">(<span class=\"hljs-params\">params?: &#123; pageSize: <span class=\"hljs-built_in\">number</span>; current: <span class=\"hljs-built_in\">number</span> &#125;</span>) =&gt;</span> <span class=\"hljs-built_in\">Promise</span>&lt;T&gt;), <span class=\"hljs-comment\">// 即 protable 中的的 fetchData，即 request</span>\n  <span class=\"hljs-attr\">defaultData</span>: <span class=\"hljs-built_in\">any</span>[] | <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-comment\">// 表格默认数据</span>\n  <span class=\"hljs-attr\">options</span>: UseFetchProps,\n): <span class=\"hljs-function\"><span class=\"hljs-params\">UseFetchDataAction</span> =&gt;</span> &#123;\n  <span class=\"hljs-comment\">// 组件卸载标记， true 表示组件已卸载</span>\n  <span class=\"hljs-keyword\">const</span> umountRef = useRef&lt;<span class=\"hljs-built_in\">boolean</span>&gt;(<span class=\"hljs-literal\">false</span>);\n\n  <span class=\"hljs-keyword\">const</span> &#123; onLoad, manual, polling, onRequestError, debounceTime = <span class=\"hljs-number\">20</span> &#125; = options || &#123;&#125;;\n\n  <span class=\"hljs-comment\">/** 是否首次加载的指示器 */</span>\n  <span class=\"hljs-keyword\">const</span> manualRequestRef = useRef&lt;<span class=\"hljs-built_in\">boolean</span>&gt;(manual);\n\n  <span class=\"hljs-comment\">/** 轮询的setTime ID 存储 */</span>\n  <span class=\"hljs-keyword\">const</span> pollingSetTimeRef = useRef&lt;<span class=\"hljs-built_in\">any</span>&gt;();\n  <span class=\"hljs-comment\">// useMountMergeState 类似 useState, props 提供值，用 props 值来初始化 state。而且挂载后执行。</span>\n  <span class=\"hljs-keyword\">const</span> [list, setList] = useMountMergeState&lt;<span class=\"hljs-built_in\">any</span>[] | <span class=\"hljs-literal\">undefined</span>&gt;(defaultData, &#123;\n    <span class=\"hljs-attr\">value</span>: options?.dataSource,\n    <span class=\"hljs-attr\">onChange</span>: options?.onDataSourceChange,\n  &#125;);\n\n  <span class=\"hljs-comment\">// 表格 loading 状态</span>\n  <span class=\"hljs-keyword\">const</span> [tableLoading, setLoading] = useMountMergeState&lt;UseFetchDataAction[<span class=\"hljs-string\">&#x27;loading&#x27;</span>]&gt;(<span class=\"hljs-literal\">false</span>, &#123;\n    <span class=\"hljs-attr\">value</span>: options?.loading,\n    <span class=\"hljs-attr\">onChange</span>: options?.onLoadingChange,\n  &#125;);\n\n  <span class=\"hljs-comment\">// 是否正在请求进行中标记</span>\n  <span class=\"hljs-keyword\">const</span> requesting = useRef(<span class=\"hljs-literal\">false</span>);\n\n  <span class=\"hljs-keyword\">const</span> [pageInfo, setPageInfoState] = useMountMergeState&lt;PageInfo&gt;(\n    <span class=\"hljs-function\">() =&gt;</span> mergeOptionAndPageInfo(options),\n    &#123;\n      <span class=\"hljs-attr\">onChange</span>: options?.onPageInfoChange,\n    &#125;,\n  );\n\n  <span class=\"hljs-comment\">// useRefFunction 保持函数引用，避免重复声明</span>\n  <span class=\"hljs-keyword\">const</span> setPageInfo = useRefFunction(<span class=\"hljs-function\">(<span class=\"hljs-params\">changePageInfo: PageInfo</span>) =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">if</span> (\n      changePageInfo.current !== pageInfo.current ||\n      changePageInfo.pageSize !== pageInfo.pageSize ||\n      changePageInfo.total !== pageInfo.total\n    ) &#123;\n      setPageInfoState(changePageInfo);\n    &#125;\n  &#125;);\n\n  <span class=\"hljs-comment\">// 轮询 loading 状态</span>\n  <span class=\"hljs-keyword\">const</span> [pollingLoading, setPollingLoading] = useMountMergeState(<span class=\"hljs-literal\">false</span>);\n\n  <span class=\"hljs-comment\">// Batching update  https://github.com/facebook/react/issues/14259</span>\n  <span class=\"hljs-keyword\">const</span> setDataAndLoading = <span class=\"hljs-function\">(<span class=\"hljs-params\">newData: T[], dataTotal: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> &#123;\n    setList(newData);\n\n    <span class=\"hljs-keyword\">if</span> (pageInfo?.total !== dataTotal) &#123;\n      setPageInfo(&#123;\n        ...pageInfo,\n        <span class=\"hljs-attr\">total</span>: dataTotal || newData.length,\n      &#125;);\n    &#125;\n  &#125;;\n\n  <span class=\"hljs-comment\">// pre state</span>\n  <span class=\"hljs-keyword\">const</span> prePage = usePrevious(pageInfo?.current);\n  <span class=\"hljs-keyword\">const</span> prePageSize = usePrevious(pageInfo?.pageSize);\n  <span class=\"hljs-keyword\">const</span> prePolling = usePrevious(polling);\n\n  <span class=\"hljs-comment\">// params、filter、sort 等查询参数相关</span>\n  <span class=\"hljs-keyword\">const</span> &#123; effects = [] &#125; = options || &#123;&#125;;\n\n  <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">   * 不这样做会导致状态不更新</span>\n<span class=\"hljs-comment\">   *</span>\n<span class=\"hljs-comment\">   * https://github.com/ant-design/pro-components/issues/4390</span>\n<span class=\"hljs-comment\">   */</span>\n  <span class=\"hljs-keyword\">const</span> requestFinally = useRefFunction(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    requestAnimationFrame(<span class=\"hljs-function\">() =&gt;</span> &#123;\n      setLoading(<span class=\"hljs-literal\">false</span>);\n      setPollingLoading(<span class=\"hljs-literal\">false</span>);\n    &#125;);\n  &#125;);\n  <span class=\"hljs-comment\">/** 请求数据 */</span>\n  <span class=\"hljs-keyword\">const</span> fetchList = <span class=\"hljs-keyword\">async</span> (isPolling: <span class=\"hljs-built_in\">boolean</span>) =&gt; &#123;\n    <span class=\"hljs-keyword\">if</span> (tableLoading || requesting.current || !getData) &#123;\n      <span class=\"hljs-keyword\">return</span> [];\n    &#125;\n\n    <span class=\"hljs-comment\">// 需要手动触发的首次请求</span>\n    <span class=\"hljs-keyword\">if</span> (manualRequestRef.current) &#123;\n      manualRequestRef.current = <span class=\"hljs-literal\">false</span>;\n      <span class=\"hljs-keyword\">return</span> [];\n    &#125;\n    <span class=\"hljs-keyword\">if</span> (!isPolling) &#123;\n      setLoading(<span class=\"hljs-literal\">true</span>);\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n      setPollingLoading(<span class=\"hljs-literal\">true</span>);\n    &#125;\n\n    requesting.current = <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-keyword\">const</span> &#123; pageSize, current &#125; = pageInfo || &#123;&#125;;\n    <span class=\"hljs-keyword\">try</span> &#123;\n      <span class=\"hljs-keyword\">const</span> pageParams =\n        options?.pageInfo !== <span class=\"hljs-literal\">false</span>\n          ? &#123;\n              current,\n              pageSize,\n            &#125;\n          : <span class=\"hljs-literal\">undefined</span>;\n\n      <span class=\"hljs-keyword\">const</span> &#123; data = [], success, total = <span class=\"hljs-number\">0</span>, ...rest &#125; = (<span class=\"hljs-keyword\">await</span> getData(pageParams)) || &#123;&#125;;\n      <span class=\"hljs-comment\">// 如果失败了，直接返回，不走剩下的逻辑了</span>\n      <span class=\"hljs-keyword\">if</span> (success === <span class=\"hljs-literal\">false</span>) <span class=\"hljs-keyword\">return</span> [];\n\n      <span class=\"hljs-keyword\">const</span> responseData = postDataPipeline&lt;T[]&gt;(\n        data!,\n        [options.postData].filter(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> item) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>,\n      );\n      setDataAndLoading(responseData, total);\n      onLoad?.(responseData, rest);\n      <span class=\"hljs-keyword\">return</span> responseData;\n    &#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;\n      <span class=\"hljs-comment\">// 如果没有传递这个方法的话，需要把错误抛出去，以免吞掉错误</span>\n      <span class=\"hljs-keyword\">if</span> (onRequestError === <span class=\"hljs-literal\">undefined</span>) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(e <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">string</span>);\n      <span class=\"hljs-keyword\">if</span> (list === <span class=\"hljs-literal\">undefined</span>) setList([]);\n      onRequestError(e <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">Error</span>);\n    &#125; <span class=\"hljs-keyword\">finally</span> &#123;\n      requesting.current = <span class=\"hljs-literal\">false</span>;\n      requestFinally();\n    &#125;\n\n    <span class=\"hljs-keyword\">return</span> [];\n  &#125;;\n\n  <span class=\"hljs-keyword\">const</span> fetchListDebounce = useDebounceFn(<span class=\"hljs-keyword\">async</span> (isPolling: <span class=\"hljs-built_in\">boolean</span>) =&gt; &#123;\n    <span class=\"hljs-keyword\">if</span> (pollingSetTimeRef.current) &#123;\n      <span class=\"hljs-built_in\">clearTimeout</span>(pollingSetTimeRef.current);\n    &#125;\n    <span class=\"hljs-keyword\">const</span> msg = <span class=\"hljs-keyword\">await</span> fetchList(isPolling);\n\n    <span class=\"hljs-comment\">// 把判断要不要轮询的逻辑放到后面来这样可以保证数据是根据当前来</span>\n    <span class=\"hljs-comment\">// 放到请求前面会导致数据是上一次的</span>\n    <span class=\"hljs-keyword\">const</span> needPolling = runFunction(polling, msg);\n\n    <span class=\"hljs-comment\">// 如果需要轮询，搞个一段时间后执行</span>\n    <span class=\"hljs-comment\">// 如果解除了挂载，删除一下</span>\n    <span class=\"hljs-keyword\">if</span> (needPolling &amp;&amp; !umountRef.current) &#123;\n      pollingSetTimeRef.current = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;\n        fetchListDebounce.run(needPolling);\n        <span class=\"hljs-comment\">// 这里判断最小要2000ms，不然一直loading</span>\n      &#125;, <span class=\"hljs-built_in\">Math</span>.max(needPolling, <span class=\"hljs-number\">2000</span>));\n    &#125;\n    <span class=\"hljs-keyword\">return</span> msg;\n  &#125;, debounceTime || <span class=\"hljs-number\">10</span>);\n\n  <span class=\"hljs-comment\">// 如果轮询结束了，直接销毁定时器</span>\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">if</span> (!polling) &#123;\n      <span class=\"hljs-built_in\">clearTimeout</span>(pollingSetTimeRef.current);\n    &#125;\n    <span class=\"hljs-keyword\">if</span> (!prePolling &amp;&amp; polling) &#123;\n      fetchListDebounce.run(<span class=\"hljs-literal\">true</span>);\n    &#125;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">clearTimeout</span>(pollingSetTimeRef.current);\n    &#125;;\n    <span class=\"hljs-comment\">// eslint-disable-next-line react-hooks/exhaustive-deps</span>\n  &#125;, [polling]);\n\n  useLayoutEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    umountRef.current = <span class=\"hljs-literal\">false</span>;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      umountRef.current = <span class=\"hljs-literal\">true</span>;\n    &#125;;\n  &#125;, []);\n\n  <span class=\"hljs-comment\">/** PageIndex 改变的时候自动刷新 */</span>\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> &#123; current, pageSize &#125; = pageInfo || &#123;&#125;;\n    <span class=\"hljs-comment\">// 如果上次的页码为空或者两次页码等于是没必要查询的</span>\n    <span class=\"hljs-comment\">// 如果 pageSize 发生变化是需要查询的，所以又加了 prePageSize</span>\n    <span class=\"hljs-keyword\">if</span> ((!prePage || prePage === current) &amp;&amp; (!prePageSize || prePageSize === pageSize)) &#123;\n      <span class=\"hljs-keyword\">return</span>;\n    &#125;\n\n    <span class=\"hljs-keyword\">if</span> ((options.pageInfo &amp;&amp; list &amp;&amp; list?.length &gt; pageSize) || <span class=\"hljs-number\">0</span>) &#123;\n      <span class=\"hljs-keyword\">return</span>;\n    &#125;\n\n    <span class=\"hljs-comment\">// 如果 list 的长度大于 pageSize 的长度</span>\n    <span class=\"hljs-comment\">// 说明是一个假分页</span>\n    <span class=\"hljs-comment\">// (pageIndex - 1 || 1) 至少要第一页</span>\n    <span class=\"hljs-comment\">// 在第一页大于 10</span>\n    <span class=\"hljs-comment\">// 第二页也应该是大于 10</span>\n    <span class=\"hljs-keyword\">if</span> (current !== <span class=\"hljs-literal\">undefined</span> &amp;&amp; list &amp;&amp; list.length &lt;= pageSize) &#123;\n      fetchListDebounce.run(<span class=\"hljs-literal\">false</span>);\n    &#125;\n    <span class=\"hljs-comment\">// eslint-disable-next-line react-hooks/exhaustive-deps</span>\n  &#125;, [pageInfo?.current]);\n\n  <span class=\"hljs-comment\">// pageSize 修改后返回第一页</span>\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">if</span> (!prePageSize) &#123;\n      <span class=\"hljs-keyword\">return</span>;\n    &#125;\n    fetchListDebounce.run(<span class=\"hljs-literal\">false</span>);\n    <span class=\"hljs-comment\">// eslint-disable-next-line react-hooks/exhaustive-deps</span>\n  &#125;, [pageInfo?.pageSize]);\n\n  <span class=\"hljs-comment\">// 深比较，参数变化重新触发请求</span>\n  useDeepCompareEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    fetchListDebounce.run(<span class=\"hljs-literal\">false</span>);\n    <span class=\"hljs-keyword\">if</span> (!manual) &#123;\n      manualRequestRef.current = <span class=\"hljs-literal\">false</span>;\n    &#125;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      fetchListDebounce.cancel();\n    &#125;;\n  &#125;, [...effects, manual]);\n\n  <span class=\"hljs-keyword\">return</span> &#123;\n    <span class=\"hljs-attr\">dataSource</span>: list!,\n    setDataSource: setList,\n    <span class=\"hljs-attr\">loading</span>: tableLoading,\n    <span class=\"hljs-attr\">reload</span>: <span class=\"hljs-keyword\">async</span> () =&gt; &#123;\n      <span class=\"hljs-keyword\">await</span> fetchListDebounce.run(<span class=\"hljs-literal\">false</span>);\n    &#125;,\n    pageInfo,\n    pollingLoading,\n    <span class=\"hljs-attr\">reset</span>: <span class=\"hljs-keyword\">async</span> () =&gt; &#123;\n      <span class=\"hljs-keyword\">const</span> &#123; <span class=\"hljs-attr\">pageInfo</span>: optionPageInfo &#125; = options || &#123;&#125;;\n      <span class=\"hljs-keyword\">const</span> &#123; defaultCurrent = <span class=\"hljs-number\">1</span>, defaultPageSize = <span class=\"hljs-number\">20</span> &#125; = optionPageInfo || &#123;&#125;;\n      <span class=\"hljs-keyword\">const</span> initialPageInfo = &#123;\n        <span class=\"hljs-attr\">current</span>: defaultCurrent,\n        <span class=\"hljs-attr\">total</span>: <span class=\"hljs-number\">0</span>,\n        <span class=\"hljs-attr\">pageSize</span>: defaultPageSize,\n      &#125;;\n      setPageInfo(initialPageInfo);\n    &#125;,\n    <span class=\"hljs-attr\">setPageInfo</span>: <span class=\"hljs-keyword\">async</span> (info) =&gt; &#123;\n      setPageInfo(&#123;\n        ...pageInfo,\n        ...info,\n      &#125;);\n    &#125;,\n  &#125;;\n&#125;;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> useFetchData;</code></pre>\n"},{"title":"utils 工具函数","index_img":"/img/2022-05-01-1.png","abbrlink":"c7d2847c","date":"2022-04-30T16:50:28.000Z","_content":"\n## runFunction\n\n是函数就返回调用函数，是值就返回值。\n\n```ts\nexport function runFunction<T extends any[]>(valueEnum: any, ...rest: T) {\n  if (typeof valueEnum === 'function') {\n    return valueEnum(...rest);\n  }\n  return valueEnum;\n}\n```\n\n## 获取 JS 数据类型\n\n```js\n/**\n * 获取 JS 数据类型 返回大写字母开头\n * @param data\n * @returns {string} Function | Array | String | Number | Undefined | Null...\n */\nexport const getType = (data: any) => {\n  return Object.prototype.toString.call(data).slice(8, -1)\n}\n```\n","source":"_posts/17.utils 工具函数.md","raw":"---\ntitle: utils 工具函数\nindex_img: /img/2022-05-01-1.png\ntags: utils\ncategories: JS\nabbrlink: c7d2847c\ndate: 2022-05-01 00:50:28\n---\n\n## runFunction\n\n是函数就返回调用函数，是值就返回值。\n\n```ts\nexport function runFunction<T extends any[]>(valueEnum: any, ...rest: T) {\n  if (typeof valueEnum === 'function') {\n    return valueEnum(...rest);\n  }\n  return valueEnum;\n}\n```\n\n## 获取 JS 数据类型\n\n```js\n/**\n * 获取 JS 数据类型 返回大写字母开头\n * @param data\n * @returns {string} Function | Array | String | Number | Undefined | Null...\n */\nexport const getType = (data: any) => {\n  return Object.prototype.toString.call(data).slice(8, -1)\n}\n```\n","slug":"17-utils-工具函数","published":1,"updated":"2022-05-02T00:59:23.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn3x0014yu3l00m94s4j","content":"<h2 id=\"runFunction\"><a href=\"#runFunction\" class=\"headerlink\" title=\"runFunction\"></a>runFunction</h2><p>是函数就返回调用函数，是值就返回值。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">runFunction</span>&lt;<span class=\"hljs-title\">T</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">any</span>[]&gt;(<span class=\"hljs-params\">valueEnum: <span class=\"hljs-built_in\">any</span>, ...rest: T</span>) </span>&#123;\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> valueEnum === <span class=\"hljs-string\">&#x27;function&#x27;</span>) &#123;\n    <span class=\"hljs-keyword\">return</span> valueEnum(...rest);\n  &#125;\n  <span class=\"hljs-keyword\">return</span> valueEnum;\n&#125;</code></pre></div>\n\n<h2 id=\"获取-JS-数据类型\"><a href=\"#获取-JS-数据类型\" class=\"headerlink\" title=\"获取 JS 数据类型\"></a>获取 JS 数据类型</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\"> * 获取 JS 数据类型 返回大写字母开头</span>\n<span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param <span class=\"hljs-variable\">data</span></span></span>\n<span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@returns <span class=\"hljs-type\">&#123;string&#125;</span> </span>Function | Array | String | Number | Undefined | Null...</span>\n<span class=\"hljs-comment\"> */</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getType = <span class=\"hljs-function\">(<span class=\"hljs-params\">data: any</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Object</span>.prototype.toString.call(data).slice(<span class=\"hljs-number\">8</span>, -<span class=\"hljs-number\">1</span>)\n&#125;</code></pre></div>\n","site":{"data":{}},"wordcount":421,"excerpt":"","more":"<h2 id=\"runFunction\"><a href=\"#runFunction\" class=\"headerlink\" title=\"runFunction\"></a>runFunction</h2><p>是函数就返回调用函数，是值就返回值。</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">runFunction</span>&lt;<span class=\"hljs-title\">T</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">any</span>[]&gt;(<span class=\"hljs-params\">valueEnum: <span class=\"hljs-built_in\">any</span>, ...rest: T</span>) </span>&#123;\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> valueEnum === <span class=\"hljs-string\">&#x27;function&#x27;</span>) &#123;\n    <span class=\"hljs-keyword\">return</span> valueEnum(...rest);\n  &#125;\n  <span class=\"hljs-keyword\">return</span> valueEnum;\n&#125;</code></pre>\n\n<h2 id=\"获取-JS-数据类型\"><a href=\"#获取-JS-数据类型\" class=\"headerlink\" title=\"获取 JS 数据类型\"></a>获取 JS 数据类型</h2><pre><code class=\"hljs js\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\"> * 获取 JS 数据类型 返回大写字母开头</span>\n<span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@param <span class=\"hljs-variable\">data</span></span></span>\n<span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@returns <span class=\"hljs-type\">&#123;string&#125;</span> </span>Function | Array | String | Number | Undefined | Null...</span>\n<span class=\"hljs-comment\"> */</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getType = <span class=\"hljs-function\">(<span class=\"hljs-params\">data: any</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Object</span>.prototype.toString.call(data).slice(<span class=\"hljs-number\">8</span>, -<span class=\"hljs-number\">1</span>)\n&#125;</code></pre>\n"},{"title":"React Hooks 之闭包","index_img":"/img/2022-04-14-1.png","abbrlink":"44dd3b46","date":"2022-04-14T03:24:48.000Z","_content":"\nReact Hooks 之设计严重依赖于闭包，使用 hooks 时容易遇到过时闭包的问题。\n\n每一个JS模块都可以认为是一个独立的作用域，当代码执行时，该词法作用域创建执行上下文，如果在模块内部，创建了可供外部引用访问的函数时，就为闭包的产生提供了条件，只要该函数在外部执行访问了模块内部的其他变量，闭包就会产生。\n\n## JS 中闭包\n\n常见场景\n\n```js\nfor ( var i=0; i<5; i++ ) {\n    setTimeout(()=>{\n        console.log(i)\n    }, 0)\n}\n```\n\n打印结果，都是 5。回调函数是在循环结束后才会被执行。\n\n如何解决这种问题，一种方法就是使用闭包。\n\n```js\nfor ( var i=0; i<5; i++ ) {\n   (function(i){\n         setTimeout(()=>{\n            console.log(i)\n        }, 0)\n   })(i)\n}\n```\n\n定时器的回调函数去引用立即执行函数里定义的变量，形成闭包保存了立即执行函数执行时 i 的值，异步定时器的回调函数才如我们想要的打印了顺序的值。\n\n## Hooks 中的闭包\n\n函数组件中，组件第一次渲染的时候，为每个 hook 都创建一个对象。对象中的 next 指向下一个 hook。依次如此，最终形成链表。\n\n```ts\nexport type Hook = {\n  memoizedState: any, // 最新的状态值\n  baseState: any, // 初始状态值\n  baseQueue: Update<any, any> | null,\n  queue: UpdateQueue<any, any> | null, // 环形链表，存储的是该 hook 多次调用产生的更新对象\n  next: Hook | null, // next 指针，之下链表中的下一个 Hook\n};\n```\n\nhook 中的场景：\n\n```jsx\nfunction Counter(){\n    const [count, setCount] = useState(1);\n    useEffect(()=>{\n        setInterval(()=>{\n            console.log(count)\n        }, 1000)\n    }, [])\n    function click(){ setCount(2) }\n}\n```\n\n具体过程如下：\n\n- 第一次渲染执行 Counter，useState 设置 count 初始状态为 1。\n- 执行 useEffect ，回调函数执行，设置定时器每 s 打印 count。\n- click 触发后，调用 setCount，触发 react 更新，更新到当前组件的时候继续执行 Counter。\n- 链表已经形成，useState 将 Hook 对象上保存的状态值置为 2，count 变为 2。\n- 继续执行到 useEffect, 依赖数组为空，回调不执行。\n- 第二次更新没有涉及到定时器，定时器还在继续执行，count 仍然是第一次渲染时的值 1。count 在定时器的回调函数里被引用了，形成了闭包一直被保存。\n\n闭包就像是一个照相机，把回调函数执行的那个时机的那些值保存了下来\n\n## 解决闭包办法\n\n方法一:\n\n闭包中使用的变量添加到依赖项\n\n方法二：\n\n用函数的方式更新 state\n\n```jsx\nsetCount(alwaysActualStateValue => newStateValue);\n```\n\n## useRef 每次都能拿到最新值的原因\n\n在组件每一次渲染的过程中，`ref = useRef()` 返回的都是同一个对象，每次组件更新所生成的 ref 指向的都是同一片内存空间。\n\n## References\n\n- [https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/](https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/)\n","source":"_posts/18.React Hooks 之闭包.md","raw":"---\ntitle: React Hooks 之闭包\nindex_img: /img/2022-04-14-1.png\ntags: 闭包\ncategories: React Hook\nabbrlink: 44dd3b46\ndate: 2022-04-14 11:24:48\n---\n\nReact Hooks 之设计严重依赖于闭包，使用 hooks 时容易遇到过时闭包的问题。\n\n每一个JS模块都可以认为是一个独立的作用域，当代码执行时，该词法作用域创建执行上下文，如果在模块内部，创建了可供外部引用访问的函数时，就为闭包的产生提供了条件，只要该函数在外部执行访问了模块内部的其他变量，闭包就会产生。\n\n## JS 中闭包\n\n常见场景\n\n```js\nfor ( var i=0; i<5; i++ ) {\n    setTimeout(()=>{\n        console.log(i)\n    }, 0)\n}\n```\n\n打印结果，都是 5。回调函数是在循环结束后才会被执行。\n\n如何解决这种问题，一种方法就是使用闭包。\n\n```js\nfor ( var i=0; i<5; i++ ) {\n   (function(i){\n         setTimeout(()=>{\n            console.log(i)\n        }, 0)\n   })(i)\n}\n```\n\n定时器的回调函数去引用立即执行函数里定义的变量，形成闭包保存了立即执行函数执行时 i 的值，异步定时器的回调函数才如我们想要的打印了顺序的值。\n\n## Hooks 中的闭包\n\n函数组件中，组件第一次渲染的时候，为每个 hook 都创建一个对象。对象中的 next 指向下一个 hook。依次如此，最终形成链表。\n\n```ts\nexport type Hook = {\n  memoizedState: any, // 最新的状态值\n  baseState: any, // 初始状态值\n  baseQueue: Update<any, any> | null,\n  queue: UpdateQueue<any, any> | null, // 环形链表，存储的是该 hook 多次调用产生的更新对象\n  next: Hook | null, // next 指针，之下链表中的下一个 Hook\n};\n```\n\nhook 中的场景：\n\n```jsx\nfunction Counter(){\n    const [count, setCount] = useState(1);\n    useEffect(()=>{\n        setInterval(()=>{\n            console.log(count)\n        }, 1000)\n    }, [])\n    function click(){ setCount(2) }\n}\n```\n\n具体过程如下：\n\n- 第一次渲染执行 Counter，useState 设置 count 初始状态为 1。\n- 执行 useEffect ，回调函数执行，设置定时器每 s 打印 count。\n- click 触发后，调用 setCount，触发 react 更新，更新到当前组件的时候继续执行 Counter。\n- 链表已经形成，useState 将 Hook 对象上保存的状态值置为 2，count 变为 2。\n- 继续执行到 useEffect, 依赖数组为空，回调不执行。\n- 第二次更新没有涉及到定时器，定时器还在继续执行，count 仍然是第一次渲染时的值 1。count 在定时器的回调函数里被引用了，形成了闭包一直被保存。\n\n闭包就像是一个照相机，把回调函数执行的那个时机的那些值保存了下来\n\n## 解决闭包办法\n\n方法一:\n\n闭包中使用的变量添加到依赖项\n\n方法二：\n\n用函数的方式更新 state\n\n```jsx\nsetCount(alwaysActualStateValue => newStateValue);\n```\n\n## useRef 每次都能拿到最新值的原因\n\n在组件每一次渲染的过程中，`ref = useRef()` 返回的都是同一个对象，每次组件更新所生成的 ref 指向的都是同一片内存空间。\n\n## References\n\n- [https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/](https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/)\n","slug":"18-React-Hooks-之闭包","published":1,"updated":"2022-05-05T01:32:15.422Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn3y0016yu3lfelz49fn","content":"<p>React Hooks 之设计严重依赖于闭包，使用 hooks 时容易遇到过时闭包的问题。</p>\n<p>每一个JS模块都可以认为是一个独立的作用域，当代码执行时，该词法作用域创建执行上下文，如果在模块内部，创建了可供外部引用访问的函数时，就为闭包的产生提供了条件，只要该函数在外部执行访问了模块内部的其他变量，闭包就会产生。</p>\n<h2 id=\"JS-中闭包\"><a href=\"#JS-中闭包\" class=\"headerlink\" title=\"JS 中闭包\"></a>JS 中闭包</h2><p>常见场景</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">for</span> ( <span class=\"hljs-keyword\">var</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">5</span>; i++ ) &#123;\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">()=&gt;</span>&#123;\n        <span class=\"hljs-built_in\">console</span>.log(i)\n    &#125;, <span class=\"hljs-number\">0</span>)\n&#125;</code></pre></div>\n\n<p>打印结果，都是 5。回调函数是在循环结束后才会被执行。</p>\n<p>如何解决这种问题，一种方法就是使用闭包。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">for</span> ( <span class=\"hljs-keyword\">var</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">5</span>; i++ ) &#123;\n   (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">i</span>)</span>&#123;\n         <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">()=&gt;</span>&#123;\n            <span class=\"hljs-built_in\">console</span>.log(i)\n        &#125;, <span class=\"hljs-number\">0</span>)\n   &#125;)(i)\n&#125;</code></pre></div>\n\n<p>定时器的回调函数去引用立即执行函数里定义的变量，形成闭包保存了立即执行函数执行时 i 的值，异步定时器的回调函数才如我们想要的打印了顺序的值。</p>\n<h2 id=\"Hooks-中的闭包\"><a href=\"#Hooks-中的闭包\" class=\"headerlink\" title=\"Hooks 中的闭包\"></a>Hooks 中的闭包</h2><p>函数组件中，组件第一次渲染的时候，为每个 hook 都创建一个对象。对象中的 next 指向下一个 hook。依次如此，最终形成链表。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">type</span> Hook = &#123;\n  <span class=\"hljs-attr\">memoizedState</span>: <span class=\"hljs-built_in\">any</span>, <span class=\"hljs-comment\">// 最新的状态值</span>\n  <span class=\"hljs-attr\">baseState</span>: <span class=\"hljs-built_in\">any</span>, <span class=\"hljs-comment\">// 初始状态值</span>\n  <span class=\"hljs-attr\">baseQueue</span>: Update&lt;<span class=\"hljs-built_in\">any</span>, <span class=\"hljs-built_in\">any</span>&gt; | <span class=\"hljs-literal\">null</span>,\n  <span class=\"hljs-attr\">queue</span>: UpdateQueue&lt;<span class=\"hljs-built_in\">any</span>, <span class=\"hljs-built_in\">any</span>&gt; | <span class=\"hljs-literal\">null</span>, <span class=\"hljs-comment\">// 环形链表，存储的是该 hook 多次调用产生的更新对象</span>\n  <span class=\"hljs-attr\">next</span>: Hook | <span class=\"hljs-literal\">null</span>, <span class=\"hljs-comment\">// next 指针，之下链表中的下一个 Hook</span>\n&#125;;</code></pre></div>\n\n<p>hook 中的场景：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>)</span>&#123;\n    <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">1</span>);\n    useEffect(<span class=\"hljs-function\">()=&gt;</span>&#123;\n        <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">()=&gt;</span>&#123;\n            <span class=\"hljs-built_in\">console</span>.log(count)\n        &#125;, <span class=\"hljs-number\">1000</span>)\n    &#125;, [])\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">click</span>(<span class=\"hljs-params\"></span>)</span>&#123; setCount(<span class=\"hljs-number\">2</span>) &#125;\n&#125;</code></pre></div>\n\n<p>具体过程如下：</p>\n<ul>\n<li>第一次渲染执行 Counter，useState 设置 count 初始状态为 1。</li>\n<li>执行 useEffect ，回调函数执行，设置定时器每 s 打印 count。</li>\n<li>click 触发后，调用 setCount，触发 react 更新，更新到当前组件的时候继续执行 Counter。</li>\n<li>链表已经形成，useState 将 Hook 对象上保存的状态值置为 2，count 变为 2。</li>\n<li>继续执行到 useEffect, 依赖数组为空，回调不执行。</li>\n<li>第二次更新没有涉及到定时器，定时器还在继续执行，count 仍然是第一次渲染时的值 1。count 在定时器的回调函数里被引用了，形成了闭包一直被保存。</li>\n</ul>\n<p>闭包就像是一个照相机，把回调函数执行的那个时机的那些值保存了下来</p>\n<h2 id=\"解决闭包办法\"><a href=\"#解决闭包办法\" class=\"headerlink\" title=\"解决闭包办法\"></a>解决闭包办法</h2><p>方法一:</p>\n<p>闭包中使用的变量添加到依赖项</p>\n<p>方法二：</p>\n<p>用函数的方式更新 state</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\">setCount(<span class=\"hljs-function\"><span class=\"hljs-params\">alwaysActualStateValue</span> =&gt;</span> newStateValue);</code></pre></div>\n\n<h2 id=\"useRef-每次都能拿到最新值的原因\"><a href=\"#useRef-每次都能拿到最新值的原因\" class=\"headerlink\" title=\"useRef 每次都能拿到最新值的原因\"></a>useRef 每次都能拿到最新值的原因</h2><p>在组件每一次渲染的过程中，<code>ref = useRef()</code> 返回的都是同一个对象，每次组件更新所生成的 ref 指向的都是同一片内存空间。</p>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><ul>\n<li><a href=\"https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/\">https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/</a></li>\n</ul>\n","site":{"data":{}},"wordcount":1496,"excerpt":"","more":"<p>React Hooks 之设计严重依赖于闭包，使用 hooks 时容易遇到过时闭包的问题。</p>\n<p>每一个JS模块都可以认为是一个独立的作用域，当代码执行时，该词法作用域创建执行上下文，如果在模块内部，创建了可供外部引用访问的函数时，就为闭包的产生提供了条件，只要该函数在外部执行访问了模块内部的其他变量，闭包就会产生。</p>\n<h2 id=\"JS-中闭包\"><a href=\"#JS-中闭包\" class=\"headerlink\" title=\"JS 中闭包\"></a>JS 中闭包</h2><p>常见场景</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">for</span> ( <span class=\"hljs-keyword\">var</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">5</span>; i++ ) &#123;\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">()=&gt;</span>&#123;\n        <span class=\"hljs-built_in\">console</span>.log(i)\n    &#125;, <span class=\"hljs-number\">0</span>)\n&#125;</code></pre>\n\n<p>打印结果，都是 5。回调函数是在循环结束后才会被执行。</p>\n<p>如何解决这种问题，一种方法就是使用闭包。</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">for</span> ( <span class=\"hljs-keyword\">var</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">5</span>; i++ ) &#123;\n   (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">i</span>)</span>&#123;\n         <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">()=&gt;</span>&#123;\n            <span class=\"hljs-built_in\">console</span>.log(i)\n        &#125;, <span class=\"hljs-number\">0</span>)\n   &#125;)(i)\n&#125;</code></pre>\n\n<p>定时器的回调函数去引用立即执行函数里定义的变量，形成闭包保存了立即执行函数执行时 i 的值，异步定时器的回调函数才如我们想要的打印了顺序的值。</p>\n<h2 id=\"Hooks-中的闭包\"><a href=\"#Hooks-中的闭包\" class=\"headerlink\" title=\"Hooks 中的闭包\"></a>Hooks 中的闭包</h2><p>函数组件中，组件第一次渲染的时候，为每个 hook 都创建一个对象。对象中的 next 指向下一个 hook。依次如此，最终形成链表。</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">type</span> Hook = &#123;\n  <span class=\"hljs-attr\">memoizedState</span>: <span class=\"hljs-built_in\">any</span>, <span class=\"hljs-comment\">// 最新的状态值</span>\n  <span class=\"hljs-attr\">baseState</span>: <span class=\"hljs-built_in\">any</span>, <span class=\"hljs-comment\">// 初始状态值</span>\n  <span class=\"hljs-attr\">baseQueue</span>: Update&lt;<span class=\"hljs-built_in\">any</span>, <span class=\"hljs-built_in\">any</span>&gt; | <span class=\"hljs-literal\">null</span>,\n  <span class=\"hljs-attr\">queue</span>: UpdateQueue&lt;<span class=\"hljs-built_in\">any</span>, <span class=\"hljs-built_in\">any</span>&gt; | <span class=\"hljs-literal\">null</span>, <span class=\"hljs-comment\">// 环形链表，存储的是该 hook 多次调用产生的更新对象</span>\n  <span class=\"hljs-attr\">next</span>: Hook | <span class=\"hljs-literal\">null</span>, <span class=\"hljs-comment\">// next 指针，之下链表中的下一个 Hook</span>\n&#125;;</code></pre>\n\n<p>hook 中的场景：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Counter</span>(<span class=\"hljs-params\"></span>)</span>&#123;\n    <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">1</span>);\n    useEffect(<span class=\"hljs-function\">()=&gt;</span>&#123;\n        <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">()=&gt;</span>&#123;\n            <span class=\"hljs-built_in\">console</span>.log(count)\n        &#125;, <span class=\"hljs-number\">1000</span>)\n    &#125;, [])\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">click</span>(<span class=\"hljs-params\"></span>)</span>&#123; setCount(<span class=\"hljs-number\">2</span>) &#125;\n&#125;</code></pre>\n\n<p>具体过程如下：</p>\n<ul>\n<li>第一次渲染执行 Counter，useState 设置 count 初始状态为 1。</li>\n<li>执行 useEffect ，回调函数执行，设置定时器每 s 打印 count。</li>\n<li>click 触发后，调用 setCount，触发 react 更新，更新到当前组件的时候继续执行 Counter。</li>\n<li>链表已经形成，useState 将 Hook 对象上保存的状态值置为 2，count 变为 2。</li>\n<li>继续执行到 useEffect, 依赖数组为空，回调不执行。</li>\n<li>第二次更新没有涉及到定时器，定时器还在继续执行，count 仍然是第一次渲染时的值 1。count 在定时器的回调函数里被引用了，形成了闭包一直被保存。</li>\n</ul>\n<p>闭包就像是一个照相机，把回调函数执行的那个时机的那些值保存了下来</p>\n<h2 id=\"解决闭包办法\"><a href=\"#解决闭包办法\" class=\"headerlink\" title=\"解决闭包办法\"></a>解决闭包办法</h2><p>方法一:</p>\n<p>闭包中使用的变量添加到依赖项</p>\n<p>方法二：</p>\n<p>用函数的方式更新 state</p>\n<pre><code class=\"hljs jsx\">setCount(<span class=\"hljs-function\"><span class=\"hljs-params\">alwaysActualStateValue</span> =&gt;</span> newStateValue);</code></pre>\n\n<h2 id=\"useRef-每次都能拿到最新值的原因\"><a href=\"#useRef-每次都能拿到最新值的原因\" class=\"headerlink\" title=\"useRef 每次都能拿到最新值的原因\"></a>useRef 每次都能拿到最新值的原因</h2><p>在组件每一次渲染的过程中，<code>ref = useRef()</code> 返回的都是同一个对象，每次组件更新所生成的 ref 指向的都是同一片内存空间。</p>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><ul>\n<li><a href=\"https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/\">https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/</a></li>\n</ul>\n"},{"title":"日常使用的容器镜像操作命令","index_img":"/img/2021-12-01-1.png","abbrlink":"25d325e2","date":"2021-12-01T02:25:42.000Z","_content":"\n构建镜像\n\n```sh\ndocker build -t user-manage:v1.0 .\n```\n\n运行容器镜像\n\n```sh\ndocker run --rm -d -p 8089:80 --name k8s-installer-test -v ~/gitlab/k8s-installer-ui/dist:/usr/share/nginx/html -v ~/default.conf:/etc/nginx/conf.d/default.conf nginx\n\n# --rm container 停止后删除 container\n# -d 后台运行容器\n# -p 80:80 前者本地端口，后者是 dockerfile 暴露端口\n# --name 指定容器名称\n# -v 挂载替换容器内指定文件\n```\n\n将镜像打成 tar 包\n\n```sh\ndocker save user-manage:latest > ~/Downloads/usermanage.tar\n```\n\n或者打成 gz, 压缩包会小很多\n\n```sh\ndocker save myimage:latest | gzip > myimage_latest.tar.gz\n```\n\n上传 tar 包到指定服务器\n\n```sh\nscp ~/Downloads/usermanage.tar root@172.16.60.99:/tmp/\n```\n\n从服务器下载 tar 包到本地\n\n```sh\nscp -r caas-aio:~/tmp/origin-web-console.tar ~/Downloads/test/\n```\n\n从 tar 包加载镜像\n\n```sh\ndocker load < /tmp/usermanage.tar\n# 可以查看到\ndocker images\n```\n\n给镜像重新打 tag\n\n```sh\ndocker tag user-manage:latest docker.io/user-manage:latest\n```\n\n进入容器内部\n\n```sh\n# 镜像 id\ndocker exec -it 73bee1a2a355 /bin/bash\n# 或者 /bin/sh\n```\n\n查看镜像元数据，常用来查看 commit-id\n\n```sh\ndocker inspect <image-id>\n```\n","source":"_posts/2.日常使用的容器镜像操作命令.md","raw":"---\ntitle: 日常使用的容器镜像操作命令\nindex_img: /img/2021-12-01-1.png\nabbrlink: 25d325e2\ndate: 2021-12-01 10:25:42\ntags:\ncategories:\n---\n\n构建镜像\n\n```sh\ndocker build -t user-manage:v1.0 .\n```\n\n运行容器镜像\n\n```sh\ndocker run --rm -d -p 8089:80 --name k8s-installer-test -v ~/gitlab/k8s-installer-ui/dist:/usr/share/nginx/html -v ~/default.conf:/etc/nginx/conf.d/default.conf nginx\n\n# --rm container 停止后删除 container\n# -d 后台运行容器\n# -p 80:80 前者本地端口，后者是 dockerfile 暴露端口\n# --name 指定容器名称\n# -v 挂载替换容器内指定文件\n```\n\n将镜像打成 tar 包\n\n```sh\ndocker save user-manage:latest > ~/Downloads/usermanage.tar\n```\n\n或者打成 gz, 压缩包会小很多\n\n```sh\ndocker save myimage:latest | gzip > myimage_latest.tar.gz\n```\n\n上传 tar 包到指定服务器\n\n```sh\nscp ~/Downloads/usermanage.tar root@172.16.60.99:/tmp/\n```\n\n从服务器下载 tar 包到本地\n\n```sh\nscp -r caas-aio:~/tmp/origin-web-console.tar ~/Downloads/test/\n```\n\n从 tar 包加载镜像\n\n```sh\ndocker load < /tmp/usermanage.tar\n# 可以查看到\ndocker images\n```\n\n给镜像重新打 tag\n\n```sh\ndocker tag user-manage:latest docker.io/user-manage:latest\n```\n\n进入容器内部\n\n```sh\n# 镜像 id\ndocker exec -it 73bee1a2a355 /bin/bash\n# 或者 /bin/sh\n```\n\n查看镜像元数据，常用来查看 commit-id\n\n```sh\ndocker inspect <image-id>\n```\n","slug":"2-日常使用的容器镜像操作命令","published":1,"updated":"2022-08-23T02:19:23.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn3z001ayu3ledsl80gk","content":"<p>构建镜像</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">docker build -t user-manage:v1.0 .</code></pre></div>\n\n<p>运行容器镜像</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">docker run --rm -d -p 8089:80 --name k8s-installer-test -v ~/gitlab/k8s-installer-ui/dist:/usr/share/nginx/html -v ~/default.conf:/etc/nginx/conf.d/default.conf nginx\n\n<span class=\"hljs-comment\"># --rm container 停止后删除 container</span>\n<span class=\"hljs-comment\"># -d 后台运行容器</span>\n<span class=\"hljs-comment\"># -p 80:80 前者本地端口，后者是 dockerfile 暴露端口</span>\n<span class=\"hljs-comment\"># --name 指定容器名称</span>\n<span class=\"hljs-comment\"># -v 挂载替换容器内指定文件</span></code></pre></div>\n\n<p>将镜像打成 tar 包</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">docker save user-manage:latest &gt; ~/Downloads/usermanage.tar</code></pre></div>\n\n<p>或者打成 gz, 压缩包会小很多</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">docker save myimage:latest | gzip &gt; myimage_latest.tar.gz</code></pre></div>\n\n<p>上传 tar 包到指定服务器</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">scp ~/Downloads/usermanage.tar root@172.16.60.99:/tmp/</code></pre></div>\n\n<p>从服务器下载 tar 包到本地</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">scp -r caas-aio:~/tmp/origin-web-console.tar ~/Downloads/<span class=\"hljs-built_in\">test</span>/</code></pre></div>\n\n<p>从 tar 包加载镜像</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">docker load &lt; /tmp/usermanage.tar\n<span class=\"hljs-comment\"># 可以查看到</span>\ndocker images</code></pre></div>\n\n<p>给镜像重新打 tag</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">docker tag user-manage:latest docker.io/user-manage:latest</code></pre></div>\n\n<p>进入容器内部</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># 镜像 id</span>\ndocker <span class=\"hljs-built_in\">exec</span> -it 73bee1a2a355 /bin/bash\n<span class=\"hljs-comment\"># 或者 /bin/sh</span></code></pre></div>\n\n<p>查看镜像元数据，常用来查看 commit-id</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">docker inspect &lt;image-id&gt;</code></pre></div>\n","site":{"data":{}},"wordcount":791,"excerpt":"","more":"<p>构建镜像</p>\n<pre><code class=\"hljs sh\">docker build -t user-manage:v1.0 .</code></pre>\n\n<p>运行容器镜像</p>\n<pre><code class=\"hljs sh\">docker run --rm -d -p 8089:80 --name k8s-installer-test -v ~/gitlab/k8s-installer-ui/dist:/usr/share/nginx/html -v ~/default.conf:/etc/nginx/conf.d/default.conf nginx\n\n<span class=\"hljs-comment\"># --rm container 停止后删除 container</span>\n<span class=\"hljs-comment\"># -d 后台运行容器</span>\n<span class=\"hljs-comment\"># -p 80:80 前者本地端口，后者是 dockerfile 暴露端口</span>\n<span class=\"hljs-comment\"># --name 指定容器名称</span>\n<span class=\"hljs-comment\"># -v 挂载替换容器内指定文件</span></code></pre>\n\n<p>将镜像打成 tar 包</p>\n<pre><code class=\"hljs sh\">docker save user-manage:latest &gt; ~/Downloads/usermanage.tar</code></pre>\n\n<p>或者打成 gz, 压缩包会小很多</p>\n<pre><code class=\"hljs sh\">docker save myimage:latest | gzip &gt; myimage_latest.tar.gz</code></pre>\n\n<p>上传 tar 包到指定服务器</p>\n<pre><code class=\"hljs sh\">scp ~/Downloads/usermanage.tar root@172.16.60.99:/tmp/</code></pre>\n\n<p>从服务器下载 tar 包到本地</p>\n<pre><code class=\"hljs sh\">scp -r caas-aio:~/tmp/origin-web-console.tar ~/Downloads/<span class=\"hljs-built_in\">test</span>/</code></pre>\n\n<p>从 tar 包加载镜像</p>\n<pre><code class=\"hljs sh\">docker load &lt; /tmp/usermanage.tar\n<span class=\"hljs-comment\"># 可以查看到</span>\ndocker images</code></pre>\n\n<p>给镜像重新打 tag</p>\n<pre><code class=\"hljs sh\">docker tag user-manage:latest docker.io/user-manage:latest</code></pre>\n\n<p>进入容器内部</p>\n<pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># 镜像 id</span>\ndocker <span class=\"hljs-built_in\">exec</span> -it 73bee1a2a355 /bin/bash\n<span class=\"hljs-comment\"># 或者 /bin/sh</span></code></pre>\n\n<p>查看镜像元数据，常用来查看 commit-id</p>\n<pre><code class=\"hljs sh\">docker inspect &lt;image-id&gt;</code></pre>\n"},{"title":"使用 useRef 跨生命周期保存变量","index_img":"/img/2022-01-13-1.png","abbrlink":"bb88c12","date":"2022-01-13T07:23:54.000Z","_content":"\nref 这一种访问 DOM 的主要方式。然而，useRef() 比 ref 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式.\n\n当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调\nref 来实现。\n\n## 场景 1：只在更新时运行 useEffect\n\n使用一个可变的 ref 手动存储一个布尔值来表示是首次渲染还是后续渲染.\n\n```jsx\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  const prevCountRef = useRef(false);\n  useEffect(() => {\n    if (prevCountRef.current) {\n      console.log(\"只在更新时候执行\");\n    } else {\n      console.log(\"首次渲染执行\");\n      prevCountRef.current = true;\n    }\n  });\n\n  return (\n    <div>\n      <div>{count}</div>\n      <button\n        onClick={() => {\n          setCount(count + 1);\n        }}\n      >\n        +\n      </button>\n    </div>\n  );\n}\n```\n\n抽成自定义 hook：\n\n```jsx\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  const update = useUpdate();\n  console.log(update, \"是否更新\");\n\n  return (\n    <div>\n      <div>{count}</div>\n      <button\n        onClick={() => {\n          setCount(count + 1);\n        }}\n      >\n        +\n      </button>\n    </div>\n  );\n}\n\nfunction useUpdate() {\n  const ref = useRef(false);\n  useEffect(() => {\n    ref.current = true;\n  });\n  return ref.current;\n}\n```\n\n## 场景 2：获取上一轮的 props 或 state\n\n为什么 ref.current 拿到是上次的值？原因：\n\n1. useEffect 很重要的一点是：它是在每次渲染之后才会触发的，是延迟执行的。\n2. return 语句是同步的，所以 return 的时候，ref.current 还是旧值。\n3. 以下代码的执行顺序是 1 3 2\n\n```jsx\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  const prevCountRef = useRef();\n\n  console.log(\"1\", count);\n  useEffect(() => {\n    console.log(\"2.\", count);\n    prevCountRef.current = count;\n  });\n\n  const prevCount = prevCountRef.current;\n\n  console.log(`3.之前的状态: ${prevCount};现在状态: ${count}`);\n  return (\n    <div>\n      <div>{count}</div>\n      <button\n        onClick={() => {\n          setCount(count + 1);\n        }}\n      >\n        +\n      </button>\n    </div>\n  );\n}\n```\n\n抽取成自定义 Hook:\n\n```jsx\nexport default function usePrevious(value) {\n  const ref = useRef();\n\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref.current;\n}\n```\n\n## 场景 3：解决 hooks 时，由于异步闭包无法获取最新 state 的问题\n\n```jsx\nimport React, { useState, useEffect, useRef } from \"react\";\n\nconst RefComponent = () => {\n  // 使用 useState 存放和改变展示的 number\n  const [number, setNumber] = useState(0);\n  // 使用 useRef 生成一个独立的 ref 对象\n  // 在它的 current 属性单独存放一个展示的 number, 初始值为 0\n  const numRef = useRef(0);\n\n  function incrementAndDelayLogging() {\n    // 点击按钮 number + 1\n    setNumber(number + 1);\n    // 同时 ref 对象的 current 属性值也 + 1\n    numRef.current++;\n    // 定时器函数中产生了闭包, 这里 number 的是组件更新前的 number 对象, 所以值一直会滞后 1\n    setTimeout(() => alert(`state: ${number} | ref: ${numRef.current}`), 1000);\n  }\n\n  // 直接渲染的组件是正常情况, 可以获取到最新的 state,\n  // 所以 ref.current 和 state 存储的值显示一致\n  return (\n    <div>\n      <h1>solving closure by useRef</h1>\n      <button onClick={incrementAndDelayLogging}>alert in setTimeout</button>\n      <h4>state: {number}</h4>\n      <h4>ref: {numRef.current}</h4>\n    </div>\n  );\n};\n```\n","source":"_posts/3.使用 useRef 跨生命周期保存变量.md","raw":"---\ntitle: 使用 useRef 跨生命周期保存变量\ntags:\n  - React\n  - HooK\nindex_img: /img/2022-01-13-1.png\ncategories: React\nabbrlink: bb88c12\ndate: 2022-01-13 15:23:54\n---\n\nref 这一种访问 DOM 的主要方式。然而，useRef() 比 ref 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式.\n\n当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调\nref 来实现。\n\n## 场景 1：只在更新时运行 useEffect\n\n使用一个可变的 ref 手动存储一个布尔值来表示是首次渲染还是后续渲染.\n\n```jsx\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  const prevCountRef = useRef(false);\n  useEffect(() => {\n    if (prevCountRef.current) {\n      console.log(\"只在更新时候执行\");\n    } else {\n      console.log(\"首次渲染执行\");\n      prevCountRef.current = true;\n    }\n  });\n\n  return (\n    <div>\n      <div>{count}</div>\n      <button\n        onClick={() => {\n          setCount(count + 1);\n        }}\n      >\n        +\n      </button>\n    </div>\n  );\n}\n```\n\n抽成自定义 hook：\n\n```jsx\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  const update = useUpdate();\n  console.log(update, \"是否更新\");\n\n  return (\n    <div>\n      <div>{count}</div>\n      <button\n        onClick={() => {\n          setCount(count + 1);\n        }}\n      >\n        +\n      </button>\n    </div>\n  );\n}\n\nfunction useUpdate() {\n  const ref = useRef(false);\n  useEffect(() => {\n    ref.current = true;\n  });\n  return ref.current;\n}\n```\n\n## 场景 2：获取上一轮的 props 或 state\n\n为什么 ref.current 拿到是上次的值？原因：\n\n1. useEffect 很重要的一点是：它是在每次渲染之后才会触发的，是延迟执行的。\n2. return 语句是同步的，所以 return 的时候，ref.current 还是旧值。\n3. 以下代码的执行顺序是 1 3 2\n\n```jsx\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  const prevCountRef = useRef();\n\n  console.log(\"1\", count);\n  useEffect(() => {\n    console.log(\"2.\", count);\n    prevCountRef.current = count;\n  });\n\n  const prevCount = prevCountRef.current;\n\n  console.log(`3.之前的状态: ${prevCount};现在状态: ${count}`);\n  return (\n    <div>\n      <div>{count}</div>\n      <button\n        onClick={() => {\n          setCount(count + 1);\n        }}\n      >\n        +\n      </button>\n    </div>\n  );\n}\n```\n\n抽取成自定义 Hook:\n\n```jsx\nexport default function usePrevious(value) {\n  const ref = useRef();\n\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref.current;\n}\n```\n\n## 场景 3：解决 hooks 时，由于异步闭包无法获取最新 state 的问题\n\n```jsx\nimport React, { useState, useEffect, useRef } from \"react\";\n\nconst RefComponent = () => {\n  // 使用 useState 存放和改变展示的 number\n  const [number, setNumber] = useState(0);\n  // 使用 useRef 生成一个独立的 ref 对象\n  // 在它的 current 属性单独存放一个展示的 number, 初始值为 0\n  const numRef = useRef(0);\n\n  function incrementAndDelayLogging() {\n    // 点击按钮 number + 1\n    setNumber(number + 1);\n    // 同时 ref 对象的 current 属性值也 + 1\n    numRef.current++;\n    // 定时器函数中产生了闭包, 这里 number 的是组件更新前的 number 对象, 所以值一直会滞后 1\n    setTimeout(() => alert(`state: ${number} | ref: ${numRef.current}`), 1000);\n  }\n\n  // 直接渲染的组件是正常情况, 可以获取到最新的 state,\n  // 所以 ref.current 和 state 存储的值显示一致\n  return (\n    <div>\n      <h1>solving closure by useRef</h1>\n      <button onClick={incrementAndDelayLogging}>alert in setTimeout</button>\n      <h4>state: {number}</h4>\n      <h4>ref: {numRef.current}</h4>\n    </div>\n  );\n};\n```\n","slug":"3-使用-useRef-跨生命周期保存变量","published":1,"updated":"2022-08-23T02:19:23.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn40001dyu3l7vo89zjo","content":"<p>ref 这一种访问 DOM 的主要方式。然而，useRef() 比 ref 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式.</p>\n<p>当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调<br>ref 来实现。</p>\n<h2 id=\"场景-1：只在更新时运行-useEffect\"><a href=\"#场景-1：只在更新时运行-useEffect\" class=\"headerlink\" title=\"场景 1：只在更新时运行 useEffect\"></a>场景 1：只在更新时运行 useEffect</h2><p>使用一个可变的 ref 手动存储一个布尔值来表示是首次渲染还是后续渲染.</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">const</span> prevCountRef = useRef(<span class=\"hljs-literal\">false</span>);\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">if</span> (prevCountRef.current) &#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;只在更新时候执行&quot;</span>);\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;首次渲染执行&quot;</span>);\n      prevCountRef.current = <span class=\"hljs-literal\">true</span>;\n    &#125;\n  &#125;);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span></span></span>\n<span class=\"hljs-tag\"><span class=\"xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span>\n<span class=\"xml\">          setCount(count + 1);</span>\n<span class=\"xml\">        &#125;&#125;</span>\n<span class=\"xml\">      &gt;</span>\n<span class=\"xml\">        +</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;</code></pre></div>\n\n<p>抽成自定义 hook：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">const</span> update = useUpdate();\n  <span class=\"hljs-built_in\">console</span>.log(update, <span class=\"hljs-string\">&quot;是否更新&quot;</span>);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span></span></span>\n<span class=\"hljs-tag\"><span class=\"xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span>\n<span class=\"xml\">          setCount(count + 1);</span>\n<span class=\"xml\">        &#125;&#125;</span>\n<span class=\"xml\">      &gt;</span>\n<span class=\"xml\">        +</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useUpdate</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> ref = useRef(<span class=\"hljs-literal\">false</span>);\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    ref.current = <span class=\"hljs-literal\">true</span>;\n  &#125;);\n  <span class=\"hljs-keyword\">return</span> ref.current;\n&#125;</code></pre></div>\n\n<h2 id=\"场景-2：获取上一轮的-props-或-state\"><a href=\"#场景-2：获取上一轮的-props-或-state\" class=\"headerlink\" title=\"场景 2：获取上一轮的 props 或 state\"></a>场景 2：获取上一轮的 props 或 state</h2><p>为什么 ref.current 拿到是上次的值？原因：</p>\n<ol>\n<li>useEffect 很重要的一点是：它是在每次渲染之后才会触发的，是延迟执行的。</li>\n<li>return 语句是同步的，所以 return 的时候，ref.current 还是旧值。</li>\n<li>以下代码的执行顺序是 1 3 2</li>\n</ol>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">const</span> prevCountRef = useRef();\n\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;1&quot;</span>, count);\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;2.&quot;</span>, count);\n    prevCountRef.current = count;\n  &#125;);\n\n  <span class=\"hljs-keyword\">const</span> prevCount = prevCountRef.current;\n\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`3.之前的状态: <span class=\"hljs-subst\">$&#123;prevCount&#125;</span>;现在状态: <span class=\"hljs-subst\">$&#123;count&#125;</span>`</span>);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span></span></span>\n<span class=\"hljs-tag\"><span class=\"xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span>\n<span class=\"xml\">          setCount(count + 1);</span>\n<span class=\"xml\">        &#125;&#125;</span>\n<span class=\"xml\">      &gt;</span>\n<span class=\"xml\">        +</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;</code></pre></div>\n\n<p>抽取成自定义 Hook:</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">usePrevious</span>(<span class=\"hljs-params\">value</span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> ref = useRef();\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    ref.current = value;\n  &#125;, [value]);\n\n  <span class=\"hljs-keyword\">return</span> ref.current;\n&#125;</code></pre></div>\n\n<h2 id=\"场景-3：解决-hooks-时，由于异步闭包无法获取最新-state-的问题\"><a href=\"#场景-3：解决-hooks-时，由于异步闭包无法获取最新-state-的问题\" class=\"headerlink\" title=\"场景 3：解决 hooks 时，由于异步闭包无法获取最新 state 的问题\"></a>场景 3：解决 hooks 时，由于异步闭包无法获取最新 state 的问题</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React, &#123; useState, useEffect, useRef &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> RefComponent = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-comment\">// 使用 useState 存放和改变展示的 number</span>\n  <span class=\"hljs-keyword\">const</span> [number, setNumber] = useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-comment\">// 使用 useRef 生成一个独立的 ref 对象</span>\n  <span class=\"hljs-comment\">// 在它的 current 属性单独存放一个展示的 number, 初始值为 0</span>\n  <span class=\"hljs-keyword\">const</span> numRef = useRef(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">incrementAndDelayLogging</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// 点击按钮 number + 1</span>\n    setNumber(number + <span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-comment\">// 同时 ref 对象的 current 属性值也 + 1</span>\n    numRef.current++;\n    <span class=\"hljs-comment\">// 定时器函数中产生了闭包, 这里 number 的是组件更新前的 number 对象, 所以值一直会滞后 1</span>\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> alert(<span class=\"hljs-string\">`state: <span class=\"hljs-subst\">$&#123;number&#125;</span> | ref: <span class=\"hljs-subst\">$&#123;numRef.current&#125;</span>`</span>), <span class=\"hljs-number\">1000</span>);\n  &#125;\n\n  <span class=\"hljs-comment\">// 直接渲染的组件是正常情况, 可以获取到最新的 state,</span>\n  <span class=\"hljs-comment\">// 所以 ref.current 和 state 存储的值显示一致</span>\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>solving closure by useRef<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;incrementAndDelayLogging&#125;</span>&gt;</span>alert in setTimeout<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h4</span>&gt;</span>state: &#123;number&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h4</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h4</span>&gt;</span>ref: &#123;numRef.current&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h4</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;;</code></pre></div>\n","site":{"data":{}},"wordcount":2697,"excerpt":"","more":"<p>ref 这一种访问 DOM 的主要方式。然而，useRef() 比 ref 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式.</p>\n<p>当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调<br>ref 来实现。</p>\n<h2 id=\"场景-1：只在更新时运行-useEffect\"><a href=\"#场景-1：只在更新时运行-useEffect\" class=\"headerlink\" title=\"场景 1：只在更新时运行 useEffect\"></a>场景 1：只在更新时运行 useEffect</h2><p>使用一个可变的 ref 手动存储一个布尔值来表示是首次渲染还是后续渲染.</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">const</span> prevCountRef = useRef(<span class=\"hljs-literal\">false</span>);\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">if</span> (prevCountRef.current) &#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;只在更新时候执行&quot;</span>);\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;首次渲染执行&quot;</span>);\n      prevCountRef.current = <span class=\"hljs-literal\">true</span>;\n    &#125;\n  &#125;);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span></span></span>\n<span class=\"hljs-tag\"><span class=\"xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span>\n<span class=\"xml\">          setCount(count + 1);</span>\n<span class=\"xml\">        &#125;&#125;</span>\n<span class=\"xml\">      &gt;</span>\n<span class=\"xml\">        +</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;</code></pre>\n\n<p>抽成自定义 hook：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">const</span> update = useUpdate();\n  <span class=\"hljs-built_in\">console</span>.log(update, <span class=\"hljs-string\">&quot;是否更新&quot;</span>);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span></span></span>\n<span class=\"hljs-tag\"><span class=\"xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span>\n<span class=\"xml\">          setCount(count + 1);</span>\n<span class=\"xml\">        &#125;&#125;</span>\n<span class=\"xml\">      &gt;</span>\n<span class=\"xml\">        +</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useUpdate</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> ref = useRef(<span class=\"hljs-literal\">false</span>);\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    ref.current = <span class=\"hljs-literal\">true</span>;\n  &#125;);\n  <span class=\"hljs-keyword\">return</span> ref.current;\n&#125;</code></pre>\n\n<h2 id=\"场景-2：获取上一轮的-props-或-state\"><a href=\"#场景-2：获取上一轮的-props-或-state\" class=\"headerlink\" title=\"场景 2：获取上一轮的 props 或 state\"></a>场景 2：获取上一轮的 props 或 state</h2><p>为什么 ref.current 拿到是上次的值？原因：</p>\n<ol>\n<li>useEffect 很重要的一点是：它是在每次渲染之后才会触发的，是延迟执行的。</li>\n<li>return 语句是同步的，所以 return 的时候，ref.current 还是旧值。</li>\n<li>以下代码的执行顺序是 1 3 2</li>\n</ol>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">const</span> prevCountRef = useRef();\n\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;1&quot;</span>, count);\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;2.&quot;</span>, count);\n    prevCountRef.current = count;\n  &#125;);\n\n  <span class=\"hljs-keyword\">const</span> prevCount = prevCountRef.current;\n\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`3.之前的状态: <span class=\"hljs-subst\">$&#123;prevCount&#125;</span>;现在状态: <span class=\"hljs-subst\">$&#123;count&#125;</span>`</span>);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span></span></span>\n<span class=\"hljs-tag\"><span class=\"xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span>\n<span class=\"xml\">          setCount(count + 1);</span>\n<span class=\"xml\">        &#125;&#125;</span>\n<span class=\"xml\">      &gt;</span>\n<span class=\"xml\">        +</span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;</code></pre>\n\n<p>抽取成自定义 Hook:</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">usePrevious</span>(<span class=\"hljs-params\">value</span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> ref = useRef();\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    ref.current = value;\n  &#125;, [value]);\n\n  <span class=\"hljs-keyword\">return</span> ref.current;\n&#125;</code></pre>\n\n<h2 id=\"场景-3：解决-hooks-时，由于异步闭包无法获取最新-state-的问题\"><a href=\"#场景-3：解决-hooks-时，由于异步闭包无法获取最新-state-的问题\" class=\"headerlink\" title=\"场景 3：解决 hooks 时，由于异步闭包无法获取最新 state 的问题\"></a>场景 3：解决 hooks 时，由于异步闭包无法获取最新 state 的问题</h2><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React, &#123; useState, useEffect, useRef &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> RefComponent = <span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-comment\">// 使用 useState 存放和改变展示的 number</span>\n  <span class=\"hljs-keyword\">const</span> [number, setNumber] = useState(<span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-comment\">// 使用 useRef 生成一个独立的 ref 对象</span>\n  <span class=\"hljs-comment\">// 在它的 current 属性单独存放一个展示的 number, 初始值为 0</span>\n  <span class=\"hljs-keyword\">const</span> numRef = useRef(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">incrementAndDelayLogging</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// 点击按钮 number + 1</span>\n    setNumber(number + <span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-comment\">// 同时 ref 对象的 current 属性值也 + 1</span>\n    numRef.current++;\n    <span class=\"hljs-comment\">// 定时器函数中产生了闭包, 这里 number 的是组件更新前的 number 对象, 所以值一直会滞后 1</span>\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> alert(<span class=\"hljs-string\">`state: <span class=\"hljs-subst\">$&#123;number&#125;</span> | ref: <span class=\"hljs-subst\">$&#123;numRef.current&#125;</span>`</span>), <span class=\"hljs-number\">1000</span>);\n  &#125;\n\n  <span class=\"hljs-comment\">// 直接渲染的组件是正常情况, 可以获取到最新的 state,</span>\n  <span class=\"hljs-comment\">// 所以 ref.current 和 state 存储的值显示一致</span>\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>solving closure by useRef<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;incrementAndDelayLogging&#125;</span>&gt;</span>alert in setTimeout<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h4</span>&gt;</span>state: &#123;number&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h4</span>&gt;</span></span>\n<span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h4</span>&gt;</span>ref: &#123;numRef.current&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h4</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n&#125;;</code></pre>\n"},{"title":"useState 引用类型数据更新不触发重新渲染问题","index_img":"/img/2022-01-14-1.png","abbrlink":"b195fb80","date":"2022-01-14T02:24:50.000Z","_content":"\n## useState 函数式更新\n\n与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。\n\n```jsx\nconst [state, setState] = useState({});\nsetState((prevState) => {\n  // 也可以使用 Object.assign\n  return { ...prevState, ...updatedValues };\n});\n```\n\n## 引用类型 state 更新\n\n经常 state 数据不是简单数据类型(值类型)，而是数组、对象之类(引用类型).而 React 组件的更新机制对 state\n只进行浅对比，也就是更新某个复杂类型数据时只要它的引用地址没变，那就不会重新渲染组件。\n\n尤其当被更新的引用类型数据需要依赖之前的数据时，容易踩坑,不触发更新。更新复杂 state 的时候必须传给它一个全新的对象，而不是复制了它引用地址再修改的对象。\n\n两种解决办法：\n\n1. 结合展开运算符返回一个新对象\n\n   ```jsx\n   function nextValue(preValue) {\n     let ipValue = Number.parseInt(newVal, 10);\n\n     if (Number.isNaN(ipValue)) {\n       ipValue = undefined;\n     }\n     if (ipValue < 0) {\n       ipValue = 0;\n     }\n     if (ipValue > 255) {\n       ipValue = 255;\n     }\n     preValue[index] = ipValue; //这里数据引用地址的值同样被修改\n     return [...preValue]; // 数据最外层的引用地址不同即可触发组件更新\n   }\n\n   setValue((preValue) => nextValue(preValue));\n   ```\n\n2. 深拷贝对象，用全新的副本更新数据。\n\n   ```jsx\n   function nextValue(preValue) {\n     const newValue = _.cloneDeep(preValue);\n     let ipValue = Number.parseInt(newVal, 10);\n\n     if (Number.isNaN(ipValue)) {\n       ipValue = undefined;\n     }\n     if (ipValue < 0) {\n       ipValue = 0;\n     }\n     if (ipValue > 255) {\n       ipValue = 255;\n     }\n     newValue[index] = ipValue; //这里数据引用地址的值同样被修改\n     return newValue; // 数据最外层的引用地址不同即可触发组件更新\n   }\n\n   setValue((preValue) => nextValue(preValue));\n   ```\n","source":"_posts/4.useState 引用类型数据更新不触发重新渲染问题.md","raw":"---\ntitle: useState 引用类型数据更新不触发重新渲染问题\ntags: HooK\nindex_img: /img/2022-01-14-1.png\ncategories: React\nabbrlink: b195fb80\ndate: 2022-01-14 10:24:50\n---\n\n## useState 函数式更新\n\n与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。\n\n```jsx\nconst [state, setState] = useState({});\nsetState((prevState) => {\n  // 也可以使用 Object.assign\n  return { ...prevState, ...updatedValues };\n});\n```\n\n## 引用类型 state 更新\n\n经常 state 数据不是简单数据类型(值类型)，而是数组、对象之类(引用类型).而 React 组件的更新机制对 state\n只进行浅对比，也就是更新某个复杂类型数据时只要它的引用地址没变，那就不会重新渲染组件。\n\n尤其当被更新的引用类型数据需要依赖之前的数据时，容易踩坑,不触发更新。更新复杂 state 的时候必须传给它一个全新的对象，而不是复制了它引用地址再修改的对象。\n\n两种解决办法：\n\n1. 结合展开运算符返回一个新对象\n\n   ```jsx\n   function nextValue(preValue) {\n     let ipValue = Number.parseInt(newVal, 10);\n\n     if (Number.isNaN(ipValue)) {\n       ipValue = undefined;\n     }\n     if (ipValue < 0) {\n       ipValue = 0;\n     }\n     if (ipValue > 255) {\n       ipValue = 255;\n     }\n     preValue[index] = ipValue; //这里数据引用地址的值同样被修改\n     return [...preValue]; // 数据最外层的引用地址不同即可触发组件更新\n   }\n\n   setValue((preValue) => nextValue(preValue));\n   ```\n\n2. 深拷贝对象，用全新的副本更新数据。\n\n   ```jsx\n   function nextValue(preValue) {\n     const newValue = _.cloneDeep(preValue);\n     let ipValue = Number.parseInt(newVal, 10);\n\n     if (Number.isNaN(ipValue)) {\n       ipValue = undefined;\n     }\n     if (ipValue < 0) {\n       ipValue = 0;\n     }\n     if (ipValue > 255) {\n       ipValue = 255;\n     }\n     newValue[index] = ipValue; //这里数据引用地址的值同样被修改\n     return newValue; // 数据最外层的引用地址不同即可触发组件更新\n   }\n\n   setValue((preValue) => nextValue(preValue));\n   ```\n","slug":"4-useState-引用类型数据更新不触发重新渲染问题","published":1,"updated":"2022-08-23T02:19:23.471Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn41001hyu3ldmkt88ky","content":"<h2 id=\"useState-函数式更新\"><a href=\"#useState-函数式更新\" class=\"headerlink\" title=\"useState 函数式更新\"></a>useState 函数式更新</h2><p>与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> [state, setState] = useState(&#123;&#125;);\nsetState(<span class=\"hljs-function\">(<span class=\"hljs-params\">prevState</span>) =&gt;</span> &#123;\n  <span class=\"hljs-comment\">// 也可以使用 Object.assign</span>\n  <span class=\"hljs-keyword\">return</span> &#123; ...prevState, ...updatedValues &#125;;\n&#125;);</code></pre></div>\n\n<h2 id=\"引用类型-state-更新\"><a href=\"#引用类型-state-更新\" class=\"headerlink\" title=\"引用类型 state 更新\"></a>引用类型 state 更新</h2><p>经常 state 数据不是简单数据类型(值类型)，而是数组、对象之类(引用类型).而 React 组件的更新机制对 state<br>只进行浅对比，也就是更新某个复杂类型数据时只要它的引用地址没变，那就不会重新渲染组件。</p>\n<p>尤其当被更新的引用类型数据需要依赖之前的数据时，容易踩坑,不触发更新。更新复杂 state 的时候必须传给它一个全新的对象，而不是复制了它引用地址再修改的对象。</p>\n<p>两种解决办法：</p>\n<ol>\n<li><p>结合展开运算符返回一个新对象</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">nextValue</span>(<span class=\"hljs-params\">preValue</span>) </span>&#123;\n  <span class=\"hljs-keyword\">let</span> ipValue = <span class=\"hljs-built_in\">Number</span>.parseInt(newVal, <span class=\"hljs-number\">10</span>);\n\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Number</span>.isNaN(ipValue)) &#123;\n    ipValue = <span class=\"hljs-literal\">undefined</span>;\n  &#125;\n  <span class=\"hljs-keyword\">if</span> (ipValue &lt; <span class=\"hljs-number\">0</span>) &#123;\n    ipValue = <span class=\"hljs-number\">0</span>;\n  &#125;\n  <span class=\"hljs-keyword\">if</span> (ipValue &gt; <span class=\"hljs-number\">255</span>) &#123;\n    ipValue = <span class=\"hljs-number\">255</span>;\n  &#125;\n  preValue[index] = ipValue; <span class=\"hljs-comment\">//这里数据引用地址的值同样被修改</span>\n  <span class=\"hljs-keyword\">return</span> [...preValue]; <span class=\"hljs-comment\">// 数据最外层的引用地址不同即可触发组件更新</span>\n&#125;\n\nsetValue(<span class=\"hljs-function\">(<span class=\"hljs-params\">preValue</span>) =&gt;</span> nextValue(preValue));</code></pre></div></li>\n<li><p>深拷贝对象，用全新的副本更新数据。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">nextValue</span>(<span class=\"hljs-params\">preValue</span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> newValue = _.cloneDeep(preValue);\n  <span class=\"hljs-keyword\">let</span> ipValue = <span class=\"hljs-built_in\">Number</span>.parseInt(newVal, <span class=\"hljs-number\">10</span>);\n\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Number</span>.isNaN(ipValue)) &#123;\n    ipValue = <span class=\"hljs-literal\">undefined</span>;\n  &#125;\n  <span class=\"hljs-keyword\">if</span> (ipValue &lt; <span class=\"hljs-number\">0</span>) &#123;\n    ipValue = <span class=\"hljs-number\">0</span>;\n  &#125;\n  <span class=\"hljs-keyword\">if</span> (ipValue &gt; <span class=\"hljs-number\">255</span>) &#123;\n    ipValue = <span class=\"hljs-number\">255</span>;\n  &#125;\n  newValue[index] = ipValue; <span class=\"hljs-comment\">//这里数据引用地址的值同样被修改</span>\n  <span class=\"hljs-keyword\">return</span> newValue; <span class=\"hljs-comment\">// 数据最外层的引用地址不同即可触发组件更新</span>\n&#125;\n\nsetValue(<span class=\"hljs-function\">(<span class=\"hljs-params\">preValue</span>) =&gt;</span> nextValue(preValue));</code></pre></div></li>\n</ol>\n","site":{"data":{}},"wordcount":1182,"excerpt":"","more":"<h2 id=\"useState-函数式更新\"><a href=\"#useState-函数式更新\" class=\"headerlink\" title=\"useState 函数式更新\"></a>useState 函数式更新</h2><p>与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> [state, setState] = useState(&#123;&#125;);\nsetState(<span class=\"hljs-function\">(<span class=\"hljs-params\">prevState</span>) =&gt;</span> &#123;\n  <span class=\"hljs-comment\">// 也可以使用 Object.assign</span>\n  <span class=\"hljs-keyword\">return</span> &#123; ...prevState, ...updatedValues &#125;;\n&#125;);</code></pre>\n\n<h2 id=\"引用类型-state-更新\"><a href=\"#引用类型-state-更新\" class=\"headerlink\" title=\"引用类型 state 更新\"></a>引用类型 state 更新</h2><p>经常 state 数据不是简单数据类型(值类型)，而是数组、对象之类(引用类型).而 React 组件的更新机制对 state<br>只进行浅对比，也就是更新某个复杂类型数据时只要它的引用地址没变，那就不会重新渲染组件。</p>\n<p>尤其当被更新的引用类型数据需要依赖之前的数据时，容易踩坑,不触发更新。更新复杂 state 的时候必须传给它一个全新的对象，而不是复制了它引用地址再修改的对象。</p>\n<p>两种解决办法：</p>\n<ol>\n<li><p>结合展开运算符返回一个新对象</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">nextValue</span>(<span class=\"hljs-params\">preValue</span>) </span>&#123;\n  <span class=\"hljs-keyword\">let</span> ipValue = <span class=\"hljs-built_in\">Number</span>.parseInt(newVal, <span class=\"hljs-number\">10</span>);\n\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Number</span>.isNaN(ipValue)) &#123;\n    ipValue = <span class=\"hljs-literal\">undefined</span>;\n  &#125;\n  <span class=\"hljs-keyword\">if</span> (ipValue &lt; <span class=\"hljs-number\">0</span>) &#123;\n    ipValue = <span class=\"hljs-number\">0</span>;\n  &#125;\n  <span class=\"hljs-keyword\">if</span> (ipValue &gt; <span class=\"hljs-number\">255</span>) &#123;\n    ipValue = <span class=\"hljs-number\">255</span>;\n  &#125;\n  preValue[index] = ipValue; <span class=\"hljs-comment\">//这里数据引用地址的值同样被修改</span>\n  <span class=\"hljs-keyword\">return</span> [...preValue]; <span class=\"hljs-comment\">// 数据最外层的引用地址不同即可触发组件更新</span>\n&#125;\n\nsetValue(<span class=\"hljs-function\">(<span class=\"hljs-params\">preValue</span>) =&gt;</span> nextValue(preValue));</code></pre></li>\n<li><p>深拷贝对象，用全新的副本更新数据。</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">nextValue</span>(<span class=\"hljs-params\">preValue</span>) </span>&#123;\n  <span class=\"hljs-keyword\">const</span> newValue = _.cloneDeep(preValue);\n  <span class=\"hljs-keyword\">let</span> ipValue = <span class=\"hljs-built_in\">Number</span>.parseInt(newVal, <span class=\"hljs-number\">10</span>);\n\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Number</span>.isNaN(ipValue)) &#123;\n    ipValue = <span class=\"hljs-literal\">undefined</span>;\n  &#125;\n  <span class=\"hljs-keyword\">if</span> (ipValue &lt; <span class=\"hljs-number\">0</span>) &#123;\n    ipValue = <span class=\"hljs-number\">0</span>;\n  &#125;\n  <span class=\"hljs-keyword\">if</span> (ipValue &gt; <span class=\"hljs-number\">255</span>) &#123;\n    ipValue = <span class=\"hljs-number\">255</span>;\n  &#125;\n  newValue[index] = ipValue; <span class=\"hljs-comment\">//这里数据引用地址的值同样被修改</span>\n  <span class=\"hljs-keyword\">return</span> newValue; <span class=\"hljs-comment\">// 数据最外层的引用地址不同即可触发组件更新</span>\n&#125;\n\nsetValue(<span class=\"hljs-function\">(<span class=\"hljs-params\">preValue</span>) =&gt;</span> nextValue(preValue));</code></pre></li>\n</ol>\n"},{"title":"如何在 class 组件中使用 hooks","index_img":"/img/2022-01-14-2.png","abbrlink":"ee7a9294","date":"2022-01-14T03:03:28.000Z","_content":"\n解决办法\n\n以一个简单的 `useScreenWidthhook` 函数为例，它的目的是获取全屏的宽度，并且去监听浏览器窗口的变化，更新宽度：\n\n```jsx\nimport { useEffect, useState } from \"react\";\n\nexport function useScreenWidth(): number {\n  const [width, setWidth] = useState(window.innerWidth);\n\n  useEffect(() => {\n    const handler = (event: any) => {\n      setWidth(event.target.innerWidth);\n    };\n    // 监听浏览器窗口变化\n    window.addEventListener(\"resize\", handler);\n    // 组件unmount时要解除监听\n    return () => {\n      window.removeEventListener(\"resize\", handler);\n    };\n  }, []);\n\n  return width;\n}\n```\n\n## 方法 1：将 Hook 包装成 HOC\n\nHOC 是 React 中复用组件的高级用法，它的本质是一个函数，它的输入参数是一个组件，返回相同的组件以及一些额外的 props。在我们的例子里，可以让 hook 函数作为 props\n传递到目标组件中:\n\n```jsx\nimport React from \"react\";\nimport { useScreenWidth } from \"../hooks/useScreenWidth\";\n\nexport const withHooksHOC = (Component: any) => {\n  return (props: any) => {\n    const screenWidth = useScreenWidth();\n\n    return <Component width={screenWidth} {...props} />;\n  };\n};\n```\n\n将我们的目标组件用上述的 withHooksHOC 包装起来\n\n```jsx\nimport React from \"react\";\nimport { withHooksHOC } from \"./withHooksHOC\";\n\ninterface IHooksHOCProps {\n  width: number;\n}\n\nclass HooksHOC extends React.Component<IHooksHOCProps> {\n  render() {\n    return <p>width: {this.props.width}</p>;\n  }\n}\n\nexport default withHooksHOC(HooksHOC);\n```\n\n## 方法 2：将 Hook 包装成函数组件\n\n将 hook 变成函数组件，它接收一个参数为 width 的 children 函数，然后将 width 作为 render prop 传递：\n\n```jsx\nimport { FunctionComponent } from \"react\";\nimport { useScreenWidth } from \"../hooks/useScreenWidth\";\n\ntype ScreenWidthChildren = (screenWidth: number) => React.ReactNode;\n\ninterface IScreenWidthProps {\n  children: ScreenWidthChildren;\n}\n\nexport const ScreenWidth: FunctionComponent<IScreenWidthProps> = ({ children }) => {\n  const screenWidth: number = useScreenWidth();\n\n  return children(screenWidth);\n};\n```\n\n使用：\n\n```jsx\nimport React from \"react\";\nimport { ScreenWidth } from \"./ScreenWidth\";\n\nexport class HooksRenderProps extends React.Component {\n  render() {\n    return <ScreenWidth>{(width) => <p style={{ fontSize: \"48px\" }}>width: {width}</p>}</ScreenWidth>;\n  }\n}\n```\n","source":"_posts/5.如何在 class 组件中使用 hooks.md","raw":"---\ntitle: 如何在 class 组件中使用 hooks\nindex_img: /img/2022-01-14-2.png\ntags: HooK\ncategories: React\nabbrlink: ee7a9294\ndate: 2022-01-14 11:03:28\n---\n\n解决办法\n\n以一个简单的 `useScreenWidthhook` 函数为例，它的目的是获取全屏的宽度，并且去监听浏览器窗口的变化，更新宽度：\n\n```jsx\nimport { useEffect, useState } from \"react\";\n\nexport function useScreenWidth(): number {\n  const [width, setWidth] = useState(window.innerWidth);\n\n  useEffect(() => {\n    const handler = (event: any) => {\n      setWidth(event.target.innerWidth);\n    };\n    // 监听浏览器窗口变化\n    window.addEventListener(\"resize\", handler);\n    // 组件unmount时要解除监听\n    return () => {\n      window.removeEventListener(\"resize\", handler);\n    };\n  }, []);\n\n  return width;\n}\n```\n\n## 方法 1：将 Hook 包装成 HOC\n\nHOC 是 React 中复用组件的高级用法，它的本质是一个函数，它的输入参数是一个组件，返回相同的组件以及一些额外的 props。在我们的例子里，可以让 hook 函数作为 props\n传递到目标组件中:\n\n```jsx\nimport React from \"react\";\nimport { useScreenWidth } from \"../hooks/useScreenWidth\";\n\nexport const withHooksHOC = (Component: any) => {\n  return (props: any) => {\n    const screenWidth = useScreenWidth();\n\n    return <Component width={screenWidth} {...props} />;\n  };\n};\n```\n\n将我们的目标组件用上述的 withHooksHOC 包装起来\n\n```jsx\nimport React from \"react\";\nimport { withHooksHOC } from \"./withHooksHOC\";\n\ninterface IHooksHOCProps {\n  width: number;\n}\n\nclass HooksHOC extends React.Component<IHooksHOCProps> {\n  render() {\n    return <p>width: {this.props.width}</p>;\n  }\n}\n\nexport default withHooksHOC(HooksHOC);\n```\n\n## 方法 2：将 Hook 包装成函数组件\n\n将 hook 变成函数组件，它接收一个参数为 width 的 children 函数，然后将 width 作为 render prop 传递：\n\n```jsx\nimport { FunctionComponent } from \"react\";\nimport { useScreenWidth } from \"../hooks/useScreenWidth\";\n\ntype ScreenWidthChildren = (screenWidth: number) => React.ReactNode;\n\ninterface IScreenWidthProps {\n  children: ScreenWidthChildren;\n}\n\nexport const ScreenWidth: FunctionComponent<IScreenWidthProps> = ({ children }) => {\n  const screenWidth: number = useScreenWidth();\n\n  return children(screenWidth);\n};\n```\n\n使用：\n\n```jsx\nimport React from \"react\";\nimport { ScreenWidth } from \"./ScreenWidth\";\n\nexport class HooksRenderProps extends React.Component {\n  render() {\n    return <ScreenWidth>{(width) => <p style={{ fontSize: \"48px\" }}>width: {width}</p>}</ScreenWidth>;\n  }\n}\n```\n","slug":"5-如何在-class-组件中使用-hooks","published":1,"updated":"2022-08-23T02:19:23.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn41001kyu3l8bqh41w5","content":"<p>解决办法</p>\n<p>以一个简单的 <code>useScreenWidthhook</code> 函数为例，它的目的是获取全屏的宽度，并且去监听浏览器窗口的变化，更新宽度：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; useEffect, useState &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useScreenWidth</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">number</span> </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [width, setWidth] = useState(<span class=\"hljs-built_in\">window</span>.innerWidth);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> handler = <span class=\"hljs-function\">(<span class=\"hljs-params\">event: any</span>) =&gt;</span> &#123;\n      setWidth(event.target.innerWidth);\n    &#125;;\n    <span class=\"hljs-comment\">// 监听浏览器窗口变化</span>\n    <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">&quot;resize&quot;</span>, handler);\n    <span class=\"hljs-comment\">// 组件unmount时要解除监听</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">window</span>.removeEventListener(<span class=\"hljs-string\">&quot;resize&quot;</span>, handler);\n    &#125;;\n  &#125;, []);\n\n  <span class=\"hljs-keyword\">return</span> width;\n&#125;</code></pre></div>\n\n<h2 id=\"方法-1：将-Hook-包装成-HOC\"><a href=\"#方法-1：将-Hook-包装成-HOC\" class=\"headerlink\" title=\"方法 1：将 Hook 包装成 HOC\"></a>方法 1：将 Hook 包装成 HOC</h2><p>HOC 是 React 中复用组件的高级用法，它的本质是一个函数，它的输入参数是一个组件，返回相同的组件以及一些额外的 props。在我们的例子里，可以让 hook 函数作为 props<br>传递到目标组件中:</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> &#123; useScreenWidth &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../hooks/useScreenWidth&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> withHooksHOC = <span class=\"hljs-function\">(<span class=\"hljs-params\">Component: any</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">props: any</span>) =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> screenWidth = useScreenWidth();\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Component</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&#123;screenWidth&#125;</span> &#123;<span class=\"hljs-attr\">...props</span>&#125; /&gt;</span></span>;\n  &#125;;\n&#125;;</code></pre></div>\n\n<p>将我们的目标组件用上述的 withHooksHOC 包装起来</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> &#123; withHooksHOC &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./withHooksHOC&quot;</span>;\n\ninterface IHooksHOCProps &#123;\n  <span class=\"hljs-attr\">width</span>: number;\n&#125;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HooksHOC</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">IHooksHOCProps</span>&gt; </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>width: &#123;this.props.width&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>;\n  &#125;\n&#125;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> withHooksHOC(HooksHOC);</code></pre></div>\n\n<h2 id=\"方法-2：将-Hook-包装成函数组件\"><a href=\"#方法-2：将-Hook-包装成函数组件\" class=\"headerlink\" title=\"方法 2：将 Hook 包装成函数组件\"></a>方法 2：将 Hook 包装成函数组件</h2><p>将 hook 变成函数组件，它接收一个参数为 width 的 children 函数，然后将 width 作为 render prop 传递：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; FunctionComponent &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> &#123; useScreenWidth &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../hooks/useScreenWidth&quot;</span>;\n\ntype ScreenWidthChildren = <span class=\"hljs-function\">(<span class=\"hljs-params\">screenWidth: number</span>) =&gt;</span> React.ReactNode;\n\ninterface IScreenWidthProps &#123;\n  <span class=\"hljs-attr\">children</span>: ScreenWidthChildren;\n&#125;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> ScreenWidth: FunctionComponent&lt;IScreenWidthProps&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">&#123; children &#125;</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> screenWidth: number = useScreenWidth();\n\n  <span class=\"hljs-keyword\">return</span> children(screenWidth);\n&#125;;</code></pre></div>\n\n<p>使用：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> &#123; ScreenWidth &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./ScreenWidth&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HooksRenderProps</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ScreenWidth</span>&gt;</span>&#123;(width) =&gt; <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&#123;&#123;</span> <span class=\"hljs-attr\">fontSize:</span> &quot;<span class=\"hljs-attr\">48px</span>&quot; &#125;&#125;&gt;</span>width: &#123;width&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ScreenWidth</span>&gt;</span></span>;\n  &#125;\n&#125;</code></pre></div>\n","site":{"data":{}},"wordcount":2130,"excerpt":"","more":"<p>解决办法</p>\n<p>以一个简单的 <code>useScreenWidthhook</code> 函数为例，它的目的是获取全屏的宽度，并且去监听浏览器窗口的变化，更新宽度：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; useEffect, useState &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useScreenWidth</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">number</span> </span>&#123;\n  <span class=\"hljs-keyword\">const</span> [width, setWidth] = useState(<span class=\"hljs-built_in\">window</span>.innerWidth);\n\n  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> handler = <span class=\"hljs-function\">(<span class=\"hljs-params\">event: any</span>) =&gt;</span> &#123;\n      setWidth(event.target.innerWidth);\n    &#125;;\n    <span class=\"hljs-comment\">// 监听浏览器窗口变化</span>\n    <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">&quot;resize&quot;</span>, handler);\n    <span class=\"hljs-comment\">// 组件unmount时要解除监听</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;\n      <span class=\"hljs-built_in\">window</span>.removeEventListener(<span class=\"hljs-string\">&quot;resize&quot;</span>, handler);\n    &#125;;\n  &#125;, []);\n\n  <span class=\"hljs-keyword\">return</span> width;\n&#125;</code></pre>\n\n<h2 id=\"方法-1：将-Hook-包装成-HOC\"><a href=\"#方法-1：将-Hook-包装成-HOC\" class=\"headerlink\" title=\"方法 1：将 Hook 包装成 HOC\"></a>方法 1：将 Hook 包装成 HOC</h2><p>HOC 是 React 中复用组件的高级用法，它的本质是一个函数，它的输入参数是一个组件，返回相同的组件以及一些额外的 props。在我们的例子里，可以让 hook 函数作为 props<br>传递到目标组件中:</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> &#123; useScreenWidth &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../hooks/useScreenWidth&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> withHooksHOC = <span class=\"hljs-function\">(<span class=\"hljs-params\">Component: any</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">props: any</span>) =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> screenWidth = useScreenWidth();\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Component</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&#123;screenWidth&#125;</span> &#123;<span class=\"hljs-attr\">...props</span>&#125; /&gt;</span></span>;\n  &#125;;\n&#125;;</code></pre>\n\n<p>将我们的目标组件用上述的 withHooksHOC 包装起来</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> &#123; withHooksHOC &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./withHooksHOC&quot;</span>;\n\ninterface IHooksHOCProps &#123;\n  <span class=\"hljs-attr\">width</span>: number;\n&#125;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HooksHOC</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">IHooksHOCProps</span>&gt; </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>width: &#123;this.props.width&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>;\n  &#125;\n&#125;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> withHooksHOC(HooksHOC);</code></pre>\n\n<h2 id=\"方法-2：将-Hook-包装成函数组件\"><a href=\"#方法-2：将-Hook-包装成函数组件\" class=\"headerlink\" title=\"方法 2：将 Hook 包装成函数组件\"></a>方法 2：将 Hook 包装成函数组件</h2><p>将 hook 变成函数组件，它接收一个参数为 width 的 children 函数，然后将 width 作为 render prop 传递：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; FunctionComponent &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> &#123; useScreenWidth &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../hooks/useScreenWidth&quot;</span>;\n\ntype ScreenWidthChildren = <span class=\"hljs-function\">(<span class=\"hljs-params\">screenWidth: number</span>) =&gt;</span> React.ReactNode;\n\ninterface IScreenWidthProps &#123;\n  <span class=\"hljs-attr\">children</span>: ScreenWidthChildren;\n&#125;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> ScreenWidth: FunctionComponent&lt;IScreenWidthProps&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">&#123; children &#125;</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> screenWidth: number = useScreenWidth();\n\n  <span class=\"hljs-keyword\">return</span> children(screenWidth);\n&#125;;</code></pre>\n\n<p>使用：</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> &#123; ScreenWidth &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./ScreenWidth&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HooksRenderProps</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ScreenWidth</span>&gt;</span>&#123;(width) =&gt; <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&#123;&#123;</span> <span class=\"hljs-attr\">fontSize:</span> &quot;<span class=\"hljs-attr\">48px</span>&quot; &#125;&#125;&gt;</span>width: &#123;width&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ScreenWidth</span>&gt;</span></span>;\n  &#125;\n&#125;</code></pre>\n"},{"title":"map 到底改不改变原数组","index_img":"/img/2022-01-14-3.png","abbrlink":"d177e434","date":"2022-01-14T05:53:44.000Z","_content":"\n一般认为 map 不会对原数组进行修改，但事实并不是如此。\n\n## 数组内为基础类型数据时,原数组不变\n\n```js\nlet array = [1, 2, 3, 4, 5];\nlet newArray = array.map((item) => item * 2);\nconsole.log(array); // [1,2,3,4,5]\nconsole.log(newArray); //[2, 4, 6, 8, 10]\n```\n\n## 数据内是引用类型数据时，注意写法\n\n1. item 上直接修改，改变原数组\n\n   ```js\n   let array = [\n     { name: \"Anna\", age: 16 },\n     { name: \"James\", age: 18 }\n   ];\n   let newArray = array.map((item) => {\n     item.like = \"eat\";\n     return item;\n   });\n   console.log(array); // [{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}]\n   console.log(newArray); //[{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}]\n   ```\n\n2. 开辟新的引用地址, 不改变原数组\n\n   ```js\n   let array = [\n     { name: \"Anna\", age: 16 },\n     { name: \"James\", age: 18 }\n   ];\n   let newArray = array.map((item) => {\n     const obj = { ...item, like: \"eat\" };\n     return obj;\n   });\n   console.log(array); // [{ name: 'Anna', age: 16},{ name: 'James', age: 18}]\n   console.log(newArray); //[{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}]\n   ```\n","source":"_posts/6.map 到底改不改变原数组.md","raw":"---\ntitle: map 到底改不改变原数组\nindex_img: /img/2022-01-14-3.png\ntags: map\ncategories: JS\nabbrlink: d177e434\ndate: 2022-01-14 13:53:44\n---\n\n一般认为 map 不会对原数组进行修改，但事实并不是如此。\n\n## 数组内为基础类型数据时,原数组不变\n\n```js\nlet array = [1, 2, 3, 4, 5];\nlet newArray = array.map((item) => item * 2);\nconsole.log(array); // [1,2,3,4,5]\nconsole.log(newArray); //[2, 4, 6, 8, 10]\n```\n\n## 数据内是引用类型数据时，注意写法\n\n1. item 上直接修改，改变原数组\n\n   ```js\n   let array = [\n     { name: \"Anna\", age: 16 },\n     { name: \"James\", age: 18 }\n   ];\n   let newArray = array.map((item) => {\n     item.like = \"eat\";\n     return item;\n   });\n   console.log(array); // [{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}]\n   console.log(newArray); //[{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}]\n   ```\n\n2. 开辟新的引用地址, 不改变原数组\n\n   ```js\n   let array = [\n     { name: \"Anna\", age: 16 },\n     { name: \"James\", age: 18 }\n   ];\n   let newArray = array.map((item) => {\n     const obj = { ...item, like: \"eat\" };\n     return obj;\n   });\n   console.log(array); // [{ name: 'Anna', age: 16},{ name: 'James', age: 18}]\n   console.log(newArray); //[{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}]\n   ```\n","slug":"6-map-到底改不改变原数组","published":1,"updated":"2022-08-23T02:19:23.468Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn42001oyu3lfr5p2jmn","content":"<p>一般认为 map 不会对原数组进行修改，但事实并不是如此。</p>\n<h2 id=\"数组内为基础类型数据时-原数组不变\"><a href=\"#数组内为基础类型数据时-原数组不变\" class=\"headerlink\" title=\"数组内为基础类型数据时,原数组不变\"></a>数组内为基础类型数据时,原数组不变</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> array = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];\n<span class=\"hljs-keyword\">let</span> newArray = array.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> item * <span class=\"hljs-number\">2</span>);\n<span class=\"hljs-built_in\">console</span>.log(array); <span class=\"hljs-comment\">// [1,2,3,4,5]</span>\n<span class=\"hljs-built_in\">console</span>.log(newArray); <span class=\"hljs-comment\">//[2, 4, 6, 8, 10]</span></code></pre></div>\n\n<h2 id=\"数据内是引用类型数据时，注意写法\"><a href=\"#数据内是引用类型数据时，注意写法\" class=\"headerlink\" title=\"数据内是引用类型数据时，注意写法\"></a>数据内是引用类型数据时，注意写法</h2><ol>\n<li><p>item 上直接修改，改变原数组</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> array = [\n  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Anna&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">16</span> &#125;,\n  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;James&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span> &#125;\n];\n<span class=\"hljs-keyword\">let</span> newArray = array.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> &#123;\n  item.like = <span class=\"hljs-string\">&quot;eat&quot;</span>;\n  <span class=\"hljs-keyword\">return</span> item;\n&#125;);\n<span class=\"hljs-built_in\">console</span>.log(array); <span class=\"hljs-comment\">// [&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span>\n<span class=\"hljs-built_in\">console</span>.log(newArray); <span class=\"hljs-comment\">//[&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span></code></pre></div></li>\n<li><p>开辟新的引用地址, 不改变原数组</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> array = [\n  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Anna&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">16</span> &#125;,\n  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;James&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span> &#125;\n];\n<span class=\"hljs-keyword\">let</span> newArray = array.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> obj = &#123; ...item, <span class=\"hljs-attr\">like</span>: <span class=\"hljs-string\">&quot;eat&quot;</span> &#125;;\n  <span class=\"hljs-keyword\">return</span> obj;\n&#125;);\n<span class=\"hljs-built_in\">console</span>.log(array); <span class=\"hljs-comment\">// [&#123; name: &#x27;Anna&#x27;, age: 16&#125;,&#123; name: &#x27;James&#x27;, age: 18&#125;]</span>\n<span class=\"hljs-built_in\">console</span>.log(newArray); <span class=\"hljs-comment\">//[&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span></code></pre></div></li>\n</ol>\n","site":{"data":{}},"wordcount":1151,"excerpt":"","more":"<p>一般认为 map 不会对原数组进行修改，但事实并不是如此。</p>\n<h2 id=\"数组内为基础类型数据时-原数组不变\"><a href=\"#数组内为基础类型数据时-原数组不变\" class=\"headerlink\" title=\"数组内为基础类型数据时,原数组不变\"></a>数组内为基础类型数据时,原数组不变</h2><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> array = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];\n<span class=\"hljs-keyword\">let</span> newArray = array.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> item * <span class=\"hljs-number\">2</span>);\n<span class=\"hljs-built_in\">console</span>.log(array); <span class=\"hljs-comment\">// [1,2,3,4,5]</span>\n<span class=\"hljs-built_in\">console</span>.log(newArray); <span class=\"hljs-comment\">//[2, 4, 6, 8, 10]</span></code></pre>\n\n<h2 id=\"数据内是引用类型数据时，注意写法\"><a href=\"#数据内是引用类型数据时，注意写法\" class=\"headerlink\" title=\"数据内是引用类型数据时，注意写法\"></a>数据内是引用类型数据时，注意写法</h2><ol>\n<li><p>item 上直接修改，改变原数组</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> array = [\n  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Anna&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">16</span> &#125;,\n  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;James&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span> &#125;\n];\n<span class=\"hljs-keyword\">let</span> newArray = array.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> &#123;\n  item.like = <span class=\"hljs-string\">&quot;eat&quot;</span>;\n  <span class=\"hljs-keyword\">return</span> item;\n&#125;);\n<span class=\"hljs-built_in\">console</span>.log(array); <span class=\"hljs-comment\">// [&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span>\n<span class=\"hljs-built_in\">console</span>.log(newArray); <span class=\"hljs-comment\">//[&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span></code></pre></li>\n<li><p>开辟新的引用地址, 不改变原数组</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> array = [\n  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Anna&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">16</span> &#125;,\n  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;James&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span> &#125;\n];\n<span class=\"hljs-keyword\">let</span> newArray = array.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">const</span> obj = &#123; ...item, <span class=\"hljs-attr\">like</span>: <span class=\"hljs-string\">&quot;eat&quot;</span> &#125;;\n  <span class=\"hljs-keyword\">return</span> obj;\n&#125;);\n<span class=\"hljs-built_in\">console</span>.log(array); <span class=\"hljs-comment\">// [&#123; name: &#x27;Anna&#x27;, age: 16&#125;,&#123; name: &#x27;James&#x27;, age: 18&#125;]</span>\n<span class=\"hljs-built_in\">console</span>.log(newArray); <span class=\"hljs-comment\">//[&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span></code></pre></li>\n</ol>\n"},{"title":"VS Code 配置","index_img":"/img/2022-02-06-1.png","abbrlink":"1ad5be0d","date":"2022-02-06T15:30:46.000Z","_content":"\n## console.log 快捷输入\n\n打开 `文件 --> 首选项 --> 用户片段`\n\n在输入框中输入markdown，可以找到markdown.json的代码片段配置 放开 example 注释\n\n```js\n\"Print to console\": {\n  \"prefix\": \"log\",\n  \"body\": [\n   \"console.log('$1');\",\n   \"$2\"\n  ],\n  \"description\": \"Log output to console\"\n },\n```\n\n## markdown 代码段快捷输入\n\n同上 在 markdown.json 中继续配置如下\n\n````js\n\"Print to ```js\": {\n  \"prefix\": \"```js\",\n  \"body\": [\n   \"```js\",\n   \"$1\",\n   \"```\",\n  ],\n  \"description\": \"js代码片段\"\n },\n \"Print to ```jsx\": {\n  \"prefix\": \"```jsx\",\n  \"body\": [\n   \"```jsx\",\n   \"$1\",\n   \"```\",\n  ],\n  \"description\": \"jsx代码片段\"\n },\n````\n\n配置添加后，markdown 中输入 ```js 并没有快捷提示 还需要在 setting.json 中添加如下配置\n\nsetting.json 打开位置：打开vs code的设置，文件 --> 首选项 --> 设置 --> 打开设置（在设置的右上角）\n\n```js\n\"[markdown]\":{\n    \"editor.quickSuggestions\": true\n}\n```\n","source":"_posts/8.VS Code 配置.md","raw":"---\ntitle: VS Code 配置\nindex_img: /img/2022-02-06-1.png\nabbrlink: 1ad5be0d\ndate: 2022-02-06 23:30:46\ntags: vscode\ncategories: vscode\n---\n\n## console.log 快捷输入\n\n打开 `文件 --> 首选项 --> 用户片段`\n\n在输入框中输入markdown，可以找到markdown.json的代码片段配置 放开 example 注释\n\n```js\n\"Print to console\": {\n  \"prefix\": \"log\",\n  \"body\": [\n   \"console.log('$1');\",\n   \"$2\"\n  ],\n  \"description\": \"Log output to console\"\n },\n```\n\n## markdown 代码段快捷输入\n\n同上 在 markdown.json 中继续配置如下\n\n````js\n\"Print to ```js\": {\n  \"prefix\": \"```js\",\n  \"body\": [\n   \"```js\",\n   \"$1\",\n   \"```\",\n  ],\n  \"description\": \"js代码片段\"\n },\n \"Print to ```jsx\": {\n  \"prefix\": \"```jsx\",\n  \"body\": [\n   \"```jsx\",\n   \"$1\",\n   \"```\",\n  ],\n  \"description\": \"jsx代码片段\"\n },\n````\n\n配置添加后，markdown 中输入 ```js 并没有快捷提示 还需要在 setting.json 中添加如下配置\n\nsetting.json 打开位置：打开vs code的设置，文件 --> 首选项 --> 设置 --> 打开设置（在设置的右上角）\n\n```js\n\"[markdown]\":{\n    \"editor.quickSuggestions\": true\n}\n```\n","slug":"8-VS-Code-配置","published":1,"updated":"2022-08-23T02:19:23.472Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn4d002iyu3l1w079pp5","content":"<h2 id=\"console-log-快捷输入\"><a href=\"#console-log-快捷输入\" class=\"headerlink\" title=\"console.log 快捷输入\"></a>console.log 快捷输入</h2><p>打开 <code>文件 --&gt; 首选项 --&gt; 用户片段</code></p>\n<p>在输入框中输入markdown，可以找到markdown.json的代码片段配置 放开 example 注释</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-string\">&quot;Print to console&quot;</span>: &#123;\n  <span class=\"hljs-string\">&quot;prefix&quot;</span>: <span class=\"hljs-string\">&quot;log&quot;</span>,\n  <span class=\"hljs-string\">&quot;body&quot;</span>: [\n   <span class=\"hljs-string\">&quot;console.log(&#x27;$1&#x27;);&quot;</span>,\n   <span class=\"hljs-string\">&quot;$2&quot;</span>\n  ],\n  <span class=\"hljs-string\">&quot;description&quot;</span>: <span class=\"hljs-string\">&quot;Log output to console&quot;</span>\n &#125;,</code></pre></div>\n\n<h2 id=\"markdown-代码段快捷输入\"><a href=\"#markdown-代码段快捷输入\" class=\"headerlink\" title=\"markdown 代码段快捷输入\"></a>markdown 代码段快捷输入</h2><p>同上 在 markdown.json 中继续配置如下</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-string\">&quot;Print to ```js&quot;</span>: &#123;\n  <span class=\"hljs-string\">&quot;prefix&quot;</span>: <span class=\"hljs-string\">&quot;```js&quot;</span>,\n  <span class=\"hljs-string\">&quot;body&quot;</span>: [\n   <span class=\"hljs-string\">&quot;```js&quot;</span>,\n   <span class=\"hljs-string\">&quot;$1&quot;</span>,\n   <span class=\"hljs-string\">&quot;```&quot;</span>,\n  ],\n  <span class=\"hljs-string\">&quot;description&quot;</span>: <span class=\"hljs-string\">&quot;js代码片段&quot;</span>\n &#125;,\n <span class=\"hljs-string\">&quot;Print to ```jsx&quot;</span>: &#123;\n  <span class=\"hljs-string\">&quot;prefix&quot;</span>: <span class=\"hljs-string\">&quot;```jsx&quot;</span>,\n  <span class=\"hljs-string\">&quot;body&quot;</span>: [\n   <span class=\"hljs-string\">&quot;```jsx&quot;</span>,\n   <span class=\"hljs-string\">&quot;$1&quot;</span>,\n   <span class=\"hljs-string\">&quot;```&quot;</span>,\n  ],\n  <span class=\"hljs-string\">&quot;description&quot;</span>: <span class=\"hljs-string\">&quot;jsx代码片段&quot;</span>\n &#125;,</code></pre></div>\n\n<p>配置添加后，markdown 中输入 ```js 并没有快捷提示 还需要在 setting.json 中添加如下配置</p>\n<p>setting.json 打开位置：打开vs code的设置，文件 –&gt; 首选项 –&gt; 设置 –&gt; 打开设置（在设置的右上角）</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-string\">&quot;[markdown]&quot;</span>:&#123;\n    <span class=\"hljs-string\">&quot;editor.quickSuggestions&quot;</span>: <span class=\"hljs-literal\">true</span>\n&#125;</code></pre></div>\n","site":{"data":{}},"wordcount":898,"excerpt":"","more":"<h2 id=\"console-log-快捷输入\"><a href=\"#console-log-快捷输入\" class=\"headerlink\" title=\"console.log 快捷输入\"></a>console.log 快捷输入</h2><p>打开 <code>文件 --&gt; 首选项 --&gt; 用户片段</code></p>\n<p>在输入框中输入markdown，可以找到markdown.json的代码片段配置 放开 example 注释</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-string\">&quot;Print to console&quot;</span>: &#123;\n  <span class=\"hljs-string\">&quot;prefix&quot;</span>: <span class=\"hljs-string\">&quot;log&quot;</span>,\n  <span class=\"hljs-string\">&quot;body&quot;</span>: [\n   <span class=\"hljs-string\">&quot;console.log(&#x27;$1&#x27;);&quot;</span>,\n   <span class=\"hljs-string\">&quot;$2&quot;</span>\n  ],\n  <span class=\"hljs-string\">&quot;description&quot;</span>: <span class=\"hljs-string\">&quot;Log output to console&quot;</span>\n &#125;,</code></pre>\n\n<h2 id=\"markdown-代码段快捷输入\"><a href=\"#markdown-代码段快捷输入\" class=\"headerlink\" title=\"markdown 代码段快捷输入\"></a>markdown 代码段快捷输入</h2><p>同上 在 markdown.json 中继续配置如下</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-string\">&quot;Print to ```js&quot;</span>: &#123;\n  <span class=\"hljs-string\">&quot;prefix&quot;</span>: <span class=\"hljs-string\">&quot;```js&quot;</span>,\n  <span class=\"hljs-string\">&quot;body&quot;</span>: [\n   <span class=\"hljs-string\">&quot;```js&quot;</span>,\n   <span class=\"hljs-string\">&quot;$1&quot;</span>,\n   <span class=\"hljs-string\">&quot;```&quot;</span>,\n  ],\n  <span class=\"hljs-string\">&quot;description&quot;</span>: <span class=\"hljs-string\">&quot;js代码片段&quot;</span>\n &#125;,\n <span class=\"hljs-string\">&quot;Print to ```jsx&quot;</span>: &#123;\n  <span class=\"hljs-string\">&quot;prefix&quot;</span>: <span class=\"hljs-string\">&quot;```jsx&quot;</span>,\n  <span class=\"hljs-string\">&quot;body&quot;</span>: [\n   <span class=\"hljs-string\">&quot;```jsx&quot;</span>,\n   <span class=\"hljs-string\">&quot;$1&quot;</span>,\n   <span class=\"hljs-string\">&quot;```&quot;</span>,\n  ],\n  <span class=\"hljs-string\">&quot;description&quot;</span>: <span class=\"hljs-string\">&quot;jsx代码片段&quot;</span>\n &#125;,</code></pre>\n\n<p>配置添加后，markdown 中输入 ```js 并没有快捷提示 还需要在 setting.json 中添加如下配置</p>\n<p>setting.json 打开位置：打开vs code的设置，文件 –&gt; 首选项 –&gt; 设置 –&gt; 打开设置（在设置的右上角）</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-string\">&quot;[markdown]&quot;</span>:&#123;\n    <span class=\"hljs-string\">&quot;editor.quickSuggestions&quot;</span>: <span class=\"hljs-literal\">true</span>\n&#125;</code></pre>\n"},{"title":"Vue3 学习笔记","index_img":"/img/2022-01-22-1.jpeg","abbrlink":"e372be48","date":"2022-01-22T02:46:00.000Z","_content":"\n## Vue 和 React 数据驱动原理对比\n\nVue1 解决方案是使用响应式，初始化的时候，watcher 监听数据的每个属性，数据发生变化的时候，就能够知道数据的哪个 key 变了，去修改对应的 DOM。\n\nReact 是虚拟 DOM 方案，用 JS 对象描述 DOM 树，这个对象就像数据和实际 DOM 的一个缓存层，通过管理这个对象的变化，来减少对实际 DOM 的操作。\n\n描述实际 DOM 的虚拟 DOM 对象如下：\n\nDOM:\n\n```html\n<div id=\"app\">\n  <p class=\"item\">Item1</p>\n  <div class=\"item\">Item2</div>\n</div>\n```\n\n虚拟 DOM：\n\n```js\n{\n  tag: \"div\",\n  attrs: {\n    id: \"app\"\n  },\n  children: [\n    {\n      tag: \"p\",\n      attrs: { className: \"item\" },\n      children: [\"Item1\"]\n    },\n    {\n      tag: \"div\",\n      attrs: { className: \"item\" },\n      children: [\"Item2\"]\n    }\n  ]\n}\n```\n\n数据变化的时候生成一个新的虚拟 DOM 数据，对比之前的虚拟 DOM 进行 diff 计算，算出要修改的 DOM，再对页面进行操作。\n\n通知页面更新的方式不同：\n\n- vue 中，数据变化，框架主动告诉你修改了哪些数据；\n- react 中，变化变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化\n\n性能问题：\n\n- vue 的响应式，在项目大了之后，每个数据都有一个 watcher 会影响性能\n- 如果 react 虚拟 dom 过于庞大，使得 diff 计算时间大于 16.6 ms(屏幕刷新率 60HZ, 1/60)，可能造成性能卡顿。\n\n为了解决性能问题， Vue 和 react 走了不同的道路。\n\n- react 借鉴操作系统时间分片概念，引入 Fiber 架构。把整个虚拟 DOM 树 微观化，变成链表，然后利用浏览器的空闲时间计算 diff。\n- vue1 的问题在于响应式数据过多，会带来内存占用过多的问题。vue2 引入虚拟 DOM 来解决响应式数据过多问题。\n\n响应式数据是主动推送变化，虚拟 DOM 是被动计算数据的 diff。vue2 将两者结合在一起，在组件级别来划分。\n\n组件间的变化，通过响应式来通知更新。组件内部的数据变化，通过虚拟 DOM 去更新页面。最终，把响应式监听器控制在组件级别，而虚拟 DOM 的量级控制在组件的大小。\n\n在模板书写上，vue 和 react 分别走了 template 和 jsx 两个路线。\n\n- react 世界只有 jsx，最终 jsx 都会在 Compiler 那层，即工程化那里编译成 js 来执行。\n- vue 默认 template。vue3 优秀的其中一点是在虚拟 DOM 的静态标记上做到了极致，让静态的部分越过虚拟 DOM 的计算，真正做到按需更新，很好的提高了性能。\n\n## Vue3 的新特性\n\n### 响应式系统\n\nVue 2 的响应式机制是基于 Object.defineProperty() 这个 API 实现的.Vue3 是基于 proxy。两者区别是 defineProperty 是拦截具体某个属性，\nProxy 是全部拦截，是代理。\n\ndefineProperty 示例如下：\n\n```js\nObject.defineProperty(obj, \"title\", {\n  get() {},\n  set() {}\n});\n```\n\n当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在\ndata 里声明。\n\n但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的\n$set。\n\nProxy API 是真正的代理，示例如下：\n\n```js\nnew Proxy(obj, {\n  get() {},\n  set() {}\n});\n```\n\nProxy 拦截 obj 这个数据，不关心 obj 里面属性，统一拦截。\n\n### 自定义渲染器\n\nvue2 内部所有模块是揉在一起，导致不好扩展。vue3 采用 monorepo 方式进行拆包，响应式、编译和运行时全部独立。独立出来的响应式，甚至可以在 react、node 中使用。\n\n![vue 架构](/img/2022-01-24-1.png)\n\n渲染逻辑拆成 **平台无关渲染逻辑** 和 **浏览器渲染 API**。\n\n### 全部模块使用 TS 重构\n\nVue2 使用 Flow.js 做类型检测；Flow.js 已被抛弃，vue3 选择 TS。\n\n### Composition API 组合语法\n\nvue2 中示例：\n\n```js\nlet App = {\n  data() {\n    return { count: 1 };\n  },\n  methods: {\n    add() {\n      this.count++;\n    }\n  },\n  computed: {\n    double() {\n      return this.count * 2;\n    }\n  }\n};\n```\n\nvue2 中 Options API 存在以下问题：\n\n- 所有数据都挂载在 this 上，Options API 写法对 TS 类型推导不友好。\n- 新增的功能基本都要修改 data、method 等，代码行数多了以后，会经常需要上下反复横跳。\n- 代码不好复用，vue2 的组件很难抽离通用逻辑，只能使用 mixin，还会导致命名冲突问题。\n\nvue3 中采用新增的 setup 写法：\n\n```js\nconst { reactive, computed } = Vue;\nlet App = {\n  setup() {\n    const state = reactive({ count: 1 });\n    function add() {\n      state.count++;\n    }\n    const double = computed(() => state.count * 2);\n    return { state, add, double };\n  }\n};\n```\n\nComposition API 好处如下：\n\n- 所有 API 都是 import 引入。对 Tree-shaking 很友好，没用到功能，打包的时候会被清理掉 ，减小包的大小\n- 一个功能模块的 methods、data 放一起书写，避免上下反复横跳。\n- 代码复用方便，一个功能的所有 methods、data 封装在一个独立的函数里。\n- Composotion API 新增的 return 等语句，在实际项目中使用。\n\n![Composition API](/img/2022-01-24-2.png)\n\n### 新的组件\n\nVue 3 还内置了 Fragment、Teleport 和 Suspense 三个新组件。\n\n- Fragment: Vue 3 组件不再要求有一个唯一的根节点，清除了很多无用的占位 div。\n- Teleport: 允许组件渲染在别的元素内，主要开发弹窗组件的时候特别有用。\n- Suspense: 异步组件，更方便开发有异步请求的组件。\n\n### 新一代工程化工具 Vite\n\nwebpack 工程化的原理是 根据 import\n依赖逻辑形成一个依赖图，然后调用对应的处理工具，把整个项目打包后，放在内存中再启动调试。因为要预打包，复杂项目开发时，启动开发环境和热更新时间都比较长，Vite 就是为了解决这个问题而出现的。\n\n现代浏览器已经默认支持 ES6 的 import 语法，Vite 就是基于这个原理实现的。\n\n在开发环境下，不需要全部预打包，只要把首页依赖的文件，依次通过网络请求去获取，开发体验得到巨大提升，做到复杂项目时，也能做到秒级调试和热更新。\n\nwebpack 工作原理如下，需要把所有路由依赖打包后，才能开始调试。\n\n![webpack 工作原理](/img/2022-01-24-3.png)\n\nVite 工作原理，根据首页的依赖模块，再去获取路由 1 的模块，按需加载。\n\n![Vite 工作原理](/img/2022-01-24-4.png)\n\n## Vue3 响应式机制\n\n响应式原理：Vue 中用过三种响应式解决方案，分别是 defineProperty、Proxy 和 value setter。\n\n---\n\ntodo: 07\n\n## Vue3 实践常见问题汇总\n\n1. vetur 报错， xx has no export.\n\n   使用 Vue3 `script setup` 语法糖时,VsCode 插件 Vetur 会报该错误，原因是 Vetur(v0.35.0) 暂不支持 ts。\n\n   解决办法： 卸载 Vetur， 用 Volar(尤大推荐) 以取代 Vetur。\n\n---\n\n上述笔记源于学习极客时间-大圣的 [玩转 Vue3 全家桶](http://gk.link/a/115Qp) 课程笔记整理。\n\n---\n","source":"_posts/7.Vue3 学习笔记.md","raw":"---\ntitle: Vue3 学习笔记\nindex_img: /img/2022-01-22-1.jpeg\ntags: Vue3\ncategories: Vue\nabbrlink: e372be48\ndate: 2022-01-22 10:46:00\n---\n\n## Vue 和 React 数据驱动原理对比\n\nVue1 解决方案是使用响应式，初始化的时候，watcher 监听数据的每个属性，数据发生变化的时候，就能够知道数据的哪个 key 变了，去修改对应的 DOM。\n\nReact 是虚拟 DOM 方案，用 JS 对象描述 DOM 树，这个对象就像数据和实际 DOM 的一个缓存层，通过管理这个对象的变化，来减少对实际 DOM 的操作。\n\n描述实际 DOM 的虚拟 DOM 对象如下：\n\nDOM:\n\n```html\n<div id=\"app\">\n  <p class=\"item\">Item1</p>\n  <div class=\"item\">Item2</div>\n</div>\n```\n\n虚拟 DOM：\n\n```js\n{\n  tag: \"div\",\n  attrs: {\n    id: \"app\"\n  },\n  children: [\n    {\n      tag: \"p\",\n      attrs: { className: \"item\" },\n      children: [\"Item1\"]\n    },\n    {\n      tag: \"div\",\n      attrs: { className: \"item\" },\n      children: [\"Item2\"]\n    }\n  ]\n}\n```\n\n数据变化的时候生成一个新的虚拟 DOM 数据，对比之前的虚拟 DOM 进行 diff 计算，算出要修改的 DOM，再对页面进行操作。\n\n通知页面更新的方式不同：\n\n- vue 中，数据变化，框架主动告诉你修改了哪些数据；\n- react 中，变化变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化\n\n性能问题：\n\n- vue 的响应式，在项目大了之后，每个数据都有一个 watcher 会影响性能\n- 如果 react 虚拟 dom 过于庞大，使得 diff 计算时间大于 16.6 ms(屏幕刷新率 60HZ, 1/60)，可能造成性能卡顿。\n\n为了解决性能问题， Vue 和 react 走了不同的道路。\n\n- react 借鉴操作系统时间分片概念，引入 Fiber 架构。把整个虚拟 DOM 树 微观化，变成链表，然后利用浏览器的空闲时间计算 diff。\n- vue1 的问题在于响应式数据过多，会带来内存占用过多的问题。vue2 引入虚拟 DOM 来解决响应式数据过多问题。\n\n响应式数据是主动推送变化，虚拟 DOM 是被动计算数据的 diff。vue2 将两者结合在一起，在组件级别来划分。\n\n组件间的变化，通过响应式来通知更新。组件内部的数据变化，通过虚拟 DOM 去更新页面。最终，把响应式监听器控制在组件级别，而虚拟 DOM 的量级控制在组件的大小。\n\n在模板书写上，vue 和 react 分别走了 template 和 jsx 两个路线。\n\n- react 世界只有 jsx，最终 jsx 都会在 Compiler 那层，即工程化那里编译成 js 来执行。\n- vue 默认 template。vue3 优秀的其中一点是在虚拟 DOM 的静态标记上做到了极致，让静态的部分越过虚拟 DOM 的计算，真正做到按需更新，很好的提高了性能。\n\n## Vue3 的新特性\n\n### 响应式系统\n\nVue 2 的响应式机制是基于 Object.defineProperty() 这个 API 实现的.Vue3 是基于 proxy。两者区别是 defineProperty 是拦截具体某个属性，\nProxy 是全部拦截，是代理。\n\ndefineProperty 示例如下：\n\n```js\nObject.defineProperty(obj, \"title\", {\n  get() {},\n  set() {}\n});\n```\n\n当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在\ndata 里声明。\n\n但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的\n$set。\n\nProxy API 是真正的代理，示例如下：\n\n```js\nnew Proxy(obj, {\n  get() {},\n  set() {}\n});\n```\n\nProxy 拦截 obj 这个数据，不关心 obj 里面属性，统一拦截。\n\n### 自定义渲染器\n\nvue2 内部所有模块是揉在一起，导致不好扩展。vue3 采用 monorepo 方式进行拆包，响应式、编译和运行时全部独立。独立出来的响应式，甚至可以在 react、node 中使用。\n\n![vue 架构](/img/2022-01-24-1.png)\n\n渲染逻辑拆成 **平台无关渲染逻辑** 和 **浏览器渲染 API**。\n\n### 全部模块使用 TS 重构\n\nVue2 使用 Flow.js 做类型检测；Flow.js 已被抛弃，vue3 选择 TS。\n\n### Composition API 组合语法\n\nvue2 中示例：\n\n```js\nlet App = {\n  data() {\n    return { count: 1 };\n  },\n  methods: {\n    add() {\n      this.count++;\n    }\n  },\n  computed: {\n    double() {\n      return this.count * 2;\n    }\n  }\n};\n```\n\nvue2 中 Options API 存在以下问题：\n\n- 所有数据都挂载在 this 上，Options API 写法对 TS 类型推导不友好。\n- 新增的功能基本都要修改 data、method 等，代码行数多了以后，会经常需要上下反复横跳。\n- 代码不好复用，vue2 的组件很难抽离通用逻辑，只能使用 mixin，还会导致命名冲突问题。\n\nvue3 中采用新增的 setup 写法：\n\n```js\nconst { reactive, computed } = Vue;\nlet App = {\n  setup() {\n    const state = reactive({ count: 1 });\n    function add() {\n      state.count++;\n    }\n    const double = computed(() => state.count * 2);\n    return { state, add, double };\n  }\n};\n```\n\nComposition API 好处如下：\n\n- 所有 API 都是 import 引入。对 Tree-shaking 很友好，没用到功能，打包的时候会被清理掉 ，减小包的大小\n- 一个功能模块的 methods、data 放一起书写，避免上下反复横跳。\n- 代码复用方便，一个功能的所有 methods、data 封装在一个独立的函数里。\n- Composotion API 新增的 return 等语句，在实际项目中使用。\n\n![Composition API](/img/2022-01-24-2.png)\n\n### 新的组件\n\nVue 3 还内置了 Fragment、Teleport 和 Suspense 三个新组件。\n\n- Fragment: Vue 3 组件不再要求有一个唯一的根节点，清除了很多无用的占位 div。\n- Teleport: 允许组件渲染在别的元素内，主要开发弹窗组件的时候特别有用。\n- Suspense: 异步组件，更方便开发有异步请求的组件。\n\n### 新一代工程化工具 Vite\n\nwebpack 工程化的原理是 根据 import\n依赖逻辑形成一个依赖图，然后调用对应的处理工具，把整个项目打包后，放在内存中再启动调试。因为要预打包，复杂项目开发时，启动开发环境和热更新时间都比较长，Vite 就是为了解决这个问题而出现的。\n\n现代浏览器已经默认支持 ES6 的 import 语法，Vite 就是基于这个原理实现的。\n\n在开发环境下，不需要全部预打包，只要把首页依赖的文件，依次通过网络请求去获取，开发体验得到巨大提升，做到复杂项目时，也能做到秒级调试和热更新。\n\nwebpack 工作原理如下，需要把所有路由依赖打包后，才能开始调试。\n\n![webpack 工作原理](/img/2022-01-24-3.png)\n\nVite 工作原理，根据首页的依赖模块，再去获取路由 1 的模块，按需加载。\n\n![Vite 工作原理](/img/2022-01-24-4.png)\n\n## Vue3 响应式机制\n\n响应式原理：Vue 中用过三种响应式解决方案，分别是 defineProperty、Proxy 和 value setter。\n\n---\n\ntodo: 07\n\n## Vue3 实践常见问题汇总\n\n1. vetur 报错， xx has no export.\n\n   使用 Vue3 `script setup` 语法糖时,VsCode 插件 Vetur 会报该错误，原因是 Vetur(v0.35.0) 暂不支持 ts。\n\n   解决办法： 卸载 Vetur， 用 Volar(尤大推荐) 以取代 Vetur。\n\n---\n\n上述笔记源于学习极客时间-大圣的 [玩转 Vue3 全家桶](http://gk.link/a/115Qp) 课程笔记整理。\n\n---\n","slug":"7-Vue3-学习笔记","published":1,"updated":"2022-08-23T02:19:23.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn4e002jyu3l3ketaj5a","content":"<h2 id=\"Vue-和-React-数据驱动原理对比\"><a href=\"#Vue-和-React-数据驱动原理对比\" class=\"headerlink\" title=\"Vue 和 React 数据驱动原理对比\"></a>Vue 和 React 数据驱动原理对比</h2><p>Vue1 解决方案是使用响应式，初始化的时候，watcher 监听数据的每个属性，数据发生变化的时候，就能够知道数据的哪个 key 变了，去修改对应的 DOM。</p>\n<p>React 是虚拟 DOM 方案，用 JS 对象描述 DOM 树，这个对象就像数据和实际 DOM 的一个缓存层，通过管理这个对象的变化，来减少对实际 DOM 的操作。</p>\n<p>描述实际 DOM 的虚拟 DOM 对象如下：</p>\n<p>DOM:</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>Item1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>Item2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre></div>\n\n<p>虚拟 DOM：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\">&#123;\n  <span class=\"hljs-attr\">tag</span>: <span class=\"hljs-string\">&quot;div&quot;</span>,\n  <span class=\"hljs-attr\">attrs</span>: &#123;\n    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">&quot;app&quot;</span>\n  &#125;,\n  <span class=\"hljs-attr\">children</span>: [\n    &#123;\n      <span class=\"hljs-attr\">tag</span>: <span class=\"hljs-string\">&quot;p&quot;</span>,\n      <span class=\"hljs-attr\">attrs</span>: &#123; <span class=\"hljs-attr\">className</span>: <span class=\"hljs-string\">&quot;item&quot;</span> &#125;,\n      <span class=\"hljs-attr\">children</span>: [<span class=\"hljs-string\">&quot;Item1&quot;</span>]\n    &#125;,\n    &#123;\n      <span class=\"hljs-attr\">tag</span>: <span class=\"hljs-string\">&quot;div&quot;</span>,\n      <span class=\"hljs-attr\">attrs</span>: &#123; <span class=\"hljs-attr\">className</span>: <span class=\"hljs-string\">&quot;item&quot;</span> &#125;,\n      <span class=\"hljs-attr\">children</span>: [<span class=\"hljs-string\">&quot;Item2&quot;</span>]\n    &#125;\n  ]\n&#125;</code></pre></div>\n\n<p>数据变化的时候生成一个新的虚拟 DOM 数据，对比之前的虚拟 DOM 进行 diff 计算，算出要修改的 DOM，再对页面进行操作。</p>\n<p>通知页面更新的方式不同：</p>\n<ul>\n<li>vue 中，数据变化，框架主动告诉你修改了哪些数据；</li>\n<li>react 中，变化变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化</li>\n</ul>\n<p>性能问题：</p>\n<ul>\n<li>vue 的响应式，在项目大了之后，每个数据都有一个 watcher 会影响性能</li>\n<li>如果 react 虚拟 dom 过于庞大，使得 diff 计算时间大于 16.6 ms(屏幕刷新率 60HZ, 1/60)，可能造成性能卡顿。</li>\n</ul>\n<p>为了解决性能问题， Vue 和 react 走了不同的道路。</p>\n<ul>\n<li>react 借鉴操作系统时间分片概念，引入 Fiber 架构。把整个虚拟 DOM 树 微观化，变成链表，然后利用浏览器的空闲时间计算 diff。</li>\n<li>vue1 的问题在于响应式数据过多，会带来内存占用过多的问题。vue2 引入虚拟 DOM 来解决响应式数据过多问题。</li>\n</ul>\n<p>响应式数据是主动推送变化，虚拟 DOM 是被动计算数据的 diff。vue2 将两者结合在一起，在组件级别来划分。</p>\n<p>组件间的变化，通过响应式来通知更新。组件内部的数据变化，通过虚拟 DOM 去更新页面。最终，把响应式监听器控制在组件级别，而虚拟 DOM 的量级控制在组件的大小。</p>\n<p>在模板书写上，vue 和 react 分别走了 template 和 jsx 两个路线。</p>\n<ul>\n<li>react 世界只有 jsx，最终 jsx 都会在 Compiler 那层，即工程化那里编译成 js 来执行。</li>\n<li>vue 默认 template。vue3 优秀的其中一点是在虚拟 DOM 的静态标记上做到了极致，让静态的部分越过虚拟 DOM 的计算，真正做到按需更新，很好的提高了性能。</li>\n</ul>\n<h2 id=\"Vue3-的新特性\"><a href=\"#Vue3-的新特性\" class=\"headerlink\" title=\"Vue3 的新特性\"></a>Vue3 的新特性</h2><h3 id=\"响应式系统\"><a href=\"#响应式系统\" class=\"headerlink\" title=\"响应式系统\"></a>响应式系统</h3><p>Vue 2 的响应式机制是基于 Object.defineProperty() 这个 API 实现的.Vue3 是基于 proxy。两者区别是 defineProperty 是拦截具体某个属性，<br>Proxy 是全部拦截，是代理。</p>\n<p>defineProperty 示例如下：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">Object</span>.defineProperty(obj, <span class=\"hljs-string\">&quot;title&quot;</span>, &#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;,\n  <span class=\"hljs-function\"><span class=\"hljs-title\">set</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;\n&#125;);</code></pre></div>\n\n<p>当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在<br>data 里声明。</p>\n<p>但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的<br>$set。</p>\n<p>Proxy API 是真正的代理，示例如下：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>(obj, &#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;,\n  <span class=\"hljs-function\"><span class=\"hljs-title\">set</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;\n&#125;);</code></pre></div>\n\n<p>Proxy 拦截 obj 这个数据，不关心 obj 里面属性，统一拦截。</p>\n<h3 id=\"自定义渲染器\"><a href=\"#自定义渲染器\" class=\"headerlink\" title=\"自定义渲染器\"></a>自定义渲染器</h3><p>vue2 内部所有模块是揉在一起，导致不好扩展。vue3 采用 monorepo 方式进行拆包，响应式、编译和运行时全部独立。独立出来的响应式，甚至可以在 react、node 中使用。</p>\n<p><img src=\"/img/2022-01-24-1.png\" alt=\"vue 架构\"></p>\n<p>渲染逻辑拆成 <strong>平台无关渲染逻辑</strong> 和 <strong>浏览器渲染 API</strong>。</p>\n<h3 id=\"全部模块使用-TS-重构\"><a href=\"#全部模块使用-TS-重构\" class=\"headerlink\" title=\"全部模块使用 TS 重构\"></a>全部模块使用 TS 重构</h3><p>Vue2 使用 Flow.js 做类型检测；Flow.js 已被抛弃，vue3 选择 TS。</p>\n<h3 id=\"Composition-API-组合语法\"><a href=\"#Composition-API-组合语法\" class=\"headerlink\" title=\"Composition API 组合语法\"></a>Composition API 组合语法</h3><p>vue2 中示例：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> App = &#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">1</span> &#125;;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-function\"><span class=\"hljs-title\">add</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n      <span class=\"hljs-built_in\">this</span>.count++;\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">computed</span>: &#123;\n    <span class=\"hljs-function\"><span class=\"hljs-title\">double</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.count * <span class=\"hljs-number\">2</span>;\n    &#125;\n  &#125;\n&#125;;</code></pre></div>\n\n<p>vue2 中 Options API 存在以下问题：</p>\n<ul>\n<li>所有数据都挂载在 this 上，Options API 写法对 TS 类型推导不友好。</li>\n<li>新增的功能基本都要修改 data、method 等，代码行数多了以后，会经常需要上下反复横跳。</li>\n<li>代码不好复用，vue2 的组件很难抽离通用逻辑，只能使用 mixin，还会导致命名冲突问题。</li>\n</ul>\n<p>vue3 中采用新增的 setup 写法：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> &#123; reactive, computed &#125; = Vue;\n<span class=\"hljs-keyword\">let</span> App = &#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">setup</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">const</span> state = reactive(&#123; <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">1</span> &#125;);\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n      state.count++;\n    &#125;\n    <span class=\"hljs-keyword\">const</span> double = computed(<span class=\"hljs-function\">() =&gt;</span> state.count * <span class=\"hljs-number\">2</span>);\n    <span class=\"hljs-keyword\">return</span> &#123; state, add, double &#125;;\n  &#125;\n&#125;;</code></pre></div>\n\n<p>Composition API 好处如下：</p>\n<ul>\n<li>所有 API 都是 import 引入。对 Tree-shaking 很友好，没用到功能，打包的时候会被清理掉 ，减小包的大小</li>\n<li>一个功能模块的 methods、data 放一起书写，避免上下反复横跳。</li>\n<li>代码复用方便，一个功能的所有 methods、data 封装在一个独立的函数里。</li>\n<li>Composotion API 新增的 return 等语句，在实际项目中使用。</li>\n</ul>\n<p><img src=\"/img/2022-01-24-2.png\" alt=\"Composition API\"></p>\n<h3 id=\"新的组件\"><a href=\"#新的组件\" class=\"headerlink\" title=\"新的组件\"></a>新的组件</h3><p>Vue 3 还内置了 Fragment、Teleport 和 Suspense 三个新组件。</p>\n<ul>\n<li>Fragment: Vue 3 组件不再要求有一个唯一的根节点，清除了很多无用的占位 div。</li>\n<li>Teleport: 允许组件渲染在别的元素内，主要开发弹窗组件的时候特别有用。</li>\n<li>Suspense: 异步组件，更方便开发有异步请求的组件。</li>\n</ul>\n<h3 id=\"新一代工程化工具-Vite\"><a href=\"#新一代工程化工具-Vite\" class=\"headerlink\" title=\"新一代工程化工具 Vite\"></a>新一代工程化工具 Vite</h3><p>webpack 工程化的原理是 根据 import<br>依赖逻辑形成一个依赖图，然后调用对应的处理工具，把整个项目打包后，放在内存中再启动调试。因为要预打包，复杂项目开发时，启动开发环境和热更新时间都比较长，Vite 就是为了解决这个问题而出现的。</p>\n<p>现代浏览器已经默认支持 ES6 的 import 语法，Vite 就是基于这个原理实现的。</p>\n<p>在开发环境下，不需要全部预打包，只要把首页依赖的文件，依次通过网络请求去获取，开发体验得到巨大提升，做到复杂项目时，也能做到秒级调试和热更新。</p>\n<p>webpack 工作原理如下，需要把所有路由依赖打包后，才能开始调试。</p>\n<p><img src=\"/img/2022-01-24-3.png\" alt=\"webpack 工作原理\"></p>\n<p>Vite 工作原理，根据首页的依赖模块，再去获取路由 1 的模块，按需加载。</p>\n<p><img src=\"/img/2022-01-24-4.png\" alt=\"Vite 工作原理\"></p>\n<h2 id=\"Vue3-响应式机制\"><a href=\"#Vue3-响应式机制\" class=\"headerlink\" title=\"Vue3 响应式机制\"></a>Vue3 响应式机制</h2><p>响应式原理：Vue 中用过三种响应式解决方案，分别是 defineProperty、Proxy 和 value setter。</p>\n<hr>\n<p>todo: 07</p>\n<h2 id=\"Vue3-实践常见问题汇总\"><a href=\"#Vue3-实践常见问题汇总\" class=\"headerlink\" title=\"Vue3 实践常见问题汇总\"></a>Vue3 实践常见问题汇总</h2><ol>\n<li><p>vetur 报错， xx has no export.</p>\n<p>使用 Vue3 <code>script setup</code> 语法糖时,VsCode 插件 Vetur 会报该错误，原因是 Vetur(v0.35.0) 暂不支持 ts。</p>\n<p>解决办法： 卸载 Vetur， 用 Volar(尤大推荐) 以取代 Vetur。</p>\n</li>\n</ol>\n<hr>\n<p>上述笔记源于学习极客时间-大圣的 <a href=\"http://gk.link/a/115Qp\">玩转 Vue3 全家桶</a> 课程笔记整理。</p>\n<hr>\n","site":{"data":{}},"wordcount":3477,"excerpt":"","more":"<h2 id=\"Vue-和-React-数据驱动原理对比\"><a href=\"#Vue-和-React-数据驱动原理对比\" class=\"headerlink\" title=\"Vue 和 React 数据驱动原理对比\"></a>Vue 和 React 数据驱动原理对比</h2><p>Vue1 解决方案是使用响应式，初始化的时候，watcher 监听数据的每个属性，数据发生变化的时候，就能够知道数据的哪个 key 变了，去修改对应的 DOM。</p>\n<p>React 是虚拟 DOM 方案，用 JS 对象描述 DOM 树，这个对象就像数据和实际 DOM 的一个缓存层，通过管理这个对象的变化，来减少对实际 DOM 的操作。</p>\n<p>描述实际 DOM 的虚拟 DOM 对象如下：</p>\n<p>DOM:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>Item1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>Item2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n\n<p>虚拟 DOM：</p>\n<pre><code class=\"hljs js\">&#123;\n  <span class=\"hljs-attr\">tag</span>: <span class=\"hljs-string\">&quot;div&quot;</span>,\n  <span class=\"hljs-attr\">attrs</span>: &#123;\n    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">&quot;app&quot;</span>\n  &#125;,\n  <span class=\"hljs-attr\">children</span>: [\n    &#123;\n      <span class=\"hljs-attr\">tag</span>: <span class=\"hljs-string\">&quot;p&quot;</span>,\n      <span class=\"hljs-attr\">attrs</span>: &#123; <span class=\"hljs-attr\">className</span>: <span class=\"hljs-string\">&quot;item&quot;</span> &#125;,\n      <span class=\"hljs-attr\">children</span>: [<span class=\"hljs-string\">&quot;Item1&quot;</span>]\n    &#125;,\n    &#123;\n      <span class=\"hljs-attr\">tag</span>: <span class=\"hljs-string\">&quot;div&quot;</span>,\n      <span class=\"hljs-attr\">attrs</span>: &#123; <span class=\"hljs-attr\">className</span>: <span class=\"hljs-string\">&quot;item&quot;</span> &#125;,\n      <span class=\"hljs-attr\">children</span>: [<span class=\"hljs-string\">&quot;Item2&quot;</span>]\n    &#125;\n  ]\n&#125;</code></pre>\n\n<p>数据变化的时候生成一个新的虚拟 DOM 数据，对比之前的虚拟 DOM 进行 diff 计算，算出要修改的 DOM，再对页面进行操作。</p>\n<p>通知页面更新的方式不同：</p>\n<ul>\n<li>vue 中，数据变化，框架主动告诉你修改了哪些数据；</li>\n<li>react 中，变化变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化</li>\n</ul>\n<p>性能问题：</p>\n<ul>\n<li>vue 的响应式，在项目大了之后，每个数据都有一个 watcher 会影响性能</li>\n<li>如果 react 虚拟 dom 过于庞大，使得 diff 计算时间大于 16.6 ms(屏幕刷新率 60HZ, 1/60)，可能造成性能卡顿。</li>\n</ul>\n<p>为了解决性能问题， Vue 和 react 走了不同的道路。</p>\n<ul>\n<li>react 借鉴操作系统时间分片概念，引入 Fiber 架构。把整个虚拟 DOM 树 微观化，变成链表，然后利用浏览器的空闲时间计算 diff。</li>\n<li>vue1 的问题在于响应式数据过多，会带来内存占用过多的问题。vue2 引入虚拟 DOM 来解决响应式数据过多问题。</li>\n</ul>\n<p>响应式数据是主动推送变化，虚拟 DOM 是被动计算数据的 diff。vue2 将两者结合在一起，在组件级别来划分。</p>\n<p>组件间的变化，通过响应式来通知更新。组件内部的数据变化，通过虚拟 DOM 去更新页面。最终，把响应式监听器控制在组件级别，而虚拟 DOM 的量级控制在组件的大小。</p>\n<p>在模板书写上，vue 和 react 分别走了 template 和 jsx 两个路线。</p>\n<ul>\n<li>react 世界只有 jsx，最终 jsx 都会在 Compiler 那层，即工程化那里编译成 js 来执行。</li>\n<li>vue 默认 template。vue3 优秀的其中一点是在虚拟 DOM 的静态标记上做到了极致，让静态的部分越过虚拟 DOM 的计算，真正做到按需更新，很好的提高了性能。</li>\n</ul>\n<h2 id=\"Vue3-的新特性\"><a href=\"#Vue3-的新特性\" class=\"headerlink\" title=\"Vue3 的新特性\"></a>Vue3 的新特性</h2><h3 id=\"响应式系统\"><a href=\"#响应式系统\" class=\"headerlink\" title=\"响应式系统\"></a>响应式系统</h3><p>Vue 2 的响应式机制是基于 Object.defineProperty() 这个 API 实现的.Vue3 是基于 proxy。两者区别是 defineProperty 是拦截具体某个属性，<br>Proxy 是全部拦截，是代理。</p>\n<p>defineProperty 示例如下：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-built_in\">Object</span>.defineProperty(obj, <span class=\"hljs-string\">&quot;title&quot;</span>, &#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;,\n  <span class=\"hljs-function\"><span class=\"hljs-title\">set</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;\n&#125;);</code></pre>\n\n<p>当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在<br>data 里声明。</p>\n<p>但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的<br>$set。</p>\n<p>Proxy API 是真正的代理，示例如下：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>(obj, &#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;,\n  <span class=\"hljs-function\"><span class=\"hljs-title\">set</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;\n&#125;);</code></pre>\n\n<p>Proxy 拦截 obj 这个数据，不关心 obj 里面属性，统一拦截。</p>\n<h3 id=\"自定义渲染器\"><a href=\"#自定义渲染器\" class=\"headerlink\" title=\"自定义渲染器\"></a>自定义渲染器</h3><p>vue2 内部所有模块是揉在一起，导致不好扩展。vue3 采用 monorepo 方式进行拆包，响应式、编译和运行时全部独立。独立出来的响应式，甚至可以在 react、node 中使用。</p>\n<p><img src=\"/img/2022-01-24-1.png\" alt=\"vue 架构\"></p>\n<p>渲染逻辑拆成 <strong>平台无关渲染逻辑</strong> 和 <strong>浏览器渲染 API</strong>。</p>\n<h3 id=\"全部模块使用-TS-重构\"><a href=\"#全部模块使用-TS-重构\" class=\"headerlink\" title=\"全部模块使用 TS 重构\"></a>全部模块使用 TS 重构</h3><p>Vue2 使用 Flow.js 做类型检测；Flow.js 已被抛弃，vue3 选择 TS。</p>\n<h3 id=\"Composition-API-组合语法\"><a href=\"#Composition-API-组合语法\" class=\"headerlink\" title=\"Composition API 组合语法\"></a>Composition API 组合语法</h3><p>vue2 中示例：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> App = &#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">1</span> &#125;;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-function\"><span class=\"hljs-title\">add</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n      <span class=\"hljs-built_in\">this</span>.count++;\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">computed</span>: &#123;\n    <span class=\"hljs-function\"><span class=\"hljs-title\">double</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.count * <span class=\"hljs-number\">2</span>;\n    &#125;\n  &#125;\n&#125;;</code></pre>\n\n<p>vue2 中 Options API 存在以下问题：</p>\n<ul>\n<li>所有数据都挂载在 this 上，Options API 写法对 TS 类型推导不友好。</li>\n<li>新增的功能基本都要修改 data、method 等，代码行数多了以后，会经常需要上下反复横跳。</li>\n<li>代码不好复用，vue2 的组件很难抽离通用逻辑，只能使用 mixin，还会导致命名冲突问题。</li>\n</ul>\n<p>vue3 中采用新增的 setup 写法：</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> &#123; reactive, computed &#125; = Vue;\n<span class=\"hljs-keyword\">let</span> App = &#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">setup</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">const</span> state = reactive(&#123; <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">1</span> &#125;);\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n      state.count++;\n    &#125;\n    <span class=\"hljs-keyword\">const</span> double = computed(<span class=\"hljs-function\">() =&gt;</span> state.count * <span class=\"hljs-number\">2</span>);\n    <span class=\"hljs-keyword\">return</span> &#123; state, add, double &#125;;\n  &#125;\n&#125;;</code></pre>\n\n<p>Composition API 好处如下：</p>\n<ul>\n<li>所有 API 都是 import 引入。对 Tree-shaking 很友好，没用到功能，打包的时候会被清理掉 ，减小包的大小</li>\n<li>一个功能模块的 methods、data 放一起书写，避免上下反复横跳。</li>\n<li>代码复用方便，一个功能的所有 methods、data 封装在一个独立的函数里。</li>\n<li>Composotion API 新增的 return 等语句，在实际项目中使用。</li>\n</ul>\n<p><img src=\"/img/2022-01-24-2.png\" alt=\"Composition API\"></p>\n<h3 id=\"新的组件\"><a href=\"#新的组件\" class=\"headerlink\" title=\"新的组件\"></a>新的组件</h3><p>Vue 3 还内置了 Fragment、Teleport 和 Suspense 三个新组件。</p>\n<ul>\n<li>Fragment: Vue 3 组件不再要求有一个唯一的根节点，清除了很多无用的占位 div。</li>\n<li>Teleport: 允许组件渲染在别的元素内，主要开发弹窗组件的时候特别有用。</li>\n<li>Suspense: 异步组件，更方便开发有异步请求的组件。</li>\n</ul>\n<h3 id=\"新一代工程化工具-Vite\"><a href=\"#新一代工程化工具-Vite\" class=\"headerlink\" title=\"新一代工程化工具 Vite\"></a>新一代工程化工具 Vite</h3><p>webpack 工程化的原理是 根据 import<br>依赖逻辑形成一个依赖图，然后调用对应的处理工具，把整个项目打包后，放在内存中再启动调试。因为要预打包，复杂项目开发时，启动开发环境和热更新时间都比较长，Vite 就是为了解决这个问题而出现的。</p>\n<p>现代浏览器已经默认支持 ES6 的 import 语法，Vite 就是基于这个原理实现的。</p>\n<p>在开发环境下，不需要全部预打包，只要把首页依赖的文件，依次通过网络请求去获取，开发体验得到巨大提升，做到复杂项目时，也能做到秒级调试和热更新。</p>\n<p>webpack 工作原理如下，需要把所有路由依赖打包后，才能开始调试。</p>\n<p><img src=\"/img/2022-01-24-3.png\" alt=\"webpack 工作原理\"></p>\n<p>Vite 工作原理，根据首页的依赖模块，再去获取路由 1 的模块，按需加载。</p>\n<p><img src=\"/img/2022-01-24-4.png\" alt=\"Vite 工作原理\"></p>\n<h2 id=\"Vue3-响应式机制\"><a href=\"#Vue3-响应式机制\" class=\"headerlink\" title=\"Vue3 响应式机制\"></a>Vue3 响应式机制</h2><p>响应式原理：Vue 中用过三种响应式解决方案，分别是 defineProperty、Proxy 和 value setter。</p>\n<hr>\n<p>todo: 07</p>\n<h2 id=\"Vue3-实践常见问题汇总\"><a href=\"#Vue3-实践常见问题汇总\" class=\"headerlink\" title=\"Vue3 实践常见问题汇总\"></a>Vue3 实践常见问题汇总</h2><ol>\n<li><p>vetur 报错， xx has no export.</p>\n<p>使用 Vue3 <code>script setup</code> 语法糖时,VsCode 插件 Vetur 会报该错误，原因是 Vetur(v0.35.0) 暂不支持 ts。</p>\n<p>解决办法： 卸载 Vetur， 用 Volar(尤大推荐) 以取代 Vetur。</p>\n</li>\n</ol>\n<hr>\n<p>上述笔记源于学习极客时间-大圣的 <a href=\"http://gk.link/a/115Qp\">玩转 Vue3 全家桶</a> 课程笔记整理。</p>\n<hr>\n"},{"title":"每日 3+1","index_img":"/img/index-img.png","date":"2022-01-01T00:28:12.000Z","_content":"\n- [你有使用过loadable组件吗？它帮我们解决了什么问题？](https://github.com/haizlin/fe-interview/issues/897)\n- [你有使用过suspense组件吗？它帮我们解决了什么问题？](https://github.com/haizlin/fe-interview/issues/896)\n- [怎样动态导入组件？](https://github.com/haizlin/fe-interview/issues/895)\n- [如何给非控组件设置默认的值？](https://github.com/haizlin/fe-interview/issues/894)\n- [怎么在React中引入其它的UI库，例如Bootstrap](https://github.com/haizlin/fe-interview/issues/893)\n- [怎样将事件传递给子组件？](https://github.com/haizlin/fe-interview/issues/892)\n- [怎样使用Hooks获取服务端数据？](https://github.com/haizlin/fe-interview/issues/891)\n- [使用Hooks要遵守哪些原则？](https://github.com/haizlin/fe-interview/issues/890)\n- [render方法的原理你有了解吗？它返回的数据类型是什么？](https://github.com/haizlin/fe-interview/issues/889)\n- [useEffect和useLayoutEffect有什么区别？](https://github.com/haizlin/fe-interview/issues/888)\n- [在React项目中你用过哪些动画的包？](https://github.com/haizlin/fe-interview/issues/887)\n- [React必须使用JSX吗？](https://github.com/haizlin/fe-interview/issues/886)\n- [自定义组件时render是可选的吗？为什么？](https://github.com/haizlin/fe-interview/issues/885)\n- [需要把keys设置为全局唯一吗？](https://github.com/haizlin/fe-interview/issues/884)\n- [怎么定时更新一个组件？](https://github.com/haizlin/fe-interview/issues/883)\n- [React根据不同的环境打包不同的域名？](https://github.com/haizlin/fe-interview/issues/882)\n- [使用webpack打包React项目，怎么减小生成的js大小？](https://github.com/haizlin/fe-interview/issues/881)\n- [在React中怎么使用async/await？](https://github.com/haizlin/fe-interview/issues/880)\n- [你阅读了几遍React的源码？都有哪些收获？你是怎么阅读的？](https://github.com/haizlin/fe-interview/issues/879)\n- [什么是React.forwardRef？它有什么作用？](https://github.com/haizlin/fe-interview/issues/878)\n- [写个例子说明什么是JSX的内联条件渲染](https://github.com/haizlin/fe-interview/issues/877)\n- [在React中怎么将参数传递给事件？](https://github.com/haizlin/fe-interview/issues/876)\n- [React的事件和普通的HTML事件有什么不同？](https://github.com/haizlin/fe-interview/issues/875)\n- [在React中怎么阻止事件的默认行为？](https://github.com/haizlin/fe-interview/issues/874)\n- [你最喜欢React的哪一个特性（说一个就好）？](https://github.com/haizlin/fe-interview/issues/873)\n- [在React中什么时候使用箭头函数更方便呢？](https://github.com/haizlin/fe-interview/issues/872)\n- [你最不喜欢React的哪一个特性（说一个就好）？](https://github.com/haizlin/fe-interview/issues/871)\n- [说说你对React的reconciliation（一致化算法）的理解](https://github.com/haizlin/fe-interview/issues/870)\n- [使用PropTypes和Flow有什么区别？](https://github.com/haizlin/fe-interview/issues/869)\n- [怎样有条件地渲染组件？](https://github.com/haizlin/fe-interview/issues/868)\n- [在JSX中如何写注释？](https://github.com/haizlin/fe-interview/issues/867)\n- [constructor和getInitialState有不同？](https://github.com/haizlin/fe-interview/issues/866)\n- [写例子说明React如何在JSX中实现for循环](https://github.com/haizlin/fe-interview/issues/865)\n- [为什么建议Fragment包裹元素？它的简写是什么？](https://github.com/haizlin/fe-interview/issues/864)\n- [你有用过React.Fragment吗？说说它有什么用途？](https://github.com/haizlin/fe-interview/issues/863)\n- [在React中你有遇到过安全问题吗？怎么解决？](https://github.com/haizlin/fe-interview/issues/862)\n- [React中如何监听state的变化？](https://github.com/haizlin/fe-interview/issues/861)\n- [React什么是有状态组件？](https://github.com/haizlin/fe-interview/issues/860)\n- [React v15中怎么处理错误边界？](https://github.com/haizlin/fe-interview/issues/859)\n- [React Fiber它的目的是解决什么问题？](https://github.com/haizlin/fe-interview/issues/858)\n- [React为什么不要直接修改state？如果想修改怎么做？](https://github.com/haizlin/fe-interview/issues/857)\n- [create-react-app有什么好处？](https://github.com/haizlin/fe-interview/issues/856)\n- [装饰器(Decorator)在React中有什么应用？](https://github.com/haizlin/fe-interview/issues/855)\n- [使用高阶组件(HOC)实现一个loading组件](https://github.com/haizlin/fe-interview/issues/854)\n- [如何用React实现滚动动画？](https://github.com/haizlin/fe-interview/issues/853)\n- [说出几点你认为的React最佳实践](https://github.com/haizlin/fe-interview/issues/852)\n- [你是如何划分React组件的？](https://github.com/haizlin/fe-interview/issues/851)\n- [举例说明如何在React创建一个事件](https://github.com/haizlin/fe-interview/issues/850)\n- [如何更新组件的状态？](https://github.com/haizlin/fe-interview/issues/849)\n- [怎样将多个组件嵌入到一个组件中？](https://github.com/haizlin/fe-interview/issues/848)\n- [React的render中可以写{if else}这样的判断吗？](https://github.com/haizlin/fe-interview/issues/847)\n- [React为什么要搞一个Hooks？](https://github.com/haizlin/fe-interview/issues/846)\n- [React Hooks帮我们解决了哪些问题？](https://github.com/haizlin/fe-interview/issues/845)\n- [使用React的memo和forwardRef包装的组件为什么提示children类型不对？](https://github.com/haizlin/fe-interview/issues/844)\n- [有在项目中使用过Antd吗？说说它的好处](https://github.com/haizlin/fe-interview/issues/843)\n- [在React中如果去除生产环境上的sourcemap？](https://github.com/haizlin/fe-interview/issues/842)\n- [在React中怎么引用sass或less？](https://github.com/haizlin/fe-interview/issues/841)\n- [组件卸载前，加在DOM元素的监听事件和定时器要不要手动清除？为什么？](https://github.com/haizlin/fe-interview/issues/840)\n- [为什么标签里的for要写成htmlFor呢？](https://github.com/haizlin/fe-interview/issues/839)\n- [状态管理器解决了什么问题？什么时候用状态管理器？](https://github.com/haizlin/fe-interview/issues/838)\n- [状态管理器它精髓是什么？](https://github.com/haizlin/fe-interview/issues/837)\n- [函数式组件有没有生命周期？为什么？](https://github.com/haizlin/fe-interview/issues/836)\n- [在React中怎么引用第三方插件？比如说jQuery等](https://github.com/haizlin/fe-interview/issues/835)\n- [React的触摸事件有哪几种？](https://github.com/haizlin/fe-interview/issues/834)\n- [路由切换时同一组件无法重新渲染的有什么方法可以解决？](https://github.com/haizlin/fe-interview/issues/833)\n- [React16新特性有哪些？](https://github.com/haizlin/fe-interview/issues/832)\n- [你有用过哪些React的UI库？它们的优缺点分别是什么？](https://github.com/haizlin/fe-interview/issues/831)\n- [`<div onClick={handlerClick}>单击</div>`和`<div onClick={handlerClick(1)}>单击</div>`有什么区别？](https://github.com/haizlin/fe-interview/issues/830)\n- [在React中如何引入图片？哪种方式更好？](https://github.com/haizlin/fe-interview/issues/829)\n- [在React中怎么使用字体图标？](https://github.com/haizlin/fe-interview/issues/828)\n- [React的应用如何打包发布？它的步骤是什么？](https://github.com/haizlin/fe-interview/issues/827)\n- [ES6的语法'...'在React中有哪些应用？](https://github.com/haizlin/fe-interview/issues/826)\n- [如何封装一个React的全局公共组件？](https://github.com/haizlin/fe-interview/issues/825)\n- [在React中组件的props改变时更新组件的有哪些方法？](https://github.com/haizlin/fe-interview/issues/824)\n- [immutable的原理是什么？](https://github.com/haizlin/fe-interview/issues/823)\n- [你对immutable有了解吗？它有什么作用？](https://github.com/haizlin/fe-interview/issues/822)\n- [如何提高组件的渲染效率呢？](https://github.com/haizlin/fe-interview/issues/821)\n- [在React中如何避免不必要的render？](https://github.com/haizlin/fe-interview/issues/820)\n- [render在什么时候会被触发？](https://github.com/haizlin/fe-interview/issues/819)\n- [写出React动态改变class切换组件样式](https://github.com/haizlin/fe-interview/issues/818)\n- [React中怎么操作虚拟DOM的Class属性？](https://github.com/haizlin/fe-interview/issues/817)\n- [为什么属性使用className而不是class呢？](https://github.com/haizlin/fe-interview/issues/816)\n- [请说下react组件更新的机制是什么？](https://github.com/haizlin/fe-interview/issues/815)\n- [怎么在JSX里属性可以被覆盖吗？覆盖的原则是什么？](https://github.com/haizlin/fe-interview/issues/814)\n- [怎么在JSX里使用自定义属性？](https://github.com/haizlin/fe-interview/issues/813)\n- [怎么防止HTML被转义？](https://github.com/haizlin/fe-interview/issues/812)\n- [经常用React，你知道React的核心思想是什么吗？](https://github.com/haizlin/fe-interview/issues/811)\n- [在React中我们怎么做静态类型检测？都有哪些方法可以做到？](https://github.com/haizlin/fe-interview/issues/810)\n- [在React中组件的state和setState有什么区别？](https://github.com/haizlin/fe-interview/issues/809)\n- [React怎样跳过重新渲染？](https://github.com/haizlin/fe-interview/issues/808)\n- [React怎么判断什么时候重新渲染组件呢？](https://github.com/haizlin/fe-interview/issues/807)\n- [什么是React的实例？函数式组件有没有实例？](https://github.com/haizlin/fe-interview/issues/806)\n- [在React中如何判断点击元素属于哪一个组件？](https://github.com/haizlin/fe-interview/issues/805)\n- [在React中组件和元素有什么区别？](https://github.com/haizlin/fe-interview/issues/804)\n- [在React中声明组件时组件名的第一个字母必须是大写吗？为什么？](https://github.com/haizlin/fe-interview/issues/803)\n- [举例说明什么是高阶组件(HOC)的反向继承？](https://github.com/haizlin/fe-interview/issues/802)\n- [有用过React Devtools吗？说说它的优缺点分别是什么？](https://github.com/haizlin/fe-interview/issues/801)\n- [举例说明什么是高阶组件(HOC)的属性代理？](https://github.com/haizlin/fe-interview/issues/800)\n- [React的isMounted有什么作用？](https://github.com/haizlin/fe-interview/issues/799)\n- [React组件命名推荐的方式是哪个？为什么不推荐使用displayName？](https://github.com/haizlin/fe-interview/issues/798)\n- [React的displayName有什么作用？](https://github.com/haizlin/fe-interview/issues/797)\n- [说说你对React的组件命名规范的理解](https://github.com/haizlin/fe-interview/issues/796)\n- [说说你对React的项目结构的理解](https://github.com/haizlin/fe-interview/issues/795)\n- [React16废弃了哪些生命周期？为什么？](https://github.com/haizlin/fe-interview/issues/794)\n- [怎样在React中开启生产模式？](https://github.com/haizlin/fe-interview/issues/793)\n- [React中getInitialState方法的作用是什么？](https://github.com/haizlin/fe-interview/issues/792)\n- [React中你知道creatClass的原理吗？](https://github.com/haizlin/fe-interview/issues/791)\n- [React中验证props的目的是什么？](https://github.com/haizlin/fe-interview/issues/790)\n- [React中你有使用过getDefaultProps吗？它有什么作用？](https://github.com/haizlin/fe-interview/issues/789)\n- [React中你有使用过propType吗？它有什么作用？](https://github.com/haizlin/fe-interview/issues/788)\n- [React中怎么检验props？](https://github.com/haizlin/fe-interview/issues/787)\n- [React.createClass和extends Component的区别有哪些？](https://github.com/haizlin/fe-interview/issues/786)\n- [高阶组件(HOC)有哪些优点和缺点？](https://github.com/haizlin/fe-interview/issues/785)\n- [给组件设置很多属性时不想一个个去设置有什么办法可以解决这问题呢？](https://github.com/haizlin/fe-interview/issues/784)\n- [React16跟之前的版本生命周期有哪些变化？](https://github.com/haizlin/fe-interview/issues/756)\n- [怎样实现React组件的记忆？原理是什么？](https://github.com/haizlin/fe-interview/issues/755)\n- [创建React动画有哪些方式？](https://github.com/haizlin/fe-interview/issues/754)\n- [为什么建议不要过渡使用Refs？](https://github.com/haizlin/fe-interview/issues/753)\n- [在React使用高阶组件(HOC)有遇到过哪些问题？如何解决？](https://github.com/haizlin/fe-interview/issues/752)\n- [在使用React过程中什么时候用高阶组件(HOC)？](https://github.com/haizlin/fe-interview/issues/751)\n- [说说React diff的原理是什么？](https://github.com/haizlin/fe-interview/issues/724)\n- [React怎么提高列表渲染的性能？](https://github.com/haizlin/fe-interview/issues/723)\n- [使用ES6的class定义的组件不支持mixins了，那用什么可以替代呢？](https://github.com/haizlin/fe-interview/issues/722)\n- [为何说虚拟DOM会提高性能？](https://github.com/haizlin/fe-interview/issues/720)\n- [React的性能优化在哪个生命周期？它优化的原理是什么？](https://github.com/haizlin/fe-interview/issues/719)\n- [你知道的React性能优化有哪些方法？](https://github.com/haizlin/fe-interview/issues/718)\n- [举例说明在React中怎么使用样式？](https://github.com/haizlin/fe-interview/issues/717)\n- [React有哪几种方法来处理表单输入？](https://github.com/haizlin/fe-interview/issues/716)\n- [什么是浅层渲染？](https://github.com/haizlin/fe-interview/issues/715)\n- [你有做过React的单元测试吗？如果有，用的是哪些工具？怎么做的？](https://github.com/haizlin/fe-interview/issues/714)\n- [在React中什么是合成事件？有什么用？](https://github.com/haizlin/fe-interview/issues/713)\n- [使用React写一个todo应用，说说你的思路](https://github.com/haizlin/fe-interview/issues/712)\n- [React16的reconciliation和commit分别是什么？](https://github.com/haizlin/fe-interview/issues/711)\n- [React的函数式组件有没有生命周期？](https://github.com/haizlin/fe-interview/issues/710)\n- [useState和this.state的区别是什么？](https://github.com/haizlin/fe-interview/issues/709)\n- [请说说什么是useImperativeHandle？](https://github.com/haizlin/fe-interview/issues/708)\n- [请说说什么是useReducer？](https://github.com/haizlin/fe-interview/issues/707)\n- [请说说什么是useRef？](https://github.com/haizlin/fe-interview/issues/706)\n- [请说说什么是useEffect？](https://github.com/haizlin/fe-interview/issues/705)\n- [举例说明useState](https://github.com/haizlin/fe-interview/issues/704)\n- [请说说什么是useState？为什么要使用useState？](https://github.com/haizlin/fe-interview/issues/703)\n- [请描述下你对React的新特性Hooks的理解？它有哪些应用场景？](https://github.com/haizlin/fe-interview/issues/702)\n- [说说你对Error Boundaries的理解](https://github.com/haizlin/fe-interview/issues/701)\n- [说说你对Fiber架构的理解](https://github.com/haizlin/fe-interview/issues/700)\n- [说说你是怎么理解React的业务组件和技术组件的？](https://github.com/haizlin/fe-interview/issues/699)\n- [为什么建议setState的第一个参数是callback而不是一个对象呢？](https://github.com/haizlin/fe-interview/issues/698)\n- [展示组件和容器组件有什么区别？](https://github.com/haizlin/fe-interview/issues/697)\n- [Mern和Yeoman脚手架有什么区别？](https://github.com/haizlin/fe-interview/issues/696)\n- [你有在项目中使用过Yeoman脚手架吗？](https://github.com/haizlin/fe-interview/issues/695)\n- [你有在项目中使用过Mern脚手架吗？](https://github.com/haizlin/fe-interview/issues/694)\n- [shouldComponentUpdate方法是做什么的？](https://github.com/haizlin/fe-interview/issues/693)\n- [怎样在React中使用innerHTML？](https://github.com/haizlin/fe-interview/issues/692)\n- [你有写过React的中间件插件吗？](https://github.com/haizlin/fe-interview/issues/691)\n- [React的中间件机制是怎么样的？这种机制有什么作用？](https://github.com/haizlin/fe-interview/issues/690)\n- [React中你用过哪些第三方的中间件？](https://github.com/haizlin/fe-interview/issues/689)\n- [不用脚手架，你会手动搭建React项目吗？](https://github.com/haizlin/fe-interview/issues/688)\n- [请说说React中Portal是什么？](https://github.com/haizlin/fe-interview/issues/687)\n- [React中修改prop引发的生命周期有哪几个？](https://github.com/haizlin/fe-interview/issues/686)\n- [React多个setState调用的原理是什么？](https://github.com/haizlin/fe-interview/issues/685)\n- [React中调用setState会更新的生命周期有哪几个？](https://github.com/haizlin/fe-interview/issues/684)\n- [React中setState的第二个参数作用是什么呢？](https://github.com/haizlin/fe-interview/issues/683)\n- [React中的setState是同步还是异步的呢？为什么state并不一定会同步更新？](https://github.com/haizlin/fe-interview/issues/682)\n- [React中的setState批量更新的过程是什么？](https://github.com/haizlin/fe-interview/issues/681)\n- [React中的setState执行机制是什么呢？](https://github.com/haizlin/fe-interview/issues/680)\n- [在React中遍历的方法有哪些？它们有什么区别呢？](https://github.com/haizlin/fe-interview/issues/679)\n- [请说说你对React的render方法的理解](https://github.com/haizlin/fe-interview/issues/678)\n- [props.children.map和js的map有什么区别？为什么优先选择React的？](https://github.com/haizlin/fe-interview/issues/677)\n- [有用过React的严格模式吗？](https://github.com/haizlin/fe-interview/issues/676)\n- [React中的setState和replaceState的区别是什么？](https://github.com/haizlin/fe-interview/issues/675)\n- [React中的setState缺点是什么呢？](https://github.com/haizlin/fe-interview/issues/674)\n- [有用过React的Fragment吗？它的运用场景是什么？](https://github.com/haizlin/fe-interview/issues/673)\n- [React组件间共享数据方法有哪些？](https://github.com/haizlin/fe-interview/issues/672)\n- [React的状态提升是什么？使用场景有哪些？](https://github.com/haizlin/fe-interview/issues/671)\n- [简单描述下你有做过哪些React项目？](https://github.com/haizlin/fe-interview/issues/670)\n- [在构造函数中调用super(props)的目的是什么？](https://github.com/haizlin/fe-interview/issues/669)\n- [你是如何学习React的？](https://github.com/haizlin/fe-interview/issues/668)\n- [从旧版本的React升级到新版本的React有做过吗？有遇到过什么坑？](https://github.com/haizlin/fe-interview/issues/667)\n- [你用过React版本有哪些？](https://github.com/haizlin/fe-interview/issues/666)\n- [有用过React的服务端渲染吗？怎么做的？](https://github.com/haizlin/fe-interview/issues/665)\n- [React的mixins有什么作用？适用于什么场景？](https://github.com/haizlin/fe-interview/issues/664)\n- [React怎么拿到组件对应的DOM元素？](https://github.com/haizlin/fe-interview/issues/663)\n- [请描述下事件在React中的处理方式是什么？](https://github.com/haizlin/fe-interview/issues/662)\n- [JSX和HTML有什么区别？](https://github.com/haizlin/fe-interview/issues/661)\n- [React的书写规范有哪些？](https://github.com/haizlin/fe-interview/issues/660)\n- [create-react-app创建新运用怎么解决卡的问题？](https://github.com/haizlin/fe-interview/issues/659)\n- [使用React的方式有哪几种？](https://github.com/haizlin/fe-interview/issues/658)\n- [说说你对reader的context的理解](https://github.com/haizlin/fe-interview/issues/657)\n- [同时引用这三个库React.js、React-dom.js和babel.js它们都有什么作用？](https://github.com/haizlin/fe-interview/issues/656)\n- [你知道Virtual DOM的工作原理吗？](https://github.com/haizlin/fe-interview/issues/655)\n- [你阅读过React的源码吗？简要说下它的执行流程](https://github.com/haizlin/fe-interview/issues/654)\n- [React中怎样阻止组件渲染？](https://github.com/haizlin/fe-interview/issues/653)\n- [React非兄弟组件如何通信？](https://github.com/haizlin/fe-interview/issues/652)\n- [React兄弟组件如何通信？](https://github.com/haizlin/fe-interview/issues/651)\n- [React非父子组件如何通信？](https://github.com/haizlin/fe-interview/issues/650)\n- [React父子组件如何通信？](https://github.com/haizlin/fe-interview/issues/649)\n- [React组件间的通信有哪些？](https://github.com/haizlin/fe-interview/issues/648)\n- [类组件和函数式组件有什么区别？](https://github.com/haizlin/fe-interview/issues/647)\n- [React自定义组件你写过吗？说说看都写过哪些？](https://github.com/haizlin/fe-interview/issues/646)\n- [React组件的state和props两者有什么区别？](https://github.com/haizlin/fe-interview/issues/645)\n- [React有几种构建组件的方式？可以写出来吗？](https://github.com/haizlin/fe-interview/issues/644)\n- [React中遍历时为什么不用索引作为唯一的key值？](https://github.com/haizlin/fe-interview/issues/643)\n- [React中的key有什么作用？](https://github.com/haizlin/fe-interview/issues/642)\n- [React中除了在构造函数中绑定this,还有别的方式吗？](https://github.com/haizlin/fe-interview/issues/641)\n- [在React中页面重新加载时怎样保留数据？](https://github.com/haizlin/fe-interview/issues/640)\n- [请描述下React的事件机制](https://github.com/haizlin/fe-interview/issues/639)\n- [怎样在React中创建一个事件？](https://github.com/haizlin/fe-interview/issues/638)\n- [在React中无状态组件有什么运用场景？](https://github.com/haizlin/fe-interview/issues/637)\n- [描述下在React中无状态组件和有状态组件的区别是什么？](https://github.com/haizlin/fe-interview/issues/636)\n- [写一个React的高阶组件(HOC)并说明你对它的理解](https://github.com/haizlin/fe-interview/issues/635)\n- [React中可以在render访问refs吗？为什么？](https://github.com/haizlin/fe-interview/issues/634)\n- [React中refs的作用是什么？有哪些应用场景？](https://github.com/haizlin/fe-interview/issues/633)\n- [请描述你对纯函数的理解？](https://github.com/haizlin/fe-interview/issues/632)\n- [受控组件和非受控组件有什么区别？](https://github.com/haizlin/fe-interview/issues/631)\n- [React中什么是非控组件？](https://github.com/haizlin/fe-interview/issues/630)\n- [React中什么是受控组件？](https://github.com/haizlin/fe-interview/issues/629)\n- [React中发起网络请求应该在哪个生命周期中进行？为什么？](https://github.com/haizlin/fe-interview/issues/628)\n- [说说React的生命周期有哪些？](https://github.com/haizlin/fe-interview/issues/627)\n- [说说你对“在React中，一切都是组件”的理解](https://github.com/haizlin/fe-interview/issues/626)\n- [写React你是用es6还是es5的语法？有什么区别？](https://github.com/haizlin/fe-interview/issues/625)\n- [浏览器为什么无法直接JSX？怎么解决呢？](https://github.com/haizlin/fe-interview/issues/624)\n- [在使用React过程中你都踩过哪些坑？你是怎么填坑的？](https://github.com/haizlin/fe-interview/issues/623)\n- [说说你喜欢React的原因是什么？它有什么优缺点？](https://github.com/haizlin/fe-interview/issues/622)\n- [如何解决引用类型在pureComponent下修改值的时候，页面不渲染的问题？](https://github.com/haizlin/fe-interview/issues/621)\n- [createElement与cloneElement两者有什么区别？](https://github.com/haizlin/fe-interview/issues/620)\n- [解释下React中Element 和Component两者的区别是什么？](https://github.com/haizlin/fe-interview/issues/619)\n- [解释下React中component和pureComponent两者的区别是什么？](https://github.com/haizlin/fe-interview/issues/618)\n- [React的虚拟DOM和vue的虚拟DOM有什么区别？](https://github.com/haizlin/fe-interview/issues/617)\n- [你觉得React上手快不快？它有哪些限制？](https://github.com/haizlin/fe-interview/issues/616)\n- [说说你对声明式编程的理解？](https://github.com/haizlin/fe-interview/issues/615)\n- [React与angular、vue有什么区别？](https://github.com/haizlin/fe-interview/issues/614)\n- [React是哪个公司开发的？](https://github.com/haizlin/fe-interview/issues/613)\n- [React是什么？它的主要特点是什么？](https://github.com/haizlin/fe-interview/issues/612)\n- [简要描述下你知道的React工作原理是什么？](https://github.com/haizlin/fe-interview/issues/611)\n- [在React中怎样改变组件状态，以及状态改变的过程是什么？](https://github.com/haizlin/fe-interview/issues/606)\n- [在React中你是怎么进行状态管理的？](https://github.com/haizlin/fe-interview/issues/605)\n- [React声明组件有哪几种方法，各有什么不同？](https://github.com/haizlin/fe-interview/issues/604)\n\n### ReactNative\n\n- [如何在React Native中设置环境变量？]()\n- [请描述下Code Push的原理是什么？](https://github.com/haizlin/fe-interview/issues/783)\n- [React Native怎样查看日记？](https://github.com/haizlin/fe-interview/issues/782)\n- [React Native怎样测试？](https://github.com/haizlin/fe-interview/issues/781)\n- [React Native怎样调试？](https://github.com/haizlin/fe-interview/issues/780)\n- [React Native和React有什么区别？](https://github.com/haizlin/fe-interview/issues/779)\n- [有做过React Native项目吗？](https://github.com/haizlin/fe-interview/issues/725)\n\n### React-Router\n\n- [React-Router怎么获取历史对象？](https://github.com/haizlin/fe-interview/issues/922)\n- [React-Router怎么获取URL的参数？](https://github.com/haizlin/fe-interview/issues/921)\n- [在history模式中push和replace有什么区别？](https://github.com/haizlin/fe-interview/issues/778)\n- [React-Router怎么设置重定向？](https://github.com/haizlin/fe-interview/issues/777)\n- [React-Router 4中`<Router>`组件有几种类型？](https://github.com/haizlin/fe-interview/issues/776)\n- [React-Router 3和React-Router\n  4有什么变化？添加了什么好的特性？](https://github.com/haizlin/fe-interview/issues/775)\n- [React-Router的实现原理是什么？](https://github.com/haizlin/fe-interview/issues/774)\n- [React-Router 4的switch有什么用？](https://github.com/haizlin/fe-interview/issues/773)\n- [React-Router的路由有几种模式？](https://github.com/haizlin/fe-interview/issues/772)\n- [React-Router 4怎样在路由变化时重新渲染同一个组件？](https://github.com/haizlin/fe-interview/issues/771)\n- [React-Router的`<Link>`标签和`<a>`标签有什么区别？](https://github.com/haizlin/fe-interview/issues/770)\n- [React的路由和普通路由有什么区别？](https://github.com/haizlin/fe-interview/issues/728)\n- [请你说说React的路由的优缺点？](https://github.com/haizlin/fe-interview/issues/727)\n- [请你说说React的路由是什么？](https://github.com/haizlin/fe-interview/issues/726)\n\n### Redux/Mobx\n\n- [你有了解Rxjs是什么吗？它是做什么的？](https://github.com/haizlin/fe-interview/issues/920)\n- [在Redux中怎么发起网络请求？](https://github.com/haizlin/fe-interview/issues/919)\n- [Redux怎样重置状态？](https://github.com/haizlin/fe-interview/issues/918)\n- [Redux怎样设置初始状态？](https://github.com/haizlin/fe-interview/issues/917)\n- [Context api可以取代Redux吗？为什么？](https://github.com/haizlin/fe-interview/issues/916)\n- [推荐在reducer中触发Action吗？为什么？](https://github.com/haizlin/fe-interview/issues/915)\n- [Redux怎么添加新的中间件？](https://github.com/haizlin/fe-interview/issues/914)\n- [redux-saga和redux-thunk有什么本质的区别？](https://github.com/haizlin/fe-interview/issues/913)\n- [在React中你是怎么对异步方案进行选型的？](https://github.com/haizlin/fe-interview/issues/912)\n- [你知道redux-saga的原理吗？](https://github.com/haizlin/fe-interview/issues/911)\n- [你有使用过redux-saga中间件吗？它是干什么的？](https://github.com/haizlin/fe-interview/issues/910)\n- [Redux中异步action和同步action最大的区别是什么？](https://github.com/haizlin/fe-interview/issues/769)\n- [Redux和vuex有什么区别？](https://github.com/haizlin/fe-interview/issues/768)\n- [Redux的中间件是什么？你有用过哪些Redux的中间件？](https://github.com/haizlin/fe-interview/issues/767)\n- [说说Redux的实现流程](https://github.com/haizlin/fe-interview/issues/766)\n- [Mobx的设计思想是什么？](https://github.com/haizlin/fe-interview/issues/765)\n- [Redux由哪些组件构成？](https://github.com/haizlin/fe-interview/issues/764)\n- [Mobx和Redux有什么区别？](https://github.com/haizlin/fe-interview/issues/763)\n- [在React项目中你是如何选择Redux和Mobx的？说说你的理解](https://github.com/haizlin/fe-interview/issues/762)\n- [你有在React中使用过Mobx吗？它的运用场景有哪些？](https://github.com/haizlin/fe-interview/issues/761)\n- [Redux的thunk作用是什么？](https://github.com/haizlin/fe-interview/issues/740)\n- [Redux的数据存储和本地储存有什么区别？](https://github.com/haizlin/fe-interview/issues/739)\n- [在Redux中，什么是reducer？它有什么作用？](https://github.com/haizlin/fe-interview/issues/738)\n- [举例说明怎么在Redux中定义action？](https://github.com/haizlin/fe-interview/issues/737)\n- [在Redux中，什么是action？](https://github.com/haizlin/fe-interview/issues/736)\n- [在Redux中，什么是store？](https://github.com/haizlin/fe-interview/issues/735)\n- [为什么Redux能做到局部渲染呢？](https://github.com/haizlin/fe-interview/issues/734)\n- [说说Redux的优缺点分别是什么？](https://github.com/haizlin/fe-interview/issues/733)\n- [Redux和Flux的区别是什么？](https://github.com/haizlin/fe-interview/issues/732)\n- [Redux它的三个原则是什么？](https://github.com/haizlin/fe-interview/issues/731)\n- [什么是单一数据源？](https://github.com/haizlin/fe-interview/issues/730)\n- [什么是Redux？说说你对Redux的理解？有哪些运用场景？](https://github.com/haizlin/fe-interview/issues/729)\n\n### Flux\n\n- [请说说点击按钮触发到状态更改，数据的流向？](https://github.com/haizlin/fe-interview/issues/742)\n- [请描述下Flux的思想](https://github.com/haizlin/fe-interview/issues/742)\n- [什么是Flux？说说你对Flux的理解？有哪些运用场景？](https://github.com/haizlin/fe-interview/issues/741)\n\n## Reference\n\n- <https://github.com/qiu-deqing/FE-interview>\n- <https://github.com/haizlin/fe-interview>\n","source":"_drafts/2.每日 3+1.md","raw":"---\ntitle: 每日 3+1\nindex_img: /img/index-img.png\ndate: 2022-01-01 08:28:12\ntags:\ncategories:\n---\n\n- [你有使用过loadable组件吗？它帮我们解决了什么问题？](https://github.com/haizlin/fe-interview/issues/897)\n- [你有使用过suspense组件吗？它帮我们解决了什么问题？](https://github.com/haizlin/fe-interview/issues/896)\n- [怎样动态导入组件？](https://github.com/haizlin/fe-interview/issues/895)\n- [如何给非控组件设置默认的值？](https://github.com/haizlin/fe-interview/issues/894)\n- [怎么在React中引入其它的UI库，例如Bootstrap](https://github.com/haizlin/fe-interview/issues/893)\n- [怎样将事件传递给子组件？](https://github.com/haizlin/fe-interview/issues/892)\n- [怎样使用Hooks获取服务端数据？](https://github.com/haizlin/fe-interview/issues/891)\n- [使用Hooks要遵守哪些原则？](https://github.com/haizlin/fe-interview/issues/890)\n- [render方法的原理你有了解吗？它返回的数据类型是什么？](https://github.com/haizlin/fe-interview/issues/889)\n- [useEffect和useLayoutEffect有什么区别？](https://github.com/haizlin/fe-interview/issues/888)\n- [在React项目中你用过哪些动画的包？](https://github.com/haizlin/fe-interview/issues/887)\n- [React必须使用JSX吗？](https://github.com/haizlin/fe-interview/issues/886)\n- [自定义组件时render是可选的吗？为什么？](https://github.com/haizlin/fe-interview/issues/885)\n- [需要把keys设置为全局唯一吗？](https://github.com/haizlin/fe-interview/issues/884)\n- [怎么定时更新一个组件？](https://github.com/haizlin/fe-interview/issues/883)\n- [React根据不同的环境打包不同的域名？](https://github.com/haizlin/fe-interview/issues/882)\n- [使用webpack打包React项目，怎么减小生成的js大小？](https://github.com/haizlin/fe-interview/issues/881)\n- [在React中怎么使用async/await？](https://github.com/haizlin/fe-interview/issues/880)\n- [你阅读了几遍React的源码？都有哪些收获？你是怎么阅读的？](https://github.com/haizlin/fe-interview/issues/879)\n- [什么是React.forwardRef？它有什么作用？](https://github.com/haizlin/fe-interview/issues/878)\n- [写个例子说明什么是JSX的内联条件渲染](https://github.com/haizlin/fe-interview/issues/877)\n- [在React中怎么将参数传递给事件？](https://github.com/haizlin/fe-interview/issues/876)\n- [React的事件和普通的HTML事件有什么不同？](https://github.com/haizlin/fe-interview/issues/875)\n- [在React中怎么阻止事件的默认行为？](https://github.com/haizlin/fe-interview/issues/874)\n- [你最喜欢React的哪一个特性（说一个就好）？](https://github.com/haizlin/fe-interview/issues/873)\n- [在React中什么时候使用箭头函数更方便呢？](https://github.com/haizlin/fe-interview/issues/872)\n- [你最不喜欢React的哪一个特性（说一个就好）？](https://github.com/haizlin/fe-interview/issues/871)\n- [说说你对React的reconciliation（一致化算法）的理解](https://github.com/haizlin/fe-interview/issues/870)\n- [使用PropTypes和Flow有什么区别？](https://github.com/haizlin/fe-interview/issues/869)\n- [怎样有条件地渲染组件？](https://github.com/haizlin/fe-interview/issues/868)\n- [在JSX中如何写注释？](https://github.com/haizlin/fe-interview/issues/867)\n- [constructor和getInitialState有不同？](https://github.com/haizlin/fe-interview/issues/866)\n- [写例子说明React如何在JSX中实现for循环](https://github.com/haizlin/fe-interview/issues/865)\n- [为什么建议Fragment包裹元素？它的简写是什么？](https://github.com/haizlin/fe-interview/issues/864)\n- [你有用过React.Fragment吗？说说它有什么用途？](https://github.com/haizlin/fe-interview/issues/863)\n- [在React中你有遇到过安全问题吗？怎么解决？](https://github.com/haizlin/fe-interview/issues/862)\n- [React中如何监听state的变化？](https://github.com/haizlin/fe-interview/issues/861)\n- [React什么是有状态组件？](https://github.com/haizlin/fe-interview/issues/860)\n- [React v15中怎么处理错误边界？](https://github.com/haizlin/fe-interview/issues/859)\n- [React Fiber它的目的是解决什么问题？](https://github.com/haizlin/fe-interview/issues/858)\n- [React为什么不要直接修改state？如果想修改怎么做？](https://github.com/haizlin/fe-interview/issues/857)\n- [create-react-app有什么好处？](https://github.com/haizlin/fe-interview/issues/856)\n- [装饰器(Decorator)在React中有什么应用？](https://github.com/haizlin/fe-interview/issues/855)\n- [使用高阶组件(HOC)实现一个loading组件](https://github.com/haizlin/fe-interview/issues/854)\n- [如何用React实现滚动动画？](https://github.com/haizlin/fe-interview/issues/853)\n- [说出几点你认为的React最佳实践](https://github.com/haizlin/fe-interview/issues/852)\n- [你是如何划分React组件的？](https://github.com/haizlin/fe-interview/issues/851)\n- [举例说明如何在React创建一个事件](https://github.com/haizlin/fe-interview/issues/850)\n- [如何更新组件的状态？](https://github.com/haizlin/fe-interview/issues/849)\n- [怎样将多个组件嵌入到一个组件中？](https://github.com/haizlin/fe-interview/issues/848)\n- [React的render中可以写{if else}这样的判断吗？](https://github.com/haizlin/fe-interview/issues/847)\n- [React为什么要搞一个Hooks？](https://github.com/haizlin/fe-interview/issues/846)\n- [React Hooks帮我们解决了哪些问题？](https://github.com/haizlin/fe-interview/issues/845)\n- [使用React的memo和forwardRef包装的组件为什么提示children类型不对？](https://github.com/haizlin/fe-interview/issues/844)\n- [有在项目中使用过Antd吗？说说它的好处](https://github.com/haizlin/fe-interview/issues/843)\n- [在React中如果去除生产环境上的sourcemap？](https://github.com/haizlin/fe-interview/issues/842)\n- [在React中怎么引用sass或less？](https://github.com/haizlin/fe-interview/issues/841)\n- [组件卸载前，加在DOM元素的监听事件和定时器要不要手动清除？为什么？](https://github.com/haizlin/fe-interview/issues/840)\n- [为什么标签里的for要写成htmlFor呢？](https://github.com/haizlin/fe-interview/issues/839)\n- [状态管理器解决了什么问题？什么时候用状态管理器？](https://github.com/haizlin/fe-interview/issues/838)\n- [状态管理器它精髓是什么？](https://github.com/haizlin/fe-interview/issues/837)\n- [函数式组件有没有生命周期？为什么？](https://github.com/haizlin/fe-interview/issues/836)\n- [在React中怎么引用第三方插件？比如说jQuery等](https://github.com/haizlin/fe-interview/issues/835)\n- [React的触摸事件有哪几种？](https://github.com/haizlin/fe-interview/issues/834)\n- [路由切换时同一组件无法重新渲染的有什么方法可以解决？](https://github.com/haizlin/fe-interview/issues/833)\n- [React16新特性有哪些？](https://github.com/haizlin/fe-interview/issues/832)\n- [你有用过哪些React的UI库？它们的优缺点分别是什么？](https://github.com/haizlin/fe-interview/issues/831)\n- [`<div onClick={handlerClick}>单击</div>`和`<div onClick={handlerClick(1)}>单击</div>`有什么区别？](https://github.com/haizlin/fe-interview/issues/830)\n- [在React中如何引入图片？哪种方式更好？](https://github.com/haizlin/fe-interview/issues/829)\n- [在React中怎么使用字体图标？](https://github.com/haizlin/fe-interview/issues/828)\n- [React的应用如何打包发布？它的步骤是什么？](https://github.com/haizlin/fe-interview/issues/827)\n- [ES6的语法'...'在React中有哪些应用？](https://github.com/haizlin/fe-interview/issues/826)\n- [如何封装一个React的全局公共组件？](https://github.com/haizlin/fe-interview/issues/825)\n- [在React中组件的props改变时更新组件的有哪些方法？](https://github.com/haizlin/fe-interview/issues/824)\n- [immutable的原理是什么？](https://github.com/haizlin/fe-interview/issues/823)\n- [你对immutable有了解吗？它有什么作用？](https://github.com/haizlin/fe-interview/issues/822)\n- [如何提高组件的渲染效率呢？](https://github.com/haizlin/fe-interview/issues/821)\n- [在React中如何避免不必要的render？](https://github.com/haizlin/fe-interview/issues/820)\n- [render在什么时候会被触发？](https://github.com/haizlin/fe-interview/issues/819)\n- [写出React动态改变class切换组件样式](https://github.com/haizlin/fe-interview/issues/818)\n- [React中怎么操作虚拟DOM的Class属性？](https://github.com/haizlin/fe-interview/issues/817)\n- [为什么属性使用className而不是class呢？](https://github.com/haizlin/fe-interview/issues/816)\n- [请说下react组件更新的机制是什么？](https://github.com/haizlin/fe-interview/issues/815)\n- [怎么在JSX里属性可以被覆盖吗？覆盖的原则是什么？](https://github.com/haizlin/fe-interview/issues/814)\n- [怎么在JSX里使用自定义属性？](https://github.com/haizlin/fe-interview/issues/813)\n- [怎么防止HTML被转义？](https://github.com/haizlin/fe-interview/issues/812)\n- [经常用React，你知道React的核心思想是什么吗？](https://github.com/haizlin/fe-interview/issues/811)\n- [在React中我们怎么做静态类型检测？都有哪些方法可以做到？](https://github.com/haizlin/fe-interview/issues/810)\n- [在React中组件的state和setState有什么区别？](https://github.com/haizlin/fe-interview/issues/809)\n- [React怎样跳过重新渲染？](https://github.com/haizlin/fe-interview/issues/808)\n- [React怎么判断什么时候重新渲染组件呢？](https://github.com/haizlin/fe-interview/issues/807)\n- [什么是React的实例？函数式组件有没有实例？](https://github.com/haizlin/fe-interview/issues/806)\n- [在React中如何判断点击元素属于哪一个组件？](https://github.com/haizlin/fe-interview/issues/805)\n- [在React中组件和元素有什么区别？](https://github.com/haizlin/fe-interview/issues/804)\n- [在React中声明组件时组件名的第一个字母必须是大写吗？为什么？](https://github.com/haizlin/fe-interview/issues/803)\n- [举例说明什么是高阶组件(HOC)的反向继承？](https://github.com/haizlin/fe-interview/issues/802)\n- [有用过React Devtools吗？说说它的优缺点分别是什么？](https://github.com/haizlin/fe-interview/issues/801)\n- [举例说明什么是高阶组件(HOC)的属性代理？](https://github.com/haizlin/fe-interview/issues/800)\n- [React的isMounted有什么作用？](https://github.com/haizlin/fe-interview/issues/799)\n- [React组件命名推荐的方式是哪个？为什么不推荐使用displayName？](https://github.com/haizlin/fe-interview/issues/798)\n- [React的displayName有什么作用？](https://github.com/haizlin/fe-interview/issues/797)\n- [说说你对React的组件命名规范的理解](https://github.com/haizlin/fe-interview/issues/796)\n- [说说你对React的项目结构的理解](https://github.com/haizlin/fe-interview/issues/795)\n- [React16废弃了哪些生命周期？为什么？](https://github.com/haizlin/fe-interview/issues/794)\n- [怎样在React中开启生产模式？](https://github.com/haizlin/fe-interview/issues/793)\n- [React中getInitialState方法的作用是什么？](https://github.com/haizlin/fe-interview/issues/792)\n- [React中你知道creatClass的原理吗？](https://github.com/haizlin/fe-interview/issues/791)\n- [React中验证props的目的是什么？](https://github.com/haizlin/fe-interview/issues/790)\n- [React中你有使用过getDefaultProps吗？它有什么作用？](https://github.com/haizlin/fe-interview/issues/789)\n- [React中你有使用过propType吗？它有什么作用？](https://github.com/haizlin/fe-interview/issues/788)\n- [React中怎么检验props？](https://github.com/haizlin/fe-interview/issues/787)\n- [React.createClass和extends Component的区别有哪些？](https://github.com/haizlin/fe-interview/issues/786)\n- [高阶组件(HOC)有哪些优点和缺点？](https://github.com/haizlin/fe-interview/issues/785)\n- [给组件设置很多属性时不想一个个去设置有什么办法可以解决这问题呢？](https://github.com/haizlin/fe-interview/issues/784)\n- [React16跟之前的版本生命周期有哪些变化？](https://github.com/haizlin/fe-interview/issues/756)\n- [怎样实现React组件的记忆？原理是什么？](https://github.com/haizlin/fe-interview/issues/755)\n- [创建React动画有哪些方式？](https://github.com/haizlin/fe-interview/issues/754)\n- [为什么建议不要过渡使用Refs？](https://github.com/haizlin/fe-interview/issues/753)\n- [在React使用高阶组件(HOC)有遇到过哪些问题？如何解决？](https://github.com/haizlin/fe-interview/issues/752)\n- [在使用React过程中什么时候用高阶组件(HOC)？](https://github.com/haizlin/fe-interview/issues/751)\n- [说说React diff的原理是什么？](https://github.com/haizlin/fe-interview/issues/724)\n- [React怎么提高列表渲染的性能？](https://github.com/haizlin/fe-interview/issues/723)\n- [使用ES6的class定义的组件不支持mixins了，那用什么可以替代呢？](https://github.com/haizlin/fe-interview/issues/722)\n- [为何说虚拟DOM会提高性能？](https://github.com/haizlin/fe-interview/issues/720)\n- [React的性能优化在哪个生命周期？它优化的原理是什么？](https://github.com/haizlin/fe-interview/issues/719)\n- [你知道的React性能优化有哪些方法？](https://github.com/haizlin/fe-interview/issues/718)\n- [举例说明在React中怎么使用样式？](https://github.com/haizlin/fe-interview/issues/717)\n- [React有哪几种方法来处理表单输入？](https://github.com/haizlin/fe-interview/issues/716)\n- [什么是浅层渲染？](https://github.com/haizlin/fe-interview/issues/715)\n- [你有做过React的单元测试吗？如果有，用的是哪些工具？怎么做的？](https://github.com/haizlin/fe-interview/issues/714)\n- [在React中什么是合成事件？有什么用？](https://github.com/haizlin/fe-interview/issues/713)\n- [使用React写一个todo应用，说说你的思路](https://github.com/haizlin/fe-interview/issues/712)\n- [React16的reconciliation和commit分别是什么？](https://github.com/haizlin/fe-interview/issues/711)\n- [React的函数式组件有没有生命周期？](https://github.com/haizlin/fe-interview/issues/710)\n- [useState和this.state的区别是什么？](https://github.com/haizlin/fe-interview/issues/709)\n- [请说说什么是useImperativeHandle？](https://github.com/haizlin/fe-interview/issues/708)\n- [请说说什么是useReducer？](https://github.com/haizlin/fe-interview/issues/707)\n- [请说说什么是useRef？](https://github.com/haizlin/fe-interview/issues/706)\n- [请说说什么是useEffect？](https://github.com/haizlin/fe-interview/issues/705)\n- [举例说明useState](https://github.com/haizlin/fe-interview/issues/704)\n- [请说说什么是useState？为什么要使用useState？](https://github.com/haizlin/fe-interview/issues/703)\n- [请描述下你对React的新特性Hooks的理解？它有哪些应用场景？](https://github.com/haizlin/fe-interview/issues/702)\n- [说说你对Error Boundaries的理解](https://github.com/haizlin/fe-interview/issues/701)\n- [说说你对Fiber架构的理解](https://github.com/haizlin/fe-interview/issues/700)\n- [说说你是怎么理解React的业务组件和技术组件的？](https://github.com/haizlin/fe-interview/issues/699)\n- [为什么建议setState的第一个参数是callback而不是一个对象呢？](https://github.com/haizlin/fe-interview/issues/698)\n- [展示组件和容器组件有什么区别？](https://github.com/haizlin/fe-interview/issues/697)\n- [Mern和Yeoman脚手架有什么区别？](https://github.com/haizlin/fe-interview/issues/696)\n- [你有在项目中使用过Yeoman脚手架吗？](https://github.com/haizlin/fe-interview/issues/695)\n- [你有在项目中使用过Mern脚手架吗？](https://github.com/haizlin/fe-interview/issues/694)\n- [shouldComponentUpdate方法是做什么的？](https://github.com/haizlin/fe-interview/issues/693)\n- [怎样在React中使用innerHTML？](https://github.com/haizlin/fe-interview/issues/692)\n- [你有写过React的中间件插件吗？](https://github.com/haizlin/fe-interview/issues/691)\n- [React的中间件机制是怎么样的？这种机制有什么作用？](https://github.com/haizlin/fe-interview/issues/690)\n- [React中你用过哪些第三方的中间件？](https://github.com/haizlin/fe-interview/issues/689)\n- [不用脚手架，你会手动搭建React项目吗？](https://github.com/haizlin/fe-interview/issues/688)\n- [请说说React中Portal是什么？](https://github.com/haizlin/fe-interview/issues/687)\n- [React中修改prop引发的生命周期有哪几个？](https://github.com/haizlin/fe-interview/issues/686)\n- [React多个setState调用的原理是什么？](https://github.com/haizlin/fe-interview/issues/685)\n- [React中调用setState会更新的生命周期有哪几个？](https://github.com/haizlin/fe-interview/issues/684)\n- [React中setState的第二个参数作用是什么呢？](https://github.com/haizlin/fe-interview/issues/683)\n- [React中的setState是同步还是异步的呢？为什么state并不一定会同步更新？](https://github.com/haizlin/fe-interview/issues/682)\n- [React中的setState批量更新的过程是什么？](https://github.com/haizlin/fe-interview/issues/681)\n- [React中的setState执行机制是什么呢？](https://github.com/haizlin/fe-interview/issues/680)\n- [在React中遍历的方法有哪些？它们有什么区别呢？](https://github.com/haizlin/fe-interview/issues/679)\n- [请说说你对React的render方法的理解](https://github.com/haizlin/fe-interview/issues/678)\n- [props.children.map和js的map有什么区别？为什么优先选择React的？](https://github.com/haizlin/fe-interview/issues/677)\n- [有用过React的严格模式吗？](https://github.com/haizlin/fe-interview/issues/676)\n- [React中的setState和replaceState的区别是什么？](https://github.com/haizlin/fe-interview/issues/675)\n- [React中的setState缺点是什么呢？](https://github.com/haizlin/fe-interview/issues/674)\n- [有用过React的Fragment吗？它的运用场景是什么？](https://github.com/haizlin/fe-interview/issues/673)\n- [React组件间共享数据方法有哪些？](https://github.com/haizlin/fe-interview/issues/672)\n- [React的状态提升是什么？使用场景有哪些？](https://github.com/haizlin/fe-interview/issues/671)\n- [简单描述下你有做过哪些React项目？](https://github.com/haizlin/fe-interview/issues/670)\n- [在构造函数中调用super(props)的目的是什么？](https://github.com/haizlin/fe-interview/issues/669)\n- [你是如何学习React的？](https://github.com/haizlin/fe-interview/issues/668)\n- [从旧版本的React升级到新版本的React有做过吗？有遇到过什么坑？](https://github.com/haizlin/fe-interview/issues/667)\n- [你用过React版本有哪些？](https://github.com/haizlin/fe-interview/issues/666)\n- [有用过React的服务端渲染吗？怎么做的？](https://github.com/haizlin/fe-interview/issues/665)\n- [React的mixins有什么作用？适用于什么场景？](https://github.com/haizlin/fe-interview/issues/664)\n- [React怎么拿到组件对应的DOM元素？](https://github.com/haizlin/fe-interview/issues/663)\n- [请描述下事件在React中的处理方式是什么？](https://github.com/haizlin/fe-interview/issues/662)\n- [JSX和HTML有什么区别？](https://github.com/haizlin/fe-interview/issues/661)\n- [React的书写规范有哪些？](https://github.com/haizlin/fe-interview/issues/660)\n- [create-react-app创建新运用怎么解决卡的问题？](https://github.com/haizlin/fe-interview/issues/659)\n- [使用React的方式有哪几种？](https://github.com/haizlin/fe-interview/issues/658)\n- [说说你对reader的context的理解](https://github.com/haizlin/fe-interview/issues/657)\n- [同时引用这三个库React.js、React-dom.js和babel.js它们都有什么作用？](https://github.com/haizlin/fe-interview/issues/656)\n- [你知道Virtual DOM的工作原理吗？](https://github.com/haizlin/fe-interview/issues/655)\n- [你阅读过React的源码吗？简要说下它的执行流程](https://github.com/haizlin/fe-interview/issues/654)\n- [React中怎样阻止组件渲染？](https://github.com/haizlin/fe-interview/issues/653)\n- [React非兄弟组件如何通信？](https://github.com/haizlin/fe-interview/issues/652)\n- [React兄弟组件如何通信？](https://github.com/haizlin/fe-interview/issues/651)\n- [React非父子组件如何通信？](https://github.com/haizlin/fe-interview/issues/650)\n- [React父子组件如何通信？](https://github.com/haizlin/fe-interview/issues/649)\n- [React组件间的通信有哪些？](https://github.com/haizlin/fe-interview/issues/648)\n- [类组件和函数式组件有什么区别？](https://github.com/haizlin/fe-interview/issues/647)\n- [React自定义组件你写过吗？说说看都写过哪些？](https://github.com/haizlin/fe-interview/issues/646)\n- [React组件的state和props两者有什么区别？](https://github.com/haizlin/fe-interview/issues/645)\n- [React有几种构建组件的方式？可以写出来吗？](https://github.com/haizlin/fe-interview/issues/644)\n- [React中遍历时为什么不用索引作为唯一的key值？](https://github.com/haizlin/fe-interview/issues/643)\n- [React中的key有什么作用？](https://github.com/haizlin/fe-interview/issues/642)\n- [React中除了在构造函数中绑定this,还有别的方式吗？](https://github.com/haizlin/fe-interview/issues/641)\n- [在React中页面重新加载时怎样保留数据？](https://github.com/haizlin/fe-interview/issues/640)\n- [请描述下React的事件机制](https://github.com/haizlin/fe-interview/issues/639)\n- [怎样在React中创建一个事件？](https://github.com/haizlin/fe-interview/issues/638)\n- [在React中无状态组件有什么运用场景？](https://github.com/haizlin/fe-interview/issues/637)\n- [描述下在React中无状态组件和有状态组件的区别是什么？](https://github.com/haizlin/fe-interview/issues/636)\n- [写一个React的高阶组件(HOC)并说明你对它的理解](https://github.com/haizlin/fe-interview/issues/635)\n- [React中可以在render访问refs吗？为什么？](https://github.com/haizlin/fe-interview/issues/634)\n- [React中refs的作用是什么？有哪些应用场景？](https://github.com/haizlin/fe-interview/issues/633)\n- [请描述你对纯函数的理解？](https://github.com/haizlin/fe-interview/issues/632)\n- [受控组件和非受控组件有什么区别？](https://github.com/haizlin/fe-interview/issues/631)\n- [React中什么是非控组件？](https://github.com/haizlin/fe-interview/issues/630)\n- [React中什么是受控组件？](https://github.com/haizlin/fe-interview/issues/629)\n- [React中发起网络请求应该在哪个生命周期中进行？为什么？](https://github.com/haizlin/fe-interview/issues/628)\n- [说说React的生命周期有哪些？](https://github.com/haizlin/fe-interview/issues/627)\n- [说说你对“在React中，一切都是组件”的理解](https://github.com/haizlin/fe-interview/issues/626)\n- [写React你是用es6还是es5的语法？有什么区别？](https://github.com/haizlin/fe-interview/issues/625)\n- [浏览器为什么无法直接JSX？怎么解决呢？](https://github.com/haizlin/fe-interview/issues/624)\n- [在使用React过程中你都踩过哪些坑？你是怎么填坑的？](https://github.com/haizlin/fe-interview/issues/623)\n- [说说你喜欢React的原因是什么？它有什么优缺点？](https://github.com/haizlin/fe-interview/issues/622)\n- [如何解决引用类型在pureComponent下修改值的时候，页面不渲染的问题？](https://github.com/haizlin/fe-interview/issues/621)\n- [createElement与cloneElement两者有什么区别？](https://github.com/haizlin/fe-interview/issues/620)\n- [解释下React中Element 和Component两者的区别是什么？](https://github.com/haizlin/fe-interview/issues/619)\n- [解释下React中component和pureComponent两者的区别是什么？](https://github.com/haizlin/fe-interview/issues/618)\n- [React的虚拟DOM和vue的虚拟DOM有什么区别？](https://github.com/haizlin/fe-interview/issues/617)\n- [你觉得React上手快不快？它有哪些限制？](https://github.com/haizlin/fe-interview/issues/616)\n- [说说你对声明式编程的理解？](https://github.com/haizlin/fe-interview/issues/615)\n- [React与angular、vue有什么区别？](https://github.com/haizlin/fe-interview/issues/614)\n- [React是哪个公司开发的？](https://github.com/haizlin/fe-interview/issues/613)\n- [React是什么？它的主要特点是什么？](https://github.com/haizlin/fe-interview/issues/612)\n- [简要描述下你知道的React工作原理是什么？](https://github.com/haizlin/fe-interview/issues/611)\n- [在React中怎样改变组件状态，以及状态改变的过程是什么？](https://github.com/haizlin/fe-interview/issues/606)\n- [在React中你是怎么进行状态管理的？](https://github.com/haizlin/fe-interview/issues/605)\n- [React声明组件有哪几种方法，各有什么不同？](https://github.com/haizlin/fe-interview/issues/604)\n\n### ReactNative\n\n- [如何在React Native中设置环境变量？]()\n- [请描述下Code Push的原理是什么？](https://github.com/haizlin/fe-interview/issues/783)\n- [React Native怎样查看日记？](https://github.com/haizlin/fe-interview/issues/782)\n- [React Native怎样测试？](https://github.com/haizlin/fe-interview/issues/781)\n- [React Native怎样调试？](https://github.com/haizlin/fe-interview/issues/780)\n- [React Native和React有什么区别？](https://github.com/haizlin/fe-interview/issues/779)\n- [有做过React Native项目吗？](https://github.com/haizlin/fe-interview/issues/725)\n\n### React-Router\n\n- [React-Router怎么获取历史对象？](https://github.com/haizlin/fe-interview/issues/922)\n- [React-Router怎么获取URL的参数？](https://github.com/haizlin/fe-interview/issues/921)\n- [在history模式中push和replace有什么区别？](https://github.com/haizlin/fe-interview/issues/778)\n- [React-Router怎么设置重定向？](https://github.com/haizlin/fe-interview/issues/777)\n- [React-Router 4中`<Router>`组件有几种类型？](https://github.com/haizlin/fe-interview/issues/776)\n- [React-Router 3和React-Router\n  4有什么变化？添加了什么好的特性？](https://github.com/haizlin/fe-interview/issues/775)\n- [React-Router的实现原理是什么？](https://github.com/haizlin/fe-interview/issues/774)\n- [React-Router 4的switch有什么用？](https://github.com/haizlin/fe-interview/issues/773)\n- [React-Router的路由有几种模式？](https://github.com/haizlin/fe-interview/issues/772)\n- [React-Router 4怎样在路由变化时重新渲染同一个组件？](https://github.com/haizlin/fe-interview/issues/771)\n- [React-Router的`<Link>`标签和`<a>`标签有什么区别？](https://github.com/haizlin/fe-interview/issues/770)\n- [React的路由和普通路由有什么区别？](https://github.com/haizlin/fe-interview/issues/728)\n- [请你说说React的路由的优缺点？](https://github.com/haizlin/fe-interview/issues/727)\n- [请你说说React的路由是什么？](https://github.com/haizlin/fe-interview/issues/726)\n\n### Redux/Mobx\n\n- [你有了解Rxjs是什么吗？它是做什么的？](https://github.com/haizlin/fe-interview/issues/920)\n- [在Redux中怎么发起网络请求？](https://github.com/haizlin/fe-interview/issues/919)\n- [Redux怎样重置状态？](https://github.com/haizlin/fe-interview/issues/918)\n- [Redux怎样设置初始状态？](https://github.com/haizlin/fe-interview/issues/917)\n- [Context api可以取代Redux吗？为什么？](https://github.com/haizlin/fe-interview/issues/916)\n- [推荐在reducer中触发Action吗？为什么？](https://github.com/haizlin/fe-interview/issues/915)\n- [Redux怎么添加新的中间件？](https://github.com/haizlin/fe-interview/issues/914)\n- [redux-saga和redux-thunk有什么本质的区别？](https://github.com/haizlin/fe-interview/issues/913)\n- [在React中你是怎么对异步方案进行选型的？](https://github.com/haizlin/fe-interview/issues/912)\n- [你知道redux-saga的原理吗？](https://github.com/haizlin/fe-interview/issues/911)\n- [你有使用过redux-saga中间件吗？它是干什么的？](https://github.com/haizlin/fe-interview/issues/910)\n- [Redux中异步action和同步action最大的区别是什么？](https://github.com/haizlin/fe-interview/issues/769)\n- [Redux和vuex有什么区别？](https://github.com/haizlin/fe-interview/issues/768)\n- [Redux的中间件是什么？你有用过哪些Redux的中间件？](https://github.com/haizlin/fe-interview/issues/767)\n- [说说Redux的实现流程](https://github.com/haizlin/fe-interview/issues/766)\n- [Mobx的设计思想是什么？](https://github.com/haizlin/fe-interview/issues/765)\n- [Redux由哪些组件构成？](https://github.com/haizlin/fe-interview/issues/764)\n- [Mobx和Redux有什么区别？](https://github.com/haizlin/fe-interview/issues/763)\n- [在React项目中你是如何选择Redux和Mobx的？说说你的理解](https://github.com/haizlin/fe-interview/issues/762)\n- [你有在React中使用过Mobx吗？它的运用场景有哪些？](https://github.com/haizlin/fe-interview/issues/761)\n- [Redux的thunk作用是什么？](https://github.com/haizlin/fe-interview/issues/740)\n- [Redux的数据存储和本地储存有什么区别？](https://github.com/haizlin/fe-interview/issues/739)\n- [在Redux中，什么是reducer？它有什么作用？](https://github.com/haizlin/fe-interview/issues/738)\n- [举例说明怎么在Redux中定义action？](https://github.com/haizlin/fe-interview/issues/737)\n- [在Redux中，什么是action？](https://github.com/haizlin/fe-interview/issues/736)\n- [在Redux中，什么是store？](https://github.com/haizlin/fe-interview/issues/735)\n- [为什么Redux能做到局部渲染呢？](https://github.com/haizlin/fe-interview/issues/734)\n- [说说Redux的优缺点分别是什么？](https://github.com/haizlin/fe-interview/issues/733)\n- [Redux和Flux的区别是什么？](https://github.com/haizlin/fe-interview/issues/732)\n- [Redux它的三个原则是什么？](https://github.com/haizlin/fe-interview/issues/731)\n- [什么是单一数据源？](https://github.com/haizlin/fe-interview/issues/730)\n- [什么是Redux？说说你对Redux的理解？有哪些运用场景？](https://github.com/haizlin/fe-interview/issues/729)\n\n### Flux\n\n- [请说说点击按钮触发到状态更改，数据的流向？](https://github.com/haizlin/fe-interview/issues/742)\n- [请描述下Flux的思想](https://github.com/haizlin/fe-interview/issues/742)\n- [什么是Flux？说说你对Flux的理解？有哪些运用场景？](https://github.com/haizlin/fe-interview/issues/741)\n\n## Reference\n\n- <https://github.com/qiu-deqing/FE-interview>\n- <https://github.com/haizlin/fe-interview>\n","slug":"2-每日-3-1","published":0,"updated":"2022-08-23T02:19:23.472Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn4h002myu3lc9wyfqat","content":"<ul>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/897\">你有使用过loadable组件吗？它帮我们解决了什么问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/896\">你有使用过suspense组件吗？它帮我们解决了什么问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/895\">怎样动态导入组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/894\">如何给非控组件设置默认的值？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/893\">怎么在React中引入其它的UI库，例如Bootstrap</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/892\">怎样将事件传递给子组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/891\">怎样使用Hooks获取服务端数据？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/890\">使用Hooks要遵守哪些原则？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/889\">render方法的原理你有了解吗？它返回的数据类型是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/888\">useEffect和useLayoutEffect有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/887\">在React项目中你用过哪些动画的包？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/886\">React必须使用JSX吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/885\">自定义组件时render是可选的吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/884\">需要把keys设置为全局唯一吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/883\">怎么定时更新一个组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/882\">React根据不同的环境打包不同的域名？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/881\">使用webpack打包React项目，怎么减小生成的js大小？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/880\">在React中怎么使用async/await？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/879\">你阅读了几遍React的源码？都有哪些收获？你是怎么阅读的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/878\">什么是React.forwardRef？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/877\">写个例子说明什么是JSX的内联条件渲染</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/876\">在React中怎么将参数传递给事件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/875\">React的事件和普通的HTML事件有什么不同？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/874\">在React中怎么阻止事件的默认行为？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/873\">你最喜欢React的哪一个特性（说一个就好）？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/872\">在React中什么时候使用箭头函数更方便呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/871\">你最不喜欢React的哪一个特性（说一个就好）？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/870\">说说你对React的reconciliation（一致化算法）的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/869\">使用PropTypes和Flow有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/868\">怎样有条件地渲染组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/867\">在JSX中如何写注释？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/866\">constructor和getInitialState有不同？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/865\">写例子说明React如何在JSX中实现for循环</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/864\">为什么建议Fragment包裹元素？它的简写是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/863\">你有用过React.Fragment吗？说说它有什么用途？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/862\">在React中你有遇到过安全问题吗？怎么解决？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/861\">React中如何监听state的变化？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/860\">React什么是有状态组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/859\">React v15中怎么处理错误边界？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/858\">React Fiber它的目的是解决什么问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/857\">React为什么不要直接修改state？如果想修改怎么做？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/856\">create-react-app有什么好处？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/855\">装饰器(Decorator)在React中有什么应用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/854\">使用高阶组件(HOC)实现一个loading组件</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/853\">如何用React实现滚动动画？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/852\">说出几点你认为的React最佳实践</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/851\">你是如何划分React组件的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/850\">举例说明如何在React创建一个事件</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/849\">如何更新组件的状态？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/848\">怎样将多个组件嵌入到一个组件中？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/847\">React的render中可以写{if else}这样的判断吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/846\">React为什么要搞一个Hooks？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/845\">React Hooks帮我们解决了哪些问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/844\">使用React的memo和forwardRef包装的组件为什么提示children类型不对？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/843\">有在项目中使用过Antd吗？说说它的好处</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/842\">在React中如果去除生产环境上的sourcemap？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/841\">在React中怎么引用sass或less？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/840\">组件卸载前，加在DOM元素的监听事件和定时器要不要手动清除？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/839\">为什么标签里的for要写成htmlFor呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/838\">状态管理器解决了什么问题？什么时候用状态管理器？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/837\">状态管理器它精髓是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/836\">函数式组件有没有生命周期？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/835\">在React中怎么引用第三方插件？比如说jQuery等</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/834\">React的触摸事件有哪几种？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/833\">路由切换时同一组件无法重新渲染的有什么方法可以解决？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/832\">React16新特性有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/831\">你有用过哪些React的UI库？它们的优缺点分别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/830\"><code>&lt;div onClick=&#123;handlerClick&#125;&gt;单击&lt;/div&gt;</code>和<code>&lt;div onClick=&#123;handlerClick(1)&#125;&gt;单击&lt;/div&gt;</code>有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/829\">在React中如何引入图片？哪种方式更好？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/828\">在React中怎么使用字体图标？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/827\">React的应用如何打包发布？它的步骤是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/826\">ES6的语法’…’在React中有哪些应用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/825\">如何封装一个React的全局公共组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/824\">在React中组件的props改变时更新组件的有哪些方法？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/823\">immutable的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/822\">你对immutable有了解吗？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/821\">如何提高组件的渲染效率呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/820\">在React中如何避免不必要的render？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/819\">render在什么时候会被触发？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/818\">写出React动态改变class切换组件样式</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/817\">React中怎么操作虚拟DOM的Class属性？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/816\">为什么属性使用className而不是class呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/815\">请说下react组件更新的机制是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/814\">怎么在JSX里属性可以被覆盖吗？覆盖的原则是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/813\">怎么在JSX里使用自定义属性？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/812\">怎么防止HTML被转义？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/811\">经常用React，你知道React的核心思想是什么吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/810\">在React中我们怎么做静态类型检测？都有哪些方法可以做到？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/809\">在React中组件的state和setState有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/808\">React怎样跳过重新渲染？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/807\">React怎么判断什么时候重新渲染组件呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/806\">什么是React的实例？函数式组件有没有实例？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/805\">在React中如何判断点击元素属于哪一个组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/804\">在React中组件和元素有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/803\">在React中声明组件时组件名的第一个字母必须是大写吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/802\">举例说明什么是高阶组件(HOC)的反向继承？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/801\">有用过React Devtools吗？说说它的优缺点分别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/800\">举例说明什么是高阶组件(HOC)的属性代理？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/799\">React的isMounted有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/798\">React组件命名推荐的方式是哪个？为什么不推荐使用displayName？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/797\">React的displayName有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/796\">说说你对React的组件命名规范的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/795\">说说你对React的项目结构的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/794\">React16废弃了哪些生命周期？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/793\">怎样在React中开启生产模式？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/792\">React中getInitialState方法的作用是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/791\">React中你知道creatClass的原理吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/790\">React中验证props的目的是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/789\">React中你有使用过getDefaultProps吗？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/788\">React中你有使用过propType吗？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/787\">React中怎么检验props？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/786\">React.createClass和extends Component的区别有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/785\">高阶组件(HOC)有哪些优点和缺点？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/784\">给组件设置很多属性时不想一个个去设置有什么办法可以解决这问题呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/756\">React16跟之前的版本生命周期有哪些变化？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/755\">怎样实现React组件的记忆？原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/754\">创建React动画有哪些方式？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/753\">为什么建议不要过渡使用Refs？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/752\">在React使用高阶组件(HOC)有遇到过哪些问题？如何解决？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/751\">在使用React过程中什么时候用高阶组件(HOC)？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/724\">说说React diff的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/723\">React怎么提高列表渲染的性能？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/722\">使用ES6的class定义的组件不支持mixins了，那用什么可以替代呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/720\">为何说虚拟DOM会提高性能？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/719\">React的性能优化在哪个生命周期？它优化的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/718\">你知道的React性能优化有哪些方法？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/717\">举例说明在React中怎么使用样式？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/716\">React有哪几种方法来处理表单输入？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/715\">什么是浅层渲染？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/714\">你有做过React的单元测试吗？如果有，用的是哪些工具？怎么做的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/713\">在React中什么是合成事件？有什么用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/712\">使用React写一个todo应用，说说你的思路</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/711\">React16的reconciliation和commit分别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/710\">React的函数式组件有没有生命周期？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/709\">useState和this.state的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/708\">请说说什么是useImperativeHandle？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/707\">请说说什么是useReducer？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/706\">请说说什么是useRef？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/705\">请说说什么是useEffect？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/704\">举例说明useState</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/703\">请说说什么是useState？为什么要使用useState？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/702\">请描述下你对React的新特性Hooks的理解？它有哪些应用场景？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/701\">说说你对Error Boundaries的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/700\">说说你对Fiber架构的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/699\">说说你是怎么理解React的业务组件和技术组件的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/698\">为什么建议setState的第一个参数是callback而不是一个对象呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/697\">展示组件和容器组件有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/696\">Mern和Yeoman脚手架有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/695\">你有在项目中使用过Yeoman脚手架吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/694\">你有在项目中使用过Mern脚手架吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/693\">shouldComponentUpdate方法是做什么的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/692\">怎样在React中使用innerHTML？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/691\">你有写过React的中间件插件吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/690\">React的中间件机制是怎么样的？这种机制有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/689\">React中你用过哪些第三方的中间件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/688\">不用脚手架，你会手动搭建React项目吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/687\">请说说React中Portal是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/686\">React中修改prop引发的生命周期有哪几个？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/685\">React多个setState调用的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/684\">React中调用setState会更新的生命周期有哪几个？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/683\">React中setState的第二个参数作用是什么呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/682\">React中的setState是同步还是异步的呢？为什么state并不一定会同步更新？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/681\">React中的setState批量更新的过程是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/680\">React中的setState执行机制是什么呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/679\">在React中遍历的方法有哪些？它们有什么区别呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/678\">请说说你对React的render方法的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/677\">props.children.map和js的map有什么区别？为什么优先选择React的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/676\">有用过React的严格模式吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/675\">React中的setState和replaceState的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/674\">React中的setState缺点是什么呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/673\">有用过React的Fragment吗？它的运用场景是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/672\">React组件间共享数据方法有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/671\">React的状态提升是什么？使用场景有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/670\">简单描述下你有做过哪些React项目？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/669\">在构造函数中调用super(props)的目的是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/668\">你是如何学习React的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/667\">从旧版本的React升级到新版本的React有做过吗？有遇到过什么坑？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/666\">你用过React版本有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/665\">有用过React的服务端渲染吗？怎么做的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/664\">React的mixins有什么作用？适用于什么场景？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/663\">React怎么拿到组件对应的DOM元素？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/662\">请描述下事件在React中的处理方式是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/661\">JSX和HTML有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/660\">React的书写规范有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/659\">create-react-app创建新运用怎么解决卡的问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/658\">使用React的方式有哪几种？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/657\">说说你对reader的context的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/656\">同时引用这三个库React.js、React-dom.js和babel.js它们都有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/655\">你知道Virtual DOM的工作原理吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/654\">你阅读过React的源码吗？简要说下它的执行流程</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/653\">React中怎样阻止组件渲染？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/652\">React非兄弟组件如何通信？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/651\">React兄弟组件如何通信？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/650\">React非父子组件如何通信？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/649\">React父子组件如何通信？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/648\">React组件间的通信有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/647\">类组件和函数式组件有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/646\">React自定义组件你写过吗？说说看都写过哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/645\">React组件的state和props两者有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/644\">React有几种构建组件的方式？可以写出来吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/643\">React中遍历时为什么不用索引作为唯一的key值？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/642\">React中的key有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/641\">React中除了在构造函数中绑定this,还有别的方式吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/640\">在React中页面重新加载时怎样保留数据？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/639\">请描述下React的事件机制</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/638\">怎样在React中创建一个事件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/637\">在React中无状态组件有什么运用场景？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/636\">描述下在React中无状态组件和有状态组件的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/635\">写一个React的高阶组件(HOC)并说明你对它的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/634\">React中可以在render访问refs吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/633\">React中refs的作用是什么？有哪些应用场景？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/632\">请描述你对纯函数的理解？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/631\">受控组件和非受控组件有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/630\">React中什么是非控组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/629\">React中什么是受控组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/628\">React中发起网络请求应该在哪个生命周期中进行？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/627\">说说React的生命周期有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/626\">说说你对“在React中，一切都是组件”的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/625\">写React你是用es6还是es5的语法？有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/624\">浏览器为什么无法直接JSX？怎么解决呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/623\">在使用React过程中你都踩过哪些坑？你是怎么填坑的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/622\">说说你喜欢React的原因是什么？它有什么优缺点？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/621\">如何解决引用类型在pureComponent下修改值的时候，页面不渲染的问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/620\">createElement与cloneElement两者有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/619\">解释下React中Element 和Component两者的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/618\">解释下React中component和pureComponent两者的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/617\">React的虚拟DOM和vue的虚拟DOM有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/616\">你觉得React上手快不快？它有哪些限制？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/615\">说说你对声明式编程的理解？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/614\">React与angular、vue有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/613\">React是哪个公司开发的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/612\">React是什么？它的主要特点是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/611\">简要描述下你知道的React工作原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/606\">在React中怎样改变组件状态，以及状态改变的过程是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/605\">在React中你是怎么进行状态管理的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/604\">React声明组件有哪几种方法，各有什么不同？</a></li>\n</ul>\n<h3 id=\"ReactNative\"><a href=\"#ReactNative\" class=\"headerlink\" title=\"ReactNative\"></a>ReactNative</h3><ul>\n<li><a href=\"\">如何在React Native中设置环境变量？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/783\">请描述下Code Push的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/782\">React Native怎样查看日记？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/781\">React Native怎样测试？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/780\">React Native怎样调试？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/779\">React Native和React有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/725\">有做过React Native项目吗？</a></li>\n</ul>\n<h3 id=\"React-Router\"><a href=\"#React-Router\" class=\"headerlink\" title=\"React-Router\"></a>React-Router</h3><ul>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/922\">React-Router怎么获取历史对象？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/921\">React-Router怎么获取URL的参数？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/778\">在history模式中push和replace有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/777\">React-Router怎么设置重定向？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/776\">React-Router 4中<code>&lt;Router&gt;</code>组件有几种类型？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/775\">React-Router 3和React-Router<br>4有什么变化？添加了什么好的特性？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/774\">React-Router的实现原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/773\">React-Router 4的switch有什么用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/772\">React-Router的路由有几种模式？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/771\">React-Router 4怎样在路由变化时重新渲染同一个组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/770\">React-Router的<code>&lt;Link&gt;</code>标签和<code>&lt;a&gt;</code>标签有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/728\">React的路由和普通路由有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/727\">请你说说React的路由的优缺点？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/726\">请你说说React的路由是什么？</a></li>\n</ul>\n<h3 id=\"Redux-Mobx\"><a href=\"#Redux-Mobx\" class=\"headerlink\" title=\"Redux/Mobx\"></a>Redux/Mobx</h3><ul>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/920\">你有了解Rxjs是什么吗？它是做什么的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/919\">在Redux中怎么发起网络请求？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/918\">Redux怎样重置状态？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/917\">Redux怎样设置初始状态？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/916\">Context api可以取代Redux吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/915\">推荐在reducer中触发Action吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/914\">Redux怎么添加新的中间件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/913\">redux-saga和redux-thunk有什么本质的区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/912\">在React中你是怎么对异步方案进行选型的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/911\">你知道redux-saga的原理吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/910\">你有使用过redux-saga中间件吗？它是干什么的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/769\">Redux中异步action和同步action最大的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/768\">Redux和vuex有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/767\">Redux的中间件是什么？你有用过哪些Redux的中间件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/766\">说说Redux的实现流程</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/765\">Mobx的设计思想是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/764\">Redux由哪些组件构成？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/763\">Mobx和Redux有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/762\">在React项目中你是如何选择Redux和Mobx的？说说你的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/761\">你有在React中使用过Mobx吗？它的运用场景有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/740\">Redux的thunk作用是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/739\">Redux的数据存储和本地储存有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/738\">在Redux中，什么是reducer？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/737\">举例说明怎么在Redux中定义action？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/736\">在Redux中，什么是action？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/735\">在Redux中，什么是store？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/734\">为什么Redux能做到局部渲染呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/733\">说说Redux的优缺点分别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/732\">Redux和Flux的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/731\">Redux它的三个原则是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/730\">什么是单一数据源？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/729\">什么是Redux？说说你对Redux的理解？有哪些运用场景？</a></li>\n</ul>\n<h3 id=\"Flux\"><a href=\"#Flux\" class=\"headerlink\" title=\"Flux\"></a>Flux</h3><ul>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/742\">请说说点击按钮触发到状态更改，数据的流向？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/742\">请描述下Flux的思想</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/741\">什么是Flux？说说你对Flux的理解？有哪些运用场景？</a></li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ul>\n<li><a href=\"https://github.com/qiu-deqing/FE-interview\">https://github.com/qiu-deqing/FE-interview</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview\">https://github.com/haizlin/fe-interview</a></li>\n</ul>\n","site":{"data":{}},"wordcount":6721,"excerpt":"","more":"<ul>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/897\">你有使用过loadable组件吗？它帮我们解决了什么问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/896\">你有使用过suspense组件吗？它帮我们解决了什么问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/895\">怎样动态导入组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/894\">如何给非控组件设置默认的值？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/893\">怎么在React中引入其它的UI库，例如Bootstrap</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/892\">怎样将事件传递给子组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/891\">怎样使用Hooks获取服务端数据？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/890\">使用Hooks要遵守哪些原则？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/889\">render方法的原理你有了解吗？它返回的数据类型是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/888\">useEffect和useLayoutEffect有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/887\">在React项目中你用过哪些动画的包？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/886\">React必须使用JSX吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/885\">自定义组件时render是可选的吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/884\">需要把keys设置为全局唯一吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/883\">怎么定时更新一个组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/882\">React根据不同的环境打包不同的域名？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/881\">使用webpack打包React项目，怎么减小生成的js大小？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/880\">在React中怎么使用async/await？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/879\">你阅读了几遍React的源码？都有哪些收获？你是怎么阅读的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/878\">什么是React.forwardRef？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/877\">写个例子说明什么是JSX的内联条件渲染</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/876\">在React中怎么将参数传递给事件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/875\">React的事件和普通的HTML事件有什么不同？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/874\">在React中怎么阻止事件的默认行为？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/873\">你最喜欢React的哪一个特性（说一个就好）？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/872\">在React中什么时候使用箭头函数更方便呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/871\">你最不喜欢React的哪一个特性（说一个就好）？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/870\">说说你对React的reconciliation（一致化算法）的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/869\">使用PropTypes和Flow有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/868\">怎样有条件地渲染组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/867\">在JSX中如何写注释？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/866\">constructor和getInitialState有不同？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/865\">写例子说明React如何在JSX中实现for循环</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/864\">为什么建议Fragment包裹元素？它的简写是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/863\">你有用过React.Fragment吗？说说它有什么用途？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/862\">在React中你有遇到过安全问题吗？怎么解决？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/861\">React中如何监听state的变化？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/860\">React什么是有状态组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/859\">React v15中怎么处理错误边界？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/858\">React Fiber它的目的是解决什么问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/857\">React为什么不要直接修改state？如果想修改怎么做？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/856\">create-react-app有什么好处？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/855\">装饰器(Decorator)在React中有什么应用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/854\">使用高阶组件(HOC)实现一个loading组件</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/853\">如何用React实现滚动动画？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/852\">说出几点你认为的React最佳实践</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/851\">你是如何划分React组件的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/850\">举例说明如何在React创建一个事件</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/849\">如何更新组件的状态？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/848\">怎样将多个组件嵌入到一个组件中？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/847\">React的render中可以写{if else}这样的判断吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/846\">React为什么要搞一个Hooks？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/845\">React Hooks帮我们解决了哪些问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/844\">使用React的memo和forwardRef包装的组件为什么提示children类型不对？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/843\">有在项目中使用过Antd吗？说说它的好处</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/842\">在React中如果去除生产环境上的sourcemap？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/841\">在React中怎么引用sass或less？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/840\">组件卸载前，加在DOM元素的监听事件和定时器要不要手动清除？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/839\">为什么标签里的for要写成htmlFor呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/838\">状态管理器解决了什么问题？什么时候用状态管理器？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/837\">状态管理器它精髓是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/836\">函数式组件有没有生命周期？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/835\">在React中怎么引用第三方插件？比如说jQuery等</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/834\">React的触摸事件有哪几种？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/833\">路由切换时同一组件无法重新渲染的有什么方法可以解决？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/832\">React16新特性有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/831\">你有用过哪些React的UI库？它们的优缺点分别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/830\"><code>&lt;div onClick=&#123;handlerClick&#125;&gt;单击&lt;/div&gt;</code>和<code>&lt;div onClick=&#123;handlerClick(1)&#125;&gt;单击&lt;/div&gt;</code>有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/829\">在React中如何引入图片？哪种方式更好？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/828\">在React中怎么使用字体图标？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/827\">React的应用如何打包发布？它的步骤是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/826\">ES6的语法’…’在React中有哪些应用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/825\">如何封装一个React的全局公共组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/824\">在React中组件的props改变时更新组件的有哪些方法？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/823\">immutable的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/822\">你对immutable有了解吗？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/821\">如何提高组件的渲染效率呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/820\">在React中如何避免不必要的render？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/819\">render在什么时候会被触发？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/818\">写出React动态改变class切换组件样式</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/817\">React中怎么操作虚拟DOM的Class属性？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/816\">为什么属性使用className而不是class呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/815\">请说下react组件更新的机制是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/814\">怎么在JSX里属性可以被覆盖吗？覆盖的原则是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/813\">怎么在JSX里使用自定义属性？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/812\">怎么防止HTML被转义？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/811\">经常用React，你知道React的核心思想是什么吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/810\">在React中我们怎么做静态类型检测？都有哪些方法可以做到？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/809\">在React中组件的state和setState有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/808\">React怎样跳过重新渲染？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/807\">React怎么判断什么时候重新渲染组件呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/806\">什么是React的实例？函数式组件有没有实例？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/805\">在React中如何判断点击元素属于哪一个组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/804\">在React中组件和元素有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/803\">在React中声明组件时组件名的第一个字母必须是大写吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/802\">举例说明什么是高阶组件(HOC)的反向继承？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/801\">有用过React Devtools吗？说说它的优缺点分别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/800\">举例说明什么是高阶组件(HOC)的属性代理？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/799\">React的isMounted有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/798\">React组件命名推荐的方式是哪个？为什么不推荐使用displayName？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/797\">React的displayName有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/796\">说说你对React的组件命名规范的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/795\">说说你对React的项目结构的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/794\">React16废弃了哪些生命周期？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/793\">怎样在React中开启生产模式？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/792\">React中getInitialState方法的作用是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/791\">React中你知道creatClass的原理吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/790\">React中验证props的目的是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/789\">React中你有使用过getDefaultProps吗？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/788\">React中你有使用过propType吗？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/787\">React中怎么检验props？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/786\">React.createClass和extends Component的区别有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/785\">高阶组件(HOC)有哪些优点和缺点？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/784\">给组件设置很多属性时不想一个个去设置有什么办法可以解决这问题呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/756\">React16跟之前的版本生命周期有哪些变化？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/755\">怎样实现React组件的记忆？原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/754\">创建React动画有哪些方式？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/753\">为什么建议不要过渡使用Refs？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/752\">在React使用高阶组件(HOC)有遇到过哪些问题？如何解决？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/751\">在使用React过程中什么时候用高阶组件(HOC)？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/724\">说说React diff的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/723\">React怎么提高列表渲染的性能？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/722\">使用ES6的class定义的组件不支持mixins了，那用什么可以替代呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/720\">为何说虚拟DOM会提高性能？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/719\">React的性能优化在哪个生命周期？它优化的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/718\">你知道的React性能优化有哪些方法？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/717\">举例说明在React中怎么使用样式？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/716\">React有哪几种方法来处理表单输入？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/715\">什么是浅层渲染？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/714\">你有做过React的单元测试吗？如果有，用的是哪些工具？怎么做的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/713\">在React中什么是合成事件？有什么用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/712\">使用React写一个todo应用，说说你的思路</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/711\">React16的reconciliation和commit分别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/710\">React的函数式组件有没有生命周期？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/709\">useState和this.state的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/708\">请说说什么是useImperativeHandle？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/707\">请说说什么是useReducer？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/706\">请说说什么是useRef？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/705\">请说说什么是useEffect？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/704\">举例说明useState</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/703\">请说说什么是useState？为什么要使用useState？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/702\">请描述下你对React的新特性Hooks的理解？它有哪些应用场景？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/701\">说说你对Error Boundaries的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/700\">说说你对Fiber架构的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/699\">说说你是怎么理解React的业务组件和技术组件的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/698\">为什么建议setState的第一个参数是callback而不是一个对象呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/697\">展示组件和容器组件有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/696\">Mern和Yeoman脚手架有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/695\">你有在项目中使用过Yeoman脚手架吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/694\">你有在项目中使用过Mern脚手架吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/693\">shouldComponentUpdate方法是做什么的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/692\">怎样在React中使用innerHTML？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/691\">你有写过React的中间件插件吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/690\">React的中间件机制是怎么样的？这种机制有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/689\">React中你用过哪些第三方的中间件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/688\">不用脚手架，你会手动搭建React项目吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/687\">请说说React中Portal是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/686\">React中修改prop引发的生命周期有哪几个？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/685\">React多个setState调用的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/684\">React中调用setState会更新的生命周期有哪几个？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/683\">React中setState的第二个参数作用是什么呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/682\">React中的setState是同步还是异步的呢？为什么state并不一定会同步更新？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/681\">React中的setState批量更新的过程是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/680\">React中的setState执行机制是什么呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/679\">在React中遍历的方法有哪些？它们有什么区别呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/678\">请说说你对React的render方法的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/677\">props.children.map和js的map有什么区别？为什么优先选择React的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/676\">有用过React的严格模式吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/675\">React中的setState和replaceState的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/674\">React中的setState缺点是什么呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/673\">有用过React的Fragment吗？它的运用场景是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/672\">React组件间共享数据方法有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/671\">React的状态提升是什么？使用场景有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/670\">简单描述下你有做过哪些React项目？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/669\">在构造函数中调用super(props)的目的是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/668\">你是如何学习React的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/667\">从旧版本的React升级到新版本的React有做过吗？有遇到过什么坑？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/666\">你用过React版本有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/665\">有用过React的服务端渲染吗？怎么做的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/664\">React的mixins有什么作用？适用于什么场景？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/663\">React怎么拿到组件对应的DOM元素？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/662\">请描述下事件在React中的处理方式是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/661\">JSX和HTML有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/660\">React的书写规范有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/659\">create-react-app创建新运用怎么解决卡的问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/658\">使用React的方式有哪几种？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/657\">说说你对reader的context的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/656\">同时引用这三个库React.js、React-dom.js和babel.js它们都有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/655\">你知道Virtual DOM的工作原理吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/654\">你阅读过React的源码吗？简要说下它的执行流程</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/653\">React中怎样阻止组件渲染？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/652\">React非兄弟组件如何通信？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/651\">React兄弟组件如何通信？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/650\">React非父子组件如何通信？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/649\">React父子组件如何通信？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/648\">React组件间的通信有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/647\">类组件和函数式组件有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/646\">React自定义组件你写过吗？说说看都写过哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/645\">React组件的state和props两者有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/644\">React有几种构建组件的方式？可以写出来吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/643\">React中遍历时为什么不用索引作为唯一的key值？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/642\">React中的key有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/641\">React中除了在构造函数中绑定this,还有别的方式吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/640\">在React中页面重新加载时怎样保留数据？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/639\">请描述下React的事件机制</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/638\">怎样在React中创建一个事件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/637\">在React中无状态组件有什么运用场景？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/636\">描述下在React中无状态组件和有状态组件的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/635\">写一个React的高阶组件(HOC)并说明你对它的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/634\">React中可以在render访问refs吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/633\">React中refs的作用是什么？有哪些应用场景？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/632\">请描述你对纯函数的理解？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/631\">受控组件和非受控组件有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/630\">React中什么是非控组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/629\">React中什么是受控组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/628\">React中发起网络请求应该在哪个生命周期中进行？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/627\">说说React的生命周期有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/626\">说说你对“在React中，一切都是组件”的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/625\">写React你是用es6还是es5的语法？有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/624\">浏览器为什么无法直接JSX？怎么解决呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/623\">在使用React过程中你都踩过哪些坑？你是怎么填坑的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/622\">说说你喜欢React的原因是什么？它有什么优缺点？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/621\">如何解决引用类型在pureComponent下修改值的时候，页面不渲染的问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/620\">createElement与cloneElement两者有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/619\">解释下React中Element 和Component两者的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/618\">解释下React中component和pureComponent两者的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/617\">React的虚拟DOM和vue的虚拟DOM有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/616\">你觉得React上手快不快？它有哪些限制？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/615\">说说你对声明式编程的理解？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/614\">React与angular、vue有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/613\">React是哪个公司开发的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/612\">React是什么？它的主要特点是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/611\">简要描述下你知道的React工作原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/606\">在React中怎样改变组件状态，以及状态改变的过程是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/605\">在React中你是怎么进行状态管理的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/604\">React声明组件有哪几种方法，各有什么不同？</a></li>\n</ul>\n<h3 id=\"ReactNative\"><a href=\"#ReactNative\" class=\"headerlink\" title=\"ReactNative\"></a>ReactNative</h3><ul>\n<li><a href=\"\">如何在React Native中设置环境变量？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/783\">请描述下Code Push的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/782\">React Native怎样查看日记？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/781\">React Native怎样测试？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/780\">React Native怎样调试？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/779\">React Native和React有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/725\">有做过React Native项目吗？</a></li>\n</ul>\n<h3 id=\"React-Router\"><a href=\"#React-Router\" class=\"headerlink\" title=\"React-Router\"></a>React-Router</h3><ul>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/922\">React-Router怎么获取历史对象？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/921\">React-Router怎么获取URL的参数？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/778\">在history模式中push和replace有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/777\">React-Router怎么设置重定向？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/776\">React-Router 4中<code>&lt;Router&gt;</code>组件有几种类型？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/775\">React-Router 3和React-Router<br>4有什么变化？添加了什么好的特性？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/774\">React-Router的实现原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/773\">React-Router 4的switch有什么用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/772\">React-Router的路由有几种模式？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/771\">React-Router 4怎样在路由变化时重新渲染同一个组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/770\">React-Router的<code>&lt;Link&gt;</code>标签和<code>&lt;a&gt;</code>标签有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/728\">React的路由和普通路由有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/727\">请你说说React的路由的优缺点？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/726\">请你说说React的路由是什么？</a></li>\n</ul>\n<h3 id=\"Redux-Mobx\"><a href=\"#Redux-Mobx\" class=\"headerlink\" title=\"Redux/Mobx\"></a>Redux/Mobx</h3><ul>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/920\">你有了解Rxjs是什么吗？它是做什么的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/919\">在Redux中怎么发起网络请求？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/918\">Redux怎样重置状态？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/917\">Redux怎样设置初始状态？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/916\">Context api可以取代Redux吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/915\">推荐在reducer中触发Action吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/914\">Redux怎么添加新的中间件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/913\">redux-saga和redux-thunk有什么本质的区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/912\">在React中你是怎么对异步方案进行选型的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/911\">你知道redux-saga的原理吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/910\">你有使用过redux-saga中间件吗？它是干什么的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/769\">Redux中异步action和同步action最大的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/768\">Redux和vuex有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/767\">Redux的中间件是什么？你有用过哪些Redux的中间件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/766\">说说Redux的实现流程</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/765\">Mobx的设计思想是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/764\">Redux由哪些组件构成？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/763\">Mobx和Redux有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/762\">在React项目中你是如何选择Redux和Mobx的？说说你的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/761\">你有在React中使用过Mobx吗？它的运用场景有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/740\">Redux的thunk作用是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/739\">Redux的数据存储和本地储存有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/738\">在Redux中，什么是reducer？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/737\">举例说明怎么在Redux中定义action？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/736\">在Redux中，什么是action？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/735\">在Redux中，什么是store？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/734\">为什么Redux能做到局部渲染呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/733\">说说Redux的优缺点分别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/732\">Redux和Flux的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/731\">Redux它的三个原则是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/730\">什么是单一数据源？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/729\">什么是Redux？说说你对Redux的理解？有哪些运用场景？</a></li>\n</ul>\n<h3 id=\"Flux\"><a href=\"#Flux\" class=\"headerlink\" title=\"Flux\"></a>Flux</h3><ul>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/742\">请说说点击按钮触发到状态更改，数据的流向？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/742\">请描述下Flux的思想</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/741\">什么是Flux？说说你对Flux的理解？有哪些运用场景？</a></li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ul>\n<li><a href=\"https://github.com/qiu-deqing/FE-interview\">https://github.com/qiu-deqing/FE-interview</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview\">https://github.com/haizlin/fe-interview</a></li>\n</ul>\n"},{"title":"前端工程师面试题","index_img":"/img/2022-02-16-1.jpeg","abbrlink":"a18c0ac9","date":"2022-02-15T02:39:21.000Z","_content":"\n## CSS\n\n1. 左右两栏布局， 一侧定宽、一侧自适应撑满?\n\n2. flex:1 到底代表什么?\n\n直观的记忆是，如果设置了flex: 1，所有子项平分父亲，不管子项是否设置了固定宽度。\n\n```text\nflex: 1 等价于\nflex-grow: 1;\nflex-shrink: 1;\nflex-basis: 0%;\n不管是否设置宽度，flex-basis的值都是0，所有子项平分全部的父亲空间\n\n而flex: auto 等价于\n\nflex-grow: 1;\nflex-shrink: 1;\nflex-basis: auto;\n如果设置了宽度，flex-basis的值是width，所有子项平分取去掉flex-basis的剩余空间\n```\n\n## JS\n\n- map 和 foreach 有什么区别\n\n```js\nforeach()方法会针对每一个元素执行提供得函数,该方法没有返回值,是否会改变原数组取决与数组元素的类型是基本类型还是引用类型\nmap()方法不会改变原数组的值,返回一个新数组,新数组中的值为原数组调用函数处理之后的值：\n```\n\n- 说一下for...in 和 for...of的区别?\n\n```js\nfor...of遍历获取的是对象的键值, for...in获取的是对象的键名;\nfor...in会遍历对象的整个原型链, 性能非常差不推荐使用,而for...of只遍历当前对象不会遍历原型链;\n对于数组的遍历,for...in会返回数组中所有可枚举的属性(包括原型链上可枚举的属性),for...of只返回数组的下标对应的属性值;\n总结：for...in循环主要是为了遍历对象而生,不适用遍历数组; for....of循环可以用来遍历数组、类数组对象、字符串、Set、Map以及Generator对象\n```\n\n1、请你讲一下闭包?\n\n> 简单：闭包是有权限访问其他函数作用域内的变量的一个函数。\n\n> 完整：由于在JS中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之回收，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数——也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后作用域内的值也不会被销毁。\n\n- 闭包解决了什么？\n\n> 由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。以平时使用的Ajax成功回调为例，这里其实就是个闭包，由于上述的特性，回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。开发者不用去写钩子函数来操作上级函数作用域内部的变量了。\n\n- 闭包有哪些应用场景?\n\n> 闭包随处可见，一个Ajax请求的成功回调，一个事件绑定的回调方法，一个setTimeout的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。\n\n- react hooks 中的 闭包陷阱问题如何解决？\n\n不管在这个组件中的其他地方使用 setCount 将 count 设置为任何值，还是设置多少次，打印的都是1\n\n```jsx\nfunction App(){\n    const [count, setCount] = useState(1);\n    useEffect(()=>{\n        setInterval(()=>{\n            console.log(count)\n        }, 1000)\n    }, [])\n}\n```\n\nuseRef\n\nuseState 更新值时传入回调函数\n\n2、介绍一下 JS 里面的原型？\n\n- 所有原型链的终点都是 Object 函数的 prototype 属性\n- 每一个构造函数都拥有一个 prototype 属性，此属性指向一个对象，也就是原型对象\n- 原型对象默认拥有一个 constructor 属性，指向指向它的那个构造函数\n- 每个对象都拥有一个隐藏的属性 **proto**，指向它的原型对象\n\n- 原型的作用是什么？\n\n> 共享方法\n\n- 原型中this的指向是什么？\n\n> 原型中this的指向是实例。\n\n- 说一下平时开发使用到 prototype 的例子？\n\n3、如何理解 es6 class 中 constructor 方法？ 和 super的作用？\n\n> constructor 方法是类的构造函数。 通过 new 命令创建对象实例时，自动调用该方法。 constructor 内定义的方法是 实例方法；class 内直接定义的方法是原型方法。\n\n- super 的作用？\n\n子类是没有自己的 this 对象的，它只能继承自父类的 this 对象，然后对其进行加工，而super( )就是将父类中的this对象继承给子类的。没有 super，子类就得不到 this 对象。\n\n- 为什么要传入 props？\n\n```jsx\nclass Component {\n  constructor(props) {\n    this.props = props;\n    // ...\n  }\n}\n```\n\n确保了 this.props 在构造函数执行完毕之前已被赋值。\n\n4、eventloop\n\n浏览器或node 端 js 单线程运行时不会阻塞的一种机制。\n\n任务分为宏任务和微任务；宏任务与微任务的区别?\n\n宏任务：script全部代码、setTimeout、setInterval、I/O、UI Rendering。\n微任务：Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver\n\n- 浏览器中的 event loop\n\nJS 中有一个主线程和一个调用栈（执行栈），所有的任务都会被放到调用栈中等待主线程执行。\n\nJS 调用栈后进先出原则，当函数执行的时候，会被添加到栈顶部，当执行完后，会被从栈顶移出，直到栈内被清空。\n\nJS\n任务分为同步任务和异步任务。同步任务在调用栈中按照顺序等待主线程依次执行。异步任务会在异步任务有结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），读取到栈内等待主线程执行。\n\n任务队列：先进先出\n\n顺序：同步任务 =》微任务 =》 宏任务\n\n- 执行栈在执行完同步任务后，查看执行栈是否为空\n- 如果执行栈为空，就会去检查微任务(microTask)队列, 执行完微任务，再执行宏任务\n- 每个宏任务执行完后，都会再检查微任务队列是否为空，不为空，就按先进先出执行完微任务，设置微任务为 null，再执行宏任务。\n\nNode 中 event loop(待补充)\n\n## React\n\n1、介绍一下react diff 算法 的工作原理？\n\n- react 状态变化渲染页面时，不会马上对DOM节点进行操作，是先通过diff算法计算后，再对有变化的DOM节点进行操作。\n- diff算法就是更高效地通过对比新旧Virtual DOM来找出真正的Dom变化之处.\n- react中diff算法主要遵循三个层级的策略:tree层级、component 层级、element 层级\n- tree层级: DOM节点跨层级的操作不做优化，只会对相同层级的节点进行比较.只有删除、创建操作.新树中，R节点下没有了A，那么直接删除A，在D节点下创建A以及下属节点。\n- component 层级:是同一个组件，则会继续往下diff运算，如果不是一个类的组件，那么直接删除这个组件下的所有子节点，创建新的\n- element 层级:对于比较同一层级的节点们，每个节点在对应的层级用唯一的key作为标识.\n\n  - 3 种节点操作，分别为 INSERT_MARKUP(插入)、MOVE_EXISTING (移动)和 REMOVE_NODE (删除)\n  - 通过key可以准确地发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置\n  - 如果当前节点在新集合中的位置比老集合中的位置靠前的话，是不会影响后续节点操作的，这里这时候被动字节不用动\n  - 当ABCD节点比较完成后，diff过程还没完，还会整体遍历老集合中节点，看有没有没用到的节点，有的话，就删除\n\n由于dom节点的移动操作开销是比较昂贵的，没有key的情况下要比有key的性能更好\n\n```HTML\n1.加key\n<div key='1'>1</div>             <div key='1'>1</div>     \n<div key='2'>2</div>             <div key='3'>3</div>  \n<div key='3'>3</div>  ========>  <div key='2'>2</div>  \n<div key='4'>4</div>             <div key='5'>5</div>  \n<div key='5'>5</div>             <div key='6'>6</div>  \n操作：节点2移动至下标为2的位置，新增节点6至下标为4的位置，删除节点4。\n\n2.不加key\n<div>1</div>             <div>1</div>     \n<div>2</div>             <div>3</div>  \n<div>3</div>  ========>  <div>2</div>  \n<div>4</div>             <div>5</div>  \n<div>5</div>             <div>6</div> \n操作：修改第1个到第5个节点的innerText\n```\n\nVirtual DOM 工作过程有：\n\n    1. state 变化，生成新的 Virtual Dom\n    2. 比较 Virtual Dom 与之前 Virtual Dom 的异同\n    3. 生成差异对象\n    4. 遍历差异对象并更新真实 DOM\n\n- React diff 算法 和 vue diff 的相同点和不同点有哪些？\n\n不同点：\n\n- vue的列表比对，采用从两端到中间的比对方式，而react则采用从左到右依次比对的方式。当一个集合，只是把最后一个节点移动到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移动到第一个\n- vue比对节点，当节点元素类型相同，但是className不同，认为是不同类型元素，删除重建，而react会认为是同类型节点，只是修改节点属性\n\nVue Diff使用双向链表，边对比，边更新DOM。React主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。\n\n相同点：\n\n- 虚拟DOM在比较时只比较同一层级节点，复杂度都为 O(n)，降低了算法复杂度；\n- 都使用key比较是否是相同节点，都是为了尽可能的复用节点\n- 都是操作虚拟DOM，最小化操作真实DOM，提高性能（其实虚拟DOM的优势 并不是在于它操作DOM快）\n- 都是不要用 index作为 key\n\n2、react 里什么是高阶组件？使用高阶组件的场景？\n\n> 高阶组件(HOC)是接受一个组件并返回一个新组件的函数。\n\n2、React setState 怎么获取到更新后的值?异步函数中为什么 setState 会立即更新?\n\n3、useState 为什么不能放到条件语句里面?\n\nReact通过单链表来管理Hooks。 update 阶段，每次调用 useState，链表就会执行 next 向后移动一步。如果将 useState\n写在条件判断中，假设条件判断不成立，没有执行里面的 useState 方法，会导致接下来所有的 useState 的取值出现偏移，从而导致异常发生。\n\n4、说一下 useRef 有哪些用法？\n\n> useRef 除了获取 dom，另一个用法： 保存数据，不造成 rerender 想要保存数据，又不想触发函数的更新，该数据的更新不会造成组件 rerender\n\n5、什么情况下使用 useCallback ？ 子组件接收一个方法，避免子组件重复渲染\n\n- react 中只要父组件的 render 了，那么默认情况下就会触发子组的 render，react\n  提供了来避免这种重渲染的性能开销的一些方法：React.PureComponent、React.memo ，shouldComponentUpdate()\n- 使用 React.memo 避免子组件做没必要的渲染。\n- Reace.memo 只会对 props 做浅比较，也就是父组件重新 render 之后会传入 不同引用的方法 getList，浅比较之后不相等，导致子组件还是依然会渲染。\n- useCallback 缓存一个函数，当依赖没有改变的时候，会一直返回同一个引用\n\n6、useCallback 与 useMemo 作用用来缓存，两者的区别是什么？\n\n> useMemo 缓存值；useCallback 缓存函数\n\n注意不要滥用：\n\n经常用在以下两种场景（要保持引用相等；对于组件内部用到的 object、array、函数等，如果用在了其他 Hook 的依赖数组中，或者作为 props 传递给了下游组件，应该使用\nuseMemo/useCallback）\n\n7、react ssr 实现原理？react ssr 是在什么场景下做的？\n\nserver端接收到客户端的请求路由后，查找对应的数据，以props、context、store的形式注入组件中。然后基于react提供的API：renderToString将组件转换为html字符串输出到客户端。客户端使用该数据进行渲染，保证数据的一致性。\n\nReact SSR之所以能够实现，本质是虚拟 DOM的存在。判断环境是服务器环境，可以操作 JavaScript 对象，把虚拟 DOM 映射成字符串输出。判断环境是客户端环境，可以操作\nJavaScript 对象，将虚拟 DOM 映射成真实 DOM ，完成页面挂载。\n\n8、 react 项目里做过哪些性能优化？\n\n代码层面：\n\n- 使用return null而不是CSS的display:none来控制节点的显示隐藏。保证同一时间页面的DOM节点尽可能的少。\n- props和state的数据尽可能简单明了，扁平化。\n- 不要使用数组下标作为key\n- 利用 shouldComponentUpdate 和 PureComponent 避免过多 render function\n- render里面尽量减少新建变量和bind函数，传递参数是尽量减少传递参数的数量。\n- 尽量将 props 和 state 扁平化，只传递 component 需要的 props（传得太多，或者层次传得太深，都会加重shouldComponentUpdate里面的数据比较负担），慎将\n  component 当作 props 传入\n\n代码体积优化:\n\n- 使用 babel-plugin-import 优化业务组件的引入，实现按需加载\n- 使用 生产版本\n- 使用 SplitChunksPlugin 拆分公共代码\n- 分析 CSS 和 JS 代码覆盖率\n- 优化 Webpack 中的库\n- 使用动态 import，懒加载 React 组件\n- 使用 webpack-bundle-analyzer 可视化 webpack 输出文件的大小\n- 使用 Tree Shaking & 教程 & Tree Shaking 优化\n\n9、有 用 过 lerna 吗 ？ 多 个 项 目 之 间 共 用 的 东 西 怎 么 共 享 ？\n\n10、使用 react 中，有没有遇到觉得比较难的点？是什么？\n\n11、使用 hooks 中遇到过哪些坑？为什么？\n\n- 不要在循环，条件或嵌套函数中调用Hook，必须始终在React函数的顶层使用Hook。这是因为React需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子函数。一旦在循环或条件分支语句中调用Hook，就容易导致调用顺序的不一致性。\n- 使用useState时候，使用push，pop，splice等直接更改数组对象的坑，应该采用析构方式.\n- 必包带来的坑,因为每次 render 都有一份新的状态，因此上述代码中的 setTimeout 使用产生了一个闭包，捕获了每次 render 后的 state，也就导致了输出了\n  0、1、2。如果你希望输出的内容是最新的 state 的话，可以通过 useRef 来保存 state。前文讲过 ref\n  在组件中只存在一份，无论何时使用它的引用都不会产生变化，因此可以来解决闭包引发的问题。\n\n## Vue\n\n1、Vue如何监听数组的变化？\n\n- 对象数据是怎么被监听的?\n\nvue2.x版本中，数据监听用 Object.defineProperty.\n通过Object.defineProperty来劫持对象属性的setter和getter操作，并创建一个监听器，当数据发生变化的时候发出通知\n\n- 数组数据是怎么被监听的?\n\nVue.js是基于Object.defineProperty对对象实现“响应式化”，而对于数组，Vue.js提供的方法是重写push、pop、shift、unshift、splice、sort、reverse这七个数组方法.\n\n如果需要用数组下标修改数组并实现响应式数据变化，Vue.js提供了$set()及$remove()方法。\n\n1、Vue 组件 data 为什么必须是函数？\n\n> 因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染。 所以一个组件的 data\n> 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。\n\n2、直接给一个数组项赋值，Vue 能检测到变化吗？\n\n由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。\n\n- Vue 不能检测到以下数组的变动:\n\n1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue\n\n```js\n// 解决办法\nvm.$set(vm.items, indexOfItem, newValue)\n```\n\n2.当你修改数组的长度时，例如：vm.items.length = newLength\n\n```js\n/ 解决办法\nvm.items.splice(newLength)\n```\n\n- 检测不到的原因是什么？\n\n当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在\ndata 里声明。\n\n但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的\n$set。\n\n3、vue2 中响应式（双向绑定）的原理？vue3 的原理？ Proxy 与 Object.defineProperty 的优劣对比? 为什么在 Vue3.0 采用了 Proxy,抛弃了\nObject.defineProperty？\n\n> Proxy的优势如下: Proxy 可以直接监听对象而非属性 Proxy 可以直接监听数组的变化 Proxy 有多达 13 种拦截方法,不限于\n> apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的 Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而\n> Object.defineProperty 只能遍历对象属性直接修改 Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利\n\n> Object.defineProperty 的优势如下:\n\n> 兼容性好,支持 IE9\n\n4、vuex 的工作流程是怎么样？\n\n> Vuex有5个重要的属性，分别是 State、Getter、Mutation、Action、Module，由 view 层发起一个 Action 给 Mutation，在 Mutation\n> 中修改状态，返回新的状态，通过 Getter暴露给 view层的组件或者页面，页面监测到状态改变于是更新页面。\n\n4、Vue 的初始化过程（new Vue(options)）都做了什么？\n\n处理组件配置项\n\n初始化根组件时进行了选项合并操作，将全局配置合并到根组件的局部配置上\n\n初始化每个子组件时做了一些性能优化，将组件配置对象上的一些深层次属性放到 vm.$options 选项中，以提高代码的执行效率\n\n初始化组件实例的关系属性，比如 $parent、$children、$root、$refs 等\n\n处理自定义事件\n\n调用 beforeCreate 钩子函数\n\n初始化组件的 inject 配置项，得到 ret[key] = val 形式的配置对象，然后对该配置对象进行响应式处理，并代理每个 key 到 vm 实例上\n\n数据响应式，处理 props、methods、data、computed、watch 等选项\n\n解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上，如果 provide 是函数就用 call(vm) 方法 返回 provide 里面定义的对象\n\n调用 created 钩子函数\n\n如果发现配置项上有 el 选项，则自动调用 $mount 方法，也就是说有了 el 选项，就不需要再手动调用 $mount 方法，反之，没提供 el 选项则必须调用 $mount\n\n接下来则进入挂载阶段\n\n4、beforeCreate 期间能拿到数据吗？\n\n```\n不能，因为数据初始化阶段是在 beforeCreate 之后执行\n```\n\n4、Vue nextTick使用场景及实现原理\n\n它主要是处理我们再变更完数据以后，无法立刻拿到最新的DOM节点对象的问题。\n\nvue执行完渲染后会执行this.nextTick()里面的callback函数。\n\n将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。\n\nnextTick流程总结： 1、将回调放到callbacks里等待执行；\n2、将执行函数（flushCallbacks）放到微任务或宏任务里；原码里按照是否原生支持Promise.then、MutationObserver和setImmediate的顺序决策，都不支持则使用setTimeout\n3、等到事件循环执行到微任务或者宏任务时，执行函数依次执行callbacks里的回调；\n\n5、Vue的nextTick具体是微任务还是宏任务?\n\n| 宏任务                   | 微任务              |\n| --------------------- | ---------------- |\n| setTimeout            | process.nextTick |\n| setInterval           | MutationObserver |\n| setImmediate          | Promise.then     |\n| requestAnimationFrame |                  |\n| MessageChannel        |                  |\n\n5、 Vue3 有哪些新的新特性？\n\n- 响应式系统\n- 自定义渲染器\n- 全部模块使用 TS 重构\n- Composition API 组合语法\n- 新一代工程化工具 Vite\n\n6、Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？\n\nvue2 问题：\n\n- 代码的可读性随着组件变大而变差\n- 每一种代码复用的方式，都存在缺点\n- TypeScript支持有限\n- 逻辑组织\n\n  - 大型组件, 需要不断跳转代码块\n  - 逻辑关注点相关的代码全都放在一个函数里\n\n- 逻辑复用\n\n  - vue2 用 mixin去复用相同的逻辑, 我们一个组件混入大量不同的 mixins 的时候,命名冲突,数据来源不清\n  - vue3 写 hook 函数\n\n6、父组件可以监听到子组件的生命周期吗？\n\n比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理。\n\n方法一：手动通过 $emit 触发父组件的事件\n\n```js\n// Parent.vue\n<Child @mounted=\"doSomething\"/>\n    \n// Child.vue\nmounted() {\n  this.$emit(\"mounted\");\n}\n```\n\n方法二：父组件引用子组件时通过 @hook 来监听\n\n```js\n//  Parent.vue\n<Child @hook:mounted=\"doSomething\" ></Child>\n    \n//  Child.vue\nmounted(){\n   console.log('子组件触发 mounted 钩子函数 ...');\n},\n```\n\n@hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。\n\n7、比较 Vue 和 React 两个框架，你觉得有哪些区别？\n\n- 监听数据变化的实现原理不同:\n\n  Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化. react 中，数据变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化。\n- 数据流的不同:\n- 模板渲染方式的不同:\n\n8、什么是异步组件？\n\n在声明或注册组件时，Vue 接受提供 Promise 的工厂函数。然后可以在调用该组件时对其进行“解析”。\n\n```js\nnew Vue({\n    components: {\n        ‘tweet-box’: () => import(‘./components/async/TweetBox’)\n    }\n});\n```\n\n## http\n\n1、HTTP有哪些请求方法？PUT 和 PATCH 有什么区别？\n\n- GET, POST 和 HEAD方法；OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT\n- PUT和PATCH都是更新资源，而PATCH用来对资源进行局部更新。\n\n2、http 状态码 403 是什么错误？\n\n- 403 forbidden，表示对请求资源的访问被服务器拒绝\n\n3、知道哪些 http 的缓存策略 ？控制缓存的请求头有哪些？\n\n- HTTP缓存机制分为强制缓存和协商缓存两类。\n- 强制缓存的意思就是不要问了(不发起请求)，直接用缓存吧。\n- 强制缓存常见技术有Expires和Cache-Control。\n- Expires的值是一个时间，表示这个时间前缓存都有效，都不需要发起请求。\n- Cache-Control有很多属性值，常用属性max-age设置了缓存有效的时间长度，单位为秒，这个时间没到，都不用发起请求。\n- immutable也是Cache-Control的一个属性，表示这个资源这辈子都不用再请求了，但是他兼容性不好，Cache-Control其他属性可以参考MDN的文档。\n- Cache-Control的max-age优先级比Expires高。\n- 协商缓存是为了知道有没有更新，必须跟服务端沟通过才知道的。常见技术有ETag和Last-Modified。\n- ETag其实就是给资源算一个hash值或者版本号，对应的常用request header为If-None-Match。\n- Last-Modified其实就是加上资源修改的时间，对应的常用request header为If-Modified-Since，精度为秒。\n- ETag每次修改都会改变，而Last-Modified的精度只到秒，所以ETag更准确，优先级更高，但是需要计算，所以服务端开销更大。\n- 强制缓存和协商缓存都存在的情况下，先判断强制缓存是否生效，如果生效，不用发起请求，直接用缓存。如果强制缓存不生效再发起请求判断协商缓存。\n\n> Cache-Control，ETag，Last-Modified\n\n## 其他\n\n- 怎么解决白屏问题?\n\n```js\n1、加loading\n2、骨架屏\n```\n\n- webpack loader 和 plugin 区 别 ？\n\n```js\nLoader：直译为\"加载器\"。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到`loader`。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。   \nPlugin：直译为\"插件\"。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。\n```\n\n1. 弱网环境下页面首屏如何快速加载?\n\n   1.缓存的使用 2.SSR使用 3.骨架屏使用\n\n2. code review需要注意的点，你做code reivew的话，会重点查看哪里，怎么写出高内聚，低耦合的代码，以实习中遇到的一个通用组件实现举例。\n3. 什 么 是 TS 泛 型 ？\n4. webpack 构 建 流 程 是 怎 样 的 ？\n5. webpack 热 更 新 原 理 ？\n6. 有没有读过哪些源码？\n7. 最近开发的项目具体业务是怎么样的？介绍一下？\n8. 对前端而言，你觉得函数式编程体现在哪些方面？\n\n   纯函数、不可变数据、高阶函数。 react 就是函数式思想，数据是不可变的，react 相当于纯函数，展示出来的 ui 就是结果。 redux 更是函数式思想\n\n## Devops 相关\n\n## Git\n\n- 常用 git 操作\n\n```js\ngit branch 查看本地所有分支\ngit status 查看当前状态 \ngit commit 提交 \ngit branch -a 查看所有的分支\ngit branch -r 查看远程所有分支\ngit commit -am \"init\" 提交并且加注释 \ngit remote add origin git@192.168.1.119:ndshow\ngit push origin master 将文件给推到服务器上 \ngit remote show origin 显示远程库origin里的资源 \ngit push origin master:develop\ngit push origin master:hb-dev 将本地库与服务器上的库进行关联 \ngit checkout --track origin/dev 切换到远程dev分支\ngit branch -D master develop 删除本地库develop\ngit checkout -b dev 建立一个新的本地分支dev\ngit merge origin/dev 将分支dev与当前分支进行合并\ngit checkout dev 切换到本地dev分支\ngit remote show 查看远程库\ngit add .\ngit rm 文件名(包括路径) 从git中删除指定文件\ngit clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来\ngit config --list 看所有用户\ngit ls-files 看已经被提交的\ngit rm [file name] 删除一个文件\ngit commit -a 提交当前repos的所有的改变\ngit add [file name] 添加一个文件到git index\ngit commit -v 当你用－v参数的时候可以看commit的差异\ngit commit -m \"This is the message describing the commit\" 添加commit信息\ngit commit -a -a是代表add，把所有的change加到git index里然后再commit\ngit commit -a -v 一般提交命令\ngit log 看你commit的日志\ngit diff 查看尚未暂存的更新\ngit rm a.a 移除文件(从暂存区和工作区中删除)\ngit rm --cached a.a 移除文件(只从暂存区中删除)\ngit commit -m \"remove\" 移除文件(从Git中删除)\ngit rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)\ngit diff --cached 或 $ git diff --staged 查看尚未提交的更新\ngit stash push 将文件给push到一个临时空间中\ngit stash pop 将文件从临时空间pop下来\n```\n\n1、什么情况下使用 git rebase, 而不用 git merge\n\n### nginx\n\n1. 谈谈一下对 nginx 的理解，项目中用到 nginx 的哪些功能？\n\n- Nginx ，是一个 Web 服务器和反向代理服务器用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。\n- 主要功能如下： 正向、反向代理 2、负载均衡、分流 3、虚拟主机（绑定host）\n\n2、正向代理和反向代理区别是什么？\n\n- 正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定原始服务器，然后代理向原始服务器转交请求并将获得的内容返回给客户端。代理服务器和客户端处于同一个局域网内。\n- 比如说fanqiang。我知道我要访问谷歌，于是我就告诉代理服务器让它帮我转发。\n- 反向代理实际运行方式是代理服务器接受网络上的连接请求。它将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给网络上请求连接的客户端 。代理服务器和原始服务器处于同一个局域网内。\n- 比如说我要访问taobao，对我来说不知道图片、json、css 是不是同一个服务器返回回来的，但是我不关心，是反向代理 处理的，我不知道原始服务器。\n\n3、nginx 如何来实现负载均衡？\n\n负载均衡的5种策略:\n\n```sh\n1.轮询（默认）\n 每个请求按时间顺序逐一分配到不同的后端服务器\n\n upstream backserver {\n    server 192.168.0.14;\n    server 192.168.0.15;\n}\n\n2.weight\n指定轮询几率，weight和访问概率成正比\n\nupstream backserver {\n    server 192.168.0.14 weight=3;\n    server 192.168.0.15 weight=7;\n}\n\n3.ip_hash\n已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的.ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。\n\nupstream backserver {\n    ip_hash;\n    server 192.168.0.14:88;\n    server 192.168.0.15:80;\n}\n\n4.fair\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n\nupstream backserver {\n    server server1;\n    server server2;\n    fair;\n}\n\n5.url_hash\n按访问url的hash结果来分配请求，使每个url定向到同一个（对应的）后端服务器，后端服务器为缓存时比较有效。\n\nupstream backserver {\n    server squid1:3128;\n    server squid2:3128;\n    hash $request_uri;\n    hash_method crc32;\n}\n```\n\n### docker\n\n1、什么是 Docker？\n\n- Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。\n\n2、Dockerfile中最常见的指令是什么？\n\n- FROM：指定基础镜像；LABEL：功能是为镜像指定标签；RUN：运行指定的命令；CMD：容器启动时要运行的命令。\n\n3、docker 构建镜像多大，如何优化？\n\n- 使用轻量级基础镜像,如 Alpine\n- 多阶段构建\n\n4、 CI 中前端镜像每次构建都很慢，甚至有时候失败，如何解决？\n\n- 合理分层，利用构建镜像缓存机制\n- 失败，检查是否安装依赖超时，修改 npm timeout\n\n### k8s\n\n1、k8s是什么？请说出你的了解？\n\n- Kubernetes 是一个针对容器应用，进行自动部署，弹性伸缩和管理的开源系统。主要功能是生产环境中的容器编排。\n\n2、k8s 集群里面最小的单位是什么？\n\n- pod 是最小单位。每个pod里边可以运行一个或多个container（容器）\n\n3、Service这种资源对象的作用是什么？\n\n- 用来给相同的多个pod对象提供一个固定的统一访问接口，常用于服务发现和服务访问。\n\n### openstack\n\n1、openstack 里 KeyStone 组件是用于提供什么服务的？Nova 组件是做什么用？\n\n- 认证服务（KeyStone） Nova – 用于在计算级别管理虚拟机，并在计算或管理程序级别执行其他计算任务。\n","source":"_posts/0.前端工程师面试题.md","raw":"---\ntitle: 前端工程师面试题\nindex_img: /img/2022-02-16-1.jpeg\ntags: 前端\ncategories: 面试\nabbrlink: a18c0ac9\ndate: 2022-02-15 10:39:21\n---\n\n## CSS\n\n1. 左右两栏布局， 一侧定宽、一侧自适应撑满?\n\n2. flex:1 到底代表什么?\n\n直观的记忆是，如果设置了flex: 1，所有子项平分父亲，不管子项是否设置了固定宽度。\n\n```text\nflex: 1 等价于\nflex-grow: 1;\nflex-shrink: 1;\nflex-basis: 0%;\n不管是否设置宽度，flex-basis的值都是0，所有子项平分全部的父亲空间\n\n而flex: auto 等价于\n\nflex-grow: 1;\nflex-shrink: 1;\nflex-basis: auto;\n如果设置了宽度，flex-basis的值是width，所有子项平分取去掉flex-basis的剩余空间\n```\n\n## JS\n\n- map 和 foreach 有什么区别\n\n```js\nforeach()方法会针对每一个元素执行提供得函数,该方法没有返回值,是否会改变原数组取决与数组元素的类型是基本类型还是引用类型\nmap()方法不会改变原数组的值,返回一个新数组,新数组中的值为原数组调用函数处理之后的值：\n```\n\n- 说一下for...in 和 for...of的区别?\n\n```js\nfor...of遍历获取的是对象的键值, for...in获取的是对象的键名;\nfor...in会遍历对象的整个原型链, 性能非常差不推荐使用,而for...of只遍历当前对象不会遍历原型链;\n对于数组的遍历,for...in会返回数组中所有可枚举的属性(包括原型链上可枚举的属性),for...of只返回数组的下标对应的属性值;\n总结：for...in循环主要是为了遍历对象而生,不适用遍历数组; for....of循环可以用来遍历数组、类数组对象、字符串、Set、Map以及Generator对象\n```\n\n1、请你讲一下闭包?\n\n> 简单：闭包是有权限访问其他函数作用域内的变量的一个函数。\n\n> 完整：由于在JS中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之回收，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数——也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后作用域内的值也不会被销毁。\n\n- 闭包解决了什么？\n\n> 由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。以平时使用的Ajax成功回调为例，这里其实就是个闭包，由于上述的特性，回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。开发者不用去写钩子函数来操作上级函数作用域内部的变量了。\n\n- 闭包有哪些应用场景?\n\n> 闭包随处可见，一个Ajax请求的成功回调，一个事件绑定的回调方法，一个setTimeout的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。\n\n- react hooks 中的 闭包陷阱问题如何解决？\n\n不管在这个组件中的其他地方使用 setCount 将 count 设置为任何值，还是设置多少次，打印的都是1\n\n```jsx\nfunction App(){\n    const [count, setCount] = useState(1);\n    useEffect(()=>{\n        setInterval(()=>{\n            console.log(count)\n        }, 1000)\n    }, [])\n}\n```\n\nuseRef\n\nuseState 更新值时传入回调函数\n\n2、介绍一下 JS 里面的原型？\n\n- 所有原型链的终点都是 Object 函数的 prototype 属性\n- 每一个构造函数都拥有一个 prototype 属性，此属性指向一个对象，也就是原型对象\n- 原型对象默认拥有一个 constructor 属性，指向指向它的那个构造函数\n- 每个对象都拥有一个隐藏的属性 **proto**，指向它的原型对象\n\n- 原型的作用是什么？\n\n> 共享方法\n\n- 原型中this的指向是什么？\n\n> 原型中this的指向是实例。\n\n- 说一下平时开发使用到 prototype 的例子？\n\n3、如何理解 es6 class 中 constructor 方法？ 和 super的作用？\n\n> constructor 方法是类的构造函数。 通过 new 命令创建对象实例时，自动调用该方法。 constructor 内定义的方法是 实例方法；class 内直接定义的方法是原型方法。\n\n- super 的作用？\n\n子类是没有自己的 this 对象的，它只能继承自父类的 this 对象，然后对其进行加工，而super( )就是将父类中的this对象继承给子类的。没有 super，子类就得不到 this 对象。\n\n- 为什么要传入 props？\n\n```jsx\nclass Component {\n  constructor(props) {\n    this.props = props;\n    // ...\n  }\n}\n```\n\n确保了 this.props 在构造函数执行完毕之前已被赋值。\n\n4、eventloop\n\n浏览器或node 端 js 单线程运行时不会阻塞的一种机制。\n\n任务分为宏任务和微任务；宏任务与微任务的区别?\n\n宏任务：script全部代码、setTimeout、setInterval、I/O、UI Rendering。\n微任务：Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver\n\n- 浏览器中的 event loop\n\nJS 中有一个主线程和一个调用栈（执行栈），所有的任务都会被放到调用栈中等待主线程执行。\n\nJS 调用栈后进先出原则，当函数执行的时候，会被添加到栈顶部，当执行完后，会被从栈顶移出，直到栈内被清空。\n\nJS\n任务分为同步任务和异步任务。同步任务在调用栈中按照顺序等待主线程依次执行。异步任务会在异步任务有结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），读取到栈内等待主线程执行。\n\n任务队列：先进先出\n\n顺序：同步任务 =》微任务 =》 宏任务\n\n- 执行栈在执行完同步任务后，查看执行栈是否为空\n- 如果执行栈为空，就会去检查微任务(microTask)队列, 执行完微任务，再执行宏任务\n- 每个宏任务执行完后，都会再检查微任务队列是否为空，不为空，就按先进先出执行完微任务，设置微任务为 null，再执行宏任务。\n\nNode 中 event loop(待补充)\n\n## React\n\n1、介绍一下react diff 算法 的工作原理？\n\n- react 状态变化渲染页面时，不会马上对DOM节点进行操作，是先通过diff算法计算后，再对有变化的DOM节点进行操作。\n- diff算法就是更高效地通过对比新旧Virtual DOM来找出真正的Dom变化之处.\n- react中diff算法主要遵循三个层级的策略:tree层级、component 层级、element 层级\n- tree层级: DOM节点跨层级的操作不做优化，只会对相同层级的节点进行比较.只有删除、创建操作.新树中，R节点下没有了A，那么直接删除A，在D节点下创建A以及下属节点。\n- component 层级:是同一个组件，则会继续往下diff运算，如果不是一个类的组件，那么直接删除这个组件下的所有子节点，创建新的\n- element 层级:对于比较同一层级的节点们，每个节点在对应的层级用唯一的key作为标识.\n\n  - 3 种节点操作，分别为 INSERT_MARKUP(插入)、MOVE_EXISTING (移动)和 REMOVE_NODE (删除)\n  - 通过key可以准确地发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置\n  - 如果当前节点在新集合中的位置比老集合中的位置靠前的话，是不会影响后续节点操作的，这里这时候被动字节不用动\n  - 当ABCD节点比较完成后，diff过程还没完，还会整体遍历老集合中节点，看有没有没用到的节点，有的话，就删除\n\n由于dom节点的移动操作开销是比较昂贵的，没有key的情况下要比有key的性能更好\n\n```HTML\n1.加key\n<div key='1'>1</div>             <div key='1'>1</div>     \n<div key='2'>2</div>             <div key='3'>3</div>  \n<div key='3'>3</div>  ========>  <div key='2'>2</div>  \n<div key='4'>4</div>             <div key='5'>5</div>  \n<div key='5'>5</div>             <div key='6'>6</div>  \n操作：节点2移动至下标为2的位置，新增节点6至下标为4的位置，删除节点4。\n\n2.不加key\n<div>1</div>             <div>1</div>     \n<div>2</div>             <div>3</div>  \n<div>3</div>  ========>  <div>2</div>  \n<div>4</div>             <div>5</div>  \n<div>5</div>             <div>6</div> \n操作：修改第1个到第5个节点的innerText\n```\n\nVirtual DOM 工作过程有：\n\n    1. state 变化，生成新的 Virtual Dom\n    2. 比较 Virtual Dom 与之前 Virtual Dom 的异同\n    3. 生成差异对象\n    4. 遍历差异对象并更新真实 DOM\n\n- React diff 算法 和 vue diff 的相同点和不同点有哪些？\n\n不同点：\n\n- vue的列表比对，采用从两端到中间的比对方式，而react则采用从左到右依次比对的方式。当一个集合，只是把最后一个节点移动到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移动到第一个\n- vue比对节点，当节点元素类型相同，但是className不同，认为是不同类型元素，删除重建，而react会认为是同类型节点，只是修改节点属性\n\nVue Diff使用双向链表，边对比，边更新DOM。React主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。\n\n相同点：\n\n- 虚拟DOM在比较时只比较同一层级节点，复杂度都为 O(n)，降低了算法复杂度；\n- 都使用key比较是否是相同节点，都是为了尽可能的复用节点\n- 都是操作虚拟DOM，最小化操作真实DOM，提高性能（其实虚拟DOM的优势 并不是在于它操作DOM快）\n- 都是不要用 index作为 key\n\n2、react 里什么是高阶组件？使用高阶组件的场景？\n\n> 高阶组件(HOC)是接受一个组件并返回一个新组件的函数。\n\n2、React setState 怎么获取到更新后的值?异步函数中为什么 setState 会立即更新?\n\n3、useState 为什么不能放到条件语句里面?\n\nReact通过单链表来管理Hooks。 update 阶段，每次调用 useState，链表就会执行 next 向后移动一步。如果将 useState\n写在条件判断中，假设条件判断不成立，没有执行里面的 useState 方法，会导致接下来所有的 useState 的取值出现偏移，从而导致异常发生。\n\n4、说一下 useRef 有哪些用法？\n\n> useRef 除了获取 dom，另一个用法： 保存数据，不造成 rerender 想要保存数据，又不想触发函数的更新，该数据的更新不会造成组件 rerender\n\n5、什么情况下使用 useCallback ？ 子组件接收一个方法，避免子组件重复渲染\n\n- react 中只要父组件的 render 了，那么默认情况下就会触发子组的 render，react\n  提供了来避免这种重渲染的性能开销的一些方法：React.PureComponent、React.memo ，shouldComponentUpdate()\n- 使用 React.memo 避免子组件做没必要的渲染。\n- Reace.memo 只会对 props 做浅比较，也就是父组件重新 render 之后会传入 不同引用的方法 getList，浅比较之后不相等，导致子组件还是依然会渲染。\n- useCallback 缓存一个函数，当依赖没有改变的时候，会一直返回同一个引用\n\n6、useCallback 与 useMemo 作用用来缓存，两者的区别是什么？\n\n> useMemo 缓存值；useCallback 缓存函数\n\n注意不要滥用：\n\n经常用在以下两种场景（要保持引用相等；对于组件内部用到的 object、array、函数等，如果用在了其他 Hook 的依赖数组中，或者作为 props 传递给了下游组件，应该使用\nuseMemo/useCallback）\n\n7、react ssr 实现原理？react ssr 是在什么场景下做的？\n\nserver端接收到客户端的请求路由后，查找对应的数据，以props、context、store的形式注入组件中。然后基于react提供的API：renderToString将组件转换为html字符串输出到客户端。客户端使用该数据进行渲染，保证数据的一致性。\n\nReact SSR之所以能够实现，本质是虚拟 DOM的存在。判断环境是服务器环境，可以操作 JavaScript 对象，把虚拟 DOM 映射成字符串输出。判断环境是客户端环境，可以操作\nJavaScript 对象，将虚拟 DOM 映射成真实 DOM ，完成页面挂载。\n\n8、 react 项目里做过哪些性能优化？\n\n代码层面：\n\n- 使用return null而不是CSS的display:none来控制节点的显示隐藏。保证同一时间页面的DOM节点尽可能的少。\n- props和state的数据尽可能简单明了，扁平化。\n- 不要使用数组下标作为key\n- 利用 shouldComponentUpdate 和 PureComponent 避免过多 render function\n- render里面尽量减少新建变量和bind函数，传递参数是尽量减少传递参数的数量。\n- 尽量将 props 和 state 扁平化，只传递 component 需要的 props（传得太多，或者层次传得太深，都会加重shouldComponentUpdate里面的数据比较负担），慎将\n  component 当作 props 传入\n\n代码体积优化:\n\n- 使用 babel-plugin-import 优化业务组件的引入，实现按需加载\n- 使用 生产版本\n- 使用 SplitChunksPlugin 拆分公共代码\n- 分析 CSS 和 JS 代码覆盖率\n- 优化 Webpack 中的库\n- 使用动态 import，懒加载 React 组件\n- 使用 webpack-bundle-analyzer 可视化 webpack 输出文件的大小\n- 使用 Tree Shaking & 教程 & Tree Shaking 优化\n\n9、有 用 过 lerna 吗 ？ 多 个 项 目 之 间 共 用 的 东 西 怎 么 共 享 ？\n\n10、使用 react 中，有没有遇到觉得比较难的点？是什么？\n\n11、使用 hooks 中遇到过哪些坑？为什么？\n\n- 不要在循环，条件或嵌套函数中调用Hook，必须始终在React函数的顶层使用Hook。这是因为React需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子函数。一旦在循环或条件分支语句中调用Hook，就容易导致调用顺序的不一致性。\n- 使用useState时候，使用push，pop，splice等直接更改数组对象的坑，应该采用析构方式.\n- 必包带来的坑,因为每次 render 都有一份新的状态，因此上述代码中的 setTimeout 使用产生了一个闭包，捕获了每次 render 后的 state，也就导致了输出了\n  0、1、2。如果你希望输出的内容是最新的 state 的话，可以通过 useRef 来保存 state。前文讲过 ref\n  在组件中只存在一份，无论何时使用它的引用都不会产生变化，因此可以来解决闭包引发的问题。\n\n## Vue\n\n1、Vue如何监听数组的变化？\n\n- 对象数据是怎么被监听的?\n\nvue2.x版本中，数据监听用 Object.defineProperty.\n通过Object.defineProperty来劫持对象属性的setter和getter操作，并创建一个监听器，当数据发生变化的时候发出通知\n\n- 数组数据是怎么被监听的?\n\nVue.js是基于Object.defineProperty对对象实现“响应式化”，而对于数组，Vue.js提供的方法是重写push、pop、shift、unshift、splice、sort、reverse这七个数组方法.\n\n如果需要用数组下标修改数组并实现响应式数据变化，Vue.js提供了$set()及$remove()方法。\n\n1、Vue 组件 data 为什么必须是函数？\n\n> 因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染。 所以一个组件的 data\n> 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。\n\n2、直接给一个数组项赋值，Vue 能检测到变化吗？\n\n由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。\n\n- Vue 不能检测到以下数组的变动:\n\n1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue\n\n```js\n// 解决办法\nvm.$set(vm.items, indexOfItem, newValue)\n```\n\n2.当你修改数组的长度时，例如：vm.items.length = newLength\n\n```js\n/ 解决办法\nvm.items.splice(newLength)\n```\n\n- 检测不到的原因是什么？\n\n当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在\ndata 里声明。\n\n但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的\n$set。\n\n3、vue2 中响应式（双向绑定）的原理？vue3 的原理？ Proxy 与 Object.defineProperty 的优劣对比? 为什么在 Vue3.0 采用了 Proxy,抛弃了\nObject.defineProperty？\n\n> Proxy的优势如下: Proxy 可以直接监听对象而非属性 Proxy 可以直接监听数组的变化 Proxy 有多达 13 种拦截方法,不限于\n> apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的 Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而\n> Object.defineProperty 只能遍历对象属性直接修改 Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利\n\n> Object.defineProperty 的优势如下:\n\n> 兼容性好,支持 IE9\n\n4、vuex 的工作流程是怎么样？\n\n> Vuex有5个重要的属性，分别是 State、Getter、Mutation、Action、Module，由 view 层发起一个 Action 给 Mutation，在 Mutation\n> 中修改状态，返回新的状态，通过 Getter暴露给 view层的组件或者页面，页面监测到状态改变于是更新页面。\n\n4、Vue 的初始化过程（new Vue(options)）都做了什么？\n\n处理组件配置项\n\n初始化根组件时进行了选项合并操作，将全局配置合并到根组件的局部配置上\n\n初始化每个子组件时做了一些性能优化，将组件配置对象上的一些深层次属性放到 vm.$options 选项中，以提高代码的执行效率\n\n初始化组件实例的关系属性，比如 $parent、$children、$root、$refs 等\n\n处理自定义事件\n\n调用 beforeCreate 钩子函数\n\n初始化组件的 inject 配置项，得到 ret[key] = val 形式的配置对象，然后对该配置对象进行响应式处理，并代理每个 key 到 vm 实例上\n\n数据响应式，处理 props、methods、data、computed、watch 等选项\n\n解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上，如果 provide 是函数就用 call(vm) 方法 返回 provide 里面定义的对象\n\n调用 created 钩子函数\n\n如果发现配置项上有 el 选项，则自动调用 $mount 方法，也就是说有了 el 选项，就不需要再手动调用 $mount 方法，反之，没提供 el 选项则必须调用 $mount\n\n接下来则进入挂载阶段\n\n4、beforeCreate 期间能拿到数据吗？\n\n```\n不能，因为数据初始化阶段是在 beforeCreate 之后执行\n```\n\n4、Vue nextTick使用场景及实现原理\n\n它主要是处理我们再变更完数据以后，无法立刻拿到最新的DOM节点对象的问题。\n\nvue执行完渲染后会执行this.nextTick()里面的callback函数。\n\n将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。\n\nnextTick流程总结： 1、将回调放到callbacks里等待执行；\n2、将执行函数（flushCallbacks）放到微任务或宏任务里；原码里按照是否原生支持Promise.then、MutationObserver和setImmediate的顺序决策，都不支持则使用setTimeout\n3、等到事件循环执行到微任务或者宏任务时，执行函数依次执行callbacks里的回调；\n\n5、Vue的nextTick具体是微任务还是宏任务?\n\n| 宏任务                   | 微任务              |\n| --------------------- | ---------------- |\n| setTimeout            | process.nextTick |\n| setInterval           | MutationObserver |\n| setImmediate          | Promise.then     |\n| requestAnimationFrame |                  |\n| MessageChannel        |                  |\n\n5、 Vue3 有哪些新的新特性？\n\n- 响应式系统\n- 自定义渲染器\n- 全部模块使用 TS 重构\n- Composition API 组合语法\n- 新一代工程化工具 Vite\n\n6、Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？\n\nvue2 问题：\n\n- 代码的可读性随着组件变大而变差\n- 每一种代码复用的方式，都存在缺点\n- TypeScript支持有限\n- 逻辑组织\n\n  - 大型组件, 需要不断跳转代码块\n  - 逻辑关注点相关的代码全都放在一个函数里\n\n- 逻辑复用\n\n  - vue2 用 mixin去复用相同的逻辑, 我们一个组件混入大量不同的 mixins 的时候,命名冲突,数据来源不清\n  - vue3 写 hook 函数\n\n6、父组件可以监听到子组件的生命周期吗？\n\n比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理。\n\n方法一：手动通过 $emit 触发父组件的事件\n\n```js\n// Parent.vue\n<Child @mounted=\"doSomething\"/>\n    \n// Child.vue\nmounted() {\n  this.$emit(\"mounted\");\n}\n```\n\n方法二：父组件引用子组件时通过 @hook 来监听\n\n```js\n//  Parent.vue\n<Child @hook:mounted=\"doSomething\" ></Child>\n    \n//  Child.vue\nmounted(){\n   console.log('子组件触发 mounted 钩子函数 ...');\n},\n```\n\n@hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。\n\n7、比较 Vue 和 React 两个框架，你觉得有哪些区别？\n\n- 监听数据变化的实现原理不同:\n\n  Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化. react 中，数据变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化。\n- 数据流的不同:\n- 模板渲染方式的不同:\n\n8、什么是异步组件？\n\n在声明或注册组件时，Vue 接受提供 Promise 的工厂函数。然后可以在调用该组件时对其进行“解析”。\n\n```js\nnew Vue({\n    components: {\n        ‘tweet-box’: () => import(‘./components/async/TweetBox’)\n    }\n});\n```\n\n## http\n\n1、HTTP有哪些请求方法？PUT 和 PATCH 有什么区别？\n\n- GET, POST 和 HEAD方法；OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT\n- PUT和PATCH都是更新资源，而PATCH用来对资源进行局部更新。\n\n2、http 状态码 403 是什么错误？\n\n- 403 forbidden，表示对请求资源的访问被服务器拒绝\n\n3、知道哪些 http 的缓存策略 ？控制缓存的请求头有哪些？\n\n- HTTP缓存机制分为强制缓存和协商缓存两类。\n- 强制缓存的意思就是不要问了(不发起请求)，直接用缓存吧。\n- 强制缓存常见技术有Expires和Cache-Control。\n- Expires的值是一个时间，表示这个时间前缓存都有效，都不需要发起请求。\n- Cache-Control有很多属性值，常用属性max-age设置了缓存有效的时间长度，单位为秒，这个时间没到，都不用发起请求。\n- immutable也是Cache-Control的一个属性，表示这个资源这辈子都不用再请求了，但是他兼容性不好，Cache-Control其他属性可以参考MDN的文档。\n- Cache-Control的max-age优先级比Expires高。\n- 协商缓存是为了知道有没有更新，必须跟服务端沟通过才知道的。常见技术有ETag和Last-Modified。\n- ETag其实就是给资源算一个hash值或者版本号，对应的常用request header为If-None-Match。\n- Last-Modified其实就是加上资源修改的时间，对应的常用request header为If-Modified-Since，精度为秒。\n- ETag每次修改都会改变，而Last-Modified的精度只到秒，所以ETag更准确，优先级更高，但是需要计算，所以服务端开销更大。\n- 强制缓存和协商缓存都存在的情况下，先判断强制缓存是否生效，如果生效，不用发起请求，直接用缓存。如果强制缓存不生效再发起请求判断协商缓存。\n\n> Cache-Control，ETag，Last-Modified\n\n## 其他\n\n- 怎么解决白屏问题?\n\n```js\n1、加loading\n2、骨架屏\n```\n\n- webpack loader 和 plugin 区 别 ？\n\n```js\nLoader：直译为\"加载器\"。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到`loader`。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。   \nPlugin：直译为\"插件\"。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。\n```\n\n1. 弱网环境下页面首屏如何快速加载?\n\n   1.缓存的使用 2.SSR使用 3.骨架屏使用\n\n2. code review需要注意的点，你做code reivew的话，会重点查看哪里，怎么写出高内聚，低耦合的代码，以实习中遇到的一个通用组件实现举例。\n3. 什 么 是 TS 泛 型 ？\n4. webpack 构 建 流 程 是 怎 样 的 ？\n5. webpack 热 更 新 原 理 ？\n6. 有没有读过哪些源码？\n7. 最近开发的项目具体业务是怎么样的？介绍一下？\n8. 对前端而言，你觉得函数式编程体现在哪些方面？\n\n   纯函数、不可变数据、高阶函数。 react 就是函数式思想，数据是不可变的，react 相当于纯函数，展示出来的 ui 就是结果。 redux 更是函数式思想\n\n## Devops 相关\n\n## Git\n\n- 常用 git 操作\n\n```js\ngit branch 查看本地所有分支\ngit status 查看当前状态 \ngit commit 提交 \ngit branch -a 查看所有的分支\ngit branch -r 查看远程所有分支\ngit commit -am \"init\" 提交并且加注释 \ngit remote add origin git@192.168.1.119:ndshow\ngit push origin master 将文件给推到服务器上 \ngit remote show origin 显示远程库origin里的资源 \ngit push origin master:develop\ngit push origin master:hb-dev 将本地库与服务器上的库进行关联 \ngit checkout --track origin/dev 切换到远程dev分支\ngit branch -D master develop 删除本地库develop\ngit checkout -b dev 建立一个新的本地分支dev\ngit merge origin/dev 将分支dev与当前分支进行合并\ngit checkout dev 切换到本地dev分支\ngit remote show 查看远程库\ngit add .\ngit rm 文件名(包括路径) 从git中删除指定文件\ngit clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来\ngit config --list 看所有用户\ngit ls-files 看已经被提交的\ngit rm [file name] 删除一个文件\ngit commit -a 提交当前repos的所有的改变\ngit add [file name] 添加一个文件到git index\ngit commit -v 当你用－v参数的时候可以看commit的差异\ngit commit -m \"This is the message describing the commit\" 添加commit信息\ngit commit -a -a是代表add，把所有的change加到git index里然后再commit\ngit commit -a -v 一般提交命令\ngit log 看你commit的日志\ngit diff 查看尚未暂存的更新\ngit rm a.a 移除文件(从暂存区和工作区中删除)\ngit rm --cached a.a 移除文件(只从暂存区中删除)\ngit commit -m \"remove\" 移除文件(从Git中删除)\ngit rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)\ngit diff --cached 或 $ git diff --staged 查看尚未提交的更新\ngit stash push 将文件给push到一个临时空间中\ngit stash pop 将文件从临时空间pop下来\n```\n\n1、什么情况下使用 git rebase, 而不用 git merge\n\n### nginx\n\n1. 谈谈一下对 nginx 的理解，项目中用到 nginx 的哪些功能？\n\n- Nginx ，是一个 Web 服务器和反向代理服务器用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。\n- 主要功能如下： 正向、反向代理 2、负载均衡、分流 3、虚拟主机（绑定host）\n\n2、正向代理和反向代理区别是什么？\n\n- 正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定原始服务器，然后代理向原始服务器转交请求并将获得的内容返回给客户端。代理服务器和客户端处于同一个局域网内。\n- 比如说fanqiang。我知道我要访问谷歌，于是我就告诉代理服务器让它帮我转发。\n- 反向代理实际运行方式是代理服务器接受网络上的连接请求。它将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给网络上请求连接的客户端 。代理服务器和原始服务器处于同一个局域网内。\n- 比如说我要访问taobao，对我来说不知道图片、json、css 是不是同一个服务器返回回来的，但是我不关心，是反向代理 处理的，我不知道原始服务器。\n\n3、nginx 如何来实现负载均衡？\n\n负载均衡的5种策略:\n\n```sh\n1.轮询（默认）\n 每个请求按时间顺序逐一分配到不同的后端服务器\n\n upstream backserver {\n    server 192.168.0.14;\n    server 192.168.0.15;\n}\n\n2.weight\n指定轮询几率，weight和访问概率成正比\n\nupstream backserver {\n    server 192.168.0.14 weight=3;\n    server 192.168.0.15 weight=7;\n}\n\n3.ip_hash\n已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的.ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。\n\nupstream backserver {\n    ip_hash;\n    server 192.168.0.14:88;\n    server 192.168.0.15:80;\n}\n\n4.fair\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n\nupstream backserver {\n    server server1;\n    server server2;\n    fair;\n}\n\n5.url_hash\n按访问url的hash结果来分配请求，使每个url定向到同一个（对应的）后端服务器，后端服务器为缓存时比较有效。\n\nupstream backserver {\n    server squid1:3128;\n    server squid2:3128;\n    hash $request_uri;\n    hash_method crc32;\n}\n```\n\n### docker\n\n1、什么是 Docker？\n\n- Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。\n\n2、Dockerfile中最常见的指令是什么？\n\n- FROM：指定基础镜像；LABEL：功能是为镜像指定标签；RUN：运行指定的命令；CMD：容器启动时要运行的命令。\n\n3、docker 构建镜像多大，如何优化？\n\n- 使用轻量级基础镜像,如 Alpine\n- 多阶段构建\n\n4、 CI 中前端镜像每次构建都很慢，甚至有时候失败，如何解决？\n\n- 合理分层，利用构建镜像缓存机制\n- 失败，检查是否安装依赖超时，修改 npm timeout\n\n### k8s\n\n1、k8s是什么？请说出你的了解？\n\n- Kubernetes 是一个针对容器应用，进行自动部署，弹性伸缩和管理的开源系统。主要功能是生产环境中的容器编排。\n\n2、k8s 集群里面最小的单位是什么？\n\n- pod 是最小单位。每个pod里边可以运行一个或多个container（容器）\n\n3、Service这种资源对象的作用是什么？\n\n- 用来给相同的多个pod对象提供一个固定的统一访问接口，常用于服务发现和服务访问。\n\n### openstack\n\n1、openstack 里 KeyStone 组件是用于提供什么服务的？Nova 组件是做什么用？\n\n- 认证服务（KeyStone） Nova – 用于在计算级别管理虚拟机，并在计算或管理程序级别执行其他计算任务。\n","slug":"0-前端工程师面试题","published":1,"updated":"2022-08-23T02:19:23.468Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn4i002nyu3l41ti0n64","content":"<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><ol>\n<li><p>左右两栏布局， 一侧定宽、一侧自适应撑满?</p>\n</li>\n<li><p>flex:1 到底代表什么?</p>\n</li>\n</ol>\n<p>直观的记忆是，如果设置了flex: 1，所有子项平分父亲，不管子项是否设置了固定宽度。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs text\">flex: 1 等价于\nflex-grow: 1;\nflex-shrink: 1;\nflex-basis: 0%;\n不管是否设置宽度，flex-basis的值都是0，所有子项平分全部的父亲空间\n\n而flex: auto 等价于\n\nflex-grow: 1;\nflex-shrink: 1;\nflex-basis: auto;\n如果设置了宽度，flex-basis的值是width，所有子项平分取去掉flex-basis的剩余空间</code></pre></div>\n\n<h2 id=\"JS\"><a href=\"#JS\" class=\"headerlink\" title=\"JS\"></a>JS</h2><ul>\n<li>map 和 foreach 有什么区别</li>\n</ul>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\">foreach()方法会针对每一个元素执行提供得函数,该方法没有返回值,是否会改变原数组取决与数组元素的类型是基本类型还是引用类型\nmap()方法不会改变原数组的值,返回一个新数组,新数组中的值为原数组调用函数处理之后的值：</code></pre></div>\n\n<ul>\n<li>说一下for…in 和 for…of的区别?</li>\n</ul>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">for</span>...of遍历获取的是对象的键值, <span class=\"hljs-keyword\">for</span>...in获取的是对象的键名;\n<span class=\"hljs-keyword\">for</span>...in会遍历对象的整个原型链, 性能非常差不推荐使用,而<span class=\"hljs-keyword\">for</span>...of只遍历当前对象不会遍历原型链;\n对于数组的遍历,<span class=\"hljs-keyword\">for</span>...in会返回数组中所有可枚举的属性(包括原型链上可枚举的属性),<span class=\"hljs-keyword\">for</span>...of只返回数组的下标对应的属性值;\n总结：<span class=\"hljs-keyword\">for</span>...in循环主要是为了遍历对象而生,不适用遍历数组; <span class=\"hljs-keyword\">for</span>....of循环可以用来遍历数组、类数组对象、字符串、<span class=\"hljs-built_in\">Set</span>、<span class=\"hljs-built_in\">Map</span>以及Generator对象</code></pre></div>\n\n<p>1、请你讲一下闭包?</p>\n<blockquote>\n<p>简单：闭包是有权限访问其他函数作用域内的变量的一个函数。</p>\n</blockquote>\n<blockquote>\n<p>完整：由于在JS中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之回收，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数——也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后作用域内的值也不会被销毁。</p>\n</blockquote>\n<ul>\n<li>闭包解决了什么？</li>\n</ul>\n<blockquote>\n<p>由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。以平时使用的Ajax成功回调为例，这里其实就是个闭包，由于上述的特性，回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。开发者不用去写钩子函数来操作上级函数作用域内部的变量了。</p>\n</blockquote>\n<ul>\n<li>闭包有哪些应用场景?</li>\n</ul>\n<blockquote>\n<p>闭包随处可见，一个Ajax请求的成功回调，一个事件绑定的回调方法，一个setTimeout的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。</p>\n</blockquote>\n<ul>\n<li>react hooks 中的 闭包陷阱问题如何解决？</li>\n</ul>\n<p>不管在这个组件中的其他地方使用 setCount 将 count 设置为任何值，还是设置多少次，打印的都是1</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>)</span>&#123;\n    <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">1</span>);\n    useEffect(<span class=\"hljs-function\">()=&gt;</span>&#123;\n        <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">()=&gt;</span>&#123;\n            <span class=\"hljs-built_in\">console</span>.log(count)\n        &#125;, <span class=\"hljs-number\">1000</span>)\n    &#125;, [])\n&#125;</code></pre></div>\n\n<p>useRef</p>\n<p>useState 更新值时传入回调函数</p>\n<p>2、介绍一下 JS 里面的原型？</p>\n<ul>\n<li><p>所有原型链的终点都是 Object 函数的 prototype 属性</p>\n</li>\n<li><p>每一个构造函数都拥有一个 prototype 属性，此属性指向一个对象，也就是原型对象</p>\n</li>\n<li><p>原型对象默认拥有一个 constructor 属性，指向指向它的那个构造函数</p>\n</li>\n<li><p>每个对象都拥有一个隐藏的属性 <strong>proto</strong>，指向它的原型对象</p>\n</li>\n<li><p>原型的作用是什么？</p>\n</li>\n</ul>\n<blockquote>\n<p>共享方法</p>\n</blockquote>\n<ul>\n<li>原型中this的指向是什么？</li>\n</ul>\n<blockquote>\n<p>原型中this的指向是实例。</p>\n</blockquote>\n<ul>\n<li>说一下平时开发使用到 prototype 的例子？</li>\n</ul>\n<p>3、如何理解 es6 class 中 constructor 方法？ 和 super的作用？</p>\n<blockquote>\n<p>constructor 方法是类的构造函数。 通过 new 命令创建对象实例时，自动调用该方法。 constructor 内定义的方法是 实例方法；class 内直接定义的方法是原型方法。</p>\n</blockquote>\n<ul>\n<li>super 的作用？</li>\n</ul>\n<p>子类是没有自己的 this 对象的，它只能继承自父类的 this 对象，然后对其进行加工，而super( )就是将父类中的this对象继承给子类的。没有 super，子类就得不到 this 对象。</p>\n<ul>\n<li>为什么要传入 props？</li>\n</ul>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Component</span> </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;\n    <span class=\"hljs-built_in\">this</span>.props = props;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;\n&#125;</code></pre></div>\n\n<p>确保了 this.props 在构造函数执行完毕之前已被赋值。</p>\n<p>4、eventloop</p>\n<p>浏览器或node 端 js 单线程运行时不会阻塞的一种机制。</p>\n<p>任务分为宏任务和微任务；宏任务与微任务的区别?</p>\n<p>宏任务：script全部代码、setTimeout、setInterval、I/O、UI Rendering。<br>微任务：Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver</p>\n<ul>\n<li>浏览器中的 event loop</li>\n</ul>\n<p>JS 中有一个主线程和一个调用栈（执行栈），所有的任务都会被放到调用栈中等待主线程执行。</p>\n<p>JS 调用栈后进先出原则，当函数执行的时候，会被添加到栈顶部，当执行完后，会被从栈顶移出，直到栈内被清空。</p>\n<p>JS<br>任务分为同步任务和异步任务。同步任务在调用栈中按照顺序等待主线程依次执行。异步任务会在异步任务有结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），读取到栈内等待主线程执行。</p>\n<p>任务队列：先进先出</p>\n<p>顺序：同步任务 =》微任务 =》 宏任务</p>\n<ul>\n<li>执行栈在执行完同步任务后，查看执行栈是否为空</li>\n<li>如果执行栈为空，就会去检查微任务(microTask)队列, 执行完微任务，再执行宏任务</li>\n<li>每个宏任务执行完后，都会再检查微任务队列是否为空，不为空，就按先进先出执行完微任务，设置微任务为 null，再执行宏任务。</li>\n</ul>\n<p>Node 中 event loop(待补充)</p>\n<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><p>1、介绍一下react diff 算法 的工作原理？</p>\n<ul>\n<li><p>react 状态变化渲染页面时，不会马上对DOM节点进行操作，是先通过diff算法计算后，再对有变化的DOM节点进行操作。</p>\n</li>\n<li><p>diff算法就是更高效地通过对比新旧Virtual DOM来找出真正的Dom变化之处.</p>\n</li>\n<li><p>react中diff算法主要遵循三个层级的策略:tree层级、component 层级、element 层级</p>\n</li>\n<li><p>tree层级: DOM节点跨层级的操作不做优化，只会对相同层级的节点进行比较.只有删除、创建操作.新树中，R节点下没有了A，那么直接删除A，在D节点下创建A以及下属节点。</p>\n</li>\n<li><p>component 层级:是同一个组件，则会继续往下diff运算，如果不是一个类的组件，那么直接删除这个组件下的所有子节点，创建新的</p>\n</li>\n<li><p>element 层级:对于比较同一层级的节点们，每个节点在对应的层级用唯一的key作为标识.</p>\n<ul>\n<li>3 种节点操作，分别为 INSERT_MARKUP(插入)、MOVE_EXISTING (移动)和 REMOVE_NODE (删除)</li>\n<li>通过key可以准确地发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置</li>\n<li>如果当前节点在新集合中的位置比老集合中的位置靠前的话，是不会影响后续节点操作的，这里这时候被动字节不用动</li>\n<li>当ABCD节点比较完成后，diff过程还没完，还会整体遍历老集合中节点，看有没有没用到的节点，有的话，就删除</li>\n</ul>\n</li>\n</ul>\n<p>由于dom节点的移动操作开销是比较昂贵的，没有key的情况下要比有key的性能更好</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs HTML\">1.加key\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;1&#x27;</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;1&#x27;</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>     \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;2&#x27;</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;3&#x27;</span>&gt;</span>3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;3&#x27;</span>&gt;</span>3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  ========&gt;  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;2&#x27;</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;4&#x27;</span>&gt;</span>4<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;5&#x27;</span>&gt;</span>5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;5&#x27;</span>&gt;</span>5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;6&#x27;</span>&gt;</span>6<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n操作：节点2移动至下标为2的位置，新增节点6至下标为4的位置，删除节点4。\n\n2.不加key\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>     \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  ========&gt;  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>4<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>6<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span> \n操作：修改第1个到第5个节点的innerText</code></pre></div>\n\n<p>Virtual DOM 工作过程有：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs\">1. state 变化，生成新的 Virtual Dom\n2. 比较 Virtual Dom 与之前 Virtual Dom 的异同\n3. 生成差异对象\n4. 遍历差异对象并更新真实 DOM\n</code></pre></div>\n<ul>\n<li>React diff 算法 和 vue diff 的相同点和不同点有哪些？</li>\n</ul>\n<p>不同点：</p>\n<ul>\n<li>vue的列表比对，采用从两端到中间的比对方式，而react则采用从左到右依次比对的方式。当一个集合，只是把最后一个节点移动到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移动到第一个</li>\n<li>vue比对节点，当节点元素类型相同，但是className不同，认为是不同类型元素，删除重建，而react会认为是同类型节点，只是修改节点属性</li>\n</ul>\n<p>Vue Diff使用双向链表，边对比，边更新DOM。React主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。</p>\n<p>相同点：</p>\n<ul>\n<li>虚拟DOM在比较时只比较同一层级节点，复杂度都为 O(n)，降低了算法复杂度；</li>\n<li>都使用key比较是否是相同节点，都是为了尽可能的复用节点</li>\n<li>都是操作虚拟DOM，最小化操作真实DOM，提高性能（其实虚拟DOM的优势 并不是在于它操作DOM快）</li>\n<li>都是不要用 index作为 key</li>\n</ul>\n<p>2、react 里什么是高阶组件？使用高阶组件的场景？</p>\n<blockquote>\n<p>高阶组件(HOC)是接受一个组件并返回一个新组件的函数。</p>\n</blockquote>\n<p>2、React setState 怎么获取到更新后的值?异步函数中为什么 setState 会立即更新?</p>\n<p>3、useState 为什么不能放到条件语句里面?</p>\n<p>React通过单链表来管理Hooks。 update 阶段，每次调用 useState，链表就会执行 next 向后移动一步。如果将 useState<br>写在条件判断中，假设条件判断不成立，没有执行里面的 useState 方法，会导致接下来所有的 useState 的取值出现偏移，从而导致异常发生。</p>\n<p>4、说一下 useRef 有哪些用法？</p>\n<blockquote>\n<p>useRef 除了获取 dom，另一个用法： 保存数据，不造成 rerender 想要保存数据，又不想触发函数的更新，该数据的更新不会造成组件 rerender</p>\n</blockquote>\n<p>5、什么情况下使用 useCallback ？ 子组件接收一个方法，避免子组件重复渲染</p>\n<ul>\n<li>react 中只要父组件的 render 了，那么默认情况下就会触发子组的 render，react<br>提供了来避免这种重渲染的性能开销的一些方法：React.PureComponent、React.memo ，shouldComponentUpdate()</li>\n<li>使用 React.memo 避免子组件做没必要的渲染。</li>\n<li>Reace.memo 只会对 props 做浅比较，也就是父组件重新 render 之后会传入 不同引用的方法 getList，浅比较之后不相等，导致子组件还是依然会渲染。</li>\n<li>useCallback 缓存一个函数，当依赖没有改变的时候，会一直返回同一个引用</li>\n</ul>\n<p>6、useCallback 与 useMemo 作用用来缓存，两者的区别是什么？</p>\n<blockquote>\n<p>useMemo 缓存值；useCallback 缓存函数</p>\n</blockquote>\n<p>注意不要滥用：</p>\n<p>经常用在以下两种场景（要保持引用相等；对于组件内部用到的 object、array、函数等，如果用在了其他 Hook 的依赖数组中，或者作为 props 传递给了下游组件，应该使用<br>useMemo/useCallback）</p>\n<p>7、react ssr 实现原理？react ssr 是在什么场景下做的？</p>\n<p>server端接收到客户端的请求路由后，查找对应的数据，以props、context、store的形式注入组件中。然后基于react提供的API：renderToString将组件转换为html字符串输出到客户端。客户端使用该数据进行渲染，保证数据的一致性。</p>\n<p>React SSR之所以能够实现，本质是虚拟 DOM的存在。判断环境是服务器环境，可以操作 JavaScript 对象，把虚拟 DOM 映射成字符串输出。判断环境是客户端环境，可以操作<br>JavaScript 对象，将虚拟 DOM 映射成真实 DOM ，完成页面挂载。</p>\n<p>8、 react 项目里做过哪些性能优化？</p>\n<p>代码层面：</p>\n<ul>\n<li>使用return null而不是CSS的display:none来控制节点的显示隐藏。保证同一时间页面的DOM节点尽可能的少。</li>\n<li>props和state的数据尽可能简单明了，扁平化。</li>\n<li>不要使用数组下标作为key</li>\n<li>利用 shouldComponentUpdate 和 PureComponent 避免过多 render function</li>\n<li>render里面尽量减少新建变量和bind函数，传递参数是尽量减少传递参数的数量。</li>\n<li>尽量将 props 和 state 扁平化，只传递 component 需要的 props（传得太多，或者层次传得太深，都会加重shouldComponentUpdate里面的数据比较负担），慎将<br>component 当作 props 传入</li>\n</ul>\n<p>代码体积优化:</p>\n<ul>\n<li>使用 babel-plugin-import 优化业务组件的引入，实现按需加载</li>\n<li>使用 生产版本</li>\n<li>使用 SplitChunksPlugin 拆分公共代码</li>\n<li>分析 CSS 和 JS 代码覆盖率</li>\n<li>优化 Webpack 中的库</li>\n<li>使用动态 import，懒加载 React 组件</li>\n<li>使用 webpack-bundle-analyzer 可视化 webpack 输出文件的大小</li>\n<li>使用 Tree Shaking &amp; 教程 &amp; Tree Shaking 优化</li>\n</ul>\n<p>9、有 用 过 lerna 吗 ？ 多 个 项 目 之 间 共 用 的 东 西 怎 么 共 享 ？</p>\n<p>10、使用 react 中，有没有遇到觉得比较难的点？是什么？</p>\n<p>11、使用 hooks 中遇到过哪些坑？为什么？</p>\n<ul>\n<li>不要在循环，条件或嵌套函数中调用Hook，必须始终在React函数的顶层使用Hook。这是因为React需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子函数。一旦在循环或条件分支语句中调用Hook，就容易导致调用顺序的不一致性。</li>\n<li>使用useState时候，使用push，pop，splice等直接更改数组对象的坑，应该采用析构方式.</li>\n<li>必包带来的坑,因为每次 render 都有一份新的状态，因此上述代码中的 setTimeout 使用产生了一个闭包，捕获了每次 render 后的 state，也就导致了输出了<br>0、1、2。如果你希望输出的内容是最新的 state 的话，可以通过 useRef 来保存 state。前文讲过 ref<br>在组件中只存在一份，无论何时使用它的引用都不会产生变化，因此可以来解决闭包引发的问题。</li>\n</ul>\n<h2 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h2><p>1、Vue如何监听数组的变化？</p>\n<ul>\n<li>对象数据是怎么被监听的?</li>\n</ul>\n<p>vue2.x版本中，数据监听用 Object.defineProperty.<br>通过Object.defineProperty来劫持对象属性的setter和getter操作，并创建一个监听器，当数据发生变化的时候发出通知</p>\n<ul>\n<li>数组数据是怎么被监听的?</li>\n</ul>\n<p>Vue.js是基于Object.defineProperty对对象实现“响应式化”，而对于数组，Vue.js提供的方法是重写push、pop、shift、unshift、splice、sort、reverse这七个数组方法.</p>\n<p>如果需要用数组下标修改数组并实现响应式数据变化，Vue.js提供了$set()及$remove()方法。</p>\n<p>1、Vue 组件 data 为什么必须是函数？</p>\n<blockquote>\n<p>因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染。 所以一个组件的 data<br>选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。</p>\n</blockquote>\n<p>2、直接给一个数组项赋值，Vue 能检测到变化吗？</p>\n<p>由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。</p>\n<ul>\n<li>Vue 不能检测到以下数组的变动:</li>\n</ul>\n<p>1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 解决办法</span>\nvm.$set(vm.items, indexOfItem, newValue)</code></pre></div>\n\n<p>2.当你修改数组的长度时，例如：vm.items.length = newLength</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\">/ 解决办法\nvm.items.splice(newLength)</code></pre></div>\n\n<ul>\n<li>检测不到的原因是什么？</li>\n</ul>\n<p>当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在<br>data 里声明。</p>\n<p>但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的<br>$set。</p>\n<p>3、vue2 中响应式（双向绑定）的原理？vue3 的原理？ Proxy 与 Object.defineProperty 的优劣对比? 为什么在 Vue3.0 采用了 Proxy,抛弃了<br>Object.defineProperty？</p>\n<blockquote>\n<p>Proxy的优势如下: Proxy 可以直接监听对象而非属性 Proxy 可以直接监听数组的变化 Proxy 有多达 13 种拦截方法,不限于<br>apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的 Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而<br>Object.defineProperty 只能遍历对象属性直接修改 Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利</p>\n</blockquote>\n<blockquote>\n<p>Object.defineProperty 的优势如下:</p>\n</blockquote>\n<blockquote>\n<p>兼容性好,支持 IE9</p>\n</blockquote>\n<p>4、vuex 的工作流程是怎么样？</p>\n<blockquote>\n<p>Vuex有5个重要的属性，分别是 State、Getter、Mutation、Action、Module，由 view 层发起一个 Action 给 Mutation，在 Mutation<br>中修改状态，返回新的状态，通过 Getter暴露给 view层的组件或者页面，页面监测到状态改变于是更新页面。</p>\n</blockquote>\n<p>4、Vue 的初始化过程（new Vue(options)）都做了什么？</p>\n<p>处理组件配置项</p>\n<p>初始化根组件时进行了选项合并操作，将全局配置合并到根组件的局部配置上</p>\n<p>初始化每个子组件时做了一些性能优化，将组件配置对象上的一些深层次属性放到 vm.$options 选项中，以提高代码的执行效率</p>\n<p>初始化组件实例的关系属性，比如 $parent、$children、$root、$refs 等</p>\n<p>处理自定义事件</p>\n<p>调用 beforeCreate 钩子函数</p>\n<p>初始化组件的 inject 配置项，得到 ret[key] = val 形式的配置对象，然后对该配置对象进行响应式处理，并代理每个 key 到 vm 实例上</p>\n<p>数据响应式，处理 props、methods、data、computed、watch 等选项</p>\n<p>解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上，如果 provide 是函数就用 call(vm) 方法 返回 provide 里面定义的对象</p>\n<p>调用 created 钩子函数</p>\n<p>如果发现配置项上有 el 选项，则自动调用 $mount 方法，也就是说有了 el 选项，就不需要再手动调用 $mount 方法，反之，没提供 el 选项则必须调用 $mount</p>\n<p>接下来则进入挂载阶段</p>\n<p>4、beforeCreate 期间能拿到数据吗？</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs mipsasm\">不能，因为数据初始化阶段是在 <span class=\"hljs-keyword\">beforeCreate </span>之后执行</code></pre></div>\n\n<p>4、Vue nextTick使用场景及实现原理</p>\n<p>它主要是处理我们再变更完数据以后，无法立刻拿到最新的DOM节点对象的问题。</p>\n<p>vue执行完渲染后会执行this.nextTick()里面的callback函数。</p>\n<p>将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。</p>\n<p>nextTick流程总结： 1、将回调放到callbacks里等待执行；<br>2、将执行函数（flushCallbacks）放到微任务或宏任务里；原码里按照是否原生支持Promise.then、MutationObserver和setImmediate的顺序决策，都不支持则使用setTimeout<br>3、等到事件循环执行到微任务或者宏任务时，执行函数依次执行callbacks里的回调；</p>\n<p>5、Vue的nextTick具体是微任务还是宏任务?</p>\n<table>\n<thead>\n<tr>\n<th>宏任务</th>\n<th>微任务</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>setTimeout</td>\n<td>process.nextTick</td>\n</tr>\n<tr>\n<td>setInterval</td>\n<td>MutationObserver</td>\n</tr>\n<tr>\n<td>setImmediate</td>\n<td>Promise.then</td>\n</tr>\n<tr>\n<td>requestAnimationFrame</td>\n<td></td>\n</tr>\n<tr>\n<td>MessageChannel</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>5、 Vue3 有哪些新的新特性？</p>\n<ul>\n<li>响应式系统</li>\n<li>自定义渲染器</li>\n<li>全部模块使用 TS 重构</li>\n<li>Composition API 组合语法</li>\n<li>新一代工程化工具 Vite</li>\n</ul>\n<p>6、Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</p>\n<p>vue2 问题：</p>\n<ul>\n<li><p>代码的可读性随着组件变大而变差</p>\n</li>\n<li><p>每一种代码复用的方式，都存在缺点</p>\n</li>\n<li><p>TypeScript支持有限</p>\n</li>\n<li><p>逻辑组织</p>\n<ul>\n<li>大型组件, 需要不断跳转代码块</li>\n<li>逻辑关注点相关的代码全都放在一个函数里</li>\n</ul>\n</li>\n<li><p>逻辑复用</p>\n<ul>\n<li>vue2 用 mixin去复用相同的逻辑, 我们一个组件混入大量不同的 mixins 的时候,命名冲突,数据来源不清</li>\n<li>vue3 写 hook 函数</li>\n</ul>\n</li>\n</ul>\n<p>6、父组件可以监听到子组件的生命周期吗？</p>\n<p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理。</p>\n<p>方法一：手动通过 $emit 触发父组件的事件</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Parent.vue</span>\n&lt;Child @mounted=<span class=\"hljs-string\">&quot;doSomething&quot;</span>/&gt;\n    \n<span class=\"hljs-comment\">// Child.vue</span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">mounted</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n  <span class=\"hljs-built_in\">this</span>.$emit(<span class=\"hljs-string\">&quot;mounted&quot;</span>);\n&#125;</code></pre></div>\n\n<p>方法二：父组件引用子组件时通过 @hook 来监听</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//  Parent.vue</span>\n&lt;Child @hook:mounted=<span class=\"hljs-string\">&quot;doSomething&quot;</span> &gt;&lt;/Child&gt;\n    \n<span class=\"hljs-comment\">//  Child.vue</span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">mounted</span>(<span class=\"hljs-params\"></span>)</span>&#123;\n   <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;子组件触发 mounted 钩子函数 ...&#x27;</span>);\n&#125;,</code></pre></div>\n\n<p>@hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p>\n<p>7、比较 Vue 和 React 两个框架，你觉得有哪些区别？</p>\n<ul>\n<li><p>监听数据变化的实现原理不同:</p>\n<p>Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化. react 中，数据变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化。</p>\n</li>\n<li><p>数据流的不同:</p>\n</li>\n<li><p>模板渲染方式的不同:</p>\n</li>\n</ul>\n<p>8、什么是异步组件？</p>\n<p>在声明或注册组件时，Vue 接受提供 Promise 的工厂函数。然后可以在调用该组件时对其进行“解析”。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n    <span class=\"hljs-attr\">components</span>: &#123;\n        ‘tweet-box’: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">import</span>(‘./components/<span class=\"hljs-keyword\">async</span>/TweetBox’)\n    &#125;\n&#125;);</code></pre></div>\n\n<h2 id=\"http\"><a href=\"#http\" class=\"headerlink\" title=\"http\"></a>http</h2><p>1、HTTP有哪些请求方法？PUT 和 PATCH 有什么区别？</p>\n<ul>\n<li>GET, POST 和 HEAD方法；OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT</li>\n<li>PUT和PATCH都是更新资源，而PATCH用来对资源进行局部更新。</li>\n</ul>\n<p>2、http 状态码 403 是什么错误？</p>\n<ul>\n<li>403 forbidden，表示对请求资源的访问被服务器拒绝</li>\n</ul>\n<p>3、知道哪些 http 的缓存策略 ？控制缓存的请求头有哪些？</p>\n<ul>\n<li>HTTP缓存机制分为强制缓存和协商缓存两类。</li>\n<li>强制缓存的意思就是不要问了(不发起请求)，直接用缓存吧。</li>\n<li>强制缓存常见技术有Expires和Cache-Control。</li>\n<li>Expires的值是一个时间，表示这个时间前缓存都有效，都不需要发起请求。</li>\n<li>Cache-Control有很多属性值，常用属性max-age设置了缓存有效的时间长度，单位为秒，这个时间没到，都不用发起请求。</li>\n<li>immutable也是Cache-Control的一个属性，表示这个资源这辈子都不用再请求了，但是他兼容性不好，Cache-Control其他属性可以参考MDN的文档。</li>\n<li>Cache-Control的max-age优先级比Expires高。</li>\n<li>协商缓存是为了知道有没有更新，必须跟服务端沟通过才知道的。常见技术有ETag和Last-Modified。</li>\n<li>ETag其实就是给资源算一个hash值或者版本号，对应的常用request header为If-None-Match。</li>\n<li>Last-Modified其实就是加上资源修改的时间，对应的常用request header为If-Modified-Since，精度为秒。</li>\n<li>ETag每次修改都会改变，而Last-Modified的精度只到秒，所以ETag更准确，优先级更高，但是需要计算，所以服务端开销更大。</li>\n<li>强制缓存和协商缓存都存在的情况下，先判断强制缓存是否生效，如果生效，不用发起请求，直接用缓存。如果强制缓存不生效再发起请求判断协商缓存。</li>\n</ul>\n<blockquote>\n<p>Cache-Control，ETag，Last-Modified</p>\n</blockquote>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li>怎么解决白屏问题?</li>\n</ul>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-number\">1</span>、加loading\n<span class=\"hljs-number\">2</span>、骨架屏</code></pre></div>\n\n<ul>\n<li>webpack loader 和 plugin 区 别 ？</li>\n</ul>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\">Loader：直译为<span class=\"hljs-string\">&quot;加载器&quot;</span>。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到<span class=\"hljs-string\">`loader`</span>。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。   \nPlugin：直译为<span class=\"hljs-string\">&quot;插件&quot;</span>。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</code></pre></div>\n\n<ol>\n<li><p>弱网环境下页面首屏如何快速加载?</p>\n<p>1.缓存的使用 2.SSR使用 3.骨架屏使用</p>\n</li>\n<li><p>code review需要注意的点，你做code reivew的话，会重点查看哪里，怎么写出高内聚，低耦合的代码，以实习中遇到的一个通用组件实现举例。</p>\n</li>\n<li><p>什 么 是 TS 泛 型 ？</p>\n</li>\n<li><p>webpack 构 建 流 程 是 怎 样 的 ？</p>\n</li>\n<li><p>webpack 热 更 新 原 理 ？</p>\n</li>\n<li><p>有没有读过哪些源码？</p>\n</li>\n<li><p>最近开发的项目具体业务是怎么样的？介绍一下？</p>\n</li>\n<li><p>对前端而言，你觉得函数式编程体现在哪些方面？</p>\n<p>纯函数、不可变数据、高阶函数。 react 就是函数式思想，数据是不可变的，react 相当于纯函数，展示出来的 ui 就是结果。 redux 更是函数式思想</p>\n</li>\n</ol>\n<h2 id=\"Devops-相关\"><a href=\"#Devops-相关\" class=\"headerlink\" title=\"Devops 相关\"></a>Devops 相关</h2><h2 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h2><ul>\n<li>常用 git 操作</li>\n</ul>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\">git branch 查看本地所有分支\ngit status 查看当前状态 \ngit commit 提交 \ngit branch -a 查看所有的分支\ngit branch -r 查看远程所有分支\ngit commit -am <span class=\"hljs-string\">&quot;init&quot;</span> 提交并且加注释 \ngit remote add origin git@<span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.119</span>:ndshow\ngit push origin master 将文件给推到服务器上 \ngit remote show origin 显示远程库origin里的资源 \ngit push origin master:develop\ngit push origin master:hb-dev 将本地库与服务器上的库进行关联 \ngit checkout --track origin/dev 切换到远程dev分支\ngit branch -D master develop 删除本地库develop\ngit checkout -b dev 建立一个新的本地分支dev\ngit merge origin/dev 将分支dev与当前分支进行合并\ngit checkout dev 切换到本地dev分支\ngit remote show 查看远程库\ngit add .\ngit rm 文件名(包括路径) 从git中删除指定文件\ngit clone git:<span class=\"hljs-comment\">//github.com/schacon/grit.git 从服务器上将代码给拉下来</span>\ngit config --list 看所有用户\ngit ls-files 看已经被提交的\ngit rm [file name] 删除一个文件\ngit commit -a 提交当前repos的所有的改变\ngit add [file name] 添加一个文件到git index\ngit commit -v 当你用－v参数的时候可以看commit的差异\ngit commit -m <span class=\"hljs-string\">&quot;This is the message describing the commit&quot;</span> 添加commit信息\ngit commit -a -a是代表add，把所有的change加到git index里然后再commit\ngit commit -a -v 一般提交命令\ngit log 看你commit的日志\ngit diff 查看尚未暂存的更新\ngit rm a.a 移除文件(从暂存区和工作区中删除)\ngit rm --cached a.a 移除文件(只从暂存区中删除)\ngit commit -m <span class=\"hljs-string\">&quot;remove&quot;</span> 移除文件(从Git中删除)\ngit rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)\ngit diff --cached 或 $ git diff --staged 查看尚未提交的更新\ngit stash push 将文件给push到一个临时空间中\ngit stash pop 将文件从临时空间pop下来</code></pre></div>\n\n<p>1、什么情况下使用 git rebase, 而不用 git merge</p>\n<h3 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h3><ol>\n<li>谈谈一下对 nginx 的理解，项目中用到 nginx 的哪些功能？</li>\n</ol>\n<ul>\n<li>Nginx ，是一个 Web 服务器和反向代理服务器用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。</li>\n<li>主要功能如下： 正向、反向代理 2、负载均衡、分流 3、虚拟主机（绑定host）</li>\n</ul>\n<p>2、正向代理和反向代理区别是什么？</p>\n<ul>\n<li>正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定原始服务器，然后代理向原始服务器转交请求并将获得的内容返回给客户端。代理服务器和客户端处于同一个局域网内。</li>\n<li>比如说fanqiang。我知道我要访问谷歌，于是我就告诉代理服务器让它帮我转发。</li>\n<li>反向代理实际运行方式是代理服务器接受网络上的连接请求。它将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给网络上请求连接的客户端 。代理服务器和原始服务器处于同一个局域网内。</li>\n<li>比如说我要访问taobao，对我来说不知道图片、json、css 是不是同一个服务器返回回来的，但是我不关心，是反向代理 处理的，我不知道原始服务器。</li>\n</ul>\n<p>3、nginx 如何来实现负载均衡？</p>\n<p>负载均衡的5种策略:</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">1.轮询（默认）\n 每个请求按时间顺序逐一分配到不同的后端服务器\n\n upstream backserver &#123;\n    server 192.168.0.14;\n    server 192.168.0.15;\n&#125;\n\n2.weight\n指定轮询几率，weight和访问概率成正比\n\nupstream backserver &#123;\n    server 192.168.0.14 weight=3;\n    server 192.168.0.15 weight=7;\n&#125;\n\n3.ip_hash\n已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的.ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。\n\nupstream backserver &#123;\n    ip_hash;\n    server 192.168.0.14:88;\n    server 192.168.0.15:80;\n&#125;\n\n4.fair\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n\nupstream backserver &#123;\n    server server1;\n    server server2;\n    fair;\n&#125;\n\n5.url_hash\n按访问url的<span class=\"hljs-built_in\">hash</span>结果来分配请求，使每个url定向到同一个（对应的）后端服务器，后端服务器为缓存时比较有效。\n\nupstream backserver &#123;\n    server squid1:3128;\n    server squid2:3128;\n    <span class=\"hljs-built_in\">hash</span> <span class=\"hljs-variable\">$request_uri</span>;\n    hash_method crc32;\n&#125;</code></pre></div>\n\n<h3 id=\"docker\"><a href=\"#docker\" class=\"headerlink\" title=\"docker\"></a>docker</h3><p>1、什么是 Docker？</p>\n<ul>\n<li>Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。</li>\n</ul>\n<p>2、Dockerfile中最常见的指令是什么？</p>\n<ul>\n<li>FROM：指定基础镜像；LABEL：功能是为镜像指定标签；RUN：运行指定的命令；CMD：容器启动时要运行的命令。</li>\n</ul>\n<p>3、docker 构建镜像多大，如何优化？</p>\n<ul>\n<li>使用轻量级基础镜像,如 Alpine</li>\n<li>多阶段构建</li>\n</ul>\n<p>4、 CI 中前端镜像每次构建都很慢，甚至有时候失败，如何解决？</p>\n<ul>\n<li>合理分层，利用构建镜像缓存机制</li>\n<li>失败，检查是否安装依赖超时，修改 npm timeout</li>\n</ul>\n<h3 id=\"k8s\"><a href=\"#k8s\" class=\"headerlink\" title=\"k8s\"></a>k8s</h3><p>1、k8s是什么？请说出你的了解？</p>\n<ul>\n<li>Kubernetes 是一个针对容器应用，进行自动部署，弹性伸缩和管理的开源系统。主要功能是生产环境中的容器编排。</li>\n</ul>\n<p>2、k8s 集群里面最小的单位是什么？</p>\n<ul>\n<li>pod 是最小单位。每个pod里边可以运行一个或多个container（容器）</li>\n</ul>\n<p>3、Service这种资源对象的作用是什么？</p>\n<ul>\n<li>用来给相同的多个pod对象提供一个固定的统一访问接口，常用于服务发现和服务访问。</li>\n</ul>\n<h3 id=\"openstack\"><a href=\"#openstack\" class=\"headerlink\" title=\"openstack\"></a>openstack</h3><p>1、openstack 里 KeyStone 组件是用于提供什么服务的？Nova 组件是做什么用？</p>\n<ul>\n<li>认证服务（KeyStone） Nova – 用于在计算级别管理虚拟机，并在计算或管理程序级别执行其他计算任务。</li>\n</ul>\n","site":{"data":{}},"wordcount":14281,"excerpt":"","more":"<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><ol>\n<li><p>左右两栏布局， 一侧定宽、一侧自适应撑满?</p>\n</li>\n<li><p>flex:1 到底代表什么?</p>\n</li>\n</ol>\n<p>直观的记忆是，如果设置了flex: 1，所有子项平分父亲，不管子项是否设置了固定宽度。</p>\n<pre><code class=\"hljs text\">flex: 1 等价于\nflex-grow: 1;\nflex-shrink: 1;\nflex-basis: 0%;\n不管是否设置宽度，flex-basis的值都是0，所有子项平分全部的父亲空间\n\n而flex: auto 等价于\n\nflex-grow: 1;\nflex-shrink: 1;\nflex-basis: auto;\n如果设置了宽度，flex-basis的值是width，所有子项平分取去掉flex-basis的剩余空间</code></pre>\n\n<h2 id=\"JS\"><a href=\"#JS\" class=\"headerlink\" title=\"JS\"></a>JS</h2><ul>\n<li>map 和 foreach 有什么区别</li>\n</ul>\n<pre><code class=\"hljs js\">foreach()方法会针对每一个元素执行提供得函数,该方法没有返回值,是否会改变原数组取决与数组元素的类型是基本类型还是引用类型\nmap()方法不会改变原数组的值,返回一个新数组,新数组中的值为原数组调用函数处理之后的值：</code></pre>\n\n<ul>\n<li>说一下for…in 和 for…of的区别?</li>\n</ul>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">for</span>...of遍历获取的是对象的键值, <span class=\"hljs-keyword\">for</span>...in获取的是对象的键名;\n<span class=\"hljs-keyword\">for</span>...in会遍历对象的整个原型链, 性能非常差不推荐使用,而<span class=\"hljs-keyword\">for</span>...of只遍历当前对象不会遍历原型链;\n对于数组的遍历,<span class=\"hljs-keyword\">for</span>...in会返回数组中所有可枚举的属性(包括原型链上可枚举的属性),<span class=\"hljs-keyword\">for</span>...of只返回数组的下标对应的属性值;\n总结：<span class=\"hljs-keyword\">for</span>...in循环主要是为了遍历对象而生,不适用遍历数组; <span class=\"hljs-keyword\">for</span>....of循环可以用来遍历数组、类数组对象、字符串、<span class=\"hljs-built_in\">Set</span>、<span class=\"hljs-built_in\">Map</span>以及Generator对象</code></pre>\n\n<p>1、请你讲一下闭包?</p>\n<blockquote>\n<p>简单：闭包是有权限访问其他函数作用域内的变量的一个函数。</p>\n</blockquote>\n<blockquote>\n<p>完整：由于在JS中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之回收，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数——也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后作用域内的值也不会被销毁。</p>\n</blockquote>\n<ul>\n<li>闭包解决了什么？</li>\n</ul>\n<blockquote>\n<p>由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。以平时使用的Ajax成功回调为例，这里其实就是个闭包，由于上述的特性，回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。开发者不用去写钩子函数来操作上级函数作用域内部的变量了。</p>\n</blockquote>\n<ul>\n<li>闭包有哪些应用场景?</li>\n</ul>\n<blockquote>\n<p>闭包随处可见，一个Ajax请求的成功回调，一个事件绑定的回调方法，一个setTimeout的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。</p>\n</blockquote>\n<ul>\n<li>react hooks 中的 闭包陷阱问题如何解决？</li>\n</ul>\n<p>不管在这个组件中的其他地方使用 setCount 将 count 设置为任何值，还是设置多少次，打印的都是1</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>)</span>&#123;\n    <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">1</span>);\n    useEffect(<span class=\"hljs-function\">()=&gt;</span>&#123;\n        <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">()=&gt;</span>&#123;\n            <span class=\"hljs-built_in\">console</span>.log(count)\n        &#125;, <span class=\"hljs-number\">1000</span>)\n    &#125;, [])\n&#125;</code></pre>\n\n<p>useRef</p>\n<p>useState 更新值时传入回调函数</p>\n<p>2、介绍一下 JS 里面的原型？</p>\n<ul>\n<li><p>所有原型链的终点都是 Object 函数的 prototype 属性</p>\n</li>\n<li><p>每一个构造函数都拥有一个 prototype 属性，此属性指向一个对象，也就是原型对象</p>\n</li>\n<li><p>原型对象默认拥有一个 constructor 属性，指向指向它的那个构造函数</p>\n</li>\n<li><p>每个对象都拥有一个隐藏的属性 <strong>proto</strong>，指向它的原型对象</p>\n</li>\n<li><p>原型的作用是什么？</p>\n</li>\n</ul>\n<blockquote>\n<p>共享方法</p>\n</blockquote>\n<ul>\n<li>原型中this的指向是什么？</li>\n</ul>\n<blockquote>\n<p>原型中this的指向是实例。</p>\n</blockquote>\n<ul>\n<li>说一下平时开发使用到 prototype 的例子？</li>\n</ul>\n<p>3、如何理解 es6 class 中 constructor 方法？ 和 super的作用？</p>\n<blockquote>\n<p>constructor 方法是类的构造函数。 通过 new 命令创建对象实例时，自动调用该方法。 constructor 内定义的方法是 实例方法；class 内直接定义的方法是原型方法。</p>\n</blockquote>\n<ul>\n<li>super 的作用？</li>\n</ul>\n<p>子类是没有自己的 this 对象的，它只能继承自父类的 this 对象，然后对其进行加工，而super( )就是将父类中的this对象继承给子类的。没有 super，子类就得不到 this 对象。</p>\n<ul>\n<li>为什么要传入 props？</li>\n</ul>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Component</span> </span>&#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;\n    <span class=\"hljs-built_in\">this</span>.props = props;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;\n&#125;</code></pre>\n\n<p>确保了 this.props 在构造函数执行完毕之前已被赋值。</p>\n<p>4、eventloop</p>\n<p>浏览器或node 端 js 单线程运行时不会阻塞的一种机制。</p>\n<p>任务分为宏任务和微任务；宏任务与微任务的区别?</p>\n<p>宏任务：script全部代码、setTimeout、setInterval、I/O、UI Rendering。<br>微任务：Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver</p>\n<ul>\n<li>浏览器中的 event loop</li>\n</ul>\n<p>JS 中有一个主线程和一个调用栈（执行栈），所有的任务都会被放到调用栈中等待主线程执行。</p>\n<p>JS 调用栈后进先出原则，当函数执行的时候，会被添加到栈顶部，当执行完后，会被从栈顶移出，直到栈内被清空。</p>\n<p>JS<br>任务分为同步任务和异步任务。同步任务在调用栈中按照顺序等待主线程依次执行。异步任务会在异步任务有结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），读取到栈内等待主线程执行。</p>\n<p>任务队列：先进先出</p>\n<p>顺序：同步任务 =》微任务 =》 宏任务</p>\n<ul>\n<li>执行栈在执行完同步任务后，查看执行栈是否为空</li>\n<li>如果执行栈为空，就会去检查微任务(microTask)队列, 执行完微任务，再执行宏任务</li>\n<li>每个宏任务执行完后，都会再检查微任务队列是否为空，不为空，就按先进先出执行完微任务，设置微任务为 null，再执行宏任务。</li>\n</ul>\n<p>Node 中 event loop(待补充)</p>\n<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><p>1、介绍一下react diff 算法 的工作原理？</p>\n<ul>\n<li><p>react 状态变化渲染页面时，不会马上对DOM节点进行操作，是先通过diff算法计算后，再对有变化的DOM节点进行操作。</p>\n</li>\n<li><p>diff算法就是更高效地通过对比新旧Virtual DOM来找出真正的Dom变化之处.</p>\n</li>\n<li><p>react中diff算法主要遵循三个层级的策略:tree层级、component 层级、element 层级</p>\n</li>\n<li><p>tree层级: DOM节点跨层级的操作不做优化，只会对相同层级的节点进行比较.只有删除、创建操作.新树中，R节点下没有了A，那么直接删除A，在D节点下创建A以及下属节点。</p>\n</li>\n<li><p>component 层级:是同一个组件，则会继续往下diff运算，如果不是一个类的组件，那么直接删除这个组件下的所有子节点，创建新的</p>\n</li>\n<li><p>element 层级:对于比较同一层级的节点们，每个节点在对应的层级用唯一的key作为标识.</p>\n<ul>\n<li>3 种节点操作，分别为 INSERT_MARKUP(插入)、MOVE_EXISTING (移动)和 REMOVE_NODE (删除)</li>\n<li>通过key可以准确地发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置</li>\n<li>如果当前节点在新集合中的位置比老集合中的位置靠前的话，是不会影响后续节点操作的，这里这时候被动字节不用动</li>\n<li>当ABCD节点比较完成后，diff过程还没完，还会整体遍历老集合中节点，看有没有没用到的节点，有的话，就删除</li>\n</ul>\n</li>\n</ul>\n<p>由于dom节点的移动操作开销是比较昂贵的，没有key的情况下要比有key的性能更好</p>\n<pre><code class=\"hljs HTML\">1.加key\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;1&#x27;</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;1&#x27;</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>     \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;2&#x27;</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;3&#x27;</span>&gt;</span>3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;3&#x27;</span>&gt;</span>3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  ========&gt;  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;2&#x27;</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;4&#x27;</span>&gt;</span>4<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;5&#x27;</span>&gt;</span>5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;5&#x27;</span>&gt;</span>5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&#x27;6&#x27;</span>&gt;</span>6<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n操作：节点2移动至下标为2的位置，新增节点6至下标为4的位置，删除节点4。\n\n2.不加key\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>     \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  ========&gt;  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>4<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>  \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>             <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>6<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span> \n操作：修改第1个到第5个节点的innerText</code></pre>\n\n<p>Virtual DOM 工作过程有：</p>\n<pre><code>1. state 变化，生成新的 Virtual Dom\n2. 比较 Virtual Dom 与之前 Virtual Dom 的异同\n3. 生成差异对象\n4. 遍历差异对象并更新真实 DOM\n</code></pre>\n<ul>\n<li>React diff 算法 和 vue diff 的相同点和不同点有哪些？</li>\n</ul>\n<p>不同点：</p>\n<ul>\n<li>vue的列表比对，采用从两端到中间的比对方式，而react则采用从左到右依次比对的方式。当一个集合，只是把最后一个节点移动到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移动到第一个</li>\n<li>vue比对节点，当节点元素类型相同，但是className不同，认为是不同类型元素，删除重建，而react会认为是同类型节点，只是修改节点属性</li>\n</ul>\n<p>Vue Diff使用双向链表，边对比，边更新DOM。React主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。</p>\n<p>相同点：</p>\n<ul>\n<li>虚拟DOM在比较时只比较同一层级节点，复杂度都为 O(n)，降低了算法复杂度；</li>\n<li>都使用key比较是否是相同节点，都是为了尽可能的复用节点</li>\n<li>都是操作虚拟DOM，最小化操作真实DOM，提高性能（其实虚拟DOM的优势 并不是在于它操作DOM快）</li>\n<li>都是不要用 index作为 key</li>\n</ul>\n<p>2、react 里什么是高阶组件？使用高阶组件的场景？</p>\n<blockquote>\n<p>高阶组件(HOC)是接受一个组件并返回一个新组件的函数。</p>\n</blockquote>\n<p>2、React setState 怎么获取到更新后的值?异步函数中为什么 setState 会立即更新?</p>\n<p>3、useState 为什么不能放到条件语句里面?</p>\n<p>React通过单链表来管理Hooks。 update 阶段，每次调用 useState，链表就会执行 next 向后移动一步。如果将 useState<br>写在条件判断中，假设条件判断不成立，没有执行里面的 useState 方法，会导致接下来所有的 useState 的取值出现偏移，从而导致异常发生。</p>\n<p>4、说一下 useRef 有哪些用法？</p>\n<blockquote>\n<p>useRef 除了获取 dom，另一个用法： 保存数据，不造成 rerender 想要保存数据，又不想触发函数的更新，该数据的更新不会造成组件 rerender</p>\n</blockquote>\n<p>5、什么情况下使用 useCallback ？ 子组件接收一个方法，避免子组件重复渲染</p>\n<ul>\n<li>react 中只要父组件的 render 了，那么默认情况下就会触发子组的 render，react<br>提供了来避免这种重渲染的性能开销的一些方法：React.PureComponent、React.memo ，shouldComponentUpdate()</li>\n<li>使用 React.memo 避免子组件做没必要的渲染。</li>\n<li>Reace.memo 只会对 props 做浅比较，也就是父组件重新 render 之后会传入 不同引用的方法 getList，浅比较之后不相等，导致子组件还是依然会渲染。</li>\n<li>useCallback 缓存一个函数，当依赖没有改变的时候，会一直返回同一个引用</li>\n</ul>\n<p>6、useCallback 与 useMemo 作用用来缓存，两者的区别是什么？</p>\n<blockquote>\n<p>useMemo 缓存值；useCallback 缓存函数</p>\n</blockquote>\n<p>注意不要滥用：</p>\n<p>经常用在以下两种场景（要保持引用相等；对于组件内部用到的 object、array、函数等，如果用在了其他 Hook 的依赖数组中，或者作为 props 传递给了下游组件，应该使用<br>useMemo/useCallback）</p>\n<p>7、react ssr 实现原理？react ssr 是在什么场景下做的？</p>\n<p>server端接收到客户端的请求路由后，查找对应的数据，以props、context、store的形式注入组件中。然后基于react提供的API：renderToString将组件转换为html字符串输出到客户端。客户端使用该数据进行渲染，保证数据的一致性。</p>\n<p>React SSR之所以能够实现，本质是虚拟 DOM的存在。判断环境是服务器环境，可以操作 JavaScript 对象，把虚拟 DOM 映射成字符串输出。判断环境是客户端环境，可以操作<br>JavaScript 对象，将虚拟 DOM 映射成真实 DOM ，完成页面挂载。</p>\n<p>8、 react 项目里做过哪些性能优化？</p>\n<p>代码层面：</p>\n<ul>\n<li>使用return null而不是CSS的display:none来控制节点的显示隐藏。保证同一时间页面的DOM节点尽可能的少。</li>\n<li>props和state的数据尽可能简单明了，扁平化。</li>\n<li>不要使用数组下标作为key</li>\n<li>利用 shouldComponentUpdate 和 PureComponent 避免过多 render function</li>\n<li>render里面尽量减少新建变量和bind函数，传递参数是尽量减少传递参数的数量。</li>\n<li>尽量将 props 和 state 扁平化，只传递 component 需要的 props（传得太多，或者层次传得太深，都会加重shouldComponentUpdate里面的数据比较负担），慎将<br>component 当作 props 传入</li>\n</ul>\n<p>代码体积优化:</p>\n<ul>\n<li>使用 babel-plugin-import 优化业务组件的引入，实现按需加载</li>\n<li>使用 生产版本</li>\n<li>使用 SplitChunksPlugin 拆分公共代码</li>\n<li>分析 CSS 和 JS 代码覆盖率</li>\n<li>优化 Webpack 中的库</li>\n<li>使用动态 import，懒加载 React 组件</li>\n<li>使用 webpack-bundle-analyzer 可视化 webpack 输出文件的大小</li>\n<li>使用 Tree Shaking &amp; 教程 &amp; Tree Shaking 优化</li>\n</ul>\n<p>9、有 用 过 lerna 吗 ？ 多 个 项 目 之 间 共 用 的 东 西 怎 么 共 享 ？</p>\n<p>10、使用 react 中，有没有遇到觉得比较难的点？是什么？</p>\n<p>11、使用 hooks 中遇到过哪些坑？为什么？</p>\n<ul>\n<li>不要在循环，条件或嵌套函数中调用Hook，必须始终在React函数的顶层使用Hook。这是因为React需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子函数。一旦在循环或条件分支语句中调用Hook，就容易导致调用顺序的不一致性。</li>\n<li>使用useState时候，使用push，pop，splice等直接更改数组对象的坑，应该采用析构方式.</li>\n<li>必包带来的坑,因为每次 render 都有一份新的状态，因此上述代码中的 setTimeout 使用产生了一个闭包，捕获了每次 render 后的 state，也就导致了输出了<br>0、1、2。如果你希望输出的内容是最新的 state 的话，可以通过 useRef 来保存 state。前文讲过 ref<br>在组件中只存在一份，无论何时使用它的引用都不会产生变化，因此可以来解决闭包引发的问题。</li>\n</ul>\n<h2 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h2><p>1、Vue如何监听数组的变化？</p>\n<ul>\n<li>对象数据是怎么被监听的?</li>\n</ul>\n<p>vue2.x版本中，数据监听用 Object.defineProperty.<br>通过Object.defineProperty来劫持对象属性的setter和getter操作，并创建一个监听器，当数据发生变化的时候发出通知</p>\n<ul>\n<li>数组数据是怎么被监听的?</li>\n</ul>\n<p>Vue.js是基于Object.defineProperty对对象实现“响应式化”，而对于数组，Vue.js提供的方法是重写push、pop、shift、unshift、splice、sort、reverse这七个数组方法.</p>\n<p>如果需要用数组下标修改数组并实现响应式数据变化，Vue.js提供了$set()及$remove()方法。</p>\n<p>1、Vue 组件 data 为什么必须是函数？</p>\n<blockquote>\n<p>因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染。 所以一个组件的 data<br>选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。</p>\n</blockquote>\n<p>2、直接给一个数组项赋值，Vue 能检测到变化吗？</p>\n<p>由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。</p>\n<ul>\n<li>Vue 不能检测到以下数组的变动:</li>\n</ul>\n<p>1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 解决办法</span>\nvm.$set(vm.items, indexOfItem, newValue)</code></pre>\n\n<p>2.当你修改数组的长度时，例如：vm.items.length = newLength</p>\n<pre><code class=\"hljs js\">/ 解决办法\nvm.items.splice(newLength)</code></pre>\n\n<ul>\n<li>检测不到的原因是什么？</li>\n</ul>\n<p>当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在<br>data 里声明。</p>\n<p>但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的<br>$set。</p>\n<p>3、vue2 中响应式（双向绑定）的原理？vue3 的原理？ Proxy 与 Object.defineProperty 的优劣对比? 为什么在 Vue3.0 采用了 Proxy,抛弃了<br>Object.defineProperty？</p>\n<blockquote>\n<p>Proxy的优势如下: Proxy 可以直接监听对象而非属性 Proxy 可以直接监听数组的变化 Proxy 有多达 13 种拦截方法,不限于<br>apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的 Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而<br>Object.defineProperty 只能遍历对象属性直接修改 Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利</p>\n</blockquote>\n<blockquote>\n<p>Object.defineProperty 的优势如下:</p>\n</blockquote>\n<blockquote>\n<p>兼容性好,支持 IE9</p>\n</blockquote>\n<p>4、vuex 的工作流程是怎么样？</p>\n<blockquote>\n<p>Vuex有5个重要的属性，分别是 State、Getter、Mutation、Action、Module，由 view 层发起一个 Action 给 Mutation，在 Mutation<br>中修改状态，返回新的状态，通过 Getter暴露给 view层的组件或者页面，页面监测到状态改变于是更新页面。</p>\n</blockquote>\n<p>4、Vue 的初始化过程（new Vue(options)）都做了什么？</p>\n<p>处理组件配置项</p>\n<p>初始化根组件时进行了选项合并操作，将全局配置合并到根组件的局部配置上</p>\n<p>初始化每个子组件时做了一些性能优化，将组件配置对象上的一些深层次属性放到 vm.$options 选项中，以提高代码的执行效率</p>\n<p>初始化组件实例的关系属性，比如 $parent、$children、$root、$refs 等</p>\n<p>处理自定义事件</p>\n<p>调用 beforeCreate 钩子函数</p>\n<p>初始化组件的 inject 配置项，得到 ret[key] = val 形式的配置对象，然后对该配置对象进行响应式处理，并代理每个 key 到 vm 实例上</p>\n<p>数据响应式，处理 props、methods、data、computed、watch 等选项</p>\n<p>解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上，如果 provide 是函数就用 call(vm) 方法 返回 provide 里面定义的对象</p>\n<p>调用 created 钩子函数</p>\n<p>如果发现配置项上有 el 选项，则自动调用 $mount 方法，也就是说有了 el 选项，就不需要再手动调用 $mount 方法，反之，没提供 el 选项则必须调用 $mount</p>\n<p>接下来则进入挂载阶段</p>\n<p>4、beforeCreate 期间能拿到数据吗？</p>\n<pre><code class=\"hljs mipsasm\">不能，因为数据初始化阶段是在 <span class=\"hljs-keyword\">beforeCreate </span>之后执行</code></pre>\n\n<p>4、Vue nextTick使用场景及实现原理</p>\n<p>它主要是处理我们再变更完数据以后，无法立刻拿到最新的DOM节点对象的问题。</p>\n<p>vue执行完渲染后会执行this.nextTick()里面的callback函数。</p>\n<p>将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。</p>\n<p>nextTick流程总结： 1、将回调放到callbacks里等待执行；<br>2、将执行函数（flushCallbacks）放到微任务或宏任务里；原码里按照是否原生支持Promise.then、MutationObserver和setImmediate的顺序决策，都不支持则使用setTimeout<br>3、等到事件循环执行到微任务或者宏任务时，执行函数依次执行callbacks里的回调；</p>\n<p>5、Vue的nextTick具体是微任务还是宏任务?</p>\n<table>\n<thead>\n<tr>\n<th>宏任务</th>\n<th>微任务</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>setTimeout</td>\n<td>process.nextTick</td>\n</tr>\n<tr>\n<td>setInterval</td>\n<td>MutationObserver</td>\n</tr>\n<tr>\n<td>setImmediate</td>\n<td>Promise.then</td>\n</tr>\n<tr>\n<td>requestAnimationFrame</td>\n<td></td>\n</tr>\n<tr>\n<td>MessageChannel</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>5、 Vue3 有哪些新的新特性？</p>\n<ul>\n<li>响应式系统</li>\n<li>自定义渲染器</li>\n<li>全部模块使用 TS 重构</li>\n<li>Composition API 组合语法</li>\n<li>新一代工程化工具 Vite</li>\n</ul>\n<p>6、Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</p>\n<p>vue2 问题：</p>\n<ul>\n<li><p>代码的可读性随着组件变大而变差</p>\n</li>\n<li><p>每一种代码复用的方式，都存在缺点</p>\n</li>\n<li><p>TypeScript支持有限</p>\n</li>\n<li><p>逻辑组织</p>\n<ul>\n<li>大型组件, 需要不断跳转代码块</li>\n<li>逻辑关注点相关的代码全都放在一个函数里</li>\n</ul>\n</li>\n<li><p>逻辑复用</p>\n<ul>\n<li>vue2 用 mixin去复用相同的逻辑, 我们一个组件混入大量不同的 mixins 的时候,命名冲突,数据来源不清</li>\n<li>vue3 写 hook 函数</li>\n</ul>\n</li>\n</ul>\n<p>6、父组件可以监听到子组件的生命周期吗？</p>\n<p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理。</p>\n<p>方法一：手动通过 $emit 触发父组件的事件</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Parent.vue</span>\n&lt;Child @mounted=<span class=\"hljs-string\">&quot;doSomething&quot;</span>/&gt;\n    \n<span class=\"hljs-comment\">// Child.vue</span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">mounted</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n  <span class=\"hljs-built_in\">this</span>.$emit(<span class=\"hljs-string\">&quot;mounted&quot;</span>);\n&#125;</code></pre>\n\n<p>方法二：父组件引用子组件时通过 @hook 来监听</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">//  Parent.vue</span>\n&lt;Child @hook:mounted=<span class=\"hljs-string\">&quot;doSomething&quot;</span> &gt;&lt;/Child&gt;\n    \n<span class=\"hljs-comment\">//  Child.vue</span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">mounted</span>(<span class=\"hljs-params\"></span>)</span>&#123;\n   <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;子组件触发 mounted 钩子函数 ...&#x27;</span>);\n&#125;,</code></pre>\n\n<p>@hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p>\n<p>7、比较 Vue 和 React 两个框架，你觉得有哪些区别？</p>\n<ul>\n<li><p>监听数据变化的实现原理不同:</p>\n<p>Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化. react 中，数据变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化。</p>\n</li>\n<li><p>数据流的不同:</p>\n</li>\n<li><p>模板渲染方式的不同:</p>\n</li>\n</ul>\n<p>8、什么是异步组件？</p>\n<p>在声明或注册组件时，Vue 接受提供 Promise 的工厂函数。然后可以在调用该组件时对其进行“解析”。</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n    <span class=\"hljs-attr\">components</span>: &#123;\n        ‘tweet-box’: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">import</span>(‘./components/<span class=\"hljs-keyword\">async</span>/TweetBox’)\n    &#125;\n&#125;);</code></pre>\n\n<h2 id=\"http\"><a href=\"#http\" class=\"headerlink\" title=\"http\"></a>http</h2><p>1、HTTP有哪些请求方法？PUT 和 PATCH 有什么区别？</p>\n<ul>\n<li>GET, POST 和 HEAD方法；OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT</li>\n<li>PUT和PATCH都是更新资源，而PATCH用来对资源进行局部更新。</li>\n</ul>\n<p>2、http 状态码 403 是什么错误？</p>\n<ul>\n<li>403 forbidden，表示对请求资源的访问被服务器拒绝</li>\n</ul>\n<p>3、知道哪些 http 的缓存策略 ？控制缓存的请求头有哪些？</p>\n<ul>\n<li>HTTP缓存机制分为强制缓存和协商缓存两类。</li>\n<li>强制缓存的意思就是不要问了(不发起请求)，直接用缓存吧。</li>\n<li>强制缓存常见技术有Expires和Cache-Control。</li>\n<li>Expires的值是一个时间，表示这个时间前缓存都有效，都不需要发起请求。</li>\n<li>Cache-Control有很多属性值，常用属性max-age设置了缓存有效的时间长度，单位为秒，这个时间没到，都不用发起请求。</li>\n<li>immutable也是Cache-Control的一个属性，表示这个资源这辈子都不用再请求了，但是他兼容性不好，Cache-Control其他属性可以参考MDN的文档。</li>\n<li>Cache-Control的max-age优先级比Expires高。</li>\n<li>协商缓存是为了知道有没有更新，必须跟服务端沟通过才知道的。常见技术有ETag和Last-Modified。</li>\n<li>ETag其实就是给资源算一个hash值或者版本号，对应的常用request header为If-None-Match。</li>\n<li>Last-Modified其实就是加上资源修改的时间，对应的常用request header为If-Modified-Since，精度为秒。</li>\n<li>ETag每次修改都会改变，而Last-Modified的精度只到秒，所以ETag更准确，优先级更高，但是需要计算，所以服务端开销更大。</li>\n<li>强制缓存和协商缓存都存在的情况下，先判断强制缓存是否生效，如果生效，不用发起请求，直接用缓存。如果强制缓存不生效再发起请求判断协商缓存。</li>\n</ul>\n<blockquote>\n<p>Cache-Control，ETag，Last-Modified</p>\n</blockquote>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li>怎么解决白屏问题?</li>\n</ul>\n<pre><code class=\"hljs js\"><span class=\"hljs-number\">1</span>、加loading\n<span class=\"hljs-number\">2</span>、骨架屏</code></pre>\n\n<ul>\n<li>webpack loader 和 plugin 区 别 ？</li>\n</ul>\n<pre><code class=\"hljs js\">Loader：直译为<span class=\"hljs-string\">&quot;加载器&quot;</span>。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到<span class=\"hljs-string\">`loader`</span>。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。   \nPlugin：直译为<span class=\"hljs-string\">&quot;插件&quot;</span>。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</code></pre>\n\n<ol>\n<li><p>弱网环境下页面首屏如何快速加载?</p>\n<p>1.缓存的使用 2.SSR使用 3.骨架屏使用</p>\n</li>\n<li><p>code review需要注意的点，你做code reivew的话，会重点查看哪里，怎么写出高内聚，低耦合的代码，以实习中遇到的一个通用组件实现举例。</p>\n</li>\n<li><p>什 么 是 TS 泛 型 ？</p>\n</li>\n<li><p>webpack 构 建 流 程 是 怎 样 的 ？</p>\n</li>\n<li><p>webpack 热 更 新 原 理 ？</p>\n</li>\n<li><p>有没有读过哪些源码？</p>\n</li>\n<li><p>最近开发的项目具体业务是怎么样的？介绍一下？</p>\n</li>\n<li><p>对前端而言，你觉得函数式编程体现在哪些方面？</p>\n<p>纯函数、不可变数据、高阶函数。 react 就是函数式思想，数据是不可变的，react 相当于纯函数，展示出来的 ui 就是结果。 redux 更是函数式思想</p>\n</li>\n</ol>\n<h2 id=\"Devops-相关\"><a href=\"#Devops-相关\" class=\"headerlink\" title=\"Devops 相关\"></a>Devops 相关</h2><h2 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h2><ul>\n<li>常用 git 操作</li>\n</ul>\n<pre><code class=\"hljs js\">git branch 查看本地所有分支\ngit status 查看当前状态 \ngit commit 提交 \ngit branch -a 查看所有的分支\ngit branch -r 查看远程所有分支\ngit commit -am <span class=\"hljs-string\">&quot;init&quot;</span> 提交并且加注释 \ngit remote add origin git@<span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.119</span>:ndshow\ngit push origin master 将文件给推到服务器上 \ngit remote show origin 显示远程库origin里的资源 \ngit push origin master:develop\ngit push origin master:hb-dev 将本地库与服务器上的库进行关联 \ngit checkout --track origin/dev 切换到远程dev分支\ngit branch -D master develop 删除本地库develop\ngit checkout -b dev 建立一个新的本地分支dev\ngit merge origin/dev 将分支dev与当前分支进行合并\ngit checkout dev 切换到本地dev分支\ngit remote show 查看远程库\ngit add .\ngit rm 文件名(包括路径) 从git中删除指定文件\ngit clone git:<span class=\"hljs-comment\">//github.com/schacon/grit.git 从服务器上将代码给拉下来</span>\ngit config --list 看所有用户\ngit ls-files 看已经被提交的\ngit rm [file name] 删除一个文件\ngit commit -a 提交当前repos的所有的改变\ngit add [file name] 添加一个文件到git index\ngit commit -v 当你用－v参数的时候可以看commit的差异\ngit commit -m <span class=\"hljs-string\">&quot;This is the message describing the commit&quot;</span> 添加commit信息\ngit commit -a -a是代表add，把所有的change加到git index里然后再commit\ngit commit -a -v 一般提交命令\ngit log 看你commit的日志\ngit diff 查看尚未暂存的更新\ngit rm a.a 移除文件(从暂存区和工作区中删除)\ngit rm --cached a.a 移除文件(只从暂存区中删除)\ngit commit -m <span class=\"hljs-string\">&quot;remove&quot;</span> 移除文件(从Git中删除)\ngit rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)\ngit diff --cached 或 $ git diff --staged 查看尚未提交的更新\ngit stash push 将文件给push到一个临时空间中\ngit stash pop 将文件从临时空间pop下来</code></pre>\n\n<p>1、什么情况下使用 git rebase, 而不用 git merge</p>\n<h3 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h3><ol>\n<li>谈谈一下对 nginx 的理解，项目中用到 nginx 的哪些功能？</li>\n</ol>\n<ul>\n<li>Nginx ，是一个 Web 服务器和反向代理服务器用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。</li>\n<li>主要功能如下： 正向、反向代理 2、负载均衡、分流 3、虚拟主机（绑定host）</li>\n</ul>\n<p>2、正向代理和反向代理区别是什么？</p>\n<ul>\n<li>正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定原始服务器，然后代理向原始服务器转交请求并将获得的内容返回给客户端。代理服务器和客户端处于同一个局域网内。</li>\n<li>比如说fanqiang。我知道我要访问谷歌，于是我就告诉代理服务器让它帮我转发。</li>\n<li>反向代理实际运行方式是代理服务器接受网络上的连接请求。它将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给网络上请求连接的客户端 。代理服务器和原始服务器处于同一个局域网内。</li>\n<li>比如说我要访问taobao，对我来说不知道图片、json、css 是不是同一个服务器返回回来的，但是我不关心，是反向代理 处理的，我不知道原始服务器。</li>\n</ul>\n<p>3、nginx 如何来实现负载均衡？</p>\n<p>负载均衡的5种策略:</p>\n<pre><code class=\"hljs sh\">1.轮询（默认）\n 每个请求按时间顺序逐一分配到不同的后端服务器\n\n upstream backserver &#123;\n    server 192.168.0.14;\n    server 192.168.0.15;\n&#125;\n\n2.weight\n指定轮询几率，weight和访问概率成正比\n\nupstream backserver &#123;\n    server 192.168.0.14 weight=3;\n    server 192.168.0.15 weight=7;\n&#125;\n\n3.ip_hash\n已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的.ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。\n\nupstream backserver &#123;\n    ip_hash;\n    server 192.168.0.14:88;\n    server 192.168.0.15:80;\n&#125;\n\n4.fair\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n\nupstream backserver &#123;\n    server server1;\n    server server2;\n    fair;\n&#125;\n\n5.url_hash\n按访问url的<span class=\"hljs-built_in\">hash</span>结果来分配请求，使每个url定向到同一个（对应的）后端服务器，后端服务器为缓存时比较有效。\n\nupstream backserver &#123;\n    server squid1:3128;\n    server squid2:3128;\n    <span class=\"hljs-built_in\">hash</span> <span class=\"hljs-variable\">$request_uri</span>;\n    hash_method crc32;\n&#125;</code></pre>\n\n<h3 id=\"docker\"><a href=\"#docker\" class=\"headerlink\" title=\"docker\"></a>docker</h3><p>1、什么是 Docker？</p>\n<ul>\n<li>Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。</li>\n</ul>\n<p>2、Dockerfile中最常见的指令是什么？</p>\n<ul>\n<li>FROM：指定基础镜像；LABEL：功能是为镜像指定标签；RUN：运行指定的命令；CMD：容器启动时要运行的命令。</li>\n</ul>\n<p>3、docker 构建镜像多大，如何优化？</p>\n<ul>\n<li>使用轻量级基础镜像,如 Alpine</li>\n<li>多阶段构建</li>\n</ul>\n<p>4、 CI 中前端镜像每次构建都很慢，甚至有时候失败，如何解决？</p>\n<ul>\n<li>合理分层，利用构建镜像缓存机制</li>\n<li>失败，检查是否安装依赖超时，修改 npm timeout</li>\n</ul>\n<h3 id=\"k8s\"><a href=\"#k8s\" class=\"headerlink\" title=\"k8s\"></a>k8s</h3><p>1、k8s是什么？请说出你的了解？</p>\n<ul>\n<li>Kubernetes 是一个针对容器应用，进行自动部署，弹性伸缩和管理的开源系统。主要功能是生产环境中的容器编排。</li>\n</ul>\n<p>2、k8s 集群里面最小的单位是什么？</p>\n<ul>\n<li>pod 是最小单位。每个pod里边可以运行一个或多个container（容器）</li>\n</ul>\n<p>3、Service这种资源对象的作用是什么？</p>\n<ul>\n<li>用来给相同的多个pod对象提供一个固定的统一访问接口，常用于服务发现和服务访问。</li>\n</ul>\n<h3 id=\"openstack\"><a href=\"#openstack\" class=\"headerlink\" title=\"openstack\"></a>openstack</h3><p>1、openstack 里 KeyStone 组件是用于提供什么服务的？Nova 组件是做什么用？</p>\n<ul>\n<li>认证服务（KeyStone） Nova – 用于在计算级别管理虚拟机，并在计算或管理程序级别执行其他计算任务。</li>\n</ul>\n"},{"title":"TypeScript 笔记","index_img":"/img/2022-03-16-1.png","abbrlink":"81dvefb9","date":"2022-03-16T15:19:28.000Z","_content":"\n## 声明空间\n\nts 中有两种：类型声明空间与变量声明空间\n\n类型声明空间：\n\n```ts\nclass Foo {}\ninterface Bar {}\ntype Bas = {};\n```\n\n如下当做类型注解使用\n\n```ts\nlet foo: Foo;\nlet bar: Bar;\nlet bas: Bas;\n```\n\n定义 interface Bar {} 不能当做变量来用，因为它没有定义在变量声明空间中。\n\n## 模块\n\n如下方式定义在 **全局模块** 中\n\n```ts\nconst foo = 123;\n```\n\n如下方式文件的根级别位置含有 import 或者 export,在文件中创建本地作用域，是定义在 **文件模块** 中\n\n```ts\nexport const foo = 123;\n```\n\n## 命名空间\n\n命名空间一个最明确的目的就是解决重名问题。\n\n命名空间是位于全局命名空间下的一个普通的带有名字的 JavaScript 对象。作用是将一系列相关的全局变量组织到一个对象的属性。\n\n```ts\nnamespace Letter { \n  export let a = 1; \n  export let b = 2; \n}\n```\n\n编译成 js 如下：\n\n```ts\nvar Letter; \n(function (Letter) { \n    Letter.a = 1; \n    Letter.b = 2; \n})(Letter || (Letter = {}));\n```\n\n## 动态导入表达式 import()\n\nimport() 异步加载一个模块, 该语句用于 Webpack Code Splitting。\n\n```ts\nimport(/* webpackChunkName: \"momentjs\" */ 'moment')\n  .then(moment => {\n    const time = moment().format();\n    console.log('TypeScript >= 2.4.0 Dynamic Import Expression:');\n    console.log(time);\n  })\n  .catch(err => {\n    console.log('Failed to load moment', err);\n  });\n```\n\n## TS 类型系统\n\n原始类型 string、number、boolean 可以被用作类型注解。\n\n## 数组\n\n两种方式定义数组：\n\n1、元素类型后加 []\n\n```ts\nlet list: number[] = [1, 2, 3];\n```\n\n2、 数组泛型 Array<元素类型>\n\n```js\nlet list: Array<number> = [1, 2, 3];\n```\n\n## 接口\n\n合并众多类型声明至一个类型声明\n\n```ts\ninterface Name {\n  first: string;\n  second: string;\n}\n\nlet name: Name = {\n  first: 'John',\n  second: 'Doe'\n};\n```\n\n## 内联类型注解\n\n```ts\nlet name: {\n  first: string;\n  second: string;\n};\n\nname = {\n  first: 'John',\n  second: 'Doe'\n};\n```\n\n内联类型注解可以省去为类型起名的麻烦。\n\n如果你发现需要多次使用相同的内联注解时，那么考虑把它重构为一个接口（或者是 type alias)\n\n## 特殊类型\n\nany、 null、 undefined 以及 void\n\n:void 来表示一个函数没有一个返回值\n\n```ts\nfunction log(message: string): void {\n  console.log(message);\n}\n```\n\n## 泛型\n\n在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。\n\n```ts\nfunction reverse<T>(items: T[]): T[] {\n  const toreturn = [];\n  for (let i = items.length - 1; i >= 0; i--) {\n    toreturn.push(items[i]);\n  }\n  return toreturn;\n}\n```\n\n## 联合类型\n\n多种类型之一\n\n```ts\nfunction formatCommandline(command: string[] | string) {\n  let line = '';\n  if (typeof command === 'string') {\n    line = command.trim();\n  } else {\n    line = command.join(' ').trim();\n  }\n\n  // Do stuff with line: string\n}\n```\n\n## 交叉类型\n\nextend 是一种非常常见的模式，从两个对象中创建一个新对象，新对象拥有着两个对象所有的功能。\n\n```ts\nfunction extend<T extends object, U extends object>(first: T, second: U): T & U {\n  const result = <T & U>{};\n  for (let id in first) {\n    (<T>result)[id] = first[id];\n  }\n  for (let id in second) {\n    if (!result.hasOwnProperty(id)) {\n      (<U>result)[id] = second[id];\n    }\n  }\n\n  return result;\n}\n\nconst x = extend({ a: 'hello' }, { b: 42 });\n\n// 现在 x 拥有了 a 属性与 b 属性\nconst a = x.a;\nconst b = x.b;\n```\n\n## 元祖类型 Tuple\n\n固定长度的，元素数据类型不同的数组。数据不可变。\n\n```js\ntype FixedArray = [string, number, string];\n\nconst mixedArray: FixedArray = ['a', 2, 'c'];\n```\n\n## 类型别名\n\n以为任意的类型注解提供类型别名,在联合类型和交叉类型中比较实用。\n\n```ts\ntype StrOrNum = string | number;\n\n// 使用\nlet sample: StrOrNum;\nsample = 123;\nsample = '123';\n\n// 会检查类型\nsample = true; // Error\n```\n\n```ts\ntype Text = string | { text: string };\ntype Coordinates = [number, number];\ntype Callback = (data: string) => void;\n```\n\n## @types\n\n通过 npm 来安装使用 @types,如 `npm install @types/jquery --save-dev`\n\n## declare 声明文件\n\n.d.ts文件是ts用来声明变量，模块，type，interface等等的。\n\n在这种后缀的ts文件声明这些东西和在纯ts文件声明这些东西又什么区别呢？\n\n在.d.ts声明变量或者模块等东西之后，在其他地方可以不用import导入这些东西就可以直接用，用，而且有语法提示。\n\ndeclare声明一个类型:\n\n```ts\ndeclare type Asd {\n    name: string;\n}\n```\n\n在tsconfig.json文件里面的include数组里面添加这个文件, 在include包含的文件范围内可以直接使用Asd这个type。\n\ndeclare声明一个模块:\n\n```ts\ndeclare module '*.css';\ndeclare module '*.less';\ndeclare module '*.png';\n```\n\n编译ts文件的时候，导入一个.css/.less/.png格式的文件，如果没有经过declare的话是会提示语法错误的\n\ndeclare声明一个变量:\n\n在项目中引入了一个sdk，这个sdk（我们以微信的sdk为例）里面有一些全局的对象（比如wx），但是如果不经过任何的声明，在ts文件里面直接用wx.config()的话，肯定会报错。\n\ndeclare声明一个作用域:\n\n```ts\ndeclare namespace API {\n    interface ResponseList {}\n}\n```\n\n声明完之后在其他地方的ts就可以直接API.ResponseList引用到这个接口类型\n\n## 接口\n\n两种声明方式：\n\n```ts\n// 内联注解\ndeclare const myPoint: { x: number; y: number };\n\n// 接口形式\ninterface Point {\n  x: number;\n  y: number;\n}\ndeclare const myPoint: Point;\n```\n\n接口形式的好处在于，如果有人创建了一个基于 myPoint 的库来添加新成员, 可以轻松将此成员添加到 myPoint 的现有声明中\n\n```ts\n// Lib a.d.ts\ninterface Point {\n  x: number,\n  y: number\n}\ndeclare const myPoint: Point\n\n// Lib b.d.ts\ninterface Point {\n  z: number\n}\n\n// Your code\nmyPoint.z // Allowed!\n```\n\n## 函数重载\n\n函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 |操作符或者?操作符，把所有可能的输入类型全部包含进去，以具体实现。\n\n```ts\n// 上边是声明\nfunction add (arg1: string, arg2: string): string\nfunction add (arg1: number, arg2: number): number\n// 因为我们在下边有具体函数的实现，所以这里并不需要添加 declare 关键字\n\n// 下边是实现\nfunction add (arg1: string | number, arg2: string | number) {\n  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2\n  if (typeof arg1 === 'string' && typeof arg2 === 'string') {\n    return arg1 + arg2\n  } else if (typeof arg1 === 'number' && typeof arg2 === 'number') {\n    return arg1 + arg2\n  }\n}\n```\n\n函数重载的意义在于能够让你知道传入不同的参数得到不同的结果，如果传入的参数不同，但是得到的结果（类型）却相同，那么不要使用函数重载（没有意义）。 如果函数的返回值类型相同，那么也不需要使用函数重载\n\n以下场景可以不需要重载：\n\n```ts\nfunction func (a: number): number\nfunction func (a: number, b: number): number\n\n// 像这样的是参数个数的区别，我们可以使用可选参数来代替函数重载的定义\n\nfunction func (a: number, b?: number): number\n```\n\n```ts\n// 亦或是一些参数类型的区别导致的\nfunction func (a: number): number\nfunction func (a: string): number\n\n// 这时我们应该使用联合类型来代替函数重载\nfunction func (a: number | string): number\n```\n\n## 函数声明\n\n在没有提供函数实现的情况下，有两种声明函数类型的方式:\n\n```ts\ntype LongHand = {\n  (a: number): number;\n}; //当你想使用函数重载时, 只能用此方式\n\ntype ShortHand = (a: number) => number;\n```\n\n## 可调用的类型注解\n\n使用类型别名或者接口来表示一个可被调用的类型注解：\n\n```ts\ninterface ReturnString {\n  (): string;\n}\n// 表示一个返回值为 string 的函数：\n```\n\n```ts\ndeclare const foo: ReturnString;\n\nconst bar = foo(); // bar 被推断为一个字符串。\n```\n\n## 类型断言\n\nts 允许你覆盖它的推断，并且能以你任何你想要的方式分析它\n\njs 迁移到 ts 时常见：\n\n```ts\nconst foo = {};\nfoo.bar = 123; // Error: 'bar' 属性不存在于 ‘{}’\nfoo.bas = 'hello'; // Error: 'bas' 属性不存在于 '{}'\n```\n\nfoo 类型推断为 {}，不存在属性。通过类型断言来避免该问题\n\n```ts\ninterface Foo {\n  bar: number;\n  bas: string;\n}\n\nconst foo = {} as Foo;\nfoo.bar = 123;\nfoo.bas = 'hello';\n```\n\n## 允许额外的属性\n\n包含索引签名，以明确表明可以使用额外的属性：\n\n```ts\nlet x: { foo: number, [x: string]: any };\n\nx = { foo: 1, baz: 2 }; // ok, 'baz' 属性匹配于索引签名\n```\n\nReact State 中示例：\n\n```ts\n// 假设\ninterface State {\n  foo: string;\n  bar: string;\n}\n\n// 你可能想做：\nthis.setState({ foo: 'Hello' }); // Error: 没有属性 'bar'\n\n// 因为 state 包含 'foo' 与 'bar'，TypeScript 会强制你这么做：\nthis.setState({ foo: 'Hello', bar: this.state.bar });\n```\n\n## 类型保护\n\nts 会推到条件块中的变量类型\n\n```ts\nfunction doSome(x: number | string) {\n  if (typeof x === 'string') {\n    // 在这个块中，TypeScript 知道 `x` 的类型必须是 `string`\n    console.log(x.subtr(1)); // Error: 'subtr' 方法并没有存在于 `string` 上\n    console.log(x.substr(1)); // ok\n  }\n\n  x.substr(1); // Error: 无法保证 `x` 是 `string` 类型\n}\n```\n\nin 操作符可以一个对象上是否存在一个属性，它通常也被作为类型保护使用\n\n```ts\ninterface A {\n  x: number;\n}\n\ninterface B {\n  y: string;\n}\n\nfunction doStuff(q: A | B) {\n  if ('x' in q) {\n    // q: A\n  } else {\n    // q: B\n  }\n}\n```\n\n## 字面量类型\n\n字面量类型本身不使用，在一个联合类型中组合创建一个强大的（实用的）抽象。\n\n字符串字面量：\n\n```ts\nlet foo: 'Hello';\nfoo = 'Bar'; // Error: 'bar' 不能赋值给类型 'Hello'\n```\n\n```ts\ntype CardinalDirection = 'North' | 'East' | 'South' | 'West';\n\nfunction move(distance: number, direction: CardinalDirection) {\n  // ...\n}\n\nmove(1, 'North'); // ok\nmove(1, 'Nurth'); // Error\n```\n\nboolean 和 number 的字面量类型：\n\n```ts\ntype OneToFive = 1 | 2 | 3 | 4 | 5;\ntype Bools = true | false;\n```\n\n## Readonly\n\n```ts\nfunction foo(config: { readonly bar: number, readonly bas: number }) {\n  // ..\n}\n\ntype Foo = {\n  readonly bar: number;\n  readonly bas: number;\n};\n```\n\n这有一个 Readonly 的映射类型，它接收一个泛型 T，用来把它的所有属性标记为只读类型：\n\n```ts\ntype Foo = {\n  bar: number;\n  bas: number;\n};\n\ntype FooReadonly = Readonly<Foo>;\n```\n\n## 泛型2\n\n创建泛型类\n\n```ts\n// 创建一个泛型类\nclass Queue<T> {\n  private data: T[] = [];\n  push = (item: T) => this.data.push(item);\n  pop = (): T | undefined => this.data.shift();\n}\n\n// 简单的使用\nconst queue = new Queue<number>();\nqueue.push(0);\nqueue.push('1'); // Error：不能推入一个 `string`，只有 number 类型被允许\n```\n\n泛型的误用：近在单个参数或一个位置被使用\n\n```ts\ndeclare function foo<T>(arg: T): void;  \n// \ndeclare function foo(arg: any): void;\n```\n\naxios 请求中 泛型的使用：\n\n通常情况下，我们会把后端返回数据格式单独放入一个 interface 里：\n\n```ts\n// 请求接口数据\nexport interface ResponseData<T = any> {\n  /**\n   * 状态码\n   * @type { number }\n   */\n  code: number;\n\n  /**\n   * 数据\n   * @type { T }\n   */\n  result: T;\n\n  /**\n   * 消息\n   * @type { string }\n   */\n  message: string;\n}\n```\n\n```ts\n// 在 axios.ts 文件中对 axios 进行了处理，例如添加通用配置、拦截器等\nimport Ax from './axios';\n\nimport { ResponseData } from './interface.ts';\n\nexport function getUser<T>() {\n  return Ax.get<ResponseData<T>>('/somepath')\n    .then(res => res.data)\n    .catch(err => console.error(err));\n}\n```\n\n写入返回的数据类型 User\n\n```ts\ninterface User {\n  name: string;\n  age: number;\n}\n\nasync function test() {\n  // user 被推断出为\n  // {\n  //  code: number,\n  //  result: { name: string, age: number },\n  //  message: string\n  // }\n  const user = await getUser<User>();\n}\n```\n\n## never 类型\n\n常用在\n\n- 从来不会有返回值的函数（如：如果函数内含有 while(true) {}）\n- 总是会抛出错误的函数 throw new Error\n\nnever 类型仅能被赋值给另外一个 never\n\n```ts\nlet bar: never = (() => {\n  throw new Error('Throw my hands in the air like I just dont care');\n})();\n```\n\nvoid 和 never 的区别：\n\n- void 表示没有任何类型，never 表示永远不存在的值的类型。\n- 当一个函数返回空值时，它的返回值为 void 类型，但是，当一个函数永不返回时（或者总是抛出错误），它的返回值为 never 类型。\n- void 类型可以被赋值，但是除了 never 本身以外，其他任何类型不能赋值给 never。\n\n## redux 中的联合类型\n\n```ts\nimport { createStore } from 'redux';\n\ntype Action =\n  | {\n      type: 'INCREMENT';\n    }\n  | {\n      type: 'DECREMENT';\n    };\n\n//reducer\nfunction counter(state = 0, action: Action) {\n  switch (action.type) {\n    case 'INCREMENT':\n      return state + 1;\n    case 'DECREMENT':\n      return state - 1;\n    default:\n      return state;\n  }\n}\n```\n\n## 索引签名\n\n声明一个索引签名时，所有明确的成员都必须符合索引签名：\n\n```ts\ninterface Bar {\n  [key: string]: number;\n  x: number;\n  y: string; // Error: y 属性必须为 number 类型\n}\n```\n\n映射类型来使索引字符串为联合类型中的一员\n\n```ts\ntype Index = 'a' | 'b' | 'c';\ntype FromIndex = { [k in Index]?: number };\n\nconst bad: FromIndex = { b: 1, c: 2, d: 3 }; //err\n```\n\n```ts\ntype FromSomeIndex<K extends string> = { [key in K]: number };\n```\n\n## 索引签名中排除某些属性\n\n用交叉类型解决\n\n```ts\ntype FieldState = {\n  value: string;\n};\n\ntype FromState = {\n  isValid: boolean; // Error: 不符合索引签名\n  [filedName: string]: FieldState;\n};\n```\n\n交叉类型：\n\n```ts\ntype FieldState = {\n  value: string;\n};\n\ntype FormState = { isValid: boolean } & { [fieldName: string]: FieldState };\n```\n\n## 流动的类型\n\n捕获变量的类型\n\n```ts\nlet foo = 123;\nlet bar: typeof foo; // 'bar' 类型与 'foo' 类型相同（在这里是： 'number'）\n```\n\n捕获类成员类型 需要声明一个变量\n\n```ts\nclass Foo {\n  foo: number; // 我们想要捕获的类型\n}\n\ndeclare let _foo: Foo;\n\n// 与之前做法相同\nlet bar: typeof _foo.foo;\n```\n\n捕获键的名称\n\n```ts\nconst colors = {\n  red: 'red',\n  blue: 'blue'\n};\n\ntype Colors = keyof typeof colors;\n\nlet color: Colors; // color 的类型是 'red' | 'blue'\ncolor = 'red'; // ok\ncolor = 'blue'; // ok\ncolor = 'anythingElse'; // Error\n```\n\n## JSX 的支持\n\n函数组件\n\n```ts\ntype Props = {\n  foo: string;\n};\n\nconst MyComponent: React.FunctionComponent<Props> = props => {\n  return <span>{props.foo}</span>;\n};\n\n<MyComponent foo=\"bar\" />;\n```\n\n类组件\n\n```ts\ntype Props = {\n  foo: string;\n};\n\nclass MyComponent extends React.Component<Props, {}> {\n  render() {\n    return <span>{this.props.foo}</span>;\n  }\n}\n\n<MyComponent foo=\"bar\" />;\n```\n\n泛型组件\n\n```ts\n// 一个泛型组件\ntype SelectProps<T> = { items: T[] };\nclass Select<T> extends React.Component<SelectProps<T>, any> {}\n\n// 使用\nconst Form = () => <Select<string> items={['a', 'b']} />;\n```\n\n泛型函数\n\n```ts\nfunction foo<T>(x: T): T {\n  return x;\n}\n\n// 不能使用箭头函数\nconst foo = <T>(x: T) => T; // Error: T 标签没有关闭\n\n解决办法：用 extends 提示编译器这是泛型\nconst foo = <T extends {}>(x: T) => x;\n```\n\nRefs\n\n一个变量时，使用 ref 和 null 的联合类型\n\n```ts\nclass Use {\n  exampleRef: Example | null = null;\n\n  render() {\n    return <Example ref={exampleRef => (this.exampleRef = exampleRef)} />;\n  }\n}\n```\n\n## 参考\n\n- [深入理解 TypeScript](https://jkchao.github.io/typescript-book-chinese/)\n- [https://www.tslang.cn/docs/handbook/generics.html](https://www.tslang.cn/docs/handbook/generics.html)\n","source":"_posts/9.TypeScript 笔记.md","raw":"---\ntitle: TypeScript 笔记\nindex_img: /img/2022-03-16-1.png\nabbrlink: 81dvefb9\ndate: 2022-03-16 23:19:28\ntags: TypeScript\ncategories: TypeScript\n---\n\n## 声明空间\n\nts 中有两种：类型声明空间与变量声明空间\n\n类型声明空间：\n\n```ts\nclass Foo {}\ninterface Bar {}\ntype Bas = {};\n```\n\n如下当做类型注解使用\n\n```ts\nlet foo: Foo;\nlet bar: Bar;\nlet bas: Bas;\n```\n\n定义 interface Bar {} 不能当做变量来用，因为它没有定义在变量声明空间中。\n\n## 模块\n\n如下方式定义在 **全局模块** 中\n\n```ts\nconst foo = 123;\n```\n\n如下方式文件的根级别位置含有 import 或者 export,在文件中创建本地作用域，是定义在 **文件模块** 中\n\n```ts\nexport const foo = 123;\n```\n\n## 命名空间\n\n命名空间一个最明确的目的就是解决重名问题。\n\n命名空间是位于全局命名空间下的一个普通的带有名字的 JavaScript 对象。作用是将一系列相关的全局变量组织到一个对象的属性。\n\n```ts\nnamespace Letter { \n  export let a = 1; \n  export let b = 2; \n}\n```\n\n编译成 js 如下：\n\n```ts\nvar Letter; \n(function (Letter) { \n    Letter.a = 1; \n    Letter.b = 2; \n})(Letter || (Letter = {}));\n```\n\n## 动态导入表达式 import()\n\nimport() 异步加载一个模块, 该语句用于 Webpack Code Splitting。\n\n```ts\nimport(/* webpackChunkName: \"momentjs\" */ 'moment')\n  .then(moment => {\n    const time = moment().format();\n    console.log('TypeScript >= 2.4.0 Dynamic Import Expression:');\n    console.log(time);\n  })\n  .catch(err => {\n    console.log('Failed to load moment', err);\n  });\n```\n\n## TS 类型系统\n\n原始类型 string、number、boolean 可以被用作类型注解。\n\n## 数组\n\n两种方式定义数组：\n\n1、元素类型后加 []\n\n```ts\nlet list: number[] = [1, 2, 3];\n```\n\n2、 数组泛型 Array<元素类型>\n\n```js\nlet list: Array<number> = [1, 2, 3];\n```\n\n## 接口\n\n合并众多类型声明至一个类型声明\n\n```ts\ninterface Name {\n  first: string;\n  second: string;\n}\n\nlet name: Name = {\n  first: 'John',\n  second: 'Doe'\n};\n```\n\n## 内联类型注解\n\n```ts\nlet name: {\n  first: string;\n  second: string;\n};\n\nname = {\n  first: 'John',\n  second: 'Doe'\n};\n```\n\n内联类型注解可以省去为类型起名的麻烦。\n\n如果你发现需要多次使用相同的内联注解时，那么考虑把它重构为一个接口（或者是 type alias)\n\n## 特殊类型\n\nany、 null、 undefined 以及 void\n\n:void 来表示一个函数没有一个返回值\n\n```ts\nfunction log(message: string): void {\n  console.log(message);\n}\n```\n\n## 泛型\n\n在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。\n\n```ts\nfunction reverse<T>(items: T[]): T[] {\n  const toreturn = [];\n  for (let i = items.length - 1; i >= 0; i--) {\n    toreturn.push(items[i]);\n  }\n  return toreturn;\n}\n```\n\n## 联合类型\n\n多种类型之一\n\n```ts\nfunction formatCommandline(command: string[] | string) {\n  let line = '';\n  if (typeof command === 'string') {\n    line = command.trim();\n  } else {\n    line = command.join(' ').trim();\n  }\n\n  // Do stuff with line: string\n}\n```\n\n## 交叉类型\n\nextend 是一种非常常见的模式，从两个对象中创建一个新对象，新对象拥有着两个对象所有的功能。\n\n```ts\nfunction extend<T extends object, U extends object>(first: T, second: U): T & U {\n  const result = <T & U>{};\n  for (let id in first) {\n    (<T>result)[id] = first[id];\n  }\n  for (let id in second) {\n    if (!result.hasOwnProperty(id)) {\n      (<U>result)[id] = second[id];\n    }\n  }\n\n  return result;\n}\n\nconst x = extend({ a: 'hello' }, { b: 42 });\n\n// 现在 x 拥有了 a 属性与 b 属性\nconst a = x.a;\nconst b = x.b;\n```\n\n## 元祖类型 Tuple\n\n固定长度的，元素数据类型不同的数组。数据不可变。\n\n```js\ntype FixedArray = [string, number, string];\n\nconst mixedArray: FixedArray = ['a', 2, 'c'];\n```\n\n## 类型别名\n\n以为任意的类型注解提供类型别名,在联合类型和交叉类型中比较实用。\n\n```ts\ntype StrOrNum = string | number;\n\n// 使用\nlet sample: StrOrNum;\nsample = 123;\nsample = '123';\n\n// 会检查类型\nsample = true; // Error\n```\n\n```ts\ntype Text = string | { text: string };\ntype Coordinates = [number, number];\ntype Callback = (data: string) => void;\n```\n\n## @types\n\n通过 npm 来安装使用 @types,如 `npm install @types/jquery --save-dev`\n\n## declare 声明文件\n\n.d.ts文件是ts用来声明变量，模块，type，interface等等的。\n\n在这种后缀的ts文件声明这些东西和在纯ts文件声明这些东西又什么区别呢？\n\n在.d.ts声明变量或者模块等东西之后，在其他地方可以不用import导入这些东西就可以直接用，用，而且有语法提示。\n\ndeclare声明一个类型:\n\n```ts\ndeclare type Asd {\n    name: string;\n}\n```\n\n在tsconfig.json文件里面的include数组里面添加这个文件, 在include包含的文件范围内可以直接使用Asd这个type。\n\ndeclare声明一个模块:\n\n```ts\ndeclare module '*.css';\ndeclare module '*.less';\ndeclare module '*.png';\n```\n\n编译ts文件的时候，导入一个.css/.less/.png格式的文件，如果没有经过declare的话是会提示语法错误的\n\ndeclare声明一个变量:\n\n在项目中引入了一个sdk，这个sdk（我们以微信的sdk为例）里面有一些全局的对象（比如wx），但是如果不经过任何的声明，在ts文件里面直接用wx.config()的话，肯定会报错。\n\ndeclare声明一个作用域:\n\n```ts\ndeclare namespace API {\n    interface ResponseList {}\n}\n```\n\n声明完之后在其他地方的ts就可以直接API.ResponseList引用到这个接口类型\n\n## 接口\n\n两种声明方式：\n\n```ts\n// 内联注解\ndeclare const myPoint: { x: number; y: number };\n\n// 接口形式\ninterface Point {\n  x: number;\n  y: number;\n}\ndeclare const myPoint: Point;\n```\n\n接口形式的好处在于，如果有人创建了一个基于 myPoint 的库来添加新成员, 可以轻松将此成员添加到 myPoint 的现有声明中\n\n```ts\n// Lib a.d.ts\ninterface Point {\n  x: number,\n  y: number\n}\ndeclare const myPoint: Point\n\n// Lib b.d.ts\ninterface Point {\n  z: number\n}\n\n// Your code\nmyPoint.z // Allowed!\n```\n\n## 函数重载\n\n函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 |操作符或者?操作符，把所有可能的输入类型全部包含进去，以具体实现。\n\n```ts\n// 上边是声明\nfunction add (arg1: string, arg2: string): string\nfunction add (arg1: number, arg2: number): number\n// 因为我们在下边有具体函数的实现，所以这里并不需要添加 declare 关键字\n\n// 下边是实现\nfunction add (arg1: string | number, arg2: string | number) {\n  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2\n  if (typeof arg1 === 'string' && typeof arg2 === 'string') {\n    return arg1 + arg2\n  } else if (typeof arg1 === 'number' && typeof arg2 === 'number') {\n    return arg1 + arg2\n  }\n}\n```\n\n函数重载的意义在于能够让你知道传入不同的参数得到不同的结果，如果传入的参数不同，但是得到的结果（类型）却相同，那么不要使用函数重载（没有意义）。 如果函数的返回值类型相同，那么也不需要使用函数重载\n\n以下场景可以不需要重载：\n\n```ts\nfunction func (a: number): number\nfunction func (a: number, b: number): number\n\n// 像这样的是参数个数的区别，我们可以使用可选参数来代替函数重载的定义\n\nfunction func (a: number, b?: number): number\n```\n\n```ts\n// 亦或是一些参数类型的区别导致的\nfunction func (a: number): number\nfunction func (a: string): number\n\n// 这时我们应该使用联合类型来代替函数重载\nfunction func (a: number | string): number\n```\n\n## 函数声明\n\n在没有提供函数实现的情况下，有两种声明函数类型的方式:\n\n```ts\ntype LongHand = {\n  (a: number): number;\n}; //当你想使用函数重载时, 只能用此方式\n\ntype ShortHand = (a: number) => number;\n```\n\n## 可调用的类型注解\n\n使用类型别名或者接口来表示一个可被调用的类型注解：\n\n```ts\ninterface ReturnString {\n  (): string;\n}\n// 表示一个返回值为 string 的函数：\n```\n\n```ts\ndeclare const foo: ReturnString;\n\nconst bar = foo(); // bar 被推断为一个字符串。\n```\n\n## 类型断言\n\nts 允许你覆盖它的推断，并且能以你任何你想要的方式分析它\n\njs 迁移到 ts 时常见：\n\n```ts\nconst foo = {};\nfoo.bar = 123; // Error: 'bar' 属性不存在于 ‘{}’\nfoo.bas = 'hello'; // Error: 'bas' 属性不存在于 '{}'\n```\n\nfoo 类型推断为 {}，不存在属性。通过类型断言来避免该问题\n\n```ts\ninterface Foo {\n  bar: number;\n  bas: string;\n}\n\nconst foo = {} as Foo;\nfoo.bar = 123;\nfoo.bas = 'hello';\n```\n\n## 允许额外的属性\n\n包含索引签名，以明确表明可以使用额外的属性：\n\n```ts\nlet x: { foo: number, [x: string]: any };\n\nx = { foo: 1, baz: 2 }; // ok, 'baz' 属性匹配于索引签名\n```\n\nReact State 中示例：\n\n```ts\n// 假设\ninterface State {\n  foo: string;\n  bar: string;\n}\n\n// 你可能想做：\nthis.setState({ foo: 'Hello' }); // Error: 没有属性 'bar'\n\n// 因为 state 包含 'foo' 与 'bar'，TypeScript 会强制你这么做：\nthis.setState({ foo: 'Hello', bar: this.state.bar });\n```\n\n## 类型保护\n\nts 会推到条件块中的变量类型\n\n```ts\nfunction doSome(x: number | string) {\n  if (typeof x === 'string') {\n    // 在这个块中，TypeScript 知道 `x` 的类型必须是 `string`\n    console.log(x.subtr(1)); // Error: 'subtr' 方法并没有存在于 `string` 上\n    console.log(x.substr(1)); // ok\n  }\n\n  x.substr(1); // Error: 无法保证 `x` 是 `string` 类型\n}\n```\n\nin 操作符可以一个对象上是否存在一个属性，它通常也被作为类型保护使用\n\n```ts\ninterface A {\n  x: number;\n}\n\ninterface B {\n  y: string;\n}\n\nfunction doStuff(q: A | B) {\n  if ('x' in q) {\n    // q: A\n  } else {\n    // q: B\n  }\n}\n```\n\n## 字面量类型\n\n字面量类型本身不使用，在一个联合类型中组合创建一个强大的（实用的）抽象。\n\n字符串字面量：\n\n```ts\nlet foo: 'Hello';\nfoo = 'Bar'; // Error: 'bar' 不能赋值给类型 'Hello'\n```\n\n```ts\ntype CardinalDirection = 'North' | 'East' | 'South' | 'West';\n\nfunction move(distance: number, direction: CardinalDirection) {\n  // ...\n}\n\nmove(1, 'North'); // ok\nmove(1, 'Nurth'); // Error\n```\n\nboolean 和 number 的字面量类型：\n\n```ts\ntype OneToFive = 1 | 2 | 3 | 4 | 5;\ntype Bools = true | false;\n```\n\n## Readonly\n\n```ts\nfunction foo(config: { readonly bar: number, readonly bas: number }) {\n  // ..\n}\n\ntype Foo = {\n  readonly bar: number;\n  readonly bas: number;\n};\n```\n\n这有一个 Readonly 的映射类型，它接收一个泛型 T，用来把它的所有属性标记为只读类型：\n\n```ts\ntype Foo = {\n  bar: number;\n  bas: number;\n};\n\ntype FooReadonly = Readonly<Foo>;\n```\n\n## 泛型2\n\n创建泛型类\n\n```ts\n// 创建一个泛型类\nclass Queue<T> {\n  private data: T[] = [];\n  push = (item: T) => this.data.push(item);\n  pop = (): T | undefined => this.data.shift();\n}\n\n// 简单的使用\nconst queue = new Queue<number>();\nqueue.push(0);\nqueue.push('1'); // Error：不能推入一个 `string`，只有 number 类型被允许\n```\n\n泛型的误用：近在单个参数或一个位置被使用\n\n```ts\ndeclare function foo<T>(arg: T): void;  \n// \ndeclare function foo(arg: any): void;\n```\n\naxios 请求中 泛型的使用：\n\n通常情况下，我们会把后端返回数据格式单独放入一个 interface 里：\n\n```ts\n// 请求接口数据\nexport interface ResponseData<T = any> {\n  /**\n   * 状态码\n   * @type { number }\n   */\n  code: number;\n\n  /**\n   * 数据\n   * @type { T }\n   */\n  result: T;\n\n  /**\n   * 消息\n   * @type { string }\n   */\n  message: string;\n}\n```\n\n```ts\n// 在 axios.ts 文件中对 axios 进行了处理，例如添加通用配置、拦截器等\nimport Ax from './axios';\n\nimport { ResponseData } from './interface.ts';\n\nexport function getUser<T>() {\n  return Ax.get<ResponseData<T>>('/somepath')\n    .then(res => res.data)\n    .catch(err => console.error(err));\n}\n```\n\n写入返回的数据类型 User\n\n```ts\ninterface User {\n  name: string;\n  age: number;\n}\n\nasync function test() {\n  // user 被推断出为\n  // {\n  //  code: number,\n  //  result: { name: string, age: number },\n  //  message: string\n  // }\n  const user = await getUser<User>();\n}\n```\n\n## never 类型\n\n常用在\n\n- 从来不会有返回值的函数（如：如果函数内含有 while(true) {}）\n- 总是会抛出错误的函数 throw new Error\n\nnever 类型仅能被赋值给另外一个 never\n\n```ts\nlet bar: never = (() => {\n  throw new Error('Throw my hands in the air like I just dont care');\n})();\n```\n\nvoid 和 never 的区别：\n\n- void 表示没有任何类型，never 表示永远不存在的值的类型。\n- 当一个函数返回空值时，它的返回值为 void 类型，但是，当一个函数永不返回时（或者总是抛出错误），它的返回值为 never 类型。\n- void 类型可以被赋值，但是除了 never 本身以外，其他任何类型不能赋值给 never。\n\n## redux 中的联合类型\n\n```ts\nimport { createStore } from 'redux';\n\ntype Action =\n  | {\n      type: 'INCREMENT';\n    }\n  | {\n      type: 'DECREMENT';\n    };\n\n//reducer\nfunction counter(state = 0, action: Action) {\n  switch (action.type) {\n    case 'INCREMENT':\n      return state + 1;\n    case 'DECREMENT':\n      return state - 1;\n    default:\n      return state;\n  }\n}\n```\n\n## 索引签名\n\n声明一个索引签名时，所有明确的成员都必须符合索引签名：\n\n```ts\ninterface Bar {\n  [key: string]: number;\n  x: number;\n  y: string; // Error: y 属性必须为 number 类型\n}\n```\n\n映射类型来使索引字符串为联合类型中的一员\n\n```ts\ntype Index = 'a' | 'b' | 'c';\ntype FromIndex = { [k in Index]?: number };\n\nconst bad: FromIndex = { b: 1, c: 2, d: 3 }; //err\n```\n\n```ts\ntype FromSomeIndex<K extends string> = { [key in K]: number };\n```\n\n## 索引签名中排除某些属性\n\n用交叉类型解决\n\n```ts\ntype FieldState = {\n  value: string;\n};\n\ntype FromState = {\n  isValid: boolean; // Error: 不符合索引签名\n  [filedName: string]: FieldState;\n};\n```\n\n交叉类型：\n\n```ts\ntype FieldState = {\n  value: string;\n};\n\ntype FormState = { isValid: boolean } & { [fieldName: string]: FieldState };\n```\n\n## 流动的类型\n\n捕获变量的类型\n\n```ts\nlet foo = 123;\nlet bar: typeof foo; // 'bar' 类型与 'foo' 类型相同（在这里是： 'number'）\n```\n\n捕获类成员类型 需要声明一个变量\n\n```ts\nclass Foo {\n  foo: number; // 我们想要捕获的类型\n}\n\ndeclare let _foo: Foo;\n\n// 与之前做法相同\nlet bar: typeof _foo.foo;\n```\n\n捕获键的名称\n\n```ts\nconst colors = {\n  red: 'red',\n  blue: 'blue'\n};\n\ntype Colors = keyof typeof colors;\n\nlet color: Colors; // color 的类型是 'red' | 'blue'\ncolor = 'red'; // ok\ncolor = 'blue'; // ok\ncolor = 'anythingElse'; // Error\n```\n\n## JSX 的支持\n\n函数组件\n\n```ts\ntype Props = {\n  foo: string;\n};\n\nconst MyComponent: React.FunctionComponent<Props> = props => {\n  return <span>{props.foo}</span>;\n};\n\n<MyComponent foo=\"bar\" />;\n```\n\n类组件\n\n```ts\ntype Props = {\n  foo: string;\n};\n\nclass MyComponent extends React.Component<Props, {}> {\n  render() {\n    return <span>{this.props.foo}</span>;\n  }\n}\n\n<MyComponent foo=\"bar\" />;\n```\n\n泛型组件\n\n```ts\n// 一个泛型组件\ntype SelectProps<T> = { items: T[] };\nclass Select<T> extends React.Component<SelectProps<T>, any> {}\n\n// 使用\nconst Form = () => <Select<string> items={['a', 'b']} />;\n```\n\n泛型函数\n\n```ts\nfunction foo<T>(x: T): T {\n  return x;\n}\n\n// 不能使用箭头函数\nconst foo = <T>(x: T) => T; // Error: T 标签没有关闭\n\n解决办法：用 extends 提示编译器这是泛型\nconst foo = <T extends {}>(x: T) => x;\n```\n\nRefs\n\n一个变量时，使用 ref 和 null 的联合类型\n\n```ts\nclass Use {\n  exampleRef: Example | null = null;\n\n  render() {\n    return <Example ref={exampleRef => (this.exampleRef = exampleRef)} />;\n  }\n}\n```\n\n## 参考\n\n- [深入理解 TypeScript](https://jkchao.github.io/typescript-book-chinese/)\n- [https://www.tslang.cn/docs/handbook/generics.html](https://www.tslang.cn/docs/handbook/generics.html)\n","slug":"9-TypeScript-笔记","published":1,"updated":"2022-08-23T02:19:23.474Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn4l002wyu3l4lhb1e7f","content":"<h2 id=\"声明空间\"><a href=\"#声明空间\" class=\"headerlink\" title=\"声明空间\"></a>声明空间</h2><p>ts 中有两种：类型声明空间与变量声明空间</p>\n<p>类型声明空间：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Foo</span> </span>&#123;&#125;\n<span class=\"hljs-keyword\">interface</span> Bar &#123;&#125;\n<span class=\"hljs-keyword\">type</span> Bas = &#123;&#125;;</code></pre></div>\n\n<p>如下当做类型注解使用</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> foo: Foo;\n<span class=\"hljs-keyword\">let</span> bar: Bar;\n<span class=\"hljs-keyword\">let</span> bas: Bas;</code></pre></div>\n\n<p>定义 interface Bar {} 不能当做变量来用，因为它没有定义在变量声明空间中。</p>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><p>如下方式定义在 <strong>全局模块</strong> 中</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-number\">123</span>;</code></pre></div>\n\n<p>如下方式文件的根级别位置含有 import 或者 export,在文件中创建本地作用域，是定义在 <strong>文件模块</strong> 中</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-number\">123</span>;</code></pre></div>\n\n<h2 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h2><p>命名空间一个最明确的目的就是解决重名问题。</p>\n<p>命名空间是位于全局命名空间下的一个普通的带有名字的 JavaScript 对象。作用是将一系列相关的全局变量组织到一个对象的属性。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">namespace</span> Letter &#123; \n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">1</span>; \n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-number\">2</span>; \n&#125;</code></pre></div>\n\n<p>编译成 js 如下：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">var</span> Letter; \n(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">Letter</span>) </span>&#123; \n    Letter.a = <span class=\"hljs-number\">1</span>; \n    Letter.b = <span class=\"hljs-number\">2</span>; \n&#125;)(Letter || (Letter = &#123;&#125;));</code></pre></div>\n\n<h2 id=\"动态导入表达式-import\"><a href=\"#动态导入表达式-import\" class=\"headerlink\" title=\"动态导入表达式 import()\"></a>动态导入表达式 import()</h2><p>import() 异步加载一个模块, 该语句用于 Webpack Code Splitting。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span>(<span class=\"hljs-comment\">/* webpackChunkName: &quot;momentjs&quot; */</span> <span class=\"hljs-string\">&#x27;moment&#x27;</span>)\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">moment</span> =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> time = moment().format();\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;TypeScript &gt;= 2.4.0 Dynamic Import Expression:&#x27;</span>);\n    <span class=\"hljs-built_in\">console</span>.log(time);\n  &#125;)\n  .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;Failed to load moment&#x27;</span>, err);\n  &#125;);</code></pre></div>\n\n<h2 id=\"TS-类型系统\"><a href=\"#TS-类型系统\" class=\"headerlink\" title=\"TS 类型系统\"></a>TS 类型系统</h2><p>原始类型 string、number、boolean 可以被用作类型注解。</p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>两种方式定义数组：</p>\n<p>1、元素类型后加 []</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> list: <span class=\"hljs-built_in\">number</span>[] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];</code></pre></div>\n\n<p>2、 数组泛型 Array&lt;元素类型&gt;</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> list: <span class=\"hljs-built_in\">Array</span>&lt;number&gt; = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];</code></pre></div>\n\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>合并众多类型声明至一个类型声明</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> Name &#123;\n  <span class=\"hljs-attr\">first</span>: <span class=\"hljs-built_in\">string</span>;\n  second: <span class=\"hljs-built_in\">string</span>;\n&#125;\n\n<span class=\"hljs-keyword\">let</span> name: Name = &#123;\n  <span class=\"hljs-attr\">first</span>: <span class=\"hljs-string\">&#x27;John&#x27;</span>,\n  <span class=\"hljs-attr\">second</span>: <span class=\"hljs-string\">&#x27;Doe&#x27;</span>\n&#125;;</code></pre></div>\n\n<h2 id=\"内联类型注解\"><a href=\"#内联类型注解\" class=\"headerlink\" title=\"内联类型注解\"></a>内联类型注解</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> name: &#123;\n  <span class=\"hljs-attr\">first</span>: <span class=\"hljs-built_in\">string</span>;\n  second: <span class=\"hljs-built_in\">string</span>;\n&#125;;\n\nname = &#123;\n  <span class=\"hljs-attr\">first</span>: <span class=\"hljs-string\">&#x27;John&#x27;</span>,\n  <span class=\"hljs-attr\">second</span>: <span class=\"hljs-string\">&#x27;Doe&#x27;</span>\n&#125;;</code></pre></div>\n\n<p>内联类型注解可以省去为类型起名的麻烦。</p>\n<p>如果你发现需要多次使用相同的内联注解时，那么考虑把它重构为一个接口（或者是 type alias)</p>\n<h2 id=\"特殊类型\"><a href=\"#特殊类型\" class=\"headerlink\" title=\"特殊类型\"></a>特殊类型</h2><p>any、 null、 undefined 以及 void</p>\n<p>:void 来表示一个函数没有一个返回值</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">log</span>(<span class=\"hljs-params\">message: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">void</span> </span>&#123;\n  <span class=\"hljs-built_in\">console</span>.log(message);\n&#125;</code></pre></div>\n\n<h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><p>在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reverse</span>&lt;<span class=\"hljs-title\">T</span>&gt;(<span class=\"hljs-params\">items: T[]</span>): <span class=\"hljs-title\">T</span>[] </span>&#123;\n  <span class=\"hljs-keyword\">const</span> toreturn = [];\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = items.length - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) &#123;\n    toreturn.push(items[i]);\n  &#125;\n  <span class=\"hljs-keyword\">return</span> toreturn;\n&#125;</code></pre></div>\n\n<h2 id=\"联合类型\"><a href=\"#联合类型\" class=\"headerlink\" title=\"联合类型\"></a>联合类型</h2><p>多种类型之一</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">formatCommandline</span>(<span class=\"hljs-params\">command: <span class=\"hljs-built_in\">string</span>[] | <span class=\"hljs-built_in\">string</span></span>) </span>&#123;\n  <span class=\"hljs-keyword\">let</span> line = <span class=\"hljs-string\">&#x27;&#x27;</span>;\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> command === <span class=\"hljs-string\">&#x27;string&#x27;</span>) &#123;\n    line = command.trim();\n  &#125; <span class=\"hljs-keyword\">else</span> &#123;\n    line = command.join(<span class=\"hljs-string\">&#x27; &#x27;</span>).trim();\n  &#125;\n\n  <span class=\"hljs-comment\">// Do stuff with line: string</span>\n&#125;</code></pre></div>\n\n<h2 id=\"交叉类型\"><a href=\"#交叉类型\" class=\"headerlink\" title=\"交叉类型\"></a>交叉类型</h2><p>extend 是一种非常常见的模式，从两个对象中创建一个新对象，新对象拥有着两个对象所有的功能。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">extend</span>&lt;<span class=\"hljs-title\">T</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">object</span>, <span class=\"hljs-title\">U</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">object</span>&gt;(<span class=\"hljs-params\">first: T, second: U</span>): <span class=\"hljs-title\">T</span> &amp; <span class=\"hljs-title\">U</span> </span>&#123;\n  <span class=\"hljs-keyword\">const</span> result = &lt;T &amp; U&gt;&#123;&#125;;\n  for (let id in first) &#123;\n    (&lt;T&gt;result)[id] = first[id];\n  &#125;\n  for (let id in second) &#123;\n    if (!result.hasOwnProperty(id)) &#123;\n      (&lt;U&gt;result)[id] = second[id];\n    &#125;\n  &#125;\n\n  return result;\n&#125;\n\nconst x = extend(&#123; a: &#x27;hello&#x27; &#125;, &#123; b: 42 &#125;);\n\n// 现在 x 拥有了 a 属性与 b 属性\nconst a = x.a;\nconst b = x.b;</code></pre></div>\n\n<h2 id=\"元祖类型-Tuple\"><a href=\"#元祖类型-Tuple\" class=\"headerlink\" title=\"元祖类型 Tuple\"></a>元祖类型 Tuple</h2><p>固定长度的，元素数据类型不同的数组。数据不可变。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\">type FixedArray = [string, number, string];\n\n<span class=\"hljs-keyword\">const</span> mixedArray: FixedArray = [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>];</code></pre></div>\n\n<h2 id=\"类型别名\"><a href=\"#类型别名\" class=\"headerlink\" title=\"类型别名\"></a>类型别名</h2><p>以为任意的类型注解提供类型别名,在联合类型和交叉类型中比较实用。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> StrOrNum = <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>;\n\n<span class=\"hljs-comment\">// 使用</span>\n<span class=\"hljs-keyword\">let</span> sample: StrOrNum;\nsample = <span class=\"hljs-number\">123</span>;\nsample = <span class=\"hljs-string\">&#x27;123&#x27;</span>;\n\n<span class=\"hljs-comment\">// 会检查类型</span>\nsample = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// Error</span></code></pre></div>\n\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> Text = <span class=\"hljs-built_in\">string</span> | &#123; <span class=\"hljs-attr\">text</span>: <span class=\"hljs-built_in\">string</span> &#125;;\n<span class=\"hljs-keyword\">type</span> Coordinates = [<span class=\"hljs-built_in\">number</span>, <span class=\"hljs-built_in\">number</span>];\n<span class=\"hljs-keyword\">type</span> Callback = <span class=\"hljs-function\">(<span class=\"hljs-params\">data: <span class=\"hljs-built_in\">string</span></span>) =&gt;</span> <span class=\"hljs-built_in\">void</span>;</code></pre></div>\n\n<h2 id=\"types\"><a href=\"#types\" class=\"headerlink\" title=\"@types\"></a>@types</h2><p>通过 npm 来安装使用 @types,如 <code>npm install @types/jquery --save-dev</code></p>\n<h2 id=\"declare-声明文件\"><a href=\"#declare-声明文件\" class=\"headerlink\" title=\"declare 声明文件\"></a>declare 声明文件</h2><p>.d.ts文件是ts用来声明变量，模块，type，interface等等的。</p>\n<p>在这种后缀的ts文件声明这些东西和在纯ts文件声明这些东西又什么区别呢？</p>\n<p>在.d.ts声明变量或者模块等东西之后，在其他地方可以不用import导入这些东西就可以直接用，用，而且有语法提示。</p>\n<p>declare声明一个类型:</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">type</span> Asd &#123;\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;</code></pre></div>\n\n<p>在tsconfig.json文件里面的include数组里面添加这个文件, 在include包含的文件范围内可以直接使用Asd这个type。</p>\n<p>declare声明一个模块:</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-built_in\">module</span> <span class=\"hljs-string\">&#x27;*.css&#x27;</span>;\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-built_in\">module</span> <span class=\"hljs-string\">&#x27;*.less&#x27;</span>;\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-built_in\">module</span> <span class=\"hljs-string\">&#x27;*.png&#x27;</span>;</code></pre></div>\n\n<p>编译ts文件的时候，导入一个.css/.less/.png格式的文件，如果没有经过declare的话是会提示语法错误的</p>\n<p>declare声明一个变量:</p>\n<p>在项目中引入了一个sdk，这个sdk（我们以微信的sdk为例）里面有一些全局的对象（比如wx），但是如果不经过任何的声明，在ts文件里面直接用wx.config()的话，肯定会报错。</p>\n<p>declare声明一个作用域:</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">namespace</span> API &#123;\n    <span class=\"hljs-keyword\">interface</span> ResponseList &#123;&#125;\n&#125;</code></pre></div>\n\n<p>声明完之后在其他地方的ts就可以直接API.ResponseList引用到这个接口类型</p>\n<h2 id=\"接口-1\"><a href=\"#接口-1\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>两种声明方式：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 内联注解</span>\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">const</span> myPoint: &#123; <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">number</span>; y: <span class=\"hljs-built_in\">number</span> &#125;;\n\n<span class=\"hljs-comment\">// 接口形式</span>\n<span class=\"hljs-keyword\">interface</span> Point &#123;\n  <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">number</span>;\n  y: <span class=\"hljs-built_in\">number</span>;\n&#125;\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">const</span> myPoint: Point;</code></pre></div>\n\n<p>接口形式的好处在于，如果有人创建了一个基于 myPoint 的库来添加新成员, 可以轻松将此成员添加到 myPoint 的现有声明中</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// Lib a.d.ts</span>\n<span class=\"hljs-keyword\">interface</span> Point &#123;\n  <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">number</span>,\n  <span class=\"hljs-attr\">y</span>: <span class=\"hljs-built_in\">number</span>\n&#125;\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">const</span> myPoint: Point\n\n<span class=\"hljs-comment\">// Lib b.d.ts</span>\n<span class=\"hljs-keyword\">interface</span> Point &#123;\n  <span class=\"hljs-attr\">z</span>: <span class=\"hljs-built_in\">number</span>\n&#125;\n\n<span class=\"hljs-comment\">// Your code</span>\nmyPoint.z <span class=\"hljs-comment\">// Allowed!</span></code></pre></div>\n\n<h2 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h2><p>函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 |操作符或者?操作符，把所有可能的输入类型全部包含进去，以具体实现。</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 上边是声明</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">string</span>, arg2: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">string</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">number</span>, arg2: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\">// 因为我们在下边有具体函数的实现，所以这里并不需要添加 <span class=\"hljs-title\">declare</span> 关键字</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\">// 下边是实现</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>, arg2: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span></span>) </span>&#123;</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\">  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 <span class=\"hljs-title\">arg1</span> + <span class=\"hljs-title\">arg2</span></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\">  <span class=\"hljs-title\">if</span> (<span class=\"hljs-params\"><span class=\"hljs-keyword\">typeof</span> arg1 === <span class=\"hljs-string\">&#x27;string&#x27;</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> arg2 === <span class=\"hljs-string\">&#x27;string&#x27;</span></span>) </span>&#123;</span>\n<span class=\"hljs-function\">    <span class=\"hljs-title\">return</span> <span class=\"hljs-title\">arg1</span> + <span class=\"hljs-title\">arg2</span></span>\n<span class=\"hljs-function\">  &#125; <span class=\"hljs-title\">else</span> <span class=\"hljs-title\">if</span> (<span class=\"hljs-params\"><span class=\"hljs-keyword\">typeof</span> arg1 === <span class=\"hljs-string\">&#x27;number&#x27;</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> arg2 === <span class=\"hljs-string\">&#x27;number&#x27;</span></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> arg1 + arg2\n  &#125;\n&#125;</code></pre></div>\n\n<p>函数重载的意义在于能够让你知道传入不同的参数得到不同的结果，如果传入的参数不同，但是得到的结果（类型）却相同，那么不要使用函数重载（没有意义）。 如果函数的返回值类型相同，那么也不需要使用函数重载</p>\n<p>以下场景可以不需要重载：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span> (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span> (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, b: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\">// 像这样的是参数个数的区别，我们可以使用可选参数来代替函数重载的定义</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span> (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, b?: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span></span></span></code></pre></div>\n\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 亦或是一些参数类型的区别导致的</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span> (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span> (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">number</span></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\">// 这时我们应该使用联合类型来代替函数重载</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span> (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">number</span></span></span></span></code></pre></div>\n\n<h2 id=\"函数声明\"><a href=\"#函数声明\" class=\"headerlink\" title=\"函数声明\"></a>函数声明</h2><p>在没有提供函数实现的情况下，有两种声明函数类型的方式:</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> LongHand = &#123;\n  (a: <span class=\"hljs-built_in\">number</span>): <span class=\"hljs-built_in\">number</span>;\n&#125;; <span class=\"hljs-comment\">//当你想使用函数重载时, 只能用此方式</span>\n\n<span class=\"hljs-keyword\">type</span> ShortHand = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> <span class=\"hljs-built_in\">number</span>;</code></pre></div>\n\n<h2 id=\"可调用的类型注解\"><a href=\"#可调用的类型注解\" class=\"headerlink\" title=\"可调用的类型注解\"></a>可调用的类型注解</h2><p>使用类型别名或者接口来表示一个可被调用的类型注解：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> ReturnString &#123;\n  (): <span class=\"hljs-built_in\">string</span>;\n&#125;\n<span class=\"hljs-comment\">// 表示一个返回值为 string 的函数：</span></code></pre></div>\n\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">const</span> foo: ReturnString;\n\n<span class=\"hljs-keyword\">const</span> bar = foo(); <span class=\"hljs-comment\">// bar 被推断为一个字符串。</span></code></pre></div>\n\n<h2 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h2><p>ts 允许你覆盖它的推断，并且能以你任何你想要的方式分析它</p>\n<p>js 迁移到 ts 时常见：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> foo = &#123;&#125;;\nfoo.bar = <span class=\"hljs-number\">123</span>; <span class=\"hljs-comment\">// Error: &#x27;bar&#x27; 属性不存在于 ‘&#123;&#125;’</span>\nfoo.bas = <span class=\"hljs-string\">&#x27;hello&#x27;</span>; <span class=\"hljs-comment\">// Error: &#x27;bas&#x27; 属性不存在于 &#x27;&#123;&#125;&#x27;</span></code></pre></div>\n\n<p>foo 类型推断为 {}，不存在属性。通过类型断言来避免该问题</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> Foo &#123;\n  <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-built_in\">number</span>;\n  bas: <span class=\"hljs-built_in\">string</span>;\n&#125;\n\n<span class=\"hljs-keyword\">const</span> foo = &#123;&#125; <span class=\"hljs-keyword\">as</span> Foo;\nfoo.bar = <span class=\"hljs-number\">123</span>;\nfoo.bas = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;</code></pre></div>\n\n<h2 id=\"允许额外的属性\"><a href=\"#允许额外的属性\" class=\"headerlink\" title=\"允许额外的属性\"></a>允许额外的属性</h2><p>包含索引签名，以明确表明可以使用额外的属性：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> x: &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-built_in\">number</span>, [x: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">any</span> &#125;;\n\nx = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-number\">2</span> &#125;; <span class=\"hljs-comment\">// ok, &#x27;baz&#x27; 属性匹配于索引签名</span></code></pre></div>\n\n<p>React State 中示例：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 假设</span>\n<span class=\"hljs-keyword\">interface</span> State &#123;\n  <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-built_in\">string</span>;\n  bar: <span class=\"hljs-built_in\">string</span>;\n&#125;\n\n<span class=\"hljs-comment\">// 你可能想做：</span>\n<span class=\"hljs-built_in\">this</span>.setState(&#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;Hello&#x27;</span> &#125;); <span class=\"hljs-comment\">// Error: 没有属性 &#x27;bar&#x27;</span>\n\n<span class=\"hljs-comment\">// 因为 state 包含 &#x27;foo&#x27; 与 &#x27;bar&#x27;，TypeScript 会强制你这么做：</span>\n<span class=\"hljs-built_in\">this</span>.setState(&#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;Hello&#x27;</span>, <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-built_in\">this</span>.state.bar &#125;);</code></pre></div>\n\n<h2 id=\"类型保护\"><a href=\"#类型保护\" class=\"headerlink\" title=\"类型保护\"></a>类型保护</h2><p>ts 会推到条件块中的变量类型</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">doSome</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span></span>) </span>&#123;\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> x === <span class=\"hljs-string\">&#x27;string&#x27;</span>) &#123;\n    <span class=\"hljs-comment\">// 在这个块中，TypeScript 知道 `x` 的类型必须是 `string`</span>\n    <span class=\"hljs-built_in\">console</span>.log(x.subtr(<span class=\"hljs-number\">1</span>)); <span class=\"hljs-comment\">// Error: &#x27;subtr&#x27; 方法并没有存在于 `string` 上</span>\n    <span class=\"hljs-built_in\">console</span>.log(x.substr(<span class=\"hljs-number\">1</span>)); <span class=\"hljs-comment\">// ok</span>\n  &#125;\n\n  x.substr(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// Error: 无法保证 `x` 是 `string` 类型</span>\n&#125;</code></pre></div>\n\n<p>in 操作符可以一个对象上是否存在一个属性，它通常也被作为类型保护使用</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> A &#123;\n  <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">number</span>;\n&#125;\n\n<span class=\"hljs-keyword\">interface</span> B &#123;\n  <span class=\"hljs-attr\">y</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">doStuff</span>(<span class=\"hljs-params\">q: A | B</span>) </span>&#123;\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">&#x27;x&#x27;</span> <span class=\"hljs-keyword\">in</span> q) &#123;\n    <span class=\"hljs-comment\">// q: A</span>\n  &#125; <span class=\"hljs-keyword\">else</span> &#123;\n    <span class=\"hljs-comment\">// q: B</span>\n  &#125;\n&#125;</code></pre></div>\n\n<h2 id=\"字面量类型\"><a href=\"#字面量类型\" class=\"headerlink\" title=\"字面量类型\"></a>字面量类型</h2><p>字面量类型本身不使用，在一个联合类型中组合创建一个强大的（实用的）抽象。</p>\n<p>字符串字面量：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> foo: <span class=\"hljs-string\">&#x27;Hello&#x27;</span>;\nfoo = <span class=\"hljs-string\">&#x27;Bar&#x27;</span>; <span class=\"hljs-comment\">// Error: &#x27;bar&#x27; 不能赋值给类型 &#x27;Hello&#x27;</span></code></pre></div>\n\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> CardinalDirection = <span class=\"hljs-string\">&#x27;North&#x27;</span> | <span class=\"hljs-string\">&#x27;East&#x27;</span> | <span class=\"hljs-string\">&#x27;South&#x27;</span> | <span class=\"hljs-string\">&#x27;West&#x27;</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">move</span>(<span class=\"hljs-params\">distance: <span class=\"hljs-built_in\">number</span>, direction: CardinalDirection</span>) </span>&#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n\nmove(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;North&#x27;</span>); <span class=\"hljs-comment\">// ok</span>\nmove(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;Nurth&#x27;</span>); <span class=\"hljs-comment\">// Error</span></code></pre></div>\n\n<p>boolean 和 number 的字面量类型：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> OneToFive = <span class=\"hljs-number\">1</span> | <span class=\"hljs-number\">2</span> | <span class=\"hljs-number\">3</span> | <span class=\"hljs-number\">4</span> | <span class=\"hljs-number\">5</span>;\n<span class=\"hljs-keyword\">type</span> Bools = <span class=\"hljs-literal\">true</span> | <span class=\"hljs-literal\">false</span>;</code></pre></div>\n\n<h2 id=\"Readonly\"><a href=\"#Readonly\" class=\"headerlink\" title=\"Readonly\"></a>Readonly</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">config: &#123; <span class=\"hljs-keyword\">readonly</span> bar: <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-keyword\">readonly</span> bas: <span class=\"hljs-built_in\">number</span> &#125;</span>) </span>&#123;\n  <span class=\"hljs-comment\">// ..</span>\n&#125;\n\n<span class=\"hljs-keyword\">type</span> Foo = &#123;\n  <span class=\"hljs-keyword\">readonly</span> bar: <span class=\"hljs-built_in\">number</span>;\n  <span class=\"hljs-keyword\">readonly</span> bas: <span class=\"hljs-built_in\">number</span>;\n&#125;;</code></pre></div>\n\n<p>这有一个 Readonly 的映射类型，它接收一个泛型 T，用来把它的所有属性标记为只读类型：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> Foo = &#123;\n  <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-built_in\">number</span>;\n  bas: <span class=\"hljs-built_in\">number</span>;\n&#125;;\n\n<span class=\"hljs-keyword\">type</span> FooReadonly = Readonly&lt;Foo&gt;;</code></pre></div>\n\n<h2 id=\"泛型2\"><a href=\"#泛型2\" class=\"headerlink\" title=\"泛型2\"></a>泛型2</h2><p>创建泛型类</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 创建一个泛型类</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Queue</span>&lt;<span class=\"hljs-title\">T</span>&gt; </span>&#123;\n  <span class=\"hljs-keyword\">private</span> data: T[] = [];\n  push = <span class=\"hljs-function\">(<span class=\"hljs-params\">item: T</span>) =&gt;</span> <span class=\"hljs-built_in\">this</span>.data.push(item);\n  pop = (): T | <span class=\"hljs-function\"><span class=\"hljs-params\">undefined</span> =&gt;</span> <span class=\"hljs-built_in\">this</span>.data.shift();\n&#125;\n\n<span class=\"hljs-comment\">// 简单的使用</span>\n<span class=\"hljs-keyword\">const</span> queue = <span class=\"hljs-keyword\">new</span> Queue&lt;<span class=\"hljs-built_in\">number</span>&gt;();\nqueue.push(<span class=\"hljs-number\">0</span>);\nqueue.push(<span class=\"hljs-string\">&#x27;1&#x27;</span>); <span class=\"hljs-comment\">// Error：不能推入一个 `string`，只有 number 类型被允许</span></code></pre></div>\n\n<p>泛型的误用：近在单个参数或一个位置被使用</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>&lt;<span class=\"hljs-title\">T</span>&gt;(<span class=\"hljs-params\">arg: T</span>): <span class=\"hljs-title\">void</span></span>;  \n<span class=\"hljs-comment\">// </span>\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">arg: <span class=\"hljs-built_in\">any</span></span>): <span class=\"hljs-title\">void</span></span>;</code></pre></div>\n\n<p>axios 请求中 泛型的使用：</p>\n<p>通常情况下，我们会把后端返回数据格式单独放入一个 interface 里：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 请求接口数据</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> ResponseData&lt;T = any&gt; &#123;\n  <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">   * 状态码</span>\n<span class=\"hljs-comment\">   * <span class=\"hljs-doctag\">@type <span class=\"hljs-type\">&#123; number &#125;</span></span></span>\n<span class=\"hljs-comment\">   */</span>\n  <span class=\"hljs-attr\">code</span>: <span class=\"hljs-built_in\">number</span>;\n\n  <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">   * 数据</span>\n<span class=\"hljs-comment\">   * <span class=\"hljs-doctag\">@type <span class=\"hljs-type\">&#123; T &#125;</span></span></span>\n<span class=\"hljs-comment\">   */</span>\n  result: T;\n\n  <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">   * 消息</span>\n<span class=\"hljs-comment\">   * <span class=\"hljs-doctag\">@type <span class=\"hljs-type\">&#123; string &#125;</span></span></span>\n<span class=\"hljs-comment\">   */</span>\n  message: <span class=\"hljs-built_in\">string</span>;\n&#125;</code></pre></div>\n\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 在 axios.ts 文件中对 axios 进行了处理，例如添加通用配置、拦截器等</span>\n<span class=\"hljs-keyword\">import</span> Ax <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./axios&#x27;</span>;\n\n<span class=\"hljs-keyword\">import</span> &#123; ResponseData &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./interface.ts&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getUser</span>&lt;<span class=\"hljs-title\">T</span>&gt;(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> Ax.get&lt;ResponseData&lt;T&gt;&gt;(<span class=\"hljs-string\">&#x27;/somepath&#x27;</span>)\n    .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> res.data)\n    .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.error(err));\n&#125;</code></pre></div>\n\n<p>写入返回的数据类型 User</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> User &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n  age: <span class=\"hljs-built_in\">number</span>;\n&#125;\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// user 被推断出为</span>\n  <span class=\"hljs-comment\">// &#123;</span>\n  <span class=\"hljs-comment\">//  code: number,</span>\n  <span class=\"hljs-comment\">//  result: &#123; name: string, age: number &#125;,</span>\n  <span class=\"hljs-comment\">//  message: string</span>\n  <span class=\"hljs-comment\">// &#125;</span>\n  <span class=\"hljs-keyword\">const</span> user = <span class=\"hljs-keyword\">await</span> getUser&lt;User&gt;();\n&#125;</code></pre></div>\n\n<h2 id=\"never-类型\"><a href=\"#never-类型\" class=\"headerlink\" title=\"never 类型\"></a>never 类型</h2><p>常用在</p>\n<ul>\n<li>从来不会有返回值的函数（如：如果函数内含有 while(true) {}）</li>\n<li>总是会抛出错误的函数 throw new Error</li>\n</ul>\n<p>never 类型仅能被赋值给另外一个 never</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> bar: <span class=\"hljs-built_in\">never</span> = (<span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;Throw my hands in the air like I just dont care&#x27;</span>);\n&#125;)();</code></pre></div>\n\n<p>void 和 never 的区别：</p>\n<ul>\n<li>void 表示没有任何类型，never 表示永远不存在的值的类型。</li>\n<li>当一个函数返回空值时，它的返回值为 void 类型，但是，当一个函数永不返回时（或者总是抛出错误），它的返回值为 never 类型。</li>\n<li>void 类型可以被赋值，但是除了 never 本身以外，其他任何类型不能赋值给 never。</li>\n</ul>\n<h2 id=\"redux-中的联合类型\"><a href=\"#redux-中的联合类型\" class=\"headerlink\" title=\"redux 中的联合类型\"></a>redux 中的联合类型</h2><div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> &#123; createStore &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;redux&#x27;</span>;\n\n<span class=\"hljs-keyword\">type</span> Action =\n  | &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;INCREMENT&#x27;</span>;\n    &#125;\n  | &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;DECREMENT&#x27;</span>;\n    &#125;;\n\n<span class=\"hljs-comment\">//reducer</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">counter</span>(<span class=\"hljs-params\">state = <span class=\"hljs-number\">0</span>, action: Action</span>) </span>&#123;\n  <span class=\"hljs-keyword\">switch</span> (action.type) &#123;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;INCREMENT&#x27;</span>:\n      <span class=\"hljs-keyword\">return</span> state + <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;DECREMENT&#x27;</span>:\n      <span class=\"hljs-keyword\">return</span> state - <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">default</span>:\n      <span class=\"hljs-keyword\">return</span> state;\n  &#125;\n&#125;</code></pre></div>\n\n<h2 id=\"索引签名\"><a href=\"#索引签名\" class=\"headerlink\" title=\"索引签名\"></a>索引签名</h2><p>声明一个索引签名时，所有明确的成员都必须符合索引签名：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> Bar &#123;\n  [key: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">number</span>;\n  x: <span class=\"hljs-built_in\">number</span>;\n  y: <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-comment\">// Error: y 属性必须为 number 类型</span>\n&#125;</code></pre></div>\n\n<p>映射类型来使索引字符串为联合类型中的一员</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> Index = <span class=\"hljs-string\">&#x27;a&#x27;</span> | <span class=\"hljs-string\">&#x27;b&#x27;</span> | <span class=\"hljs-string\">&#x27;c&#x27;</span>;\n<span class=\"hljs-keyword\">type</span> FromIndex = &#123; [k <span class=\"hljs-keyword\">in</span> Index]?: <span class=\"hljs-built_in\">number</span> &#125;;\n\n<span class=\"hljs-keyword\">const</span> bad: FromIndex = &#123; <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">d</span>: <span class=\"hljs-number\">3</span> &#125;; <span class=\"hljs-comment\">//err</span></code></pre></div>\n\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> FromSomeIndex&lt;K <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">string</span>&gt; = &#123; [key <span class=\"hljs-keyword\">in</span> K]: <span class=\"hljs-built_in\">number</span> &#125;;</code></pre></div>\n\n<h2 id=\"索引签名中排除某些属性\"><a href=\"#索引签名中排除某些属性\" class=\"headerlink\" title=\"索引签名中排除某些属性\"></a>索引签名中排除某些属性</h2><p>用交叉类型解决</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> FieldState = &#123;\n  <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;;\n\n<span class=\"hljs-keyword\">type</span> FromState = &#123;\n  <span class=\"hljs-attr\">isValid</span>: <span class=\"hljs-built_in\">boolean</span>; <span class=\"hljs-comment\">// Error: 不符合索引签名</span>\n  [filedName: <span class=\"hljs-built_in\">string</span>]: FieldState;\n&#125;;</code></pre></div>\n\n<p>交叉类型：</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> FieldState = &#123;\n  <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;;\n\n<span class=\"hljs-keyword\">type</span> FormState = &#123; <span class=\"hljs-attr\">isValid</span>: <span class=\"hljs-built_in\">boolean</span> &#125; &amp; &#123; [fieldName: <span class=\"hljs-built_in\">string</span>]: FieldState &#125;;</code></pre></div>\n\n<h2 id=\"流动的类型\"><a href=\"#流动的类型\" class=\"headerlink\" title=\"流动的类型\"></a>流动的类型</h2><p>捕获变量的类型</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-number\">123</span>;\n<span class=\"hljs-keyword\">let</span> bar: <span class=\"hljs-keyword\">typeof</span> foo; <span class=\"hljs-comment\">// &#x27;bar&#x27; 类型与 &#x27;foo&#x27; 类型相同（在这里是： &#x27;number&#x27;）</span></code></pre></div>\n\n<p>捕获类成员类型 需要声明一个变量</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Foo</span> </span>&#123;\n  <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-built_in\">number</span>; <span class=\"hljs-comment\">// 我们想要捕获的类型</span>\n&#125;\n\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">let</span> _foo: Foo;\n\n<span class=\"hljs-comment\">// 与之前做法相同</span>\n<span class=\"hljs-keyword\">let</span> bar: <span class=\"hljs-keyword\">typeof</span> _foo.foo;</code></pre></div>\n\n<p>捕获键的名称</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> colors = &#123;\n  <span class=\"hljs-attr\">red</span>: <span class=\"hljs-string\">&#x27;red&#x27;</span>,\n  <span class=\"hljs-attr\">blue</span>: <span class=\"hljs-string\">&#x27;blue&#x27;</span>\n&#125;;\n\n<span class=\"hljs-keyword\">type</span> Colors = keyof <span class=\"hljs-keyword\">typeof</span> colors;\n\n<span class=\"hljs-keyword\">let</span> color: Colors; <span class=\"hljs-comment\">// color 的类型是 &#x27;red&#x27; | &#x27;blue&#x27;</span>\ncolor = <span class=\"hljs-string\">&#x27;red&#x27;</span>; <span class=\"hljs-comment\">// ok</span>\ncolor = <span class=\"hljs-string\">&#x27;blue&#x27;</span>; <span class=\"hljs-comment\">// ok</span>\ncolor = <span class=\"hljs-string\">&#x27;anythingElse&#x27;</span>; <span class=\"hljs-comment\">// Error</span></code></pre></div>\n\n<h2 id=\"JSX-的支持\"><a href=\"#JSX-的支持\" class=\"headerlink\" title=\"JSX 的支持\"></a>JSX 的支持</h2><p>函数组件</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> Props = &#123;\n  <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;;\n\n<span class=\"hljs-keyword\">const</span> MyComponent: React.FunctionComponent&lt;Props&gt; = <span class=\"hljs-function\"><span class=\"hljs-params\">props</span> =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>&#123;props.foo&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></span>;\n&#125;;\n\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span> <span class=\"hljs-attr\">foo</span>=<span class=\"hljs-string\">&quot;bar&quot;</span> /&gt;</span></span>;</code></pre></div>\n\n<p>类组件</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> Props = &#123;\n  <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyComponent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">Props</span>, </span>&#123;&#125;&gt; &#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>&#123;this.props.foo&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></span>;\n  &#125;\n&#125;\n\n&lt;MyComponent foo=<span class=\"hljs-string\">&quot;bar&quot;</span> /&gt;;</code></pre></div>\n\n<p>泛型组件</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 一个泛型组件</span>\n<span class=\"hljs-keyword\">type</span> SelectProps&lt;T&gt; = &#123; <span class=\"hljs-attr\">items</span>: T[] &#125;;\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Select</span>&lt;<span class=\"hljs-title\">T</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">SelectProps</span>&lt;<span class=\"hljs-title\">T</span>&gt;, <span class=\"hljs-title\">any</span>&gt; </span>&#123;&#125;\n\n<span class=\"hljs-comment\">// 使用</span>\n<span class=\"hljs-keyword\">const</span> Form = <span class=\"hljs-function\">() =&gt;</span> &lt;Select&lt;<span class=\"hljs-built_in\">string</span>&gt; items=&#123;[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>]&#125; /&gt;;</code></pre></div>\n\n<p>泛型函数</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>&lt;<span class=\"hljs-title\">T</span>&gt;(<span class=\"hljs-params\">x: T</span>): <span class=\"hljs-title\">T</span> </span>&#123;\n  <span class=\"hljs-keyword\">return</span> x;\n&#125;\n\n<span class=\"hljs-comment\">// 不能使用箭头函数</span>\n<span class=\"hljs-keyword\">const</span> foo = &lt;T&gt;<span class=\"hljs-function\">(<span class=\"hljs-params\">x: T</span>) =&gt;</span> T; <span class=\"hljs-comment\">// Error: T 标签没有关闭</span>\n\n解决办法：用 <span class=\"hljs-keyword\">extends</span> 提示编译器这是泛型\n<span class=\"hljs-keyword\">const</span> foo = <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">T</span> <span class=\"hljs-attr\">extends</span> &#123;&#125;&gt;</span>(x: T) =&gt; x;</span></code></pre></div>\n\n<p>Refs</p>\n<p>一个变量时，使用 ref 和 null 的联合类型</p>\n<div class=\"hljs code-wrapper\"><pre><code class=\"hljs ts\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Use</span> </span>&#123;\n  <span class=\"hljs-attr\">exampleRef</span>: Example | <span class=\"hljs-literal\">null</span> = <span class=\"hljs-literal\">null</span>;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Example</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">&#123;exampleRef</span> =&gt;</span> (this.exampleRef = exampleRef)&#125; /&gt;</span>;\n  &#125;\n&#125;</code></pre></div>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://jkchao.github.io/typescript-book-chinese/\">深入理解 TypeScript</a></li>\n<li><a href=\"https://www.tslang.cn/docs/handbook/generics.html\">https://www.tslang.cn/docs/handbook/generics.html</a></li>\n</ul>\n","site":{"data":{}},"wordcount":10922,"excerpt":"","more":"<h2 id=\"声明空间\"><a href=\"#声明空间\" class=\"headerlink\" title=\"声明空间\"></a>声明空间</h2><p>ts 中有两种：类型声明空间与变量声明空间</p>\n<p>类型声明空间：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Foo</span> </span>&#123;&#125;\n<span class=\"hljs-keyword\">interface</span> Bar &#123;&#125;\n<span class=\"hljs-keyword\">type</span> Bas = &#123;&#125;;</code></pre>\n\n<p>如下当做类型注解使用</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> foo: Foo;\n<span class=\"hljs-keyword\">let</span> bar: Bar;\n<span class=\"hljs-keyword\">let</span> bas: Bas;</code></pre>\n\n<p>定义 interface Bar {} 不能当做变量来用，因为它没有定义在变量声明空间中。</p>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><p>如下方式定义在 <strong>全局模块</strong> 中</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-number\">123</span>;</code></pre>\n\n<p>如下方式文件的根级别位置含有 import 或者 export,在文件中创建本地作用域，是定义在 <strong>文件模块</strong> 中</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-number\">123</span>;</code></pre>\n\n<h2 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h2><p>命名空间一个最明确的目的就是解决重名问题。</p>\n<p>命名空间是位于全局命名空间下的一个普通的带有名字的 JavaScript 对象。作用是将一系列相关的全局变量组织到一个对象的属性。</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">namespace</span> Letter &#123; \n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">1</span>; \n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-number\">2</span>; \n&#125;</code></pre>\n\n<p>编译成 js 如下：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">var</span> Letter; \n(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">Letter</span>) </span>&#123; \n    Letter.a = <span class=\"hljs-number\">1</span>; \n    Letter.b = <span class=\"hljs-number\">2</span>; \n&#125;)(Letter || (Letter = &#123;&#125;));</code></pre>\n\n<h2 id=\"动态导入表达式-import\"><a href=\"#动态导入表达式-import\" class=\"headerlink\" title=\"动态导入表达式 import()\"></a>动态导入表达式 import()</h2><p>import() 异步加载一个模块, 该语句用于 Webpack Code Splitting。</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span>(<span class=\"hljs-comment\">/* webpackChunkName: &quot;momentjs&quot; */</span> <span class=\"hljs-string\">&#x27;moment&#x27;</span>)\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">moment</span> =&gt;</span> &#123;\n    <span class=\"hljs-keyword\">const</span> time = moment().format();\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;TypeScript &gt;= 2.4.0 Dynamic Import Expression:&#x27;</span>);\n    <span class=\"hljs-built_in\">console</span>.log(time);\n  &#125;)\n  .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;Failed to load moment&#x27;</span>, err);\n  &#125;);</code></pre>\n\n<h2 id=\"TS-类型系统\"><a href=\"#TS-类型系统\" class=\"headerlink\" title=\"TS 类型系统\"></a>TS 类型系统</h2><p>原始类型 string、number、boolean 可以被用作类型注解。</p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>两种方式定义数组：</p>\n<p>1、元素类型后加 []</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> list: <span class=\"hljs-built_in\">number</span>[] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];</code></pre>\n\n<p>2、 数组泛型 Array&lt;元素类型&gt;</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> list: <span class=\"hljs-built_in\">Array</span>&lt;number&gt; = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];</code></pre>\n\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>合并众多类型声明至一个类型声明</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> Name &#123;\n  <span class=\"hljs-attr\">first</span>: <span class=\"hljs-built_in\">string</span>;\n  second: <span class=\"hljs-built_in\">string</span>;\n&#125;\n\n<span class=\"hljs-keyword\">let</span> name: Name = &#123;\n  <span class=\"hljs-attr\">first</span>: <span class=\"hljs-string\">&#x27;John&#x27;</span>,\n  <span class=\"hljs-attr\">second</span>: <span class=\"hljs-string\">&#x27;Doe&#x27;</span>\n&#125;;</code></pre>\n\n<h2 id=\"内联类型注解\"><a href=\"#内联类型注解\" class=\"headerlink\" title=\"内联类型注解\"></a>内联类型注解</h2><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> name: &#123;\n  <span class=\"hljs-attr\">first</span>: <span class=\"hljs-built_in\">string</span>;\n  second: <span class=\"hljs-built_in\">string</span>;\n&#125;;\n\nname = &#123;\n  <span class=\"hljs-attr\">first</span>: <span class=\"hljs-string\">&#x27;John&#x27;</span>,\n  <span class=\"hljs-attr\">second</span>: <span class=\"hljs-string\">&#x27;Doe&#x27;</span>\n&#125;;</code></pre>\n\n<p>内联类型注解可以省去为类型起名的麻烦。</p>\n<p>如果你发现需要多次使用相同的内联注解时，那么考虑把它重构为一个接口（或者是 type alias)</p>\n<h2 id=\"特殊类型\"><a href=\"#特殊类型\" class=\"headerlink\" title=\"特殊类型\"></a>特殊类型</h2><p>any、 null、 undefined 以及 void</p>\n<p>:void 来表示一个函数没有一个返回值</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">log</span>(<span class=\"hljs-params\">message: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">void</span> </span>&#123;\n  <span class=\"hljs-built_in\">console</span>.log(message);\n&#125;</code></pre>\n\n<h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><p>在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reverse</span>&lt;<span class=\"hljs-title\">T</span>&gt;(<span class=\"hljs-params\">items: T[]</span>): <span class=\"hljs-title\">T</span>[] </span>&#123;\n  <span class=\"hljs-keyword\">const</span> toreturn = [];\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = items.length - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) &#123;\n    toreturn.push(items[i]);\n  &#125;\n  <span class=\"hljs-keyword\">return</span> toreturn;\n&#125;</code></pre>\n\n<h2 id=\"联合类型\"><a href=\"#联合类型\" class=\"headerlink\" title=\"联合类型\"></a>联合类型</h2><p>多种类型之一</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">formatCommandline</span>(<span class=\"hljs-params\">command: <span class=\"hljs-built_in\">string</span>[] | <span class=\"hljs-built_in\">string</span></span>) </span>&#123;\n  <span class=\"hljs-keyword\">let</span> line = <span class=\"hljs-string\">&#x27;&#x27;</span>;\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> command === <span class=\"hljs-string\">&#x27;string&#x27;</span>) &#123;\n    line = command.trim();\n  &#125; <span class=\"hljs-keyword\">else</span> &#123;\n    line = command.join(<span class=\"hljs-string\">&#x27; &#x27;</span>).trim();\n  &#125;\n\n  <span class=\"hljs-comment\">// Do stuff with line: string</span>\n&#125;</code></pre>\n\n<h2 id=\"交叉类型\"><a href=\"#交叉类型\" class=\"headerlink\" title=\"交叉类型\"></a>交叉类型</h2><p>extend 是一种非常常见的模式，从两个对象中创建一个新对象，新对象拥有着两个对象所有的功能。</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">extend</span>&lt;<span class=\"hljs-title\">T</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">object</span>, <span class=\"hljs-title\">U</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">object</span>&gt;(<span class=\"hljs-params\">first: T, second: U</span>): <span class=\"hljs-title\">T</span> &amp; <span class=\"hljs-title\">U</span> </span>&#123;\n  <span class=\"hljs-keyword\">const</span> result = &lt;T &amp; U&gt;&#123;&#125;;\n  for (let id in first) &#123;\n    (&lt;T&gt;result)[id] = first[id];\n  &#125;\n  for (let id in second) &#123;\n    if (!result.hasOwnProperty(id)) &#123;\n      (&lt;U&gt;result)[id] = second[id];\n    &#125;\n  &#125;\n\n  return result;\n&#125;\n\nconst x = extend(&#123; a: &#x27;hello&#x27; &#125;, &#123; b: 42 &#125;);\n\n// 现在 x 拥有了 a 属性与 b 属性\nconst a = x.a;\nconst b = x.b;</code></pre>\n\n<h2 id=\"元祖类型-Tuple\"><a href=\"#元祖类型-Tuple\" class=\"headerlink\" title=\"元祖类型 Tuple\"></a>元祖类型 Tuple</h2><p>固定长度的，元素数据类型不同的数组。数据不可变。</p>\n<pre><code class=\"hljs js\">type FixedArray = [string, number, string];\n\n<span class=\"hljs-keyword\">const</span> mixedArray: FixedArray = [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>];</code></pre>\n\n<h2 id=\"类型别名\"><a href=\"#类型别名\" class=\"headerlink\" title=\"类型别名\"></a>类型别名</h2><p>以为任意的类型注解提供类型别名,在联合类型和交叉类型中比较实用。</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> StrOrNum = <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>;\n\n<span class=\"hljs-comment\">// 使用</span>\n<span class=\"hljs-keyword\">let</span> sample: StrOrNum;\nsample = <span class=\"hljs-number\">123</span>;\nsample = <span class=\"hljs-string\">&#x27;123&#x27;</span>;\n\n<span class=\"hljs-comment\">// 会检查类型</span>\nsample = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// Error</span></code></pre>\n\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> Text = <span class=\"hljs-built_in\">string</span> | &#123; <span class=\"hljs-attr\">text</span>: <span class=\"hljs-built_in\">string</span> &#125;;\n<span class=\"hljs-keyword\">type</span> Coordinates = [<span class=\"hljs-built_in\">number</span>, <span class=\"hljs-built_in\">number</span>];\n<span class=\"hljs-keyword\">type</span> Callback = <span class=\"hljs-function\">(<span class=\"hljs-params\">data: <span class=\"hljs-built_in\">string</span></span>) =&gt;</span> <span class=\"hljs-built_in\">void</span>;</code></pre>\n\n<h2 id=\"types\"><a href=\"#types\" class=\"headerlink\" title=\"@types\"></a>@types</h2><p>通过 npm 来安装使用 @types,如 <code>npm install @types/jquery --save-dev</code></p>\n<h2 id=\"declare-声明文件\"><a href=\"#declare-声明文件\" class=\"headerlink\" title=\"declare 声明文件\"></a>declare 声明文件</h2><p>.d.ts文件是ts用来声明变量，模块，type，interface等等的。</p>\n<p>在这种后缀的ts文件声明这些东西和在纯ts文件声明这些东西又什么区别呢？</p>\n<p>在.d.ts声明变量或者模块等东西之后，在其他地方可以不用import导入这些东西就可以直接用，用，而且有语法提示。</p>\n<p>declare声明一个类型:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">type</span> Asd &#123;\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;</code></pre>\n\n<p>在tsconfig.json文件里面的include数组里面添加这个文件, 在include包含的文件范围内可以直接使用Asd这个type。</p>\n<p>declare声明一个模块:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-built_in\">module</span> <span class=\"hljs-string\">&#x27;*.css&#x27;</span>;\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-built_in\">module</span> <span class=\"hljs-string\">&#x27;*.less&#x27;</span>;\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-built_in\">module</span> <span class=\"hljs-string\">&#x27;*.png&#x27;</span>;</code></pre>\n\n<p>编译ts文件的时候，导入一个.css/.less/.png格式的文件，如果没有经过declare的话是会提示语法错误的</p>\n<p>declare声明一个变量:</p>\n<p>在项目中引入了一个sdk，这个sdk（我们以微信的sdk为例）里面有一些全局的对象（比如wx），但是如果不经过任何的声明，在ts文件里面直接用wx.config()的话，肯定会报错。</p>\n<p>declare声明一个作用域:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">namespace</span> API &#123;\n    <span class=\"hljs-keyword\">interface</span> ResponseList &#123;&#125;\n&#125;</code></pre>\n\n<p>声明完之后在其他地方的ts就可以直接API.ResponseList引用到这个接口类型</p>\n<h2 id=\"接口-1\"><a href=\"#接口-1\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>两种声明方式：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 内联注解</span>\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">const</span> myPoint: &#123; <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">number</span>; y: <span class=\"hljs-built_in\">number</span> &#125;;\n\n<span class=\"hljs-comment\">// 接口形式</span>\n<span class=\"hljs-keyword\">interface</span> Point &#123;\n  <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">number</span>;\n  y: <span class=\"hljs-built_in\">number</span>;\n&#125;\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">const</span> myPoint: Point;</code></pre>\n\n<p>接口形式的好处在于，如果有人创建了一个基于 myPoint 的库来添加新成员, 可以轻松将此成员添加到 myPoint 的现有声明中</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// Lib a.d.ts</span>\n<span class=\"hljs-keyword\">interface</span> Point &#123;\n  <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">number</span>,\n  <span class=\"hljs-attr\">y</span>: <span class=\"hljs-built_in\">number</span>\n&#125;\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">const</span> myPoint: Point\n\n<span class=\"hljs-comment\">// Lib b.d.ts</span>\n<span class=\"hljs-keyword\">interface</span> Point &#123;\n  <span class=\"hljs-attr\">z</span>: <span class=\"hljs-built_in\">number</span>\n&#125;\n\n<span class=\"hljs-comment\">// Your code</span>\nmyPoint.z <span class=\"hljs-comment\">// Allowed!</span></code></pre>\n\n<h2 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h2><p>函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 |操作符或者?操作符，把所有可能的输入类型全部包含进去，以具体实现。</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 上边是声明</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">string</span>, arg2: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">string</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">number</span>, arg2: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\">// 因为我们在下边有具体函数的实现，所以这里并不需要添加 <span class=\"hljs-title\">declare</span> 关键字</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\">// 下边是实现</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span> (<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span>, arg2: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-built_in\">number</span></span>) </span>&#123;</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\">  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 <span class=\"hljs-title\">arg1</span> + <span class=\"hljs-title\">arg2</span></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\">  <span class=\"hljs-title\">if</span> (<span class=\"hljs-params\"><span class=\"hljs-keyword\">typeof</span> arg1 === <span class=\"hljs-string\">&#x27;string&#x27;</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> arg2 === <span class=\"hljs-string\">&#x27;string&#x27;</span></span>) </span>&#123;</span>\n<span class=\"hljs-function\">    <span class=\"hljs-title\">return</span> <span class=\"hljs-title\">arg1</span> + <span class=\"hljs-title\">arg2</span></span>\n<span class=\"hljs-function\">  &#125; <span class=\"hljs-title\">else</span> <span class=\"hljs-title\">if</span> (<span class=\"hljs-params\"><span class=\"hljs-keyword\">typeof</span> arg1 === <span class=\"hljs-string\">&#x27;number&#x27;</span> &amp;&amp; <span class=\"hljs-keyword\">typeof</span> arg2 === <span class=\"hljs-string\">&#x27;number&#x27;</span></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> arg1 + arg2\n  &#125;\n&#125;</code></pre>\n\n<p>函数重载的意义在于能够让你知道传入不同的参数得到不同的结果，如果传入的参数不同，但是得到的结果（类型）却相同，那么不要使用函数重载（没有意义）。 如果函数的返回值类型相同，那么也不需要使用函数重载</p>\n<p>以下场景可以不需要重载：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span> (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span> (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, b: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\">// 像这样的是参数个数的区别，我们可以使用可选参数来代替函数重载的定义</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span> (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span>, b?: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span></span></span></code></pre>\n\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 亦或是一些参数类型的区别导致的</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span> (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span></span>): <span class=\"hljs-title\">number</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span> (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">number</span></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\">// 这时我们应该使用联合类型来代替函数重载</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">func</span> (<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span></span>): <span class=\"hljs-title\">number</span></span></span></span></code></pre>\n\n<h2 id=\"函数声明\"><a href=\"#函数声明\" class=\"headerlink\" title=\"函数声明\"></a>函数声明</h2><p>在没有提供函数实现的情况下，有两种声明函数类型的方式:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> LongHand = &#123;\n  (a: <span class=\"hljs-built_in\">number</span>): <span class=\"hljs-built_in\">number</span>;\n&#125;; <span class=\"hljs-comment\">//当你想使用函数重载时, 只能用此方式</span>\n\n<span class=\"hljs-keyword\">type</span> ShortHand = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">number</span></span>) =&gt;</span> <span class=\"hljs-built_in\">number</span>;</code></pre>\n\n<h2 id=\"可调用的类型注解\"><a href=\"#可调用的类型注解\" class=\"headerlink\" title=\"可调用的类型注解\"></a>可调用的类型注解</h2><p>使用类型别名或者接口来表示一个可被调用的类型注解：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> ReturnString &#123;\n  (): <span class=\"hljs-built_in\">string</span>;\n&#125;\n<span class=\"hljs-comment\">// 表示一个返回值为 string 的函数：</span></code></pre>\n\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">const</span> foo: ReturnString;\n\n<span class=\"hljs-keyword\">const</span> bar = foo(); <span class=\"hljs-comment\">// bar 被推断为一个字符串。</span></code></pre>\n\n<h2 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h2><p>ts 允许你覆盖它的推断，并且能以你任何你想要的方式分析它</p>\n<p>js 迁移到 ts 时常见：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> foo = &#123;&#125;;\nfoo.bar = <span class=\"hljs-number\">123</span>; <span class=\"hljs-comment\">// Error: &#x27;bar&#x27; 属性不存在于 ‘&#123;&#125;’</span>\nfoo.bas = <span class=\"hljs-string\">&#x27;hello&#x27;</span>; <span class=\"hljs-comment\">// Error: &#x27;bas&#x27; 属性不存在于 &#x27;&#123;&#125;&#x27;</span></code></pre>\n\n<p>foo 类型推断为 {}，不存在属性。通过类型断言来避免该问题</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> Foo &#123;\n  <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-built_in\">number</span>;\n  bas: <span class=\"hljs-built_in\">string</span>;\n&#125;\n\n<span class=\"hljs-keyword\">const</span> foo = &#123;&#125; <span class=\"hljs-keyword\">as</span> Foo;\nfoo.bar = <span class=\"hljs-number\">123</span>;\nfoo.bas = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;</code></pre>\n\n<h2 id=\"允许额外的属性\"><a href=\"#允许额外的属性\" class=\"headerlink\" title=\"允许额外的属性\"></a>允许额外的属性</h2><p>包含索引签名，以明确表明可以使用额外的属性：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> x: &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-built_in\">number</span>, [x: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">any</span> &#125;;\n\nx = &#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-number\">2</span> &#125;; <span class=\"hljs-comment\">// ok, &#x27;baz&#x27; 属性匹配于索引签名</span></code></pre>\n\n<p>React State 中示例：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 假设</span>\n<span class=\"hljs-keyword\">interface</span> State &#123;\n  <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-built_in\">string</span>;\n  bar: <span class=\"hljs-built_in\">string</span>;\n&#125;\n\n<span class=\"hljs-comment\">// 你可能想做：</span>\n<span class=\"hljs-built_in\">this</span>.setState(&#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;Hello&#x27;</span> &#125;); <span class=\"hljs-comment\">// Error: 没有属性 &#x27;bar&#x27;</span>\n\n<span class=\"hljs-comment\">// 因为 state 包含 &#x27;foo&#x27; 与 &#x27;bar&#x27;，TypeScript 会强制你这么做：</span>\n<span class=\"hljs-built_in\">this</span>.setState(&#123; <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">&#x27;Hello&#x27;</span>, <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-built_in\">this</span>.state.bar &#125;);</code></pre>\n\n<h2 id=\"类型保护\"><a href=\"#类型保护\" class=\"headerlink\" title=\"类型保护\"></a>类型保护</h2><p>ts 会推到条件块中的变量类型</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">doSome</span>(<span class=\"hljs-params\">x: <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span></span>) </span>&#123;\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> x === <span class=\"hljs-string\">&#x27;string&#x27;</span>) &#123;\n    <span class=\"hljs-comment\">// 在这个块中，TypeScript 知道 `x` 的类型必须是 `string`</span>\n    <span class=\"hljs-built_in\">console</span>.log(x.subtr(<span class=\"hljs-number\">1</span>)); <span class=\"hljs-comment\">// Error: &#x27;subtr&#x27; 方法并没有存在于 `string` 上</span>\n    <span class=\"hljs-built_in\">console</span>.log(x.substr(<span class=\"hljs-number\">1</span>)); <span class=\"hljs-comment\">// ok</span>\n  &#125;\n\n  x.substr(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// Error: 无法保证 `x` 是 `string` 类型</span>\n&#125;</code></pre>\n\n<p>in 操作符可以一个对象上是否存在一个属性，它通常也被作为类型保护使用</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> A &#123;\n  <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">number</span>;\n&#125;\n\n<span class=\"hljs-keyword\">interface</span> B &#123;\n  <span class=\"hljs-attr\">y</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">doStuff</span>(<span class=\"hljs-params\">q: A | B</span>) </span>&#123;\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">&#x27;x&#x27;</span> <span class=\"hljs-keyword\">in</span> q) &#123;\n    <span class=\"hljs-comment\">// q: A</span>\n  &#125; <span class=\"hljs-keyword\">else</span> &#123;\n    <span class=\"hljs-comment\">// q: B</span>\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"字面量类型\"><a href=\"#字面量类型\" class=\"headerlink\" title=\"字面量类型\"></a>字面量类型</h2><p>字面量类型本身不使用，在一个联合类型中组合创建一个强大的（实用的）抽象。</p>\n<p>字符串字面量：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> foo: <span class=\"hljs-string\">&#x27;Hello&#x27;</span>;\nfoo = <span class=\"hljs-string\">&#x27;Bar&#x27;</span>; <span class=\"hljs-comment\">// Error: &#x27;bar&#x27; 不能赋值给类型 &#x27;Hello&#x27;</span></code></pre>\n\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> CardinalDirection = <span class=\"hljs-string\">&#x27;North&#x27;</span> | <span class=\"hljs-string\">&#x27;East&#x27;</span> | <span class=\"hljs-string\">&#x27;South&#x27;</span> | <span class=\"hljs-string\">&#x27;West&#x27;</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">move</span>(<span class=\"hljs-params\">distance: <span class=\"hljs-built_in\">number</span>, direction: CardinalDirection</span>) </span>&#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n\nmove(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;North&#x27;</span>); <span class=\"hljs-comment\">// ok</span>\nmove(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;Nurth&#x27;</span>); <span class=\"hljs-comment\">// Error</span></code></pre>\n\n<p>boolean 和 number 的字面量类型：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> OneToFive = <span class=\"hljs-number\">1</span> | <span class=\"hljs-number\">2</span> | <span class=\"hljs-number\">3</span> | <span class=\"hljs-number\">4</span> | <span class=\"hljs-number\">5</span>;\n<span class=\"hljs-keyword\">type</span> Bools = <span class=\"hljs-literal\">true</span> | <span class=\"hljs-literal\">false</span>;</code></pre>\n\n<h2 id=\"Readonly\"><a href=\"#Readonly\" class=\"headerlink\" title=\"Readonly\"></a>Readonly</h2><pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">config: &#123; <span class=\"hljs-keyword\">readonly</span> bar: <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-keyword\">readonly</span> bas: <span class=\"hljs-built_in\">number</span> &#125;</span>) </span>&#123;\n  <span class=\"hljs-comment\">// ..</span>\n&#125;\n\n<span class=\"hljs-keyword\">type</span> Foo = &#123;\n  <span class=\"hljs-keyword\">readonly</span> bar: <span class=\"hljs-built_in\">number</span>;\n  <span class=\"hljs-keyword\">readonly</span> bas: <span class=\"hljs-built_in\">number</span>;\n&#125;;</code></pre>\n\n<p>这有一个 Readonly 的映射类型，它接收一个泛型 T，用来把它的所有属性标记为只读类型：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> Foo = &#123;\n  <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-built_in\">number</span>;\n  bas: <span class=\"hljs-built_in\">number</span>;\n&#125;;\n\n<span class=\"hljs-keyword\">type</span> FooReadonly = Readonly&lt;Foo&gt;;</code></pre>\n\n<h2 id=\"泛型2\"><a href=\"#泛型2\" class=\"headerlink\" title=\"泛型2\"></a>泛型2</h2><p>创建泛型类</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 创建一个泛型类</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Queue</span>&lt;<span class=\"hljs-title\">T</span>&gt; </span>&#123;\n  <span class=\"hljs-keyword\">private</span> data: T[] = [];\n  push = <span class=\"hljs-function\">(<span class=\"hljs-params\">item: T</span>) =&gt;</span> <span class=\"hljs-built_in\">this</span>.data.push(item);\n  pop = (): T | <span class=\"hljs-function\"><span class=\"hljs-params\">undefined</span> =&gt;</span> <span class=\"hljs-built_in\">this</span>.data.shift();\n&#125;\n\n<span class=\"hljs-comment\">// 简单的使用</span>\n<span class=\"hljs-keyword\">const</span> queue = <span class=\"hljs-keyword\">new</span> Queue&lt;<span class=\"hljs-built_in\">number</span>&gt;();\nqueue.push(<span class=\"hljs-number\">0</span>);\nqueue.push(<span class=\"hljs-string\">&#x27;1&#x27;</span>); <span class=\"hljs-comment\">// Error：不能推入一个 `string`，只有 number 类型被允许</span></code></pre>\n\n<p>泛型的误用：近在单个参数或一个位置被使用</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>&lt;<span class=\"hljs-title\">T</span>&gt;(<span class=\"hljs-params\">arg: T</span>): <span class=\"hljs-title\">void</span></span>;  \n<span class=\"hljs-comment\">// </span>\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">arg: <span class=\"hljs-built_in\">any</span></span>): <span class=\"hljs-title\">void</span></span>;</code></pre>\n\n<p>axios 请求中 泛型的使用：</p>\n<p>通常情况下，我们会把后端返回数据格式单独放入一个 interface 里：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 请求接口数据</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> ResponseData&lt;T = any&gt; &#123;\n  <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">   * 状态码</span>\n<span class=\"hljs-comment\">   * <span class=\"hljs-doctag\">@type <span class=\"hljs-type\">&#123; number &#125;</span></span></span>\n<span class=\"hljs-comment\">   */</span>\n  <span class=\"hljs-attr\">code</span>: <span class=\"hljs-built_in\">number</span>;\n\n  <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">   * 数据</span>\n<span class=\"hljs-comment\">   * <span class=\"hljs-doctag\">@type <span class=\"hljs-type\">&#123; T &#125;</span></span></span>\n<span class=\"hljs-comment\">   */</span>\n  result: T;\n\n  <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">   * 消息</span>\n<span class=\"hljs-comment\">   * <span class=\"hljs-doctag\">@type <span class=\"hljs-type\">&#123; string &#125;</span></span></span>\n<span class=\"hljs-comment\">   */</span>\n  message: <span class=\"hljs-built_in\">string</span>;\n&#125;</code></pre>\n\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 在 axios.ts 文件中对 axios 进行了处理，例如添加通用配置、拦截器等</span>\n<span class=\"hljs-keyword\">import</span> Ax <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./axios&#x27;</span>;\n\n<span class=\"hljs-keyword\">import</span> &#123; ResponseData &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./interface.ts&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getUser</span>&lt;<span class=\"hljs-title\">T</span>&gt;(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> Ax.get&lt;ResponseData&lt;T&gt;&gt;(<span class=\"hljs-string\">&#x27;/somepath&#x27;</span>)\n    .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> res.data)\n    .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.error(err));\n&#125;</code></pre>\n\n<p>写入返回的数据类型 User</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> User &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n  age: <span class=\"hljs-built_in\">number</span>;\n&#125;\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// user 被推断出为</span>\n  <span class=\"hljs-comment\">// &#123;</span>\n  <span class=\"hljs-comment\">//  code: number,</span>\n  <span class=\"hljs-comment\">//  result: &#123; name: string, age: number &#125;,</span>\n  <span class=\"hljs-comment\">//  message: string</span>\n  <span class=\"hljs-comment\">// &#125;</span>\n  <span class=\"hljs-keyword\">const</span> user = <span class=\"hljs-keyword\">await</span> getUser&lt;User&gt;();\n&#125;</code></pre>\n\n<h2 id=\"never-类型\"><a href=\"#never-类型\" class=\"headerlink\" title=\"never 类型\"></a>never 类型</h2><p>常用在</p>\n<ul>\n<li>从来不会有返回值的函数（如：如果函数内含有 while(true) {}）</li>\n<li>总是会抛出错误的函数 throw new Error</li>\n</ul>\n<p>never 类型仅能被赋值给另外一个 never</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> bar: <span class=\"hljs-built_in\">never</span> = (<span class=\"hljs-function\">() =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;Throw my hands in the air like I just dont care&#x27;</span>);\n&#125;)();</code></pre>\n\n<p>void 和 never 的区别：</p>\n<ul>\n<li>void 表示没有任何类型，never 表示永远不存在的值的类型。</li>\n<li>当一个函数返回空值时，它的返回值为 void 类型，但是，当一个函数永不返回时（或者总是抛出错误），它的返回值为 never 类型。</li>\n<li>void 类型可以被赋值，但是除了 never 本身以外，其他任何类型不能赋值给 never。</li>\n</ul>\n<h2 id=\"redux-中的联合类型\"><a href=\"#redux-中的联合类型\" class=\"headerlink\" title=\"redux 中的联合类型\"></a>redux 中的联合类型</h2><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> &#123; createStore &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;redux&#x27;</span>;\n\n<span class=\"hljs-keyword\">type</span> Action =\n  | &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;INCREMENT&#x27;</span>;\n    &#125;\n  | &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;DECREMENT&#x27;</span>;\n    &#125;;\n\n<span class=\"hljs-comment\">//reducer</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">counter</span>(<span class=\"hljs-params\">state = <span class=\"hljs-number\">0</span>, action: Action</span>) </span>&#123;\n  <span class=\"hljs-keyword\">switch</span> (action.type) &#123;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;INCREMENT&#x27;</span>:\n      <span class=\"hljs-keyword\">return</span> state + <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;DECREMENT&#x27;</span>:\n      <span class=\"hljs-keyword\">return</span> state - <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">default</span>:\n      <span class=\"hljs-keyword\">return</span> state;\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"索引签名\"><a href=\"#索引签名\" class=\"headerlink\" title=\"索引签名\"></a>索引签名</h2><p>声明一个索引签名时，所有明确的成员都必须符合索引签名：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">interface</span> Bar &#123;\n  [key: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">number</span>;\n  x: <span class=\"hljs-built_in\">number</span>;\n  y: <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-comment\">// Error: y 属性必须为 number 类型</span>\n&#125;</code></pre>\n\n<p>映射类型来使索引字符串为联合类型中的一员</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> Index = <span class=\"hljs-string\">&#x27;a&#x27;</span> | <span class=\"hljs-string\">&#x27;b&#x27;</span> | <span class=\"hljs-string\">&#x27;c&#x27;</span>;\n<span class=\"hljs-keyword\">type</span> FromIndex = &#123; [k <span class=\"hljs-keyword\">in</span> Index]?: <span class=\"hljs-built_in\">number</span> &#125;;\n\n<span class=\"hljs-keyword\">const</span> bad: FromIndex = &#123; <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">d</span>: <span class=\"hljs-number\">3</span> &#125;; <span class=\"hljs-comment\">//err</span></code></pre>\n\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> FromSomeIndex&lt;K <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-built_in\">string</span>&gt; = &#123; [key <span class=\"hljs-keyword\">in</span> K]: <span class=\"hljs-built_in\">number</span> &#125;;</code></pre>\n\n<h2 id=\"索引签名中排除某些属性\"><a href=\"#索引签名中排除某些属性\" class=\"headerlink\" title=\"索引签名中排除某些属性\"></a>索引签名中排除某些属性</h2><p>用交叉类型解决</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> FieldState = &#123;\n  <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;;\n\n<span class=\"hljs-keyword\">type</span> FromState = &#123;\n  <span class=\"hljs-attr\">isValid</span>: <span class=\"hljs-built_in\">boolean</span>; <span class=\"hljs-comment\">// Error: 不符合索引签名</span>\n  [filedName: <span class=\"hljs-built_in\">string</span>]: FieldState;\n&#125;;</code></pre>\n\n<p>交叉类型：</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> FieldState = &#123;\n  <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;;\n\n<span class=\"hljs-keyword\">type</span> FormState = &#123; <span class=\"hljs-attr\">isValid</span>: <span class=\"hljs-built_in\">boolean</span> &#125; &amp; &#123; [fieldName: <span class=\"hljs-built_in\">string</span>]: FieldState &#125;;</code></pre>\n\n<h2 id=\"流动的类型\"><a href=\"#流动的类型\" class=\"headerlink\" title=\"流动的类型\"></a>流动的类型</h2><p>捕获变量的类型</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-number\">123</span>;\n<span class=\"hljs-keyword\">let</span> bar: <span class=\"hljs-keyword\">typeof</span> foo; <span class=\"hljs-comment\">// &#x27;bar&#x27; 类型与 &#x27;foo&#x27; 类型相同（在这里是： &#x27;number&#x27;）</span></code></pre>\n\n<p>捕获类成员类型 需要声明一个变量</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Foo</span> </span>&#123;\n  <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-built_in\">number</span>; <span class=\"hljs-comment\">// 我们想要捕获的类型</span>\n&#125;\n\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">let</span> _foo: Foo;\n\n<span class=\"hljs-comment\">// 与之前做法相同</span>\n<span class=\"hljs-keyword\">let</span> bar: <span class=\"hljs-keyword\">typeof</span> _foo.foo;</code></pre>\n\n<p>捕获键的名称</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">const</span> colors = &#123;\n  <span class=\"hljs-attr\">red</span>: <span class=\"hljs-string\">&#x27;red&#x27;</span>,\n  <span class=\"hljs-attr\">blue</span>: <span class=\"hljs-string\">&#x27;blue&#x27;</span>\n&#125;;\n\n<span class=\"hljs-keyword\">type</span> Colors = keyof <span class=\"hljs-keyword\">typeof</span> colors;\n\n<span class=\"hljs-keyword\">let</span> color: Colors; <span class=\"hljs-comment\">// color 的类型是 &#x27;red&#x27; | &#x27;blue&#x27;</span>\ncolor = <span class=\"hljs-string\">&#x27;red&#x27;</span>; <span class=\"hljs-comment\">// ok</span>\ncolor = <span class=\"hljs-string\">&#x27;blue&#x27;</span>; <span class=\"hljs-comment\">// ok</span>\ncolor = <span class=\"hljs-string\">&#x27;anythingElse&#x27;</span>; <span class=\"hljs-comment\">// Error</span></code></pre>\n\n<h2 id=\"JSX-的支持\"><a href=\"#JSX-的支持\" class=\"headerlink\" title=\"JSX 的支持\"></a>JSX 的支持</h2><p>函数组件</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> Props = &#123;\n  <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;;\n\n<span class=\"hljs-keyword\">const</span> MyComponent: React.FunctionComponent&lt;Props&gt; = <span class=\"hljs-function\"><span class=\"hljs-params\">props</span> =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>&#123;props.foo&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></span>;\n&#125;;\n\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span> <span class=\"hljs-attr\">foo</span>=<span class=\"hljs-string\">&quot;bar&quot;</span> /&gt;</span></span>;</code></pre>\n\n<p>类组件</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">type</span> Props = &#123;\n  <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-built_in\">string</span>;\n&#125;;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyComponent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">Props</span>, </span>&#123;&#125;&gt; &#123;\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>&#123;this.props.foo&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></span>;\n  &#125;\n&#125;\n\n&lt;MyComponent foo=<span class=\"hljs-string\">&quot;bar&quot;</span> /&gt;;</code></pre>\n\n<p>泛型组件</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 一个泛型组件</span>\n<span class=\"hljs-keyword\">type</span> SelectProps&lt;T&gt; = &#123; <span class=\"hljs-attr\">items</span>: T[] &#125;;\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Select</span>&lt;<span class=\"hljs-title\">T</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">SelectProps</span>&lt;<span class=\"hljs-title\">T</span>&gt;, <span class=\"hljs-title\">any</span>&gt; </span>&#123;&#125;\n\n<span class=\"hljs-comment\">// 使用</span>\n<span class=\"hljs-keyword\">const</span> Form = <span class=\"hljs-function\">() =&gt;</span> &lt;Select&lt;<span class=\"hljs-built_in\">string</span>&gt; items=&#123;[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>]&#125; /&gt;;</code></pre>\n\n<p>泛型函数</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>&lt;<span class=\"hljs-title\">T</span>&gt;(<span class=\"hljs-params\">x: T</span>): <span class=\"hljs-title\">T</span> </span>&#123;\n  <span class=\"hljs-keyword\">return</span> x;\n&#125;\n\n<span class=\"hljs-comment\">// 不能使用箭头函数</span>\n<span class=\"hljs-keyword\">const</span> foo = &lt;T&gt;<span class=\"hljs-function\">(<span class=\"hljs-params\">x: T</span>) =&gt;</span> T; <span class=\"hljs-comment\">// Error: T 标签没有关闭</span>\n\n解决办法：用 <span class=\"hljs-keyword\">extends</span> 提示编译器这是泛型\n<span class=\"hljs-keyword\">const</span> foo = <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">T</span> <span class=\"hljs-attr\">extends</span> &#123;&#125;&gt;</span>(x: T) =&gt; x;</span></code></pre>\n\n<p>Refs</p>\n<p>一个变量时，使用 ref 和 null 的联合类型</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Use</span> </span>&#123;\n  <span class=\"hljs-attr\">exampleRef</span>: Example | <span class=\"hljs-literal\">null</span> = <span class=\"hljs-literal\">null</span>;\n\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Example</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">&#123;exampleRef</span> =&gt;</span> (this.exampleRef = exampleRef)&#125; /&gt;</span>;\n  &#125;\n&#125;</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://jkchao.github.io/typescript-book-chinese/\">深入理解 TypeScript</a></li>\n<li><a href=\"https://www.tslang.cn/docs/handbook/generics.html\">https://www.tslang.cn/docs/handbook/generics.html</a></li>\n</ul>\n"},{"title":"0.1前端工程师面试题2.md","index_img":"/img/index-img.png","date":"2022-02-15T02:14:34.000Z","abbrlink":"vdfge343","_content":"\n## | HTTP/HTML/浏览器\n\n### 说一下 http 和 https\n\n参考回答：\n\nhttps 的 SSL 加密是在传输层实现的。(1)http 和 https 的基本概念\n\nhttp: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW\n服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。\n\nhttps: 是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL\n\n层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。\n\nhttps 协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。\n\n2. http 和 https 的区别？\n\nhttp 传输的数据都是未加密的，也就是明文的，网景公司设置了 SSL 协议来对 http 协议传输的数据进行加密处理，简单来说 https 协议是由 http 和 ssl\n协议构建的可进行加密传输和身份认证的网络协议，比 http 协议的安全性更高。\n\n主要的区别如下：\n\nHttps 协议需要 ca 证书，费用较高。\n\nhttp 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。\n\n使用不同的链接方式，端口也不同，一般而言，http 协议的端口为 80，https 的端口为 443\n\nhttp 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。\n\n3. https 协议的工作原理\n\n客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤，如图所示。客户使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。\n\nweb 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。\n\n客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。\n\n客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。\n\nweb 服务器通过自己的私钥解密出会话密钥。\n\nweb 服务器通过会话密钥加密与客户端之间的通信。(4)https 协议的优点\n\n使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；\n\nHTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比http 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。HTTPS\n是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。\n\n谷歌曾在 2014 年 8 月份调整搜索引擎算法，并称“比起同等 HTTP 网站，采用 HTTPS\n\n加密的网站在搜索结果中的排名将会更高”。(5)https 协议的缺点\n\nhttps 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%\\~20%的耗电。https 缓存不如 http 高效，会增加数据开销。\n\nSSL 证书也需要钱，功能越强大的证书费用越高。\n\nSSL 证书需要绑定 IP，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。\n\n### tcp 三次握手，一句话概括\n\n参考回答：\n\n客户端和服务端都需要直到各自可收发，因此需要三次握手。简化三次握手：\n\n<img width=\"487\" alt=\"2018-07-10 3 42 11\"\nsrc=\"[_https://user-_](https://user-images.githubusercontent.com/17233651/42496289-1c6d668a-8458-11e8-98b3-65db50f64d48.png)\n[_images.githubusercontent.com/17233651/42496289-1c6d668a-8458-11e8-98b3-_](https://user-images.githubusercontent.com/17233651/42496289-1c6d668a-8458-11e8-98b3-65db50f64d48.png)\n[_65db50f64d48.png_](https://user-images.githubusercontent.com/17233651/42496289-1c6d668a-8458-11e8-98b3-65db50f64d48.png)\">\n\n从图片可以得到三次握手可以简化为：C 发起请求连接S 确认，也发起连接C 确认我们再看看每次握手的作用：第一次握手：S 只可以确认 自己可以接受C 发送的报文段第二次握手：C 可以确认 S\n收到了自己发送的报文段，并且可以确认 自己可以接受S 发送的报文段第三次握手：S 可以确认 C 收到了自己发送的报文段\n\n- ### TCP 和 UDP 的区别\n\n参考回答：\n\n1. TCP 是面向连接的，udp 是无连接的即发送数据前不需要先建立链接。\n\n2. TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失， 不重复，且按序到达;UDP 尽最大努力交付，即不保证可靠交付。 并且因为 tcp 可靠，\n   面向连接，不会丢失数据因此适合大数据量的交换。\n\n3. TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低\n\n（因此会出现丢包，对实时的应用比如 IP 电话和视频会议等）。\n\n4. TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多。\n\n5. TCP 的首部较大为 20 字节，而 UDP 只有 8 字节。\n\n6. TCP 是面向连接的可靠性传输，而 UDP 是不可靠的。\n\n- ### WebSocket 的实现和应用\n\n参考回答：\n\n1. 什么是 WebSocket?\n\nWebSocket 是 HTML5 中的协议，支持持久连续，http 协议不支持持久性连接。Http1.0 和 HTTP1.1 都不支持持久性的链接，HTTP1.1 中的 keep-alive，将多个\nhttp 请求合并为 1 个\n\n2. WebSocket 是什么样的协议，具体有什么优点？\n\nHTTP 的生命周期通过 Request 来界定，也就是 Request 一个 Response，那么在Http1.0 协议中，这次 Http 请求就结束了。在 Http1.1\n中进行了改进，是的有一个connection：Keep-alive，也就是说，在一个 Http 连接中，可以发送多个 Request， 接收多个 Response。但是必须记住，在 Http 中一个\nRequest 只能对应有一个Response，而且这个 Response 是被动的，不能主动发起。\n\nWebSocket 是基于 Http 协议的，或者说借用了 Http 协议来完成一部分握手，在握手阶段与 Http 是相同的。我们来看一个 websocket 握手协议的实现，基本是 2 个属性，\nupgrade，connection。\n\n基本请求如下：\n\n### GET /chat HTTP/1.1\n\n> Host: server.example.com Upgrade: websocket Connection: Upgrade\n\n> Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== Sec-WebSocket-Protocol: chat, superchat\n> Sec-WebSocket-Version: 13\n\n> [Origin: http://example.com](http://example.com/)\n\n多了下面 2 个属性：\n\n告诉服务器发送的是 websocket\n\n- ### HTTP 请求的方式，HEAD 方式\n\n参考回答：\n\nhead：类似于 get 请求，只不过返回的响应中没有具体的内容，用户获取报头options：允许客户端查看服务器的性能，比如说服务器支持的请求方式等等。\n\n- ### 一个图片 url 访问后直接下载怎样实现？\n\n参考回答：\n\n请求的返回头里面，用于浏览器解析的重要参数就是 OSS 的 API 文档里面的返回 http\n\n头，决定用户下载行为的参数。下载的情况下：\n\n1. x-oss-object-type: Normal\n\n2. x-oss-request-id: 598D5ED34F29D01FE2925F41\n\n3. x-oss-storage-class: Standard\n\n- ### 说一下 web Quality（无障碍）\n\n参考回答：\n\n能够被残障人士使用的网站才能称得上一个易用的（易访问的）网站。残障人士指的是那些带有残疾或者身体不健康的用户。\n\n使用 alt 属性：\n\n<img src=\"person.jpg\" alt=\"this is a person\"/>\n\n有时候浏览器会无法显示图像。具体的原因有： 用户关闭了图像显示\n\n浏览器是不支持图形显示的迷你浏览器\n\n浏览器是语音浏览器（供盲人和弱视人群使用）\n\n如果您使用了 alt 属性，那么浏览器至少可以显示或读出有关图像的描述。\n\n- ### 几个很实用的 BOM 属性对象方法?\n\n参考回答：\n\n什么是 Bom? Bom 是浏览器对象。有哪些常用的 Bom 属性呢？ (1)location 对象\n\nlocation.href-- 返 回 或 设 置 当 前 文 档 的 URL location.search -- 返回 URL 中的查询字符串部分。例\n\n如\n[_http://www.dreamdu.com/dreamdu.php?id=5&name=dreamdu_](http://www.dreamdu.com/dreamdu.php?id=5&name=dreamdu)\n返回包括(?)后面的内容?id=5&name=dreamdu\n\nlocation.hash -- 返回 URL#后面的内容，如果没有#，返回空location.host -- 返回 URL 中的域名部分，例如\n[_www.dreamdu.com_](http://www.dreamdu.com/) location.hostname -- 返回 URL 中的主域名部分，例如 dreamdu.com\nlocation.pathname -- 返回 URL 的域名后的部分。例\n\n如 [_http://www.dreamdu.com/xhtml/_](http://www.dreamdu.com/xhtml/) 返回/xhtml/ location.port -- 返回 URL\n中的端口部分。例\n\n如 _<http://www.dreamdu.com:8080/xhtml/>_ 返 回 8080\n\nlocation.protocol -- 返回 URL 中的协议部分。例\n\n如 _<http://www.dreamdu.com:8080/xhtml/>_ 返回(//)前面的内容 http: location.assign -- 设置当前文档的 URL\n\nlocation.replace() -- 设置当前文档的 URL，并且在 history 对象的地址列表中移除这个 URL location.replace(url);\n\nlocation.reload() -- 重载当前页面(2)history 对象\n\nhistory.go() -- 前进或后退指定的页面数 history.go(num); history.back() -- 后退一页\n\nhistory.forward() -- 前进一页(3)Navigator 对象\n\nnavigator.userAgent -- 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)\n\nnavigator.cookieEnabled -- 返回浏览器是否支持(启用)cookie\n\n- ### 说一下 HTML5 drag api\n\n参考回答：\n\ndragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发，。darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。dragend：事件主体是被拖放元素，在整个拖放操作结束时触发\n\n- ### 说一下 http2.0\n\n参考回答：\n\n首先补充一下，http 和 https 的区别，相比于 http,https 是基于 ssl 加密的 http 协议\n\n简要概括：http2.0 是基于 1999 年发布的 http1.0 之后的首次更新。\n\n提升访问速度（可以对于，请求资源所需时间更少，访问速度更快，相比 http1.0） 允许多路复用：多路复用允许同时通过单一的 HTTP/2 连接发送多重请求-响应信息。改善了：在 http1.1\n中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。\n\n二进制分帧：HTTP2.0 会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码\n\n首部压缩\n\n服务器端推送\n\n- ### 补充 400 和 401、403 状态码\n\n参考回答：\n\n(1)400 状态码：请求无效产生原因：\n\n前端提交数据的字段名称和字段类型与后台的实体没有保持一致\n\n前端提交到后台的数据应该是 json 字符串类型，但是前端没有将对象 JSON.stringify\n\n转化成字符串。解决方法：\n\n对照字段的名称，保持一致性\n\n将 obj 对象通过 JSON.stringify 实现序列化(2)401 状态码：当前请求需要用户验证\n\n3. 403 状态码：服务器已经得到请求，但是拒绝执行\n\n- ### fetch 发送 2 次请求的原因\n\n参考回答：\n\nfetch 发送 post 请求的时候，总是发送 2 次，第一次状态码是 204，第二次才成功？ 原因很简单，因为你用 fetch 的 post 请求的时候，导致 fetch\n第一次发送了一个Options 请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。\n\n- ### Cookie、sessionStorage、localStorage 的区别\n\n参考回答：\n\n共同点：都是保存在浏览器端，并且是同源的\n\nCookie：cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递。而 sessionStorage 和 localStorage\n不会自动把数据发给服务器，仅在本地保存。cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下,存储的大小很小只有 4K 左右。\n（key：可以在浏览器和服务器端来回传递，存储容量小，只有大约 4K 左右）\n\nsessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持， localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据； cookie 只在设置的\ncookie 过期时间之前一直有效，即使窗口或浏览器关闭。（key： 本身就是一个回话过程，关闭浏览器后消失，session 为一个回话，当页面不同即使是同一页面打开两次，也被视为同一次回话）\n\nlocalStorage：localStorage 在所有同源窗口中都是共享的；cookie\n也是在所有同源窗口中都是共享的。（key：同源窗口都会共享，并且不会失效，不管窗口或者浏览器关闭与否都会始终生效）\n\n补充说明一下 cookie 的作用：\n\n保存用户登录状态。例如将用户 id 存储于一个 cookie 内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie\n还可以设置过期时间，当超过时间期限后，cookie 就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。\n\n跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了 cookie 后就会显得很人性化了，\n系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后\n台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便定制页面。如果网站提供了换肤或更换布局的功能， 那么可以使用 cookie\n来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。\n\n- ### 说一下 web worker\n\n参考回答：\n\n在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面你的性能。并且通过\npostMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。\n\n如何创建 web worker：\n\n检测浏览器对于 web worker 的支持性\n\n创建 web worker 文件（js，回传函数等） 创建 web worker 对象\n\n- ### 对 HTML 语义化标签的理解\n\n参考回答：\n\nHTML5 语义化标签是指正确的标签包含了正确的内容，结构良好，便于阅读，比如 nav\n\n表示导航条，类似的还有 article、header、footer 等等标签。\n\n- ### iframe 是什么？有什么缺点？\n\n参考回答：\n\n定义：iframe 元素会创建包含另一个文档的内联框架\n\n提示：可以将提示文字放在\\<iframe>\\</iframe>之间，来提示某些不支持 iframe 的浏览器\n\n缺点：\n\n会阻塞主页面的 onload 事件\n\n搜索引擎无法解读这种页面，不利于 SEO\n\niframe 和主页面共享连接池，而浏览器对相同区域有限制所以会影响性能。\n\n- ### Doctype 作用?严格模式与混杂模式如何区分？它们有何意义?\n\n参考回答：\n\nDoctype 声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。\n\n严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。\n\n混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。\n\n- ### Cookie 如何防范 XSS 攻击\n\n参考回答：\n\nXSS（跨站脚本攻击）是指攻击者在返回的 HTML 中嵌入 javascript 脚本，为了减轻这些攻击，需要在 HTTP 头部配上，set-cookie：\n\nhttponly-这个属性可以防止 XSS,它会禁止 javascript 脚本来访问 cookie。secure - 这个属性告诉浏览器仅在请求为 https 的时候发送 cookie。\n\n结果应该是这样的：Set-Cookie=\\<cookie-value>.\n\n- ### Cookie 和 session 的区别\n\n参考回答：\n\nHTTP 是一个无状态协议，因此 Cookie 的最大的作用就是存储 sessionId 用来唯一标识用户。\n\n- ### 一句话概括 RESTFUL\n\n参考回答：\n\n就是用 URL 定位资源，用 HTTP 描述操作。\n\n- ### 讲讲 viewport 和移动端布局\n\n参考回答：\n\n可以参考这篇文章：\n\n[_响应式布局的常用解决方案对比(媒体查询、百分比、rem 和 vw/vh）_](https://github.com/forthealllight/blog/issues/13)\n\n- ### click 在 ios 上有 300ms 延迟，原因及如何解决？\n\n参考回答：\n\n1. 粗暴型，禁用缩放\n\n<meta name=\"viewport\" content=\"width=device-width, user-scalable=no\"> (2)利用 FastClick，其原理是：\n\n检测到 touchend 事件后，立刻出发模拟 click 事件，并且把浏览器 300 毫秒之后真正出发的事件给阻断掉\n\n- ### addEventListener 参数\n\n参考回答：\n\naddEventListener(event, function, useCapture)\n\n其中，event 指定事件名；function 指定要事件触发时执行的函数；useCapture 指定事件是否在捕获或冒泡阶段执行。\n\n- ### cookie sessionStorage localStorage 区别\n\n参考回答：\n\ncookie 数据始终在同源的 http 请求中携带(即使不需要)，即 cookie 在浏览器和服务器间来回传递\n\ncookie 数据还有路径（path）的概念，可以限制。cookie 只属于某个路径下\n\n存储大小限制也不同，cookie 数据不能超过 4K，同时因为每次 http 请求都会携带\n\ncookie，所以 cookie 只适合保存很小的数据，如回话标识。\n\nwebStorage 虽然也有存储大小的限制，但是比 cookie 大得多，可以达到 5M 或更大数据的有效期不同 sessionStorage：仅在当前的浏览器窗口关闭有效；\nlocalStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据； cookie：只在设置的 cookie 过期时间之前一直有效，即使窗口和浏览器关闭\n\n作用域不同 sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面； localStorage：在所有同源窗口都是共享的；cookie：也是在所有同源窗口中共享的\n\n- ### cookie session 区别\n\n参考回答：\n\n1. cookie 数据存放在客户的浏览器上，session 数据放在服务器上。\n\n2. cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗\n\n考虑到安全应当使用 session。\n\n3. session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能\n\n考虑到减轻服务器性能方面，应当使用 COOKIE。\n\n4. 单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个cookie。\n\n- ### 介绍知道的 http 返回的状态码\n\n参考回答：\n\n100 Continue 继续。客户端应继续其请求\n\n101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议\n\n200 OK 请求成功。一般用于 GET 与 POST 请求\n\n201 Created 已创建。成功请求并创建了新的资源\n\n202 Accepted 已接受。已经接受请求，但未处理完成\n\n203 Non-Authoritative Information 非授权信息。请求成功。但返回的 meta 信息不在原始的服务器，而是一个副本\n\n204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档\n\n205 Reset Content 重置内容。服务器处理成功，用户终端（例如： 浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域\n\n206 Partial Content 部分内容。服务器成功处理了部分 GET 请求\n\n300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择\n\n301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替\n\n302 Found 临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有 URI\n\n303 See Other 查看其它地址。与 301 类似。使用 GET 和 POST 请求查看\n\n304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源\n\n305 Use Proxy 使用代理。所请求的资源必须通过代理访问\n\n306 Unused 已经被废弃的 HTTP 状态码\n\n307 Temporary Redirect 临时重定向。与 302 类似。使用 GET 请求重定向\n\n400 Bad Request 客户端请求的语法错误，服务器无法理解401 Unauthorized 请求要求用户的身份认证\n\n402 Payment Required 保留，将来使用\n\n403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求\n\n404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面\n\n405 Method Not Allowed 客户端请求中的方法被禁止\n\n406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求407 Proxy Authentication Required 请求要求代理的身份认证，与401\n类似，但请求者应当使用代理进行授权\n\n408 Request Time-out 服务器等待客户端发送的请求时间过长，超时\n\n409 Conflict 服务器完成客户端的 PUT 请求是可能返回此代码，服务器处理请求时发生了冲突\n\n410 Gone 客户端请求的资源已经不存在。410 不同于 404，如果资源以前有现在被永久删除了可使用 410 代码，网站设计人员可通过 301 代码指定资源的新位置\n\n411 Length Required 服务器无法处理客户端发送的不带 Content- Length 的请求信息\n\n412 Precondition Failed 客户端请求信息的先决条件错误\n\n413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个\nRetry-After 的响应信息\n\n414 Request-URI Too Large 请求的 URI 过长（URI 通常为网址），服务器无法处理\n\n415 Unsupported Media Type 服务器无法处理请求附带的媒体格式416 Requested range not satisfiable 客户端请求的范围无效417\nExpectation Failed 服务器无法满足 Expect 的请求头信息 500 Internal Server Error 服务器内部错误，无法完成请求\n\n501 Not Implemented 服务器不支持请求的功能，无法完成请求\n\n502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时， 从远程服务器接收到了一个无效的响应\n\n503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中\n\n504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求\n\n505 HTTP Version not supported 服务器不支持请求的 HTTP 协议的版本，无法完成处理\n\n- ### http 常用请求头\n\n参考回答：\n\n[TABLE]\n\n[TABLE]\n\n[TABLE]\n\n- ### 强，协商缓存\n\n参考回答：\n\n缓存分为两种：强缓存和协商缓存，根据响应的 header 内容来决定。\n\n[TABLE]\n\n强缓存相关字段有 expires，cache-control。如果 cache-control 与 expires 同时存在的话，cache-control 的优先级高于 expires。\n\n协商缓存相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match\n\n- ### 讲讲 304\n\n参考回答：\n\n304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个 304 状态\n\n码。\n\n- ### 强缓存、协商缓存什么时候用哪个\n\n参考回答：\n\n因为服务器上的资源不是一直固定不变的，大多数情况下它会更新，这个时候如果我们还访问本地缓存，那么对用户来说，那就相当于资源没有更新，用户看到的还是旧的资源；所以我们希望服务器上的资源更新了浏览器就请求新的资源，没有更新就使用本地的缓存，以最大程度的减少因网络请求而产生的资源浪费。\n\n![](media/image1.jpeg)\n\n参考 [_https://segmentfault.com/a/1190000008956069_](https://segmentfault.com/a/1190000008956069)\n\n- ### 前端优化\n\n参考回答：\n\n降低请求量：合并资源，减少 HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。\n\n加快请求速度：预解析 DNS，减少域名数，并行加载，CDN 分发。\n\n缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage。\n\n渲染：JS/CSS 优化，加载顺序，服务端渲染，pipeline。\n\n- ### GET 和 POST 的区别\n\n参考回答：\n\nget 参数通过 url 传递，post 放在 request body 中。\n\nget 请求在 url 中传递的参数是有长度限制的，而 post 没有。\n\nget 比 post 更不安全，因为参数直接暴露在 url 中，所以不能用来传递敏感信息。get 请求只能进行 url 编码，而 post 支持多种编码方式\n\nget 请求会浏览器主动 cache，而 post 支持多种编码方式。\n\nget 请求参数会被完整保留在浏览历史记录里，而 post 中的参数不会被保留。\n\nGET 和 POST 本质上就是 TCP 链接，并无差别。但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。\n\nGET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。\n\n- ### 301 和 302 的区别\n\n参考回答：\n\n301 Moved Permanently 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI\n之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。\n\n302 Found 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires\n中进行了指定的情况下，这个响应才是可缓存的。\n\n字面上的区别就是 301 是永久重定向，而 302 是临时重定向。\n\n301 比较常用的场景是使用域名跳转。302 用来做临时跳转 比如未登陆的用户访问用户中心重定向到登录页面。\n\n- ### HTTP 支持的方法\n\n参考回答：\n\n### GET, POST, HEAD, OPTIONS, PUT, DELETE, TRACE, CONNECT\n\n- ### 如何画一个三角形\n\n参考回答：\n\n三角形原理：边框的均分原理\n\n### div { width:0px; height:0px\n\n> border-top:10px solid red;\n\n> border-right:10px solid transparent; border-bottom:10px solid transparent; border-left:10px solid\n> transparent;\n\n> }\n\n- ### 状态码 304 和 200\n\n参考回答：\n\n状态码 200：请求已成功，请求所希望的响应头或数据体将随此响应返回。即返回的数据为全量的数据，如果文件不通过 GZIP 压缩的话，文件是多大，则要有多大传输量。状态码\n304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状\n态码。即客户端和服务器端只需要传输很少的数据量来做文件的校验，如果文件没有 修改过，则不需要返回全量的数据。\n\n- ### 说一下浏览器缓存\n\n参考回答：\n\n缓存分为两种：强缓存和协商缓存，根据响应的 header 内容来决定。\n\n强缓存相关字段有 expires，cache-control。如果 cache-control 与 expires 同时存在的话，cache-control 的优先级高于 expires。\n\n协商缓存相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match\n\n- ### HTML5 新增的元素\n\n参考回答：\n\n首先 html5 为了更好的实践 web 语义化，增加了 header，footer，nav,aside,section\n\n等语义化标签，在表单方面，为了增强表单，为 input 增加了 color，\n\nemial,data ,range 等类型，在存储方面，提供了\nsessionStorage，localStorage,和离线存储，通过这些存储方式方便数据在客户端的存储和获取，在多媒体方面规定了音频和视频元素 audio 和\nvedio，另外还有地理定位，canvas 画布，拖放，多线程编程的 web worker 和 websocket 协议。\n\n- ### 在地址栏里输入一个 URL,到这个页面呈现出来，中间会发生什么？\n\n参考回答：\n\n这是一个必考的面试问题，\n\n输入 url 后，首先需要找到这个 url 域名的服务器 ip,为了寻找这个 ip，浏览器首先会寻找缓存，查看缓存中是否有记录，缓存的查找记录为：浏览器缓存-》系统缓存\n\n-》路由器缓存，缓存中没有则查找系统的 hosts 文件中是否有记录，如果没有则查询DNS 服务器，得到服务器的 ip 地址后，浏览器根据这个 ip 以及相应的端口号，构造一个 http\n请求，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并将这个 http 请求封装在一个 tcp 包中，这个 tcp\n包会依次经过传输层，网络层，数据链路层，物理层到达服务器，服务器解析这个请求来作出响应，返回相应的 html 给浏览器，因为 html 是一个树形结构，浏览器根据这个 html 来构建DOM 树，在\ndom 树的构建过程中如果遇到 JS 脚本和外部 JS 连接，则会停止构建 DOM 树来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐 JS 代码应该放在 html\n代码的后面，之后根据外部央视，内部央视，内联样式构建一个 CSS 对象模型树 CSSOM 树，构建完成后和 DOM 树合并为渲染树，这里主要做的是排除非视觉节点，比如\n\nscript，meta 标签和排除 display 为 none 的节点，之后进行布局，布局主要是确定各个元素的位置和尺寸，之后是渲染页面，因为 html 文件中会含有图片，视频，音频等资源，在解析\nDOM 的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是 4-6 个，当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过\nCache-Control、Last-Modify、Expires 等首部字段控制。Cache-Control 和 Expires 的区别在于 Cache-Control 使用相对时间，Expires\n使用的是基于服务器 端的绝对时间，因为存在时差问题，一般采用 Cache-Control，在请求这些有设置了缓存的数据时，会先\n查看是否过期，如果没有过期则直接使用本地缓存，过期则请求并在服务器校验文件是否修改，如果上一次 响应设置了 ETag 值会在这次请求的时候作为 If-None-Match\n的值交给服务器校验，如果一致，继续校验Last-Modified，没有设置 ETag 则直接验证 Last-Modified，再决定是否返回 304。\n\n- ### cookie 和 session 的区别，localstorage 和 sessionstorage 的区别\n\n参考回答：\n\nCookie 和 session 都可用来存储用户信息，cookie 存放于客户端，session 存放于服务器端，因为cookie 存放于客户端有可能被窃取，所以 cookie\n一般用来存放不敏感的信息，比如用户设置的网站主题，敏感的信息用 session 存储，比如用户的登陆信息，session 可以存放于文件，数据库，内存中都可以，cookie\n可以服务器端响应的时候设置，也可以客户端通过 JS 设置 cookie 会在请求时在 http 首部发送给客户端， cookie 一般在客户端有大小限制，一般为 4K，\n\n下面从几个方向区分一下 cookie，localstorage，sessionstorage 的区别1、生命周期：\n\nCookie：可设置失效时间，否则默认为关闭浏览器后失效Localstorage:除非被手动清除，否则永久保存\n\nSessionstorage：仅在当前网页会话下有效，关闭页面或浏览器后就会被清除 2、存放数据：\n\nCookie：4k 左右\n\nLocalstorage 和 sessionstorage：可以保存 5M 的信息3、http 请求：\n\nCookie：每次都会携带在 http 头中，如果使用 cookie 保存过多数据会带来性能问题其他两个：仅在客户端即浏览器中保存，不参与和服务器的通信\n\n4、易用性：\n\nCookie：需要程序员自己封装，原生的 cookie 接口不友好其他两个：即可采用原生接口，亦可再次封装\n\n5、应用场景：\n\n从安全性来说，因为每次 http 请求都回携带 cookie 信息，这样子浪费了带宽，所以cookie 应该尽可能的少用，此外 cookie\n还需要指定作用域，不可以跨域调用，限制很多，但是用户识别用户登陆来说，cookie 还是比storage 好用，其他情况下可以用storage，localstorage\n可以用来在页面传递参数，sessionstorage 可以用来保存一些临时的数据，防止用户刷新页面后丢失了一些参数。\n\n- ### 常见的 HTTP 的头部\n\n参考回答：\n\n可以将 http 首部分为通用首部，请求首部，响应首部，实体首部通用首部表示一些通用信息，比如 date 表示报文创建时间，\n\n请求首部就是请求报文中独有的，如 cookie，和缓存相关的如 if-Modified-Since\n\n响应首部就是响应报文中独有的，如 set-cookie，和重定向相关的 location，\n\n实体首部用来描述实体部分，如 allow 用来描述可执行的请求方法，content-type 描述主题类型，content-Encoding 描述主体的编码方式。\n\n- ### HTTP2.0 的特性\n\n参考回答：\n\nhttp2.0 的特性如下：\n\n1、内容安全，应为 http2.0 是基于 https 的，天然具有安全特性，通过 http2.0 的特性可以避免单纯使用 https 的性能下降\n\n2、二进制格式，http1.X 的解析是基于文本的，http2.0 将所有的传输信息分割为更小的消息和帧，并对他们采用二进制格式编码，基于二进制可以让协议有更多的扩展性，比如引入了帧来传输数据和指令\n\n3、多路复用，这个功能相当于是长连接的增强，每个 request 请求可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里\n面，另外多路复用中也支持了流的优先级，允许客户端告诉服务器那些内容是更优先级的资源，可以优先传输。\n\n- ### cache-control 的值有哪些\n\n参考回答：\n\ncache-control 是一个通用消息头字段被用于 HTTP 请求和响应中，通过指定指令来实现缓存机制，这个缓存指令是单向的，常见的取值有\nprivate、no-cache、max-age、must-revalidate 等，默认为 private。\n\n- ### 浏览器在生成页面的时候，会生成那两颗树？\n\n参考回答：\n\n构造两棵树，DOM 树和 CSSOM 规则树，\n\n当浏览器接收到服务器相应来的 HTML 文档后，会遍历文档节点，生成 DOM 树， CSSOM 规则树由浏览器解析 CSS 文件生成。\n\n- ### csrf 和 xss 的网络攻击及防范\n\n参考回答：\n\nCSRF：跨站请求伪造，可以理解为攻击者盗用了用户的身份，以用户的名义发送了恶意请求，比如用户登录了一个网站后，立刻在另一个ｔａｂ页面访问量攻击者用来制\n\n造攻击的网站，这个网站要求访问刚刚登陆的网站，并发送了一个恶意请求，这时候CSRF\n就产生了，比如这个制造攻击的网站使用一张图片，但是这种图片的链接却是可以修改数据库的，这时候攻击者就可以以用户的名义操作这个数据库，防御方式的 话：使用验证码，检查 https 头部的\nrefer，使用 token XSS：跨站脚本攻击，是说攻击者通过注入恶意的脚本，在用户浏览网页的时候进行攻击，比如获取\ncookie，或者其他用户身份信息，可以分为存储型和反射型，存储型是攻击者输入一些数据并且存储到了数据库中，其他浏览者看到的时候进行攻击，反射型的话不存储在数据库中，往往表现为将攻击代码放在 url\n地址的请求参数中，防御的话为 cookie 设置 httpOnly 属性，对用户的输入进行检查，进行特殊字符过滤。\n\n- ### 怎么看网站的性能如何\n\n参考回答：\n\n检测页面加载时间一般有两种方式，一种是被动去测：就是在被检测的页面置入脚本或探针，当用户访问网页时，探针自动采集数据并传回数据库进行分析，另一种主动监测的方式，即主动的搭建分布式受控环境，模拟用户发起页面访问请求，主动采集性能数据并分析，在检测的精准度上，专业的第三方工具效果更佳，比如说性能极\n客。\n\n- ### 介绍 HTTP 协议(特征)\n\n参考回答：\n\nHTTP 是一个基于 TCP/IP 通信协议来传递数据（HTML 文件, 图片文件, 查询结果等） HTTP 是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于\n1990 年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在 WWW 中使用的是 HTTP/1.0 的第六版，HTTP/1.1 的规范化工作正在进行之中，而且 HTTP-NG(Next\nGeneration of HTTP)的建议已经提出。HTTP 协议工作于客户端-服务端架构为上。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器发送所有请求。Web\n服务器根据接收到的请求后，向客户端发送响应信息。\n\n- ### 输入 URL 到页面加载显示完成发生了什么?\n\n参考回答： DNS 解析TCP 连接\n\n发送 HTTP 请求\n\n服务器处理请求并返回 HTTP 报文浏览器解析渲染页面\n\n连接结束\n\n- ### 说一下对 Cookie 和 Session 的认知，Cookie 有哪些限制？\n\n参考回答：\n\n1. cookie 数据存放在客户的浏览器上，session 数据放在服务器上。\n\n2. cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗\n\n考虑到安全应当使用 session。\n\n3. session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能\n\n考虑到减轻服务器性能方面，应当使用 COOKIE。\n\n4. 单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个cookie。\n\n- ### 描述一下 XSS 和 CRSF 攻击？防御方法？\n\n参考回答：\n\nXSS, 即为（Cross Site Scripting）, 中文名为跨站脚本, 是发生在目标用户的浏览器层面上的，当渲染 DOM 树的过程成发生了不在预期内执行的 JS 代码时，就发生了XSS\n攻击。大多数 XSS 攻击的主要方式是嵌入一段远程或者第三方域上的 JS 代码。实际上是在目标网站的作用域下执行了这段 JS 代码。\n\nCSRF（Cross Site Request Forgery，跨站请求伪造），字面理解意思就是在别的站点伪造了一个请求。专业术语来说就是在受害者访问一个网站时，其 Cookie\n还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。\n\nXSS 防御的总体思路是：对输入(和 URL 参数)进行过滤，对输出进行编码。也就是对提交的所有内容进行过滤，对 url\n中的参数进行过滤，过滤掉会导致脚本执行的相关内容；然后对动态输出到页面的内容进行 html 编码，使脚本无法在浏览器中执行。虽然对输入过滤可以被绕过，但是也还是会拦截很大一部分的 XSS 攻击。\n\n防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token\n\n并验证；在 HTTP 头中自定义属性并验证。\n\n- ### 知道 304 吗，什么时候用 304？\n\n参考回答：\n\n304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个 304 状态\n\n码。\n\n- ### 具体有哪些请求头是跟缓存相关的\n\n参考回答：\n\n缓存分为两种：强缓存和协商缓存，根据响应的 header 内容来决定。\n\n强缓存相关字段有 expires，cache-control。如果 cache-control 与 expires 同时存在的话，cache-control 的优先级高于 expires。\n\n协商缓存相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match\n\n- ### cookie 和 session 的区别\n\n参考回答：\n\n1. cookie 数据存放在客户的浏览器上，session 数据放在服务器上。\n\n2. cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗\n\n考虑到安全应当使用 session。\n\n3. session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能\n\n考虑到减轻服务器性能方面，应当使用 COOKIE。\n\n4. 单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个cookie。\n\n- ### cookie 有哪些字段可以设置\n\n参考回答：\n\nname 字段为一个 cookie 的名称。value 字段为一个 cookie 的值。\n\ndomain 字段为可以访问此 cookie 的域名。\n\n非顶级域名，如二级域名或者三级域名，设置的 cookie 的 domain 只能为顶级域名或者二级域名或者三级域名本身，不能设置其他二级域名的 cookie，否则 cookie 无法生成。\n\n顶级域名只能设置 domain 为顶级域名，不能设置为二级域名或者三级域名，否则\n\ncookie 无法生成。\n\n二级域名能读取设置了 domain 为顶级域名或者自身的 cookie，不能读取其他二级域名domain 的 cookie。所以要想 cookie 在多个二级域名中共享，需要设置 domain\n为顶级域名，这样就可以在所有二级域名里面或者到这个 cookie 的值了。\n\n顶级域名只能获取到 domain 设置为顶级域名的 cookie，其他 domain 设置为二级域名的无法获取。\n\npath 字段为可以访问此 cookie 的页面路径。 比如 domain 是 abc.com,path 是/test， 那么只有/test 路径下的页面可以读取此 cookie。\n\nexpires/Max-Age 字段为此 cookie 超时时间。若设置其值为一个时间，那么当到达此时间后，此 cookie 失效。不设置的话默认值是 Session，意思是 cookie\n会和session 一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie 失效。\n\nSize 字段 此 cookie 大小。\n\nhttp 字段 cookie 的 httponly 属性。若此属性为 true，则只有在 http 请求头中会带有此 cookie 的信息，而不能通过 document.cookie 来访问此\ncookie。\n\nsecure 字段 设置是否只能通过 https 来传递此条 cookie\n\n- ### cookie 有哪些编码方式？\n\n参 考 回 答 ： encodeURI（）\n\n- ### 除了 cookie，还有什么存储方式。说说 cookie 和 localStorage 的区别\n\n参考回答：\n\n还有 localStorage，sessionStorage，indexdDB 等cookie 和 localStorage 的区别：\n\ncookie 数据始终在同源的 http 请求中携带(即使不需要)，即 cookie 在浏览器和服务器间来回传递\n\ncookie 数据还有路径（path）的概念，可以限制。cookie 只属于某个路径下\n\n存储大小限制也不同，cookie 数据不能超过 4K，同时因为每次 http 请求都会携带\n\ncookie，所以 cookie 只适合保存很小的数据，如回话标识。\n\nlocalStorage 虽然也有存储大小的限制，但是比cookie 大得多，可以达到 5M 或更大localStorage 始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie\n只在设置的 cookie 过期时间之前一直有效，即使窗口和浏览器关闭。\n\n- ### 浏览器输入网址到页面渲染全过程\n\n参考回答： DNS 解析TCP 连接\n\n发送 HTTP 请求\n\n服务器处理请求并返回 HTTP 报文浏览器解析渲染页面\n\n连接结束\n\n- ### HTML5 和 CSS3 用的多吗？你了解它们的新属性吗？有在项目中用过吗？\n\n参考回答： html5： 1）标签增删\n\n8 个语义元素 header section footer aside nav main article figure 内容元素 mark 高亮 progress 进度\n\n新的表单控件 calander date time email url search\n\n新的 input 类型 color date datetime datetime-local email 移除过时标签 big font frame frameset\n\n2）canvas 绘图，支持内联 SVG。支持 MathML 3）多媒体 audio video source embed track\n\n4. 本地离线存储，把需要离线存储在本地的文件列在一个 manifest 配置文件\n\n5. web 存储。localStorage、SessionStorage\n\ncss3：\n\nCSS3 边框如 border-radius，box-shadow 等；CSS3 背景如 background-size， background-origin 等；CSS3 2D，3D 转换如\ntransform 等；CSS3 动画如 animation 等。 参考\n[_https://www.cnblogs.com/xkweb/p/5862612.html_](https://www.cnblogs.com/xkweb/p/5862612.html)\n\n- ### http 常见的请求方法\n\n参考回答：\n\nget、post，这两个用的是最多的，还有很多比如 patch、delete、put、options 等等\n\n- ### get 和 post 的区别\n\n参考回答：\n\nGET - 从指定的资源请求数据。\n\nPOST - 向指定的资源提交要被处理的数据。\n\nGET：不同的浏览器和服务器不同，一般限制在 2\\~8K 之间，更加常见的是 1k 以内。GET 和 POST 的底层也是 TCP/IP，GET/POST 都是 TCP 链接。\n\nGET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。\n\n对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应\n\n200（返回数据）；\n\n而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送data，服务器响应 200 ok（返回数据）。\n\n- ### 说说 302，301，304 的状态码\n\n参考回答：\n\n301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替\n\n302 Found 临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有 URI\n\n304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源\n\n- ### web 性能优化\n\n参考回答：\n\n降低请求量：合并资源，减少 HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。\n\n加快请求速度：预解析 DNS，减少域名数，并行加载，CDN 分发。\n\n缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage。\n\n渲染：JS/CSS 优化，加载顺序，服务端渲染，pipeline。\n\n- ### 浏览器缓存机制\n\n参考回答：\n\n缓存分为两种：强缓存和协商缓存，根据响应的 header 内容来决定。\n\n强缓存相关字段有 expires，cache-control。如果 cache-control 与 expires 同时存在的话，cache-control 的优先级高于 expires。\n\n协商缓存相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match\n\n- ### post 和 get 区别\n\n参考回答：\n\nGET - 从指定的资源请求数据。\n\nPOST - 向指定的资源提交要被处理的数据。\n\nGET：不同的浏览器和服务器不同，一般限制在 2\\~8K 之间，更加常见的是 1k 以内。GET 和 POST 的底层也是 TCP/IP，GET/POST 都是 TCP 链接。\n\nGET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。\n\n对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应\n\n200（返回数据）；\n\n而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送data，服务器响应 200 ok（返回数据）。\n\n## 1.2 \\| CSS\n\n- ### 说一下 css 盒模型\n\n参考回答：\n\n简介：就是用来装页面上的元素的矩形区域。CSS 中的盒子模型包括 IE 盒子模型和标准的 W3C 盒子模型。\n\nbox-sizing(有 3 个值哦)：border-box,padding-box,content-box. 标准盒子模型：\n\n![](media/image2.jpeg)\n\n![](media/image3.jpeg) IE 盒子模型：\n\n区别：从图中我们可以看出，这两种盒子模型最主要的区别就是 width 的包含范围， 在标准的盒子模型中，width 指 content 部分的宽度，在 IE 盒子模型中，width\n表示content+padding+border 这三个部分的宽度，故这使得在计算整个盒子的宽度时存在着差异：\n\n标准盒子模型的盒子宽度：左右 border+左右 padding+width IE 盒子模型的盒子宽度：width\n\n在 CSS3 中引入了 box-sizing 属性，box-sizing:content-box;表示标准的盒子模型，\n\nbox-sizing:border-box 表示的是 IE 盒子模型\n\n最后，前面我们还提到了，box-sizing:padding-box,这个属性值的宽度包含了左右\n\npadding+width\n\n也很好理解性记忆，包含什么，width 就从什么开始算起。\n\n- ### 画一条 0.5px 的线\n\n参考回答：\n\n采用 meta viewport 的方式\n\n<meta name=\"viewport\" content=\"initial-scale=1.0, maximum-scale=1.0, user- scalable=no\" />\n\n采用 border-image 的方式\n\n采用 transform: scale()的方式\n\n- ### link 标签和 import 标签的区别\n\n参考回答：\n\nlink 属于 html 标签，而@import 是 css 提供的\n\n页面被加载时，link 会同时被加载，而@import 引用的 css 会等到页面加载结束后加载。\n\nlink 是 html 标签，因此没有兼容性，而@import 只有 IE5 以上才能识别。link 方式样式的权重高于@import 的。\n\n- ### transition 和 animation 的区别\n\n参考回答：\n\nAnimation 和 transition 大部分属性是相同的，他们都是随时间改变元素的属性值， 他们的主要区别是 transition 需要触发一个事件才能改变属性，而 animation\n不需要触发任何事件的情况下才会随时间改变属性值，并且 transition 为 2 帧，从\n\nfrom to，而 animation 可以一帧一帧的。\n\n- ### Flex 布局\n\n参考回答： 文章链接：\n\n[_http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool_](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool%EF%BC%88%E8%AF%AD%E6%B3%95%E7%AF%87%EF%BC%89)\n\n[_（语法篇）_](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool%EF%BC%88%E8%AF%AD%E6%B3%95%E7%AF%87%EF%BC%89)\n\n[_http://www.ruanyifeng.com/blog/2015/07/flex-examples.html（实例篇）_](http://www.ruanyifeng.com/blog/2015/07/flex-examples.html%EF%BC%88%E5%AE%9E%E4%BE%8B%E7%AF%87%EF%BC%89)Flex\n是\n\nFlexible Box 的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。\n\n布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。\n\n简单的分为容器属性和元素属性容器的属性：\n\nflex-direction：决定主轴的方向（即子 item 的排列方法）\n\n.box {\n\nflex-direction: row \\| row-reverse \\| column \\| column-reverse;\n\n}\n\nflex-wrap：决定换行规则\n\n.box{\n\nflex-wrap: nowrap \\| wrap \\| wrap-reverse;\n\n}\n\nflex-flow：\n\n.box {\n\nflex-flow: \\<flex-direction> \\|\\| \\<flex-wrap>;\n\n}\n\njustify-content：对其方式，水平主轴对齐方式align-items：对齐方式，竖直轴线方向\n\n项目的属性（元素的属性）：\n\norder 属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为 0 flex-grow 属性：定义项目的放大比例，即使存在空间，也不会放大\n\nflex-shrink 属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果定义个 item 的 flow-shrink 为 0，则为不缩小\n\nflex-basis 属性：定义了在分配多余的空间，项目占据的空间。\n\nflex：是 flex-grow 和 flex-shrink、flex-basis 的简写，默认值为 0 1 auto。align-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖\nalign-items，默认属性为 auto，表示继承父元素的 align-items\n\n比如说，用 flex 实现圣杯布局\n\n- ### BFC（块级格式化上下文，用于清楚浮动，防止 margin 重叠等）\n\n参考回答：\n\n直译成：块级格式化上下文，是一个独立的渲染区域，并且有一定的布局规则。BFC 区域不会与 float box 重叠\n\nBFC 是页面上的一个独立容器，子元素不会影响到外面计算 BFC 的高度时，浮动元素也会参与计算\n\n那些元素会生成 BFC：\n\n根元素\n\nfloat 不为 none 的元素\n\nposition 为 fixed 和 absolute 的元素\n\ndisplay 为 inline-block、table-cell、table-caption，flex，inline-flex 的元素overflow 不为 visible 的元素\n\n- ### 垂直居中的方法\n\n参 考 回 答 ： (1)margin:auto 法css:\n\n### div{\n\n> width: 400px; height: 400px; position: relative;\n\n> border: 1px solid #465468;\n\n> } img{\n\n> position: absolute; margin: auto;\n\n> top: 0; left: 0; right: 0; bottom: 0;\n\n> } html:\n\n> <div>\n\n> <img src=\"mm.jpg\">\n\n> </div>\n\n定位为上下左右为 0，margin：0 可以实现脱离文档流的居中. (2)margin 负值法\n\n### .container{ width: 500px; height: 400px\n\n> border: 2px solid #379; position: relative;\n\n> }\n\n> .inner{ width: 480px;\n\n> height: 380px; background-color: #746; position: absolute; top: 50%;\n\n> left: 50%;\n\nmargin-top: -190px; /\\*height 的一半\\*/ margin-left: -240px; /\\*width 的一半\\*/\n\n}\n\n补充：其实这里也可以将 marin-top 和 margin-left 负值替换成， transform：translateX(-50%) 和 transform：translateY(-50%)\n(3)table-cell（未脱离文档流的）\n\n设置父元素的 display:table-cell,并且 vertical-align:middle，这样子元素可以实现垂直居中。\n\n### css: div{\n\n> width: 300px; height: 300px;\n\n> border: 3px solid #555; display: table-cell; vertical-align: middle; text-align: center;\n\n> } img{\n\n> vertical-align: middle;\n\n> }\n\n4. 利用 flex\n\n将父元素设置为 display:flex，并且设置 align-items:center;justify- content:center;\n\n- ### 关于 JS 动画和 css3 动画的差异性\n\n参考回答：\n\n渲染线程分为 main thread 和 compositor thread，如果 css 动画只改变 transform 和opacity，这时整个 CSS 动画得以在 compositor\ntrhead 完成（而 JS 动画则会在 main thread 执行，然后出发 compositor thread 进行下一步操作），特别注意的是如果改变 transform 和 opacity\n是不会 layout 或者 paint 的。\n\n区别：\n\n功能涵盖面，JS 比 CSS 大\n\n实现/重构难度不一，CSS3 比 JS 更加简单，性能跳优方向固定对帧速表现不好的低版本浏览器，css3 可以做到自然降级\n\ncss 动画有天然事件支持css3 有兼容性问题\n\n- ### 说一下块元素和行元素\n\n参考回答：\n\n块元素：独占一行，并且有自动填满父元素，可以设置 margin 和 pading 以及高度和宽度\n\n行元素：不会独占一行，width 和 height 会失效，并且在垂直方向的 padding 和\n\nmargin 会失效。\n\n- ### 多行元素的文本省略号\n\n参考回答：\n\n- ### visibility=hidden, opacity=0，display:none\n\n参考回答：\n\nopacity=0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如 click 事件，那么点击该区域，也能触发点击事件的 visibility=hidden，\n该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件display=none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样。\n\n- ### 双边距重叠问题（外边距折叠）\n\n参考回答：\n\n多个相邻（兄弟或者父子关系）普通流的块元素垂直方向 marigin 会重叠折叠的结果为：\n\n两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。\n\n- ### position 属性 比较\n\n参考回答：\n\n固定定位 fixed：\n\n元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重\n\n叠。\n\n相对定位 relative：\n\n如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。\n在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 绝对定位 absolute：\n\n绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素， 那么它的位置相对于\\<html>。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute\n定位的元素和其他元素重叠。\n\n粘性定位 sticky：\n\n元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和containing\nblock（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。\n\n默认定位 Static：\n\n默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者z-index 声明）。\n\ninherit:\n\n规定应该从父元素继承 position 属性的值。\n\n- ### 浮动清除\n\n参考回答：\n\n方法一：使用带 clear 属性的空元素\n\n在浮动元素后使用一个空元素如\\<div class=\"clear\">\\</div>，并在 CSS 中赋\n\n予.clear{clear:both;}属性即可清理浮动。亦可使用\\<br class=\"clear\" />或\\<hr class=\"clear\" />来进行清理。\n\n方法二：使用 CSS 的 overflow 属性\n\n给浮动元素的容器添加 overflow:hidden;或 overflow:auto;可以清除浮动，另外在IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。\n\n在添加 overflow 属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。\n\n方法三：给浮动的元素的容器添加浮动\n\n给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动， 影响布局，不推荐使用。\n\n方法四：使用邻接元素处理\n\n什么都不做，给浮动元素后面的元素添加 clear 属性。方法五：使用 CSS 的:after 伪元素\n\n结合:after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素） 和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发hasLayout。\n\n给浮动元素的容器添加一个 clearfix 的 class，然后给这个 class 添加一个:after 伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。\n\n参考\n[_https://www.cnblogs.com/ForEvErNoME/p/3383539.html_](https://www.cnblogs.com/ForEvErNoME/p/3383539.html)\n\n- ### css3 新特性\n\n参考回答：\n\n开放题。CSS3 边框如 border-radius，box-shadow 等；CSS3 背景如 background- size，background-origin 等；CSS3 2D，3D 转换如\ntransform 等；CSS3 动画如animation 等。\n\n参考 [_https://www.cnblogs.com/xkweb/p/5862612.html_](https://www.cnblogs.com/xkweb/p/5862612.html)\n\n- ### CSS 选择器有哪些，优先级呢\n\n参考回答：\n\nid 选择器，class 选择器，标签选择器，伪元素选择器，伪类选择器等\n\n同一元素引用了多个样式时，排在后面的样式属性的优先级高；\n\n样式选择器的类型不同时，优先级顺序为：id 选择器 \\> class 选择器 \\> 标签选择器；\n\n标签之间存在层级包含关系时，后代元素会继承祖先元素的样式。如果后代元素定义了与祖先元素相同的样式，则祖先元素的相同的样式属性会被覆盖。继承的样式的优先级比较低，至少比标签选择器的优先级低；\n\n带有!important 标记的样式属性的优先级最高；\n\n样式表的来源不同时，优先级顺序为：内联样式> 内部样式 \\> 外部样式 \\> 浏览器用户自定义样式 \\> 浏览器默认样式\n\n- ### 清除浮动的方法，能讲讲吗\n\n参考回答：\n\n方法一：使用带 clear 属性的空元素\n\n在浮动元素后使用一个空元素如\\<div class=\"clear\">\\</div>，并在 CSS 中赋\n\n予.clear{clear:both;}属性即可清理浮动。亦可使用\\<br class=\"clear\" />或\\<hr class=\"clear\" />来进行清理。\n\n方法二：使用 CSS 的 overflow 属性\n\n给浮动元素的容器添加 overflow:hidden;或 overflow:auto;可以清除浮动，另外在IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。\n\n在添加 overflow 属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。\n\n方法三：给浮动的元素的容器添加浮动\n\n给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动， 影响布局，不推荐使用。\n\n方法四：使用邻接元素处理\n\n什么都不做，给浮动元素后面的元素添加 clear 属性。方法五：使用 CSS 的:after 伪元素\n\n结合:after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素） 和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发hasLayout。\n\n给浮动元素的容器添加一个 clearfix 的 class，然后给这个 class 添加一个:after 伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。\n\n参考\n[_https://www.cnblogs.com/ForEvErNoME/p/3383539.html_](https://www.cnblogs.com/ForEvErNoME/p/3383539.html)\n\n- ### 怎么样让一个元素消失，讲讲\n\n参考回答：\n\ndisplay:none; visibility:hidden; opacity: 0; 等等\n\n- ### 介绍一下盒模型\n\n参考回答：\n\nCSS 盒模型本质上是一个盒子，封装周围的 HTML 元素，它包括：边距，边框，填充， 和实际内容。\n\n标准盒模型：一个块的总宽度=width+margin(左右)+padding(左右)+border(左右) 怪异盒模型：一个块的总宽度=width+margin（左右）（既 width 已经包含了\npadding 和 border 值）\n\n设置盒模型：box-sizing:border-box\n\n- ### position 相关属性\n\n参考回答：\n\n固定定位 fixed：\n\n元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重\n\n叠。\n\n相对定位 relative：\n\n如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。\n在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 绝对定位 absolute：\n\n绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素， 那么它的位置相对于\\<html>。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute\n定位的元素和其他元素重叠。\n\n粘性定位 sticky：\n\n元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和containing\nblock（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。\n\n默认定位 Static：\n\n默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者z-index 声明）。\n\ninherit:\n\n规定应该从父元素继承 position 属性的值。\n\n- ### css 动画如何实现\n\n参考回答：\n\n创建动画序列，需要使用 animation 属性或其子属性，该属性允许配置动画时间、时长以及其他动画细节，但该属性不能配置动画的实际表现，动画的实际表现是\n\n由 @keyframes 规则实现，具体情况参见使用 keyframes 定义动画序列小节部分。transition 也可实现动画。transition\n强调过渡，是元素的一个或多个属性发生变化时产生的过渡效果，同一个元素通过两个不同的途径获取样式，而第二个途径当某种改变发生（例如 hover）时才能获取样式，这样就会产生过渡动画。\n\n- ### 如何实现图片在某个容器中居中的？\n\n参考回答：\n\n父元素固定宽高，利用定位及设置子元素 margin 值为自身的一半。\n\n父元素固定宽高，子元素设置 position: absolute，margin：auto 平均分配 margin css3 属 性 transform 。 子 元 素 设 置 position:\nabsolute; left: 50%; top: 50%;transform: translate(-50%,-50%);即可。\n\n将父元素设置成 display: table, 子元素设置为单元格 display: table-cell。\n\n弹性布局 display: flex。设置 align-items: center; justify-content: center\n\n- ### 如何实现元素的垂直居中\n\n参考回答：\n\n法一：父元素 display:flex,align-items:center;\n\n法二：元素绝对定位，top:50%，margin-top：-（高度/2）\n\n法三：高度不确定用 transform：translateY（-50%）\n\n法四：父元素 table 布局，子元素设置 vertical-align:center;\n\n- ### CSS3 中对溢出的处理\n\n参考回答： cnkOhu\n\ntext-overflow 属性，值为 clip 是修剪文本；ellipsis 为显示省略符号来表被修剪的文本；string 为使用给定的字符串来代表被修剪的文本。\n\n- ### float 的元素，display 是什么\n\n参 考 回 答 ： display 为 block\n\n- ### 隐藏页面中某个元素的方法\n\n参考回答：\n\ndisplay:none; visibility:hidden; opacity: 0; position 移到外部，z-index 涂层遮盖等等\n\n- ### 三栏布局的实现方式，尽可能多写，浮动布局时，三个 div 的生成顺序有没有影响\n\n参考回答：\n\n三列布局又分为两种，两列定宽一列自适应，以及两侧定宽中间自适应两列定宽一列自适应：\n\n1、使用 float+margin：\n\n给 div 设置 float：left，left 的 div 添加属性 margin-right：left 和 center 的间隔 px,right 的 div 添加属性\nmargin-left：left 和 center 的宽度之和加上间隔\n\n2、使用 float+overflow：\n\n给 div 设置 float：left，再给 right 的 div 设置 overflow:hidden。这样子两个盒子浮动，另一个盒子触发 bfc 达到自适应\n\n3、使用 position：\n\n父级 div 设置 position：relative，三个子级 div 设置 position：absolute，这个要计算好盒子的宽度和间隔去设置位置，兼容性比较好，\n\n4、使用 table 实现：\n\n父级 div 设置 display：table，设置 border-spacing：10px//设置间距，取值随意, 子级 div 设置\ndisplay:table-cell，这种方法兼容性好，适用于高度宽度未知的情况，但是 margin 失效，设计间隔比较麻烦，\n\n5、flex 实现：\n\nparent 的 div 设置 display：flex；left 和 center 的 div 设置 margin-right；然后right 的 div 设置 flex：1；这样子 right\n自适应，但是 flex 的兼容性不好\n\n6、grid 实现：\n\nparent 的 div 设置 display：grid，设置 grid-template-columns 属性，固定第一列第二列宽度，第三列 auto，\n\n对于两侧定宽中间自适应的布局，对于这种布局需要把 center 放在前面，可以采用双飞翼布局：圣杯布局，来实现，也可以使用上述方法中的 grid，table，flex， position 实现\n\n- ### 什么是 BFC\n\n参考回答：\n\nBFC 也就是常说的块格式化上下文，这是一个独立的渲染区域，规定了内部如何布局， 并且这个区域的子元素不会影响到外面的元素，其中比较重要的布局规则有内部 box 垂直放置，计算 BFC\n的高度的时候，浮动元素也参与计算，触发 BFC 的规则有根元\n\n素，浮动元素，position 为 absolute 或 fixed 的元素，display 为 inline-block，\ntable-cell，table-caption，flex，inline-flex，overflow 不为 visible 的元素\n\n- ### calc 属性\n\n参考回答：\n\nCalc 用户动态计算长度值，任何长度值都可以使用 calc()函数计算，需要注意的是， 运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；\n\n- ### 有一个 width300，height300，怎么实现在屏幕上垂直水平居中\n\n参考回答：\n\n对于行内块级元素，\n\n1、父级元素设置 text-alig：center，然后设置 line-height 和 vertical-align 使其垂直居中，最后设置 font-size：0 消除近似居中的 bug\n\n2、父级元素设置 display：table-cell，vertical-align：middle 达到水平垂直居中3、采用绝对定位，原理是子绝父相，父元素设置\nposition：relative，子元素设置position：absolute，然后通过 transform 或 margin 组合使用达到垂直居中效果，设置\ntop：50%，left：50%，transform：translate（-50%，-50%）\n\n4、绝对居中，原理是当 top,bottom 为 0 时，margin-top&bottom 设置 auto 的话会无限延伸沾满空间并平分，当 left，right 为 0\n时,margin-left&right 设置 auto 会无限延伸占满空间并平分，\n\n5、采用 flex，父元素设置 display：flex，子元素设置 margin：auto\n\n6、视窗居中，vh 为视口单位，50vh 即是视口高度的 50/100，设置 margin：50vh auto 0，transform：translate(-50%)\n\n- ### display：table 和本身的 table 有什么区别\n\n参考回答：\n\nDisplay:table 和本身 table 是相对应的，区别在于，display：table 的 css 声明能够让一个 html 元素和它的子节点像 table 元素一样，使用基于表格的 css\n布局，是我们能够轻松定义一个单元格的边界，背景等样式，而不会产生因为使用了 table 那样的制表标签导致的语义化问题。\n\n之所以现在逐渐淘汰了 table 系表格元素，是因为用 div+css 编写出来的文件比用table 边写出来的文件小，而且 table 必须在页面完全加载后才显示，div 则是逐行显示，table\n的嵌套性太多，没有 div 简洁\n\n- ### position 属性的值有哪些及其区别\n\n参考回答：\n\nPosition 属性把元素放置在一个静态的，相对的，绝对的，固定的位置中， Static：位置设置为 static 的元素，他始终处于页面流给予的位置，static 元素会忽略任何\ntop,buttom,left,right 声明\n\nRelative：位置设置为 relative 的元素，可将其移至相对于其正常位置的地方，因此\n\nleft：20 会将元素移至元素正常位置左边 20 个像素的位置\n\nAbsolute：此元素可定位于相对包含他的元素的指定坐标，此元素可通过 left，top\n\n等属性规定\n\nFixed：位置被设为 fiexd 的元素，可定为与相对浏览器窗口的指定坐标，可以通过\n\nleft，top，right 属性来定位\n\n- ### z-index 的定位方法\n\n参考回答：\n\n26. index 属性设置元素的堆叠顺序，拥有更好堆叠顺序的元素会处于较低顺序元素之前，z-index 可以为负，且z-index 只能在定位元素上奏效，该属性设置一个定位元素沿z\n    轴的位置，如果为正数，离用户越近，为负数，离用户越远，它的属性值有auto，默认，堆叠顺序与父元素相等，number，inherit，从父元素继承 z-index 属性的值\n\n- ### 如果想要改变一个 DOM 元素的字体颜色，不在它本身上进行操作？\n\n参考回答：\n\n可以更改父元素的 color\n\n- ### 对 CSS 的新属性有了解过的吗？\n\n参考回答：\n\nCSS3 的新特性中，在布局方面新增了 flex 布局，在选择器方面新增了例如 first-of- type,nth-child 等选择器，在盒模型方面添加了box-sizing\n来改变盒模型，在动画方面增加了 animation，2d 变换，3d 变换等，在颜色方面添加透明，rbga 等，在字体方面允许嵌入字体和设置字体阴影，最后还有媒体查讯等\n\n- ### 用的最多的 css 属性是啥？\n\n参考回答：\n\n用的目前来说最多的是 flex 属性，灵活但是兼容性方面不强。\n\n- ### line-height 和 height 的区别\n\n参考回答：\n\nline-height 一般是指布局里面一段文字上下行之间的高度，是针对字体来设置的，\n\nheight 一般是指容器的整体高度。\n\n- ### 设置一个元素的背景颜色，背景颜色会填充哪些区域？\n\n参考回答：\n\nbackground-color 设置的背景颜色会填充元素的content、padding、border 区域。\n\n- ### 知道属性选择器和伪类选择器的优先级吗\n\n参考回答：\n\n属性选择器和伪类选择器优先级相同\n\n- ### inline-block、inline 和 block 的区别；为什么 img 是 inline 还可以设置宽高\n\n参考回答：\n\nBlock 是块级元素，其前后都会有换行符，能设置宽度，高度，margin/padding 水平垂直方向都有效。\n\nInline：设置 width 和 height 无效，margin 在竖直方向上无效，padding 在水平方向垂直方向都有效，前后无换行符\n\nInline-block：能设置宽度高度，margin/padding 水平垂直方向 都有效，前后无换行符\n\n- ### 用 css 实现一个硬币旋转的效果\n\n参考回答：\n\n虽然不认为很多人能在面试中写出来\n\n### #euro { width: 150px\n\n> height: 150px; margin-left: -75px; margin-top: -75px; position: absolute; top: 50%;\n\n> left: 50%;\n\n> transform-style: preserve-3d; animation: spin 2.5s linear infinite;\n\n> }\n\n> .back {\n\n> background-image: url(\"/uploads/160101/backeuro.png\"); width: 150px;\n\n> height: 150px;\n\n> }\n\n> .middle {\n\n> background-image: url(\"/uploads/160101/faceeuro.png\"); width: 150px;\n\n> height: 150px;\n\n> transform: translateZ(1px); position: absolute;\n\n> top: 0;\n\n> }\n\n> .front {\n\n> background-image: url(\"/uploads/160101/faceeuro.png\"); height: 150px;\n\n> position: absolute; top: 0;\n\n> transform: translateZ(10px); width: 150px;\n\n> }\n\n> @keyframes spin { 0% {\n\n> transform: rotateY(0deg);\n\n> }\n\n> 100% {\n\n> transform: rotateY(360deg);\n\n> }\n\n> }\n\n- ### 了解重绘和重排吗，知道怎么去减少重绘和重排吗，让文档脱离文档流有哪些方法\n\n参考回答：\n\nDOM 的变化影响到了预算内宿的几何属性比如宽高，浏览器重新计算元素的几何属性， 其他元素的几何属性也会受到影响，浏览器需要重新构造渲染书，这个过程称之为重排，浏览器将受到影响的部分重新绘制在屏幕上\n的过程称为重绘，引起重排重绘的原因有：\n\n添加或者删除可见的 DOM 元素， 元素尺寸位置的改变\n\n浏览器页面初始化，\n\n浏览器窗口大小发生改变，重排一定导致重绘，重绘不一定导致重排， 减少重绘重排的方法有：\n\n不在布局信息改变时做 DOM 查询，\n\n使用 csstext,className 一次性改变属性使用 fragment\n\n对于多次重排的元素，比如说动画。使用绝对定位脱离文档流，使其不影响其他元素\n\n- ### CSS 画正方体，三角形\n\n参考回答： 画三角形\n\n### #triangle02{ width: 0; height: 0\n\n> border-top: 50px solid blue; border-right: 50px solid red; border-bottom: 50px solid green;\n> border-left: 50px solid yellow;\n\n> }\n\n画正方体：\n\n### <!DOCTYPE html>\n\n> <html lang=\"en\">\n\n> <head>\n\n> <meta charset=\"UTF-8\">\n\n> <title>perspective\\</title>\n\n> <style>\n\n> .wrapper{ width: 50%; float: left;\n\n> }\n\n> .cube{\n\n> font-size: 4em; width: 2em;\n\n> margin: 1.5em auto; transform-style:preserve-3d;\n\n> transform:rotateX(-35deg) rotateY(30deg);\n\n> }\n\n> .side{\n\n> position: absolute; width: 2em;\n\n> height: 2em;\n\n> background: rgba(255,99,71,0.6); border: 1px solid rgba(0,0,0,0.5); color: white;\n\n> text-align: center; line-height: 2em;\n\n> }\n\n> .front{ transform:translateZ(1em);\n\n> }\n\n> .bottom{\n\n> transform:rotateX(-90deg) translateZ(1em);\n\n> }\n\n> .top{\n\n> transform:rotateX(90deg) translateZ(1em);\n\n> }\n\n> .left{\n\n> transform:rotateY(-90deg) translateZ(1em);\n\n> }\n\n> .right{\n\n> transform:rotateY(90deg) translateZ(1em);\n\n> }\n\n> .back{ transform:translateZ(-1em);\n\n> }\n\n> </style>\n\n> </head>\n\n> <body>\n\n> <div class=\"wrapper w1\">\n\n> <div class=\"cube\">\n\n> <div class=\"side front\">1\\</div>\n\n> <div class=\"side back\">6\\</div>\n\n> <div class=\"side right\">4\\</div>\n\n> <div class=\"side left\">3\\</div>\n\n> <div class=\"side top\">5\\</div>\n\n> <div class=\"side bottom\">2\\</div>\n\n> </div>\n\n> </div>\n\n> <div class=\"wrapper w2\">\n\n> <div class=\"cube\">\n\n> <div class=\"side front\">1\\</div>\n\n> <div class=\"side back\">6\\</div>\n\n> <div class=\"side right\">4\\</div>\n\n> <div class=\"side left\">3\\</div>\n\n> <div class=\"side top\">5\\</div>\n\n> <div class=\"side bottom\">2\\</div>\n\n> </div>\n\n> </div>\n\n> </body>\n\n> </html>\n\n- ### overflow 的原理\n\n参考回答：\n\n要讲清楚这个解决方案的原理，首先需要了解块格式化上下文，A block formatting context is a part of a visual CSS rendering of a Web\npage. It is the region in which the layout of block boxes occurs and in which floats interact with\neach other.翻译过来就是块格式化上下文是 CSS 可视化渲染的一部分，它是一块区域，规定了内部块盒 的渲染方式，以及浮动相互之间的影响关系\n\n当元素设置了 overflow 样式且值部位 visible 时，该元素就构建了一个 BFC，BFC 在计算高度时，内部浮动元素的高度也要计算在内，也就是说技术 BFC 区域内只有一个浮动元素，BFC\n的高度也不会发生塌缩，所以达到了清除浮动的目的。\n\n- ### 清除浮动的方法\n\n参考回答：\n\n给要清除浮动的元素添加样式 clear，\\\\\n\n父元素结束标签钱插入清除浮动的块级元素，给该元素添加样式 clear\n\n添加伪元素，在父级元素的最后，添加一个伪元素，通过清除伪元素的浮动，注意该伪元素的 display 为 block，\n\n父元素添加样式 overflow 清除浮动，overflow 设置除 visible 以外的任何位置\n\n- ### box-sizing 的语法和基本用处\n\n参考回答：\n\nbox-sizing 规定两个并排的带边框的框，语法为box-sizing：content-box/border- box/inherit\n\ncontent-box：宽度和高度分别应用到元素的内容框，在宽度和高度之外绘制元素的内边距和边框\n\nborder-box：为元素设定的宽度和高度决定了元素的边框盒， inherit：继承父元素的 box-sizing\n\n- ### 使元素消失的方法有哪些？\n\n参考回答：\n\n1. opacity：0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如 click 事件，那么点击该区域，也能触发点击事件的\n\n2. visibility：hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件\n\n3. display：none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉。\n\n- ### 两个嵌套的 div，position 都是 absolute，子 div 设置 top 属性，那么这个 top 是相对于父元素的哪个位置定位的\n\n参 考 回 答 ： margin 的外边缘\n\n- ### 说说盒子模型\n\n参考回答：\n\nCSS 盒模型本质上是一个盒子，封装周围的 HTML 元素，它包括：边距，边框，填充， 和实际内容。\n\n标准盒模型：一个块的总宽度=width+margin(左右)+padding(左右)+border(左右) 怪异盒模型：一个块的总宽度=width+margin（左右）（既 width 已经包含了\npadding 和 border 值）\n\n如何设置：box-sizing:border-box\n\n- ### display\n\n参考回答：\n\n主要取值有 none,block,inline-block,inline,flex 等。具体可参考\n\n[_https://developer.mozilla.org/zh-CN/docs/Web/CSS/display_](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display)\n\n- ### 怎么隐藏一个元素\n\n参考回答：\n\n1. opacity：0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如 click 事件，那么点击该区域，也能触发点击事件的\n\n2. visibility：hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件\n\n3. display：none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉。\n\n- ### display:none 和 visibilty:hidden 的区别\n\n参考回答：\n\n1. visibility：hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件\n\n2. display：none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉。\n\n- ### 相对布局和绝对布局，position:relative 和 obsolute\n\n参考回答：\n\n相对定位 relative：\n\n如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。\n在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 绝对定位 absolute：\n\n绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素， 那么它的位置相对于\\<html>。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute\n定位的元素和其他元素重叠。\n\n- ### flex 布局\n\n参考回答：\n\nflex 是 Flexible Box 的缩写，意为\"弹性布局\"。指定容器 display: flex\n即可。容器有以下属性：flex-direction，flex-wrap，flex-flow，justify-content， align-items，align-content。\n\nflex-direction 属性决定主轴的方向；\n\nflex-wrap 属性定义，如果一条轴线排不下，如何换行；\n\nflex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap；\n\njustify-content 属性定义了项目在主轴上的对齐方式。align-items 属性定义项目在交叉轴上如何对齐。\n\nalign-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n\n项目（子元素）也有一些属性：order，flex-grow，flex-shrink，flex-basis，\n\nflex，align-self。\n\norder 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。\n\nflex-grow 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。\n\nflex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为\n0 1 auto。后两个属性可选。\n\nalign-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于\nstretch。\n\n参考\n[_http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html_](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)\n\n- ### block、inline、inline-block 的区别\n\n参考回答：\n\nblock 元素会独占一行，多个 block 元素会各自新起一行。默认情况下，block 元素宽度自动填满其父元素宽度。\n\nblock 元素可以设置 width,height 属性。块级元素即使设置了宽度,仍然是独占一行。block 元素可以设置 margin 和 padding 属性。\n\ninline 元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。\n\ninline 元素设置 width,height 属性无效。\n\ninline 元素的 margin 和 padding 属性，水平方向的 padding-left, padding-right, margin-left, margin-right\n都产生边距效果；但竖直方向的 padding-top, padding- bottom, margin-top, margin-bottom 不会产生边距效果。\n\ninline-block：简单来说就是将对象呈现为 inline 对象，但是对象的内容作为 block\n\n对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个 link（a 元\n\n素）inline-block 属性值，使其既具有 block 的宽度高度特性又具有 inline 的同行特性。\n\n- ### css 的常用选择器\n\n参考回答：\n\nid 选择器，类选择器，伪类选择器等\n\n- ### css 布局\n\n参考回答：\n\n六种布局方式总结：圣杯布局、双飞翼布局、Flex 布局、绝对定位布局、表格布局、网格布局。\n\n圣杯布局是指布局从上到下分为 header、container、footer，然后 container 部分定为三栏布局。这种布局方式同样分为\nheader、container、footer。圣杯布局的缺陷在于 center 是在 container 的 padding 中的，因此宽度小的时候会出现混乱。\n\n双飞翼布局给 center 部分包裹了一个 main 通过设置 margin 主动地把页面撑开。Flex 布局是由 CSS3 提供的一种方便的布局方式。\n\n绝对定位布局是给 container 设置 position: relative 和 overflow: hidden，因为绝对定位的元素的参照物为第一个 postion 不为 static\n的祖先元素。 left 向左浮动，right 向右浮动。center 使用绝对定位，通过设置 left 和 right 并把两边撑开。 center 设置 top: 0 和 bottom: 0\n使其高度撑开。\n\n表格布局的好处是能使三栏的高度统一。\n\n网格布局可能是最强大的布局方式了，使用起来极其方便，但目前而言，兼容性并不好。网格布局，可以将页面分割成多个区域，或者用来定义内部元素的大小，位置， 图层关系。\n\n- ### css 定位\n\n参考回答：\n\n固定定位 fixed：\n\n元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重\n\n叠。\n\n相对定位 relative：\n\n如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。\n在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 绝对定位 absolute：\n\n绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素， 那么它的位置相对于\\<html>。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute\n定位的元素和其他元素重叠。\n\n粘性定位 sticky：\n\n元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和containing\nblock（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。\n\n默认定位 Static：\n\n默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者z-index 声明）。\n\ninherit:\n\n规定应该从父元素继承 position 属性的值。\n\n- ### relative 定位规则\n\n参考回答：\n\n如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。\n在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。\n\n- ### 垂直居中\n\n参考回答：\n\n父元素固定宽高，利用定位及设置子元素 margin 值为自身的一半。\n\n父元素固定宽高，子元素设置 position: absolute，margin：auto 平均分配 margin css3 属 性 transform 。 子 元 素 设 置 position:\nabsolute; left: 50%; top: 50%;transform: translate(-50%,-50%);即可。\n\n将父元素设置成 display: table, 子元素设置为单元格 display: table-cell。\n\n弹性布局 display: flex。设置 align-items: center; justify-content: center;\n\n- ### css 预处理器有什么\n\n参考回答： less，sass 等\n\n3. ## | JavaScript\n\n- ### get 请求传参长度的误区\n\n参考回答：\n\n误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。\n\n实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或 web 服务器，浏览器或 web 服务器限制了 url\n的长度。为了明确这个概念，我们必须再次强调下面几点:\n\nHTTP 协议 未规定 GET 和 POST 的长度限制\n\nGET 的最大长度显示是因为 浏览器和 web 服务器限制了 URI 的长度不同的浏览器和 WEB 服务器，限制的最大长度不一样\n\n要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte\n\n- ### 补充 get 和 post 请求在缓存方面的区别\n\n参考回答：\n\npost/get 的请求区别，具体不再赘述。\n\n补充补充一个 get 和 post 在缓存方面的区别：\n\nget 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。\n\npost 不同，post 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此 get 请求适合于请求缓存。\n\n- ### 说一下闭包\n\n参考回答：\n\n一句话可以概括：闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放。\n\n- ### 说一下类的创建和继承\n\n参考回答：\n\n1. 类的创建（es5）：new 一个 function，在这个 function 的 prototype 里面增加属性和方法。\n\n下面来创建一个 Animal 类：\n\n// 定义一个动物类function Animal (name) {\n\n// 属性\n\nthis.name = name \\|\\| 'Animal';\n\n// 实例方法\n\nthis.sleep = function(){ console.log(this.name + '正在睡觉！');\n\n}\n\n}\n\n// 原型方法\n\nAnimal.prototype.eat = function(food) { console.log(this.name + '正在吃：' + food);\n\n};\n\n这样就生成了一个 Animal 类，实力化生成对象后，有方法和属性。\n\n2. 类的继承——原型链继承\n\n--原型链继承\n\n### function Cat(){ } Cat.prototype = new Animal(); Cat.prototype.name = 'cat'\n\n> // Test Code\n\n> var cat = new Cat(); console.log(cat.name); console.log(cat.eat('fish'));\n> console.log(cat.sleep());\n\n> console.log(cat instanceof Animal); //true console.log(cat instanceof Cat); //true\n\n介绍：在这里我们可以看到 new 了一个空对象,这个空对象指向 Animal 并且\n\nCat.prototype 指向了这个空对象，这种就是基于原型链的继承。特点：基于原型链，既是父类的实例，也是子类的实例\n\n缺点：无法实现多继承\n\n3. 构造继承：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）\n\n### function Cat(name){ Animal.call(this); this.name = name \\|\\| 'Tom'\n\n> }\n\n> // Test Code\n\n> var cat = new Cat(); console.log(cat.name); console.log(cat.sleep());\n\n> console.log(cat instanceof Animal); // false console.log(cat instanceof Cat); // true\n\n特点：可以实现多继承\n\n缺点：只能继承父类实例的属性和方法，不能继承原型上的属性和方法。\n\n4. 实例继承和拷贝继承\n\n实例继承：为父类实例添加新特性，作为子类实例返回拷贝继承：拷贝父类元素上的属性和方法\n\n上述两个实用性不强，不一一举例。\n\n5. 组合继承：相当于构造继承和原型链继承的组合体。通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用function Cat(name){\n\n### Animal.call(this); this.name = name \\|\\| 'Tom'\n\n> }\n\n> Cat.prototype = new Animal(); Cat.prototype.constructor = Cat;\n\n> // Test Code\n\n> var cat = new Cat(); console.log(cat.name); console.log(cat.sleep());\n\n> console.log(cat instanceof Animal); // true console.log(cat instanceof Cat); // true\n\n特点：可以继承实例属性/方法，也可以继承原型属性/方法缺点：调用了两次父类构造函数，生成了两份实例\n\n6. 寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性\n\n### function Cat(name){ Animal.call(this); this.name = name \\|\\| 'Tom'\n\n> }\n\n> (function(){\n\n// 创建一个没有实例方法的类\n\n### var Super = function(){}; Super.prototype = Animal.prototype\n\n//将实例作为子类的原型\n\n### Cat.prototype = new Super()\n\n> })();\n\n> // Test Code\n\n> var cat = new Cat(); console.log(cat.name); console.log(cat.sleep());\n\n> console.log(cat instanceof Animal); // true console.log(cat instanceof Cat); //true\n\n较为推荐\n\n- ### 如何解决异步回调地狱\n\n参考回答：\n\n- ### 说说前端中的事件流\n\n参考回答：\n\nHTML 中与 javascript 交互是通过事件驱动来实现的，例如鼠标点击事件 onclick、页面的滚动事件 onscroll\n等等，可以向文档或者文档中的元素添加事件侦听器来预订事件。想要知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概\n\n念。\n\n什么是事件流：事件流描述的是从页面中接收事件的顺序,DOM2 级事件流包括下面几个阶段。\n\n事件捕获阶段处于目标阶段事件冒泡阶段\n\naddEventListener：addEventListener 是 DOM2 级事件新增的指定事件处理程序的操作，这个方法接收 3\n个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。\n\nIE 只支持事件冒泡。\n\n- ### 如何让事件先冒泡后捕获\n\n参考回答：\n\n在 DOM 标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间。\n\n- ### 说一下事件委托\n\n参考回答：\n\n简介：事件委托指的是，不在事件的发生地（直接 dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素 DOM\n的类型，来做出不同的响应。\n\n举例：最经典的就是 ul 和 li 标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在 li 标签上直接添加，而是在 ul 父元素上添加。\n\n好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。\n\n- ### 说一下图片的懒加载和预加载\n\n参考回答：\n\n预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。\n\n懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。\n\n两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。\n\n- ### mouseover 和 mouseenter 的区别\n\n参考回答：\n\nmouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是 mouseout\n\nmouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是 mouseleave\n\n- ### JS 的 new 操作符做了哪些事情\n\n参考回答：\n\nnew 操作符新建了一个空对象，这个对象原型指向构造函数的 prototype，执行构造函数后返回这个对象。\n\n- ### 改变函数内部 this 指针的指向函数（bind，apply，call 的区别）\n\n参考回答：\n\n通过 apply 和 call 改变函数的 this 指向，他们两个函数的第一个参数都是一样的表示要改变指向的那个对象，第二个参数，apply 是数组，而 call 则是\narg1,arg2...这种形式。通过 bind 改变 this 作用域会返回一个新的函数，这个函数不会马上执行。\n\n- ### JS 的各种位置，比如 clientHeight,scrollHeight,offsetHeight ,以及 scrollTop, offsetTop,clientTop 的区别？\n\n参考回答：\n\nclientHeight：表示的是可视区域的高度，不包含 border 和滚动条offsetHeight：表示可视区域的高度，包含了 border\n和滚动条scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分。clientTop：表示边框 border 的厚度，在未指定的情况下一般为 0\n\nscrollTop：滚动后被隐藏的高度，获取对象相对于由 offsetParent 属性指定的父坐标(css 定位的元素或 body 元素)距离顶端的高度。\n\n- ### JS 拖拽功能的实现\n\n参考回答：\n\n首先是三个事件，分别是 mousedown，mousemove，mouseup\n\n当鼠标点击按下的时候，需要一个 tag 标识此时已经按下，可以执行 mousemove 里面的具体方法。\n\nclientX，clientY 标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用\n\noffsetX 和 offsetY 来表示元素的元素的初始坐标，移动的举例应该是：\n\n鼠标移动时候的坐标-鼠标按下去时候的坐标。\n\n也就是说定位信息为：\n\n鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的 offetLeft.\n\n还有一点也是原理性的东西，也就是拖拽的同时是绝对定位，我们改变的是绝对定位条件下的 left\n\n以及 top 等等值。\n\n补充：也可以通过 html5 的拖放（Drag 和 drop）来实现\n\n- ### 异步加载 JS 的方法\n\n参考回答：\n\ndefer：只支持 IE 如果您的脚本不会改变文档的内容，可将 defer 属性加入到\n\n<script>标签中，以便加快处理文档的速度。因为浏览器知道它将能够安全地读取文档的剩余部分而不用执行脚本，它将推迟对脚本的解释，直到文档已经显示给用户为止。\n\nasync，HTML5 属性仅适用于外部脚本，并且如果在 IE 中，同时存在 defer 和 async， 那么 defer 的优先级比较高，脚本将在页面完成时执行。\n\n创建 script 标签，插入到 DOM 中\n\n- ### Ajax 解决浏览器缓存问题\n\n参考回答：\n\n在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(\"If-Modified- Since\",\"0\")。\n\n在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(\"Cache-Control\",\"no- cache\")。\n\n在 URL 后面加上一个随机数： \"fresh=\" + Math.random()。\n\n在 URL 后面加上时间搓：\"nowtime=\" + new Date().getTime()。\n\n如果是使用 jQuery，直接这样就可以了 \\$.ajaxSetup({cache:false})。这样页面的所有 ajax 都会执行这条语句就是不需要保存缓存记录。\n\n- ### JS 的节流和防抖\n\n参 考 回 答 ：\n[_http://www.cnblogs.com/coco1s/p/5499469.html_](http://www.cnblogs.com/coco1s/p/5499469.html)\n\n- ### JS 中的垃圾回收机制\n\n参考回答：\n\n必要性：由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript\n程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript\n的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。\n\n这段话解释了为什么需要系统需要垃圾回收，JS 不像 C/C++，他有自己的一套垃圾回收机制（Garbage Collection）。JavaScript\n的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。例如：\n\n### var a=\"hello world\"; var b=\"world\"\n\n> var a=b;\n\n//这时，会释放掉\"hello world\"，释放内存以便再引用\n\n垃圾回收的方法：标记清除、计数引用。标记清除\n\n这是最常见的垃圾回收方式，当变量进入环境时，就标记这个变量为”进入环境“,从逻辑上讲，永远不能释放进入环境的变量所占的内存，永远不能释放进入环境变量所占用的内存，只要执行流程进入相应的环境，就可能用到他们。当离开环境时，就标记为离开环境。\n\n垃圾回收器在运行的时候会给存储在内存中的变量都加上标记（所有都加），然后去掉环境变量中的变量，以及被环境变量中的变量所引用的变量（条件性去除标记），\n删除所有被标记的变量，删除的变量无法在环境变量中被访问所以会被删除，最后垃圾回收器，完成了内存的清除工作，并回收他们所占用的内存。\n\n引用计数法\n\n另一种不太常见的方法就是引用计数法，引用计数法的意思就是每个值没引用的次 数，当声明了一个变量，并用一个引用类型的值赋值给改变量，则这个值的引用次数为\n1,；相反的，如果包含了对这个值引用的变量又取得了另外一个值，则原先的引用\n\n值引用次数就减 1，当这个值的引用次数为 0 的时候，说明没有办法再访问这个值了， 因此就把所占的内存给回收进来，这样垃圾收集器再次运行的时候，就会释放引用次数为 0 的这些值。\n\n用引用计数法会存在内存泄露，下面来看原因：\n\n### function problem() {\n\n> var objA = new Object(); var objB = new Object();\n\n> objA.someOtherObject = objB; objB.anotherObject = objA;\n\n> }\n\n在这个例子里面，objA 和 objB 通过各自的属性相互引用，这样的话，两个对象的引用次数都为 2，在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，因为计数不为\n0，这样的相互引用如果大量存在就会导致内存泄露。\n\n特别是在 DOM 对象中，也容易存在这种问题：\n\n### var element=document.getElementById（’‘）； var myObj=new Object(); myObj.element=element; element.someObject=myObj\n\n这样就不会有垃圾回收的过程。\n\n- ### eval 是做什么的\n\n参考回答：\n\n它的功能是将对应的字符串解析成 JS 并执行，应该避免使用 JS，因为非常消耗性能\n\n（2 次，一次解析成 JS，一次执行）\n\n- ### 如何理解前端模块化\n\n参考回答：\n\n前端模块化就是复杂的文件编程一个一个独立的模块，比如 JS 文件等等，分成独立的模块有利于重用（复用性）和维护（版本迭代），这样会引来模块之间相互依赖的问题，所以有了 commonJS\n规范，AMD，CMD 规范等等，以及用于 JS 打包（编译等处理） 的工具webpack\n\n- ### 说一下 CommonJS、AMD 和 CMD\n\n参考回答：\n\n一个模块是能实现特定功能的文件，有了模块就可以方便的使用别人的代码，想要什么功能就能加载什么模块。\n\nCommonJS：开始于服务器端的模块化，同步定义的模块化，每个模块都是一个单独的作用域，模块输出，modules.exports，模块加载 require()引入模块。\nAMD：中文名异步模块定义的意思。\n\nrequireJS 实现了 AMD 规范，主要用于解决下述两个问题。\n\n1. 多个文件有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器\n\n2. 加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应的时间越长。语法：requireJS 定义了一个函数 define，它是全局变量，用来定义模块。requireJS 的例子：\n\n//定义模块\n\n### define(\\['dependency'\\], function(){ var name = 'Byron'\n\n> function printName(){ console.log(name);\n\n> }\n\n> return {\n\n> printName: printName\n\n> };\n\n> });\n\n//加载模块\n\n### require(\\['myModule'\\], function (my){ my.printName()\n\n> }\n\nRequireJS 定义了一个函数 define,它是全局变量，用来定义模块：\n\ndefine(id?dependencies?,factory) 在页面上使用模块加载函数： require(\\[dependencies\\],factory)；\n\n总结 AMD 规范：require（）函数在加载依赖函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块加载成功，才会去执行。\n\n因为网页在加载 JS 的时候会停止渲染，因此我们可以通过异步的方式去加载 JS,而如果需要依赖某些，也是异步去依赖，依赖后再执行某些方法。\n\n- ### 对象深度克隆的简单实现\n\n参考回答：\n\n### function deepClone(obj){\n\n> var newObj= obj instanceof Array ? \\[\\]:{}; for(var item in obj){\n\n> var temple= typeof obj\\[item\\] == 'object' ? deepClone(obj\\[item\\]):obj\\[item\\]; newObj\\[item\\] =\n> temple;\n\n> }\n\n> return newObj;\n\n> }\n\nES5 的常用的对象克隆的一种方式。注意数组是对象，但是跟对象又有一定区别，所以我们一开始判断了一些类型，决定 newObj 是对象还是数组。\n\n- ### 实现一个 once 函数，传入函数参数只执行一次\n\n参考回答：\n\n### function ones(func){ var tag=true\n\n> return function(){ if(tag==true){ func.apply(null,arguments); tag=false;\n\n> }\n\n> return undefined\n\n> }\n\n> }\n\n- ### 将原生的 ajax 封装成 promise\n\n参考回答：\n\n### var myNewAjax=function(url){\n\n> return new Promise(function(resolve,reject){\n\n> var xhr = new XMLHttpRequest(); xhr.open('get',url); xhr.send(data);\n> xhr.onreadystatechange=function(){ if(xhr.status==200&&readyState==4){\n\n> var json=JSON.parse(xhr.responseText); resolve(json)\n\n> }else if(xhr.readyState==4&&xhr.status!=200){ reject('error');\n\n> }\n\n> }\n\n> })\n\n> }\n\n- ### JS 监听对象属性的改变\n\n参考回答：\n\n我们假设这里有一个 user 对象,\n\n1. 在 ES5 中可以通过 Object.defineProperty 来实现已有属性的监听Object.defineProperty(user,'name',{\n   set：function(key,value){\n\n### }\n\n> })\n\n缺点：如果 id 不在 user 对象中，则不能监听 id 的变化(2)在 ES6 中可以通过 Proxy 来实现\n\n### var user = new Proxy({}，{ set：function(target,key,value,receiver){\n\n> }\n\n> })\n\n这样即使有属性在 user 中不存在，通过 user.id 来定义也同样可以这样监听这个属性的变化哦。\n\n- ### 如何实现一个私有变量，用 getName 方法可以访问，不能直接访问\n\n参考回答：\n\n1. 通过 defineProperty 来实现\n\n### obj={ name:yuxiaoliang, getName:function(){ return this.name\n\n> }\n\n> } object.defineProperty(obj,\"name\",{\n\n//不可枚举不可配置\n\n});\n\n2. 通过函数的创建形式\n\n### function product(){\n\n> var name='yuxiaoliang'; this.getName=function(){ return name;\n\n> }\n\n> }\n\n> var obj=new product();\n\n### • ==和===、以及 Object.is 的区别\n\n参考回答： (1) ==\n\n主要存在：强制转换成 number,null==undefined \" \"==0 //true\n\n\"0\"==0 //true \" \" !=\"0\" //true\n\n123==\"123\" //true null==undefined //true (2)Object.js\n\n主要的区别就是+0！=-0 而 NaN==NaN (相对比===和==的改进)\n\n- ### setTimeout、setInterval 和 requestAnimationFrame 之间的区别\n\n参考回答：\n\n这里有一篇文章讲的是 requestAnimationFrame：\n[_http://www.cnblogs.com/xiaohuochai/p/5777186.html_](http://www.cnblogs.com/xiaohuochai/p/5777186.html)\n\n与 setTimeout 和 setInterval 不同，requestAnimationFrame 不需要设置时间间隔， 大多数电脑显示器的刷新频率是 60Hz，大概相当于每秒钟重绘 60\n次。大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。因此，最平滑动画的最佳循环间隔是 1000ms/60，约等于 16.6ms。RAF\n采用的是系统时间间隔，不会因为前面的任务，不会影响 RAF，但是如果前面的任务多的话，\n\n会响应 setTimeout 和 setInterval 真正运行时的时间间隔。特点：\n\n1. requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。\n\n2. 在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量\n\n3. requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销。\n\n- ### 实现一个两列等高布局，讲讲思路\n\n参考回答：\n\n为了实现两列等高，可以给每列加上 padding-bottom:9999px; margin-bottom:-9999px;同时父元素设置 overflow:hidden;\n\n- ### 自己实现一个 bind 函数\n\n参考回答：\n\n原理：通过 apply 或者 call 方法来实现。(1)初始版本\n\n### Function.prototype.bind=function(obj,arg){\n\n> var arg=Array.prototype.slice.call(arguments,1); var context=this;\n\n> return function(newArg){ arg=arg.concat(Array.prototype.slice.call(newArg)); return\n> context.apply(obj,arg);\n\n> }\n\n> }\n\n2. 考虑到原型链\n\n为什么要考虑？因为在 new 一个 bind 过生成的新函数的时候，必须的条件是要继承原函数的原型\n\n### Function.prototype.bind=function(obj,arg){\n\n> var arg=Array.prototype.slice.call(arguments,1); var context=this;\n\n> var bound=function(newArg){ arg=arg.concat(Array.prototype.slice.call(newArg)); return\n> context.apply(obj,arg);\n\n> }\n\n> var F=function(){}\n\n> //这里需要一个寄生组合继承F.prototype=context.prototype; bound.prototype=new F(); return bound;\n\n> }\n\n- ### 用 setTimeout 来实现 setInterval\n\n参考回答：\n\n1. 用 setTimeout()方法来模拟 setInterval()与 setInterval()之间的什么区别？ 首先来看 setInterval 的缺陷，使用\n   setInterval()创建的定时器确保了定时器代码规则地插入队列中。这个问题在于：如果定时器代码在代码再次添加到队列之前还没完成执行，结果就会导致定时器代码连续运行好几次。而之间没有间隔。不过幸运的\n\n是：javascript 引擎足够聪明，能够避免这个问题。当且仅当没有该定时器的如何代码实例时，才会将定时器代码添加到队列中。这确保了定时器代码加入队列中最小的时间间隔为指定时间。\n\n这种重复定时器的规则有两个问题：1.某些间隔会被跳过 2.多个定时器的代码执行时间可能会比预期小。\n\n下面举例子说明：\n\n假设，某个 onclick 事件处理程序使用啦 setInterval()来设置了一个 200ms 的重复定时器。如果事件处理程序花了 300ms 多一点的时间完成。\n\n<img width=\"626\" alt=\"2018-07-10 11 36 43\"\nsrc=\"[_https://user-_](https://user-images.githubusercontent.com/17233651/42487876-92656f2c-8435-11e8-8a5f-0a97918039da.png)\n[_images.githubusercontent.com/17233651/42487876-92656f2c-8435-11e8-8a5f-_](https://user-images.githubusercontent.com/17233651/42487876-92656f2c-8435-11e8-8a5f-0a97918039da.png)\n[_0a97918039da.png_](https://user-images.githubusercontent.com/17233651/42487876-92656f2c-8435-11e8-8a5f-0a97918039da.png)\">\n\n这个例子中的第一个定时器是在 205ms 处添加到队列中，但是要过 300ms 才能执行。在 405ms 又添加了一个副本。在一个间隔，605ms 处，第一个定时器代码还在执行中，\n而且队列中已经有了一个定时器实例，结果是 605ms 的定时器代码不会添加到队列\n\n中。结果是在 5ms 处添加的定时器代码执行结束后，405 处的代码立即执行。\n\n### function say(){\n\n> //something setTimeout(say,200);\n\n> } setTimeout(say,200) 或者\n\n> setTimeout(function(){\n\n> //do something setTimeout(arguments.callee,200);\n\n> },200);\n\n- ### JS 怎么控制一次加载一张图片，加载完后再加载下一张\n\n参考回答： (1)方法 1\n\n### <script type=\"text/javascript\"> var obj=new Image()\n\n> [obj.src=\"http://www.phpernote.com/uploadfiles/editor/2011072405022011](http://www.phpernote.com/uploadfiles/editor/2011072405022011)\n> 79.jpg\";\n\n> obj.onload=function(){\n\nalert('图片的宽度为：'+obj.width+'；图片的高度为：'+obj.height);\n\n### document.getElementById(\"mypic\").innnerHTML=\"\\<img src='\"+this.src+\"'\n\n> />\";\n\n> }\n\n> </script>\n\n> <div id=\"mypic\">onloading……\\</div>\n\n2. 方法 2\n\n### <script type=\"text/javascript\"> var obj=new Image()\n\n> [obj.src=\"http://www.phpernote.com/uploadfiles/editor/2011072405022011](http://www.phpernote.com/uploadfiles/editor/2011072405022011)\n> 79.jpg\";\n\n> obj.onreadystatechange=function(){ if(this.readyState==\"complete\"){\n\nalert('图片的宽度为：'+obj.width+'；图片的高度为：'+obj.height);\n\n### document.getElementById(\"mypic\").innnerHTML=\"\\<img src='\"+this.src+\"'\n\n> />\";\n\n> }\n\n> }\n\n> </script>\n\n> <div id=\"mypic\">onloading……\\</div>\n\n- ### 代码的执行顺序\n\n> 参 考 回 答 ： setTimeout(function(){console.log(1)},0); new Promise(function(resolve,reject){\n> console.log(2);\n\n> resolve();\n\n> }).then(function(){console.log(3)\n\n> }).then(function(){console.log(4)}); process.nextTick(function(){console.log(5)}); console.log(6);\n\n//输出 2,6,5,3,4,1\n\n为什么呢？具体请参考这篇文章：\n\n[_从 promise、process.nextTick、setTimeout 出发，谈谈 Event Loop 中的 Job\nqueue_](https://github.com/forthealllight/blog/issues/5)\n\n- ### 如何实现 sleep 的效果（es5 或者 es6）\n\n参 考 回 答 ： (1)while 循环的方式\n\n### function sleep(ms){\n\n> var start=Date.now(),expire=start+ms; while(Date.now()\\<expire); console.log('1111');\n\n> return;\n\n> }\n\n执行 sleep(1000)之后，休眠了 1000ms 之后输出了 1111。上述循环的方式缺点很明显，容易造成死循环。\n\n2. 通过 promise 来实现\n\n### function sleep(ms){\n\n> var temple=new Promise( (resolve)=>{\n\n> console.log(111);setTimeout(resolve,ms)\n\n> });\n\n> return temple\n\n> } sleep(500).then(function(){\n\n> //console.log(222)\n\n> })\n\n//先输出了 111，延迟 500ms 后输出 222 (3)通过 async 封装\n\n### function sleep(ms){\n\n> return new Promise((resolve)=>setTimeout(resolve,ms));\n\n> }\n\n> async function test(){\n\n> var temple=await sleep(1000); console.log(1111)\n\n> return temple\n\n> } test();\n\n> //延迟 1000ms 输出了 1111 (4).通过 generate 来实现function\\* sleep(ms){\n\n### yield new Promise(function(resolve,reject){ console.log(111)\n\n> setTimeout(resolve,ms);\n\n> })\n\n> } sleep(500).next().value.then(function(){console.log(2222)})\n\n- ### 简单的实现一个 promise\n\n参考回答：\n\n[_首先明确什么是 promiseA+规范，参考规范的地址：primise_](https://promisesaplus.com/) A+规范\n\n如何实现一个 promise，参考这篇文章：\n\n[_实现一个完美符合 Promise/A+规范的 Promise_](https://github.com/forthealllight/blog/issues/4)\n\n一般不会问的很详细，只要能写出上述文章中的 v1.0 版本的简单 promise 即可。\n\n- ### Function.\\_proto\\_(getPrototypeOf)是什么？\n\n参考回答：\n\n获取一个对象的原型，在 chrome 中可以通过_proto_的形式，或者在 ES6 中可以通过\n\nObject.getPrototypeOf 的形式。\n\n那么 Function.proto 是什么么？也就是说 Function 由什么对象继承而来，我们来做如下判别。\n\nFunction. proto ==Object.prototype //false Function. proto ==Function.prototype//true 我们发现 Function\n的原型也是 Function。\n\n我们用图可以来明确这个关系：\n\n<img width=\"646\" alt=\"2018-07-10 2 38 27\"\nsrc=\"[_https://user-_](https://user-images.githubusercontent.com/17233651/42493275-f55d0860-844e-11e8-983f-e04189a4f3d8.png)\n[_images.githubusercontent.com/17233651/42493275-f55d0860-844e-11e8-983f-_](https://user-images.githubusercontent.com/17233651/42493275-f55d0860-844e-11e8-983f-e04189a4f3d8.png)\n[_e04189a4f3d8.png_](https://user-images.githubusercontent.com/17233651/42493275-f55d0860-844e-11e8-983f-e04189a4f3d8.png)\">\n\n- ### 实现 JS 中所有对象的深度克隆（包装对象，Date 对象，正则对象）\n\n参考回答：\n\n通过递归可以简单实现对象的深度克隆，但是这种方法不管是 ES6 还是 ES5 实现，都有同样的缺陷，就是只能实现特定的 object 的深度复制（比如数组和函数），不能实现包装对象\nNumber，String ， Boolean，以及 Date 对象，RegExp 对象的复制。(1)前文的方法\n\n### function deepClone(obj){\n\n> var newObj= obj instanceof Array?\\[\\]:{}; for(var i in obj){\n\n> newObj\\[i\\]=typeof obj\\[i\\]=='object'? deepClone(obj\\[i\\]):obj\\[i\\];\n\n> }\n\n> return newObj;\n\n> }\n\n这种方法可以实现一般对象和数组对象的克隆，比如：\n\n### var arr=\\[1,2,3\\]\n\n> var newArr=deepClone(arr);\n\n> // newArr->\\[1,2,3\\] var obj={\n\n> x:1, y:2\n\n> }\n\n> var newObj=deepClone(obj);\n\n> // newObj={x:1,y:2}\n\n但是不能实现例如包装对象 Number,String,Boolean,以及正则对象 RegExp 和 Date 对象的克隆，比如：\n\n//Number 包装对象\n\n### var num=new Number(1)\n\n> typeof num // \"object\"\n\n> var newNum=deepClone(num);\n\n//newNum -> {} 空 对 象\n\n//String 包装对象\n\n### var str=new String(\"hello\"); typeof str //\"object\"\n\n> var newStr=deepClone(str);\n\n> //newStr-> {0:'h',1:'e',2:'l',3:'l',4:'o'};\n\n//Boolean 包装对象\n\n### var bol=new Boolean(true); typeof bol //\"object\"\n\n> var newBol=deepClone(bol);\n\n// newBol ->{} 空对象\n\n....\n\n2. valueof()函数\n\n所有对象都有 valueOf 方法，valueOf 方法对于：如果存在任意原始值，它就默认将对象转换为表示它的原始值。对象是复合值，而且大多数对象无法真正表示为一个原始值，因此默认的\nvalueOf()方法简单地返回对象本身，而不是返回一个原始值。数组、函数和正则表达式简单地继承了这个默认方法，调用这些类型的实例的 valueOf()方法只是简单返回这个对象本身。\n\n### 对于原始值或者包装类： function baseClone(base){ return base.valueOf()\n\n> }\n\n> //Number\n\n> var num=new Number(1);\n\n> var newNum=baseClone(num);\n\n> //newNum->1\n\n> //String\n\n> var str=new String('hello'); var newStr=baseClone(str);\n\n> // newStr->\"hello\"\n\n> //Boolean\n\n> var bol=new Boolean(true); var newBol=baseClone(bol);\n\n> //newBol-> true\n\n其实对于包装类，完全可以用=号来进行克隆，其实没有深度克隆一说， 这里用 valueOf 实现，语法上比较符合规范。\n\n对于 Date 类型：\n\n因为 valueOf 方法，日期类定义的 valueOf()方法会返回它的一个内部表示：1970 年 1\n\n月 1 日以来的毫秒数.因此我们可以在 Date 的原型上定义克隆的方法：\n\n### Date.prototype.clone=function(){ return new Date(this.valueOf())\n\n> }\n\n> var date=new Date('2010'); var newDate=date.clone();\n\n> // newDate-> Fri Jan 01 2010 08:00:00 GMT+0800\n\n> 对 于 正 则 对 象 RegExp： RegExp.prototype.clone = function() { var pattern = this.valueOf();\n\n### var flags = ''\n\n> flags += pattern.global ? 'g' : ''; flags += pattern.ignoreCase ? 'i' : ''; flags +=\n> pattern.multiline ? 'm' : '';\n\n> return new RegExp(pattern.source, flags);\n\n> };\n\n> var reg=new RegExp('/111/'); var newReg=reg.clone();\n\n> //newReg-> /\\\\/111\\\\//\n\n- ### 简单实现 Node 的 Events 模块\n\n参考回答：\n\n简介：观察者模式或者说订阅模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。\n\nnode 中的 Events 模块就是通过观察者模式来实现的：\n\n### var events=require('events')\n\n> var eventEmitter=new events.EventEmitter(); eventEmitter.on('say',function(name){\n> console.log('Hello',name);\n\n> })\n\n> eventEmitter.emit('say','Jony yu');\n\n这样，eventEmitter 发出 say 事件，通过 On 接收，并且输出结果，这就是一个订阅模式的实现，下面我们来简单的实现一个 Events 模块的 EventEmitter。\n\n1. 实现简单的 Event 模块的 emit 和 on 方法function Events(){ this.on=function(eventName,callBack){\n   if(!this.handles){\n\n### this.handles={}\n\n> } if(!this.handles\\[eventName\\]){ this.handles\\[eventName\\]=\\[\\];\n\n> }\n\n> this.handles\\[eventName\\].push(callBack);\n\n> } this.emit=function(eventName,obj){ if(this.handles\\[eventName\\]){\n\n> for(var i=0;o\\<this.handles\\[eventName\\].length;i++){ this.handles\\[eventName\\]\\[i\\](obj);\n\n> }\n\n> }\n\n> }\n\n> return this;\n\n> }\n\n> 这样我们就定义了 Events，现在我们可以开始来调用： var events=new Events(); events.on('say',function(name){\n> console.log('Hello',nama)\n\n### })\n\n> events.emit('say','Jony yu');\n\n//结果就是通过 emit 调用之后，输出了 Jony yu (2)每个对象是独立的\n\n因为是通过 new 的方式，每次生成的对象都是不相同的，因此：\n\n### var event1=new Events(); var event2=new Events(); event1.on('say',function(){ console.log('Jony event1')\n\n> });\n\n> event2.on('say',function(){ console.log('Jony event2');\n\n> }) event1.emit('say'); event2.emit('say');\n\n//event1、event2 之间的事件监听互相不影响\n\n//输出结果为'Jony event1' 'Jony event2'\n\n- ### 箭头函数中 this 指向举例\n\n参考回答：\n\n### var a=11; function test2(){ this.a=22\n\n> let b=()=>{console.log(this.a)} b();\n\n> }\n\n> var x=new test2();\n\n//输出 22\n\n定义时绑定。\n\n- ### JS 判断类型\n\n参考回答：\n\n判断方法：typeof()，instanceof，Object.prototype.toString.call()等\n\n- ### 数组常用方法\n\n参 考 回 答 ： push()，pop()，shift()，unshift()，splice()，sort()，reverse()，map()等\n\n- ### 数组去重\n\n参考回答：\n\n法一：indexOf 循环去重\n\n法二：ES6 Set 去重；Array.from(new Set(array))\n\n法三：Object 键值对去重；把数组的值存成 Object 的 key 值，比如Object\\[value1\\] = true，在判断另一个值的时候，如果 Object\\[value2\\]存在的话，\n就说明该值是重复的。\n\n- ### 闭包 有什么用\n\n参考回答：\n\n1. 什么是闭包：\n\n闭包是指有权访问另外一个函数作用域中的变量的函数。\n\n闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。当在一个函数内定义另外一个函数就会产生闭包。\n\n2. 为什么要用：\n\n匿名自执行函数：我们知道所有的变量，如果不加上 var\n关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用\nvar 关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，可以用闭包。 结果缓存：我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对\n象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。\n\n封装：实现类和继承等。\n\n- ### 事件代理在捕获阶段的实际应用\n\n参考回答：\n\n可以在父元素层面阻止事件向子元素传播，也可代替子元素执行某些操作。\n\n- ### 去除字符串首尾空格\n\n参考回答：\n\n使用正则(^\\\\s\\*)\\|(\\\\s\\*\\$)即可\n\n- ### 性能优化\n\n参考回答： 减少 HTTP 请求\n\n使用内容发布网络（CDN） 添加本地缓存\n\n压缩资源文件\n\n将 CSS 样式表放在顶部，把 javascript 放在底部（浏览器的运行机制决定） 避免使用 CSS 表达式\n\n减少 DNS 查询\n\n使用外部 javascript 和 CSS\n\n避免重定向 图片 lazyLoad\n\n- ### 来讲讲 JS 的闭包吧\n\n参考回答：\n\n闭包是指有权访问另外一个函数作用域中的变量的函数。\n\n闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。当在一个函数内定义另外一个函数就会产生闭包。\n\n2. 为什么要用：\n\n匿名自执行函数：我们知道所有的变量，如果不加上 var\n关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用\nvar 关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，可以用闭包。 结果缓存：我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对\n象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用\n\n这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。\n\n- ### 能来讲讲 JS 的语言特性吗\n\n参考回答：\n\n运行在客户端浏览器上；\n\n不用预编译，直接解析执行代码； 是弱类型语言，较为灵活；\n\n与操作系统无关，跨平台的语言； 脚本语言、解释性语言\n\n- ### 如何判断一个数组(讲到 typeof 差点掉坑里)\n\n> 参 考 回 答 ： Object.prototype.call.toString() instanceof\n\n- ### 你说到 typeof，能不能加一个限制条件达到判断条件\n\n参考回答：\n\ntypeof 只能判断是 object,可以判断一下是否拥有数组的方法\n\n- ### JS 实现跨域\n\n参考回答：\n\nJSONP：通过动态创建 script，再请求一个带参网址实现跨域通信。document.domain\n\n- iframe 跨域：两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域。\n\nlocation.hash + iframe 跨域：a 欲与b 跨域相互通信，通过中间页c 来实现。 三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 js\n访问来通信。\n\nwindow.name + iframe 跨域：通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。\n\npostMessage 跨域：可以跨域操作的 window 属性之一。\n\nCORS：服务端设置 Access-Control-Allow-Origin 即可，前端无须设置，若要带\n\ncookie 请求，前后端都需要设置。\n\n代理跨域：启一个代理服务器，实现数据的转发\n\n参考 [_https://segmentfault.com/a/1190000011145364_](https://segmentfault.com/a/1190000011145364)\n\n- ### JS 基本数据类型\n\n参考回答：\n\n基本数据类型：undefined、null、number、boolean、string、symbol\n\n- ### JS 深度拷贝一个元素的具体实现\n\n参考回答：\n\n### var deepCopy = function(obj) {\n\n> if (typeof obj !== 'object') return;\n\n> var newObj = obj instanceof Array ? \\[\\] : {}; for (var key in obj) {\n\n> if (obj.hasOwnProperty(key)) {\n\n> newObj\\[key\\] = typeof obj\\[key\\] === 'object' ? deepCopy(obj\\[key\\]) : obj\\[key\\];\n\n> }\n\n> }\n\n> return newObj;\n\n> }\n\n- ### 之前说了 ES6set 可以数组去重，是否还有数组去重的方法\n\n参考回答：\n\n法一：indexOf 循环去重\n\n法二：Object 键值对去重；把数组的值存成 Object 的 key 值，比如Object\\[value1\\] = true，在判断另一个值的时候，如果 Object\\[value2\\]存在的话，\n就说明该值是重复的。\n\n- ### 重排和重绘，讲讲看\n\n参考回答：\n\n重绘（repaint 或\nredraw）：当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。\n\n触发重绘的条件：改变元素外观属性。如：color，background-color 等。\n\n注意：table 及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值， 比同等元素要多花两倍时间，这就是我们尽量避免使用 table\n布局页面的原因之一。重排（重构/回流/reflow）：当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建,\n这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。\n\n重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。所以，重排必定会引发重绘，但重绘不一定会引发重排。\n\n- ### JS 的全排列\n\n参考回答：\n\n### function permutate(str) { var result = \\[\\]; if(str.length \\> 1) {\n\n> var left = str\\[0\\];\n\n> var rest = str.slice(1, str.length); var preResult = permutate(rest); for(var i=0;\n> i\\<preResult.length; i++) {\n\n> for(var j=0; j\\<preResult\\[i\\].length; j++) {\n\n> var tmp = preResult\\[i\\],slice(0, j) + left + preResult\\[i\\].slice(j, preResult\\[i\\].length);\n\n> result.push(tmp);\n\n> }\n\n> }\n\n> } else if (str.length == 1) { return \\[str\\];\n\n> }\n\n> return result;\n\n> }\n\n- ### 跨域的原理\n\n参考回答：\n\n跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对 JavaScript\n实施的安全限制，那么只要协议、域名、端口有任何一个不同，都被当作是不同的域。跨域原理，即是通过各种方式，避开浏览器的安全限制。\n\n- ### 不同数据类型的值的比较，是怎么转换的，有什么规则\n\n参考回答：\n\n![](media/image4.jpeg)\n\n- ### null == undefined 为什么\n\n参考回答：\n\n要比较相等性之前，不能将 null 和 undefined 转换成其他任何值，但 null == undefined 会返回 true 。ECMAScript 规范中是这样定义的。\n\n- ### this 的指向 哪几种\n\n参考回答：\n\n默认绑定：全局环境中，this 默认绑定到 window。\n\n隐式绑定：一般地，被直接对象所包含的函数调用时，也称为方法调用，this 隐式绑定到该直接对象。\n\n隐式丢失：隐式丢失是指被隐式绑定的函数丢失绑定对象，从而默认绑定到 window。显式绑定：通过 call()、apply()、bind()方法把对象绑定到 this 上，叫做显式绑定。\n\nnew 绑定：如果函数或者方法调用之前带有关键字 new，它就构成构造函数调用。对于this 绑定来说，称为 new 绑定。\n\n【1】构造函数通常不使用 return 关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。\n\n【2】如果构造函数使用 return 语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果。\n\n【3】如果构造函数显式地使用 return 语句返回一个对象，那么调用表达式的值就是这个对象。\n\n- ### 暂停死区\n\n参考回答：\n\n在代码块内，使用 let、const 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”\n\n- ### 写一个深度拷贝\n\n参考回答：\n\n### function clone( obj ) { var copy\n\n> switch( typeof obj ) { case \"undefined\": break;\n\n> case \"number\": copy = obj - 0; break;\n\n> case \"string\": copy = obj + \"\"; break;\n\n> case \"boolean\": copy = obj; break;\n\ncase \"object\": //object 分为两种情况 对象（Object）和数组（Array）\n\n### if(obj === null) { copy = null\n\n> } else {\n\n> if( Object.prototype.toString.call(obj).slice(8, -1) === \"Array\") { copy = \\[\\];\n\n> for( var i = 0 ; i \\< obj.length ; i++ ) { copy.push(clone(obj\\[i\\]));\n\n> }\n\n> } else { copy = {};\n\n> for( var j in obj) { copy\\[j\\] = clone(obj\\[j\\]);\n\n> }\n\n> }\n\n> } break; default:\n\n> copy = obj; break;\n\n> }\n\n> return copy;\n\n> }\n\n- ### 简历中提到了 requestAnimationFrame，请问是怎么使用的\n\n参考回答：\n\nrequestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。\n\n- ### 有一个游戏叫做 Flappy Bird，就是一只小鸟在飞，前面是无尽的沙漠，上下不断有钢管生成，你要躲避钢管。然后小明在玩这个游戏时候老是卡顿甚至崩溃，说出原因（3-5 个）以及解决办法（3-5 个）\n\n参考回答： 原因可能是：\n\n1. 内存溢出问题。\n\n2. 资源过大问题。\n\n3. 资源加载问题。4.canvas 绘制频率问题解决办法：\n\n4. 针对内存溢出问题，我们应该在钢管离开可视区域后，销毁钢管，让垃圾收集器回收钢管，因为不断生成的钢管不及时清理容易导致内存溢出游戏崩溃。\n\n5. 针对资源过大问题，我们应该选择图片文件大小更小的图片格式，比如使用 webp、png 格式的图片，因为绘制图片需要较大计算量。\n\n6. 针对资源加载问题，我们应该在可视区域之前就预加载好资源，如果在可视区域生成钢管的话，用户的体验就认为钢管是卡顿后才生成的，不流畅。\n\n7. 针对 canvas 绘制频率问题，我们应该需要知道大部分显示器刷新频率为 60 次/s,因此游戏的每一帧绘制间隔时间需要小于 1000/60=16.7ms，才能让用户觉得不卡顿。\n\n（注意因为这是单机游戏，所以回答与网络无关）\n\n- ### 编写代码，满足以下条件： （1）Hero(\"37er\");执行结果为 Hi! This is 37er （2）Hero(\"37er\").kill(1).recover(30);执行结果为 Hi! This is 37er Kill 1 bug Recover 30 bloods （3） Hero(\"37er\").sleep(10).kill(2)执行结果为 Hi! This is 37er //等待 10s 后 Kill 2 bugs //注意为 bugs （双斜线后的为提示信息，不需要打印）\n\n参考回答：\n\n### function Hero(name){ let o=new Object(); o.name=name; o.time=0\n\n> console.log(\"Hi! This is \"+o.name); o.kill=function(bugs) { if(bugs==1){\n\n> console.log(\"Kill \"+(bugs)+\" bug\");\n\n> }else { setTimeout(function () {\n\n> console.log(\"Kill \" + (bugs) + \" bugs\");\n\n> }, 1000 \\* this.time);\n\n> }\n\n> return o;\n\n> };\n\n18. ecover=function (bloods) { console.log(\"Recover \"+(bloods)+\" bloods\"); return o;\n\n> }\n\n19. leep=function (sleepTime) { o.time=sleepTime;\n\n> return o;\n\n> }\n\n> return o;\n\n> }\n\n- ### 什么是按需加载\n\n参考回答：\n\n当用户触发了动作时才加载对应的功能。触发的动作，是要看具体的业务场景而言， 包括但不限于以下几个情况：鼠标点击、输入文字、拉动滚动条，鼠标移动、窗口大小更改等。加载的文件，可以是\nJS、图片、CSS、HTML 等。\n\n- ### 说一下什么是 virtual dom\n\n参考回答：\n\n用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树， 插到文档当中 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异\n把所记录的差异应用到所构建的真正的 DOM 树上，视图就更新了。Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。\n\n- ### webpack 用来干什么的\n\n参考回答：\n\nwebpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency\ngraph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。\n\n- ### ant-design 优点和缺点\n\n参考回答：\n\n优点：组件非常全面，样式效果也都比较不错。\n\n缺点：框架自定义程度低，默认 UI 风格修改困难。\n\n- ### JS 中继承实现的几种方式\n\n参考回答：\n\n1、原型链继承，将父类的实例作为子类的原型，他的特点是实例是子类的实例也是父类的实例，父类新增的原型方法/属性，子类都能够访问，并且原型链继承简单易于实现，缺点是来自原型对象的所有属性被所有实例共享，无法实现多继承，无法向父类构造函数传参。\n\n2、构造继承，使用父类的构造函数来增强子类实例，即复制父类的实例属性给子类， 构造继承可以向父类传递参数，可以实现多继承，通过 call\n多个父类对象。但是构造继承只能继承父类的实例属性和方法，不能继承原型属性和方法，无法实现函数服\n\n用，每个子类都有父类实例函数的副本，影响性能\n\n3、实例继承，为父类实例添加新特性，作为子类实例返回，实例继承的特点是不限制调用方法，不管是 new 子类（）还是子类（）返回的对象具有相同的效果，缺点是实例是父类的实例，不是子类的实例，不支持多继承\n\n4、拷贝继承：特点：支持多继承，缺点：效率较低，内存占用高（因为要拷贝父类的属性）无法获取父类不可枚举的方法（不可枚举方法，不能使用 for in 访问到）\n\n5、组合继承：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n6、寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点\n\n- ### 写一个函数，第一秒打印 1，第二秒打印 2\n\n参考回答：\n\n> 两个方法，第一个是用 let 块级作用域for(let i=0;i\\<5;i++){ setTimeout(function(){ console.log(i)\n\n### },1000\\*i)\n\n> }\n\n第二个方法闭包\n\n### for(var i=0;i\\<5;i++){ (function(i){ setTimeout(function(){ console.log(i)\n\n> },1000\\*i)\n\n> })(i)\n\n> }\n\n- ### Vue 的生命周期\n\n参考回答：\n\nVue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是 Vue 的生命周期。通俗说就是 Vue\n实例从创建到销毁的过程，就是生命周期。\n\n每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁。\n\n实例、组件通过 new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行beforeCreate 钩子函数，这个时候，数据还没有挂载呢，只是一个空壳，无法访问到数据和真实的\ndom，一般不做操作\n\n挂载数据，绑定事件等等，然后执行 created 函数，这个时候已经可以使用到数据， 也可以更改数据,在这里更改数据不会触发 updated\n函数，在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取\n\n接下来开始找实例或者组件对应的模板，编译模板为虚拟 dom 放入到 render 函数中准备渲染，然后执行 beforeMount 钩子函数，在这个函数中虚拟 dom\n已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发 updated，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取 接下来开始\nrender，渲染出真实 dom，然后执行 mounted 钩子函数，此时，组件已经出现在页面中，数据、真实 dom 都已经处理好了,事件都已经挂载好了，可以在这里操作真实 dom 等事情...\n\n当组件或实例的数据更改之后，会立即执行 beforeUpdate，然后 Vue 的虚拟 dom 机制会重新构建虚拟 dom 与上一次的虚拟 dom 树利用 diff\n算法进行对比之后重新渲染，一般不做什么事儿\n\n当更新完成后，执行 updated，数据已经更改完成，dom 也重新 render 完成，可以操作更新后的虚拟 dom\n\n当经过某种途径调用\\$destroy 方法后，立即执行beforeDestroy，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等\n\n组件的数据绑定、监听...去掉后只剩下 dom 空壳，这个时候，执行 destroyed，在这里做善后工作也可以\n\n- ### 简单介绍一下 symbol\n\n参考回答：\n\nSymbol 是 ES6 的新增属性，代表用给定名称作为唯一标识，这种类型的值可以这样创建，let id=symbol(“id”)\n\nSymbl 确保唯一，即使采用相同的名称，也会产生不同的值，我们创建一个字段，仅为知道对应 symbol 的人能访问，使用 symbol 很有用，symbol 并不是 100%隐藏，有内置方法\nObject.getOwnPropertySymbols(obj)可以获得所有的 symbol。\n\n也有一个方法 Reflect.ownKeys(obj)返回对象所有的键，包括 symbol。\n\n所以并不是真正隐藏。但大多数库内置方法和语法结构遵循通用约定他们是隐藏的。\n\n- ### 什么是事件监听\n\n参考回答：\n\naddEventListener()方法，用于向指定元素添加事件句柄，它可以更简单的控制事件，语法为\n\nelement.addEventListener(event, function, useCapture);\n\n第一个参数是事件的类型(如 \"click\" 或 \"mousedown\"). 第二个参数是事件触发后调用的函数。\n\n第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。事件传递有两种方式，冒泡和捕获\n\n事件传递定义了元素事件触发的顺序，如果你将P 元素插入到 div 元素中，用户点击P\n\n元素，\n\n在冒泡中，内部元素先被触发，然后再触发外部元素， 捕获中，外部元素先被触发，在触发内部元素。\n\n- ### 介绍一下 promise，及其底层如何实现\n\n参考回答：\n\nPromise 是一个对象，保存着未来将要结束的事件，她有两个特征:\n\n1、对象的状态不受外部影响，Promise 对象代表一个异步操作，有三种状态，pending 进行中，fulfilled 已成功，rejected\n已失败，只有异步操作的结果，才可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也就是 promise 名字的由来2、一旦状态改变，就不会再变，promise 对象状态改变只有两种可能，从\npending 改到 fulfilled 或者从 pending 改到 rejected，只要这两种情况发生，状态就凝固了， 不会再改变，这个时候就称为定型 resolved,\n\nPromise 的基本用法，\n\n### let promise1 = new Promise(function(resolve,reject){ setTimeout(function(){\n\n> resolve('ok')\n\n> },1000)\n\n> })\n\n> promise1.then(function success(val){ console.log(val)\n\n> })\n\n> 最简单代码实现 promise class PromiseM { constructor (process) { this.status = 'pending' this.msg = ''\n\n> process(this.resolve.bind(this), this.reject.bind(this)) return this\n\n> }\n\n> resolve (val) { this.status = 'fulfilled' this.msg = val\n\n> }\n\n> reject (err) { this.status = 'rejected' this.msg = err\n\n> }\n\n> then (fufilled, reject) { if(this.status === 'fulfilled') { fufilled(this.msg)\n\n> }\n\n> if(this.status === 'rejected') { reject(this.msg)\n\n> }\n\n> }\n\n> }\n\n//测试代码\n\n### var mm=new PromiseM(function(resolve,reject){ resolve('123')\n\n> });\n\n> mm.then(function(success){ console.log(success);\n\n> },function(){\n\n> console.log('fail!');\n\n> });\n\n- ### 说说 C++,Java，JavaScript 这三种语言的区别\n\n参考回答：\n\n从静态类型还是动态类型来看\n\n静态类型，编译的时候就能够知道每个变量的类型，编程的时候也需要给定类型，如\n\nJava 中的整型 int，浮点型 float 等。C、C++、Java 都属于静态类型语言。\n\n动态类型，运行的时候才知道每个变量的类型，编程的时候无需显示指定类型，如JavaScript 中的 var、PHP 中的\\$。JavaScript、Ruby、Python\n都属于动态类型语言。静态类型还是动态类型对语言的性能有很大影响。\n\n对于静态类型，在编译后会大量利用已知类型的优势，如 int 类型，占用 4 个字节， 编译后的代码就可以用内存地址加偏移量的方法存取变量，而地址加偏移量的算法汇编很容易实现。\n\n对于动态类型，会当做字符串通通存下来，之后存取就用字符串匹配。从编译型还是解释型来看\n\n编译型语言，像C、C++，需要编译器编译成本地可执行程序后才能运行，由开发人员在编写完成后手动实施。用户只使用这些编译好的本地代码，这些本地代码由系统加载器执行，由操作系统的 CPU\n直接执行，无需其他额外的虚拟机等。\n\n源代码=》抽象语法树=》中间表示=》本地代码\n\n解释性语言，像 JavaScript、Python，开发语言写好后直接将代码交给用户，用户使用脚本解释器将脚本文件解释执行。对于脚本语言，没有开发人员的编译过程，当 然，也不绝对。\n\n源代码=》抽象语法树=》解释器解释执行。\n\n对于 JavaScript，随着 Java 虚拟机 JIT 技术的引入，工作方式也发生了改变。可以将抽象语法树转成中间表示（字节码），再转成本地代码，如\nJavaScriptCore，这样可以大大提高执行效率。也可以从抽象语法树直接转成本地代码，如 V8\n\nJava 语言，分为两个阶段。首先像 C++语言一样，经过编译器编译。和 C++的不同， C++编译生成本地代码，Java 编译后，生成字节码，字节码与平台无关。第二阶段，由Java 的运行环境也就是\nJava 虚拟机运行字节码，使用解释器执行这些代码。一般情况下，Java 虚拟机都引入了 JIT 技术，将字节码转换成本地代码来提高执行效率。\n\n注意，在上述情况中，编译器的编译过程没有时间要求，所以编译器可以做大量的代码优化措施。\n\n对于 JavaScript 与 Java 它们还有的不同：\n\n对于 Java，Java 语言将源代码编译成字节码，这个同执行阶段是分开的。也就是从源代码到抽象语法树到字节码这段时间的长短是无所谓的。\n\n对于 JavaScript，这些都是在网页和 JavaScript 文件下载后同执行阶段一起在网页的加载和渲染过程中实施的，所以对于它们的处理时间有严格要求。\n\n- ### JS 原型链，原型链的顶端是什么？Object 的原型是什么？Object 的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法\n\n参考回答：\n\n能够把这个讲清楚弄明白是一件很困难的事，\n\n首先明白原型是什么，在 ES6 之前，JS 没有类和继承的概念，JS 是通过原型来实现继承的，在 JS 中一个构造函数默认带有一个 prototype 属性，这个的属性值是一个对象，同时这个\nprototype 对象自带有一个 constructor 属性，这个属性指向这个构造函数，同时每一个实例都会有一个_proto_属性指向这个 prototype\n对象，我们可以把这个叫做隐式原型，我们在使用一个实例的方法的时候，会先检查这个实例中是否有这个方法，没有的话就会检查这个 prototype 对象是否有这个方法，\n\n基于这个规则，如果让原型对象指向另一个类型的实例，即constructor1.protoytpe=instance2，这时候如果试图引用 constructor1 构造的实例instance1\n的某个属性 p1,\n\n首先会在 instance1 内部属性中找一遍，\n\n接着会在 instance1.\\_proto\\_（constructor1.prototype）即是 instance2 中寻找 p1\n\n搜寻轨迹：\n\ninstance1->instance2->constructor2.prototype……->Object.prototype;这即是原型链，原型链顶端是 Object.prototype\n\n补充学习：\n\n每个函数都有一个 prototype 属性，这个属性指向了一个对象，这个对象正是调用该函数而创建的实例的原型，那么什么是原型呢，可以这样理解，每一个 JavaScript\n对象在创建的时候就会预制管理另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型继承属性，如图：\n\n![](media/image5.jpeg)\n\n那么怎么表示实例与实例原型的关系呢，这时候就要用到第二个属性_proto\\_ 这是每一个 JS 对象都会有的一个属性，指向这个对象的原型，如图：\n\n> ![](media/image6.jpeg)\n\n既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢，指向实例是没有的，因为一个构造函数可以生成多个实例，但是原型有属性可以直接指向构造函数，通过constructor 即可\n\n接下来讲解实例和原型的关系：\n\n当读取实例的属性时，如果找不到，就会查找与对象相关的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层，那么原型的原型是什么呢，首先，原型也是一个对象，既然是对象，我们就可以通过构造函数的方式创建它，所以原型对象就是通过\nObject 构造函数生成的，如图：\n\n![](media/image7.jpeg)\n\n那么 Object.prototype 的原型呢，我们可以打印\n\nconsole.log(Object.prototype. proto === null)，返回 true\n\nnull 表示没有对象，即该处不应有值，所以 Object.prototype 没有原型，如图：\n\n![](media/image8.jpeg)\n\n图中这条蓝色的线即是原型链， 最 后 补 充 三 点 ： constructor：\n\nfunction Person(){\n\n}\n\nvar person = new Person(); console.log(Person === person.constructor);\n\n原本 person 中没有 constructor 属性，当不能读取到 constructor 属性时，会从\n\nperson 的原型中读取，所以指向构造函数 Person\n\nproto ：\n\n绝大部分浏览器支持这个非标准的方法访问原型，然而它并不存在与Person.prototype 中，实际上它来自 Object.prototype，当使用 obj. proto 时， 可以理解为返回来\nObject.getPrototype(obj)\n\n继承：\n\n前面说到，每个对象都会从原型继承属性，但是引用《你不知道的 JS》中的话，继承意味着复制操作，然而 JS 默认不会复制对象的属性，相反，JS\n只是在两个对象之间创建一个关联，这样子一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，叫委托更合适。\n\n- ### 什么是 js 的闭包？有什么作用，用闭包写个单例模式\n\n参考回答：\n\nMDN 对闭包的定义是：闭包是指那些能够访问自由变量的函数，自由变量是指在函数中使用的，但既不是函数参数又不是函数的局部变量的变量，由此可以看出，闭包=函数\n\n+函数能够访问的自由变量，所以从技术的角度讲，所有 JS 函数都是闭包，但是这是理论上的闭包，还有一个实践角度上的闭包，从实践角度上来说，只有满足\n1、即使创建它的上下文已经销毁，它仍然存在，2、在代码中引入了自由变量，才称为闭包\n\n闭包的应用：\n\n模仿块级作用域。2、保存外部函数的变量。3、封装私有变量单例模式：\n\n### var Singleton = (function(){ var instance\n\n> var CreateSingleton = function (name) { this.name = name;\n\n> if(instance) { return instance;\n\n> }\n\n// 打印实例名字\n\n### this.getName()\n\n> // instance = this;\n\n> // return instance; return instance = this;\n\n> }\n\n> // 获取实例的名字CreateSingleton.prototype.getName = function() { console.log(this.name)\n\n> }\n\n> return CreateSingleton;\n\n> })();\n\n// 创建实例对象 1\n\n### var a = new Singleton('a')\n\n// 创建实例对象 2\n\n### var b = new Singleton('b'); console.log(a===b)\n\n- ### promise+Generator+Async 的使用\n\n参考回答： Promise\n\n解决的问题:回调地狱Promise 规范:\n\npromise 有三种状态，等待（pending）、已完成（fulfilled/resolved）、已拒绝\n\n（rejected）.Promise 的状态只能从“等待”转到“完成”或者“拒绝”，不能逆向转换，同时“完成”和“拒绝”也不能相互转换.\n\npromise 必须提供一个 then 方法以访问其当前值、终值和据因。promise.then(resolve, reject),resolve 和 reject 都是可选参数。如果 resolve\n或 reject 不是函数，其必须被忽略.\n\nthen 方法必须返回一个 promise 对象.\n\n使用:\n\n实例化 promise 对象需要传入函数(包含两个参数),resolve 和 reject,内部确定状态.resolve 和 reject 函数可以传入参数在回调函数中使用.\n\n> resolve 和 reject 都是函数,传入的参数在 then 的回调函数中接收. var promise = new Promise(function(resolve, reject) {\n> setTimeout(function(){\n\n### resolve('好哈哈哈哈')\n\n> });\n\n> });\n\n> promise.then(function(val){ console.log(val)\n\n> })\n\nthen 接收两个函数,分别对应 resolve 和 reject 状态的回调,函数中接收实例化时传入的参数.\n\n### promise.then(val=>{\n\n> //resolved\n\n> },reason=>{\n\n> //rejected\n\n> })\n\ncatch 相当于.then(null, rejection)\n\n当 then 中没有传入 rejection 时,错误会冒泡进入 catch 函数中,若传入了 rejection, 则错误会被 rejection 捕获,而且不会进入 catch.此外,then\n中的回调函数中发生的错误只会在下一级的 then 中被捕获,不会影响该 promise 的状态.\n\n### new Promise((resolve,reject)=>{ throw new Error('错误')\n\n> }).then(null,(err)=>{ console.log(err,1);//此处捕获\n\n> }).catch((err)=>{ console.log(err,2);\n\n> });\n\n### // 对比\n\n> new Promise((resolve,reject)=>{\n\n> throw new Error('错误')\n\n> }).then(null,null).catch((err)=>{ console.log(err,2);//此处捕获\n\n> });\n\n> // 错误示例\n\n> new Promise((resolve,reject)=>{ resolve('正常');\n\n> }).then((val)=>{\n\n> throw new Error('回调函数中错误')\n\n> },(err)=>{ console.log(err,1);\n\n> }).then(null,(err)=>{ console.log(err,2);//此处捕获,也可用 catch\n\n> });\n\n两者不等价的情况:\n\n此时，catch 捕获的并不是 p1 的错误，而是 p2 的错误，\n\n### p1().then(res=>{\n\n> return p2()//p2 返回一个 promise 对象\n\n> }).catch(err=> console.log(err))\n\n一个错误捕获的错误用例:\n\n该函数调用中即使发生了错误依然会进入 then 中的 resolve 的回调函数,因为函数 p1 中实例化 promise 对象时已经调用了 catch,若发生错误会进入 catch\n中,此时会返回一个新的 promise,因此即使发生错误依然会进入 p1 函数的 then 链中的 resolve 回调函数.\n\n### function p1(val){\n\n> return new Promise((resolve,reject)=>{ if(val){\n\n> var len = val.length;//传入 null 会发生错误,进入 catch 捕获错resolve(len);\n\n> }else{ reject();\n\n> }\n\n> }).catch((err)=>{ console.log(err)\n\n> })\n\n> }; p1(null).then((len)=>{\n\n> console.log(len,'resolved');\n\n> },()=>{\n\n> console.log('rejected');\n\n> }).catch((err)=>{\n\n> console.log(err,'catch');\n\n> })\n\nPromise 回调链:\n\npromise 能够在回调函数里面使用 return 和 throw， 所以在 then 中可以 return 出一个 promise 对象或其他值，也可以 throw 出一个错误对象，但如果没有\nreturn，将默认返回 undefined，那么后面的 then 中的回调参数接收到的将是 undefined. function p1(val){\n\n### return new Promise((resolve,reject)=>{ val==1?resolve(1):reject()\n\n> })\n\n> };\n\n> function p2(val){\n\n> return new Promise((resolve,reject)=>{ val==2?resolve(2):reject();\n\n> })\n\n> };\n\n> let promimse = new Promise(function(resolve,reject){ resolve(1)\n\n> })\n\n> .then(function(data1) {\n\n> return p1(data1)//如果去掉 return,则返回 undefined 而不是 p1 的返回值, 会导致报错\n\n> })\n\n> .then(function(data2){ return p2(data2+1)\n\n> })\n\n> .then(res=>console.log(res))\n\nGenerator 函 数 ： generator 函数使用:\n\n1、分段执行，可以暂停\n\n2、可以控制阶段和每个阶段的返回值\n\n3、可以知道是否执行到结尾\n\n### function\\* g() { var o = 1; yield o++; yield o++\n\n> }\n\n> var gen = g();\n\n> console.log(gen.next()); // Object {value: 1, done: false} var xxx = g();\n\n> console.log(gen.next()); // Object {value: 2, done: false} console.log(xxx.next()); // Object\n> {value: 1, done: false} console.log(gen.next()); // Object {value: undefined, done: true}\n\ngenerator 和异步控制:\n\n利用 Generator 函数的暂停执行的效果，可以把异步操作写在 yield 语句里面，等到调用 next 方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在\nyield 语句下面，反正要等到调用 next 方法时再执行。所以， Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。\n\nasync 和异步: 用法:\n\nasync 表示这是一个 async 函数，await 只能用在这个函数里面。await 表示在这里等待异步操作返回结果，再继续执行。\n\nawait 后一般是一个 promise 对象\n\n示例:async 用于定义一个异步函数，该函数返回一个 Promise。\n\n如果 async 函数返回的是一个同步的值，这个值将被包装成一个理解 resolve 的\n\nPromise，等同于 return Promise.resolve(value)。\n\nawait 用于一个异步操作之前，表示要“等待”这个异步操作的返回值。await 也可以用于一个同步的值。\n\n### let timer = async function timer(){ return new Promise((resolve,reject) => { setTimeout(() => {\n\n> resolve('500');\n\n> },500);\n\n> });\n\n> }\n\n> timer().then(result => { console.log(result); //500\n\n> }).catch(err => { console.log(err.message);\n\n> });\n\n> //返回一个同步的值\n\n> let sayHi = async function sayHi(){ let hi = await 'hello world';\n\n> return hi; //等同于 return Promise.resolve(hi);\n\n> }\n\n> sayHi().then(result => { console.log(result);\n\n> });\n\n- ### 事件委托以及冒泡原理\n\n参考回答：\n\n事件委托是利用冒泡阶段的运行机制来实现的，就是把一个元素响应事件的函数委托到另一个元素，一般是把一组元素的事件委托到他的父元素上，委托的优点是\n\n减少内存消耗，节约效率动态绑定事件\n\n事件冒泡，就是元素自身的事件被触发后，如果父元素有相同的事件，如 onclick 事件，那么元素本身的触发状态就会传递，也就是冒到父元素，父元素的相同事件也会一级一级根据嵌套关系向外触发，直到\ndocument/window，冒泡过程结束。\n\n- ### 写个函数，可以转化下划线命名到驼峰命名\n\n参考回答：\n\n### public static String UnderlineToHump(String para){ StringBuilder result=new StringBuilder()\n\n> String a\\[\\]=para.split(\"\\_\"); for(String s:a){ if(result.length()==0){\n> result.append(s.toLowerCase());\n\n> }else{\n\n> result.append(s.substring(0, 1).toUpperCase()); result.append(s.substring(1).toLowerCase());\n\n> }\n\n> }\n\n> return result.toString();\n\n> }\n\n> }\n\n- ### 深浅拷贝的区别和实现\n\n参考回答：\n\n数组的浅拷贝：\n\n如果是数组，我们可以利用数组的一些方法，比如 slice，concat 方法返回一个新数组的特性来实现拷贝，但假如数组嵌套了对象或者数组的话，使用 concat\n方法克隆并不完整，如果数组元素是基本类型，就会拷贝一份，互不影响，而如果是对象或数\n组，就会只拷贝对象和数组的引用，这样我们无论在新旧数组进行了修改，两者都会发生变化，我们把这种复制引用的拷贝方法称为浅拷贝，\n\n深拷贝就是指完全的拷贝一个对象，即使嵌套了对象，两者也互相分离，修改一个对象的属性，不会影响另一个\n\n如何深拷贝一个数组\n\n### 1、这里介绍一个技巧，不仅适用于数组还适用于对象！那就是： var arr = \\['old', 1, true, \\['old1', 'old2'\\], {old: 1}\\] var new_arr = JSON.parse( JSON.stringify(arr) ); console.log(new_arr)\n\n原理是 JOSN 对象中的 stringify 可以把一个 js 对象序列化为一个 JSON 字符串， parse 可以把 JSON 字符串反序列化为一个 js\n对象，通过这两个方法，也可以实现对象的深复制。\n\n但是这个方法不能够拷贝函数浅拷贝的实现：\n\n以上三个方法 concat,slice ,JSON.stringify\n都是技巧类，根据实际项目情况选择使用，我们可以思考下如何实现一个对象或数组的浅拷贝，遍历对象，然后把属性和属性值都放在一个新的对象里即可\n\n### var shallowCopy = function(obj) {\n\n> // 只拷贝对象\n\n> if (typeof obj !== 'object') return;\n\n> // 根据 obj 的类型判断是新建一个数组还是对象var newObj = obj instanceof Array ? \\[\\] : {};\n\n> // 遍历 obj，并且判断是 obj 的属性才拷贝\n\n> for (var key in obj) {\n\n> if (obj.hasOwnProperty(key)) { newObj\\[key\\] = obj\\[key\\];\n\n> }\n\n> }\n\n> return newObj;\n\n深拷贝的实现\n\n那如何实现一个深拷贝呢？说起来也好简单，我们在拷贝的时候判断一下属性值的类型，如果是对象，我们递归调用深拷贝函数不就好了\\~\n\n### var deepCopy = function(obj) {\n\n> if (typeof obj !== 'object') return;\n\n> var newObj = obj instanceof Array ? \\[\\] : {}; for (var key in obj) {\n\n> if (obj.hasOwnProperty(key)) {\n\n> newObj\\[key\\] = typeof obj\\[key\\] === 'object' ? deepCopy(obj\\[key\\]) : obj\\[key\\];\n\n> }\n\n> }\n\n> return newObj;\n\n> }\n\n- ### JS 中 string 的 startwith 和 indexof 两种方法的区别\n\n参考回答：\n\nJS 中 startwith 函数，其参数有 3 个，stringObj,要搜索的字符串对象，str，搜索的字符串，position，可选，从哪个位置开始搜索，如果以 position\n开始的字符串以搜索字符串开头，则返回 true，否则返回 false\n\nIndexof 函数，indexof 函数可返回某个指定字符串在字符串中首次出现的位置。\n\n- ### JS 字符串转数字的方法\n\n参考回答：\n\n通过函数 parseInt（），可解析一个字符串，并返回一个整数，语法为 parseInt\n\n（string ,radix） string：被解析的字符串\n\nradix：表示要解析的数字的基数，默认是十进制，如果 radix\\<2 或>36,则返回 NaN\n\n- ### let const var 的区别 ，什么是块级作用域，如何用 ES5 的方法实现块级作用域（立即执行函数），ES6 呢\n\n参考回答：\n\n提起这三个最明显的区别是 var 声明的变量是全局或者整个函数块的，而 let,const 声明的变量是块级的变量，var 声明的变量存在变量提升，let,const 不存在，let\n声明的变量允许重新赋值，const 不允许。\n\n- ### ES6 箭头函数的特性\n\n参考回答：\n\nES6 增加了箭头函数，基本语法为let func = value => value;\n\n相当于\n\nlet func = function (value) { return value;\n\n};\n\n箭头函数与普通函数的区别在于：\n\n1、箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值，这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this，\n\n2、箭头函数没有自己的 arguments 对象，但是可以访问外围函数的 arguments 对象3、不能通过 new 关键字调用，同样也没有 new.target 值和原型\n\n- ### setTimeout 和 Promise 的执行顺序\n\n参考回答：\n\n首先我们来看这样一道题：\n\n### setTimeout(function() {\n\n> console.log(1)\n\n> }, 0);\n\n> new Promise(function(resolve, reject) { console.log(2)\n\n> for (var i = 0; i \\< 10000; i++) { if(i === 10) {console.log(10)}\n\n> i == 9999 && resolve();\n\n> } console.log(3)\n\n> }).then(function() { console.log(4)\n\n> }) console.log(5);\n\n输出答案为 2 10 3 5 4 1\n\n要先弄清楚 settimeout（fun,0）何时执行，promise 何时执行，then 何时执行settimeout\n这种异步操作的回调，只有主线程中没有执行任何同步代码的前提下，才会执行异步回调，而 settimeout（fun,0）表示立刻执行，也就是用来改变任务的执行顺序，要求浏览器尽可能快的进行回调\n\npromise 何时执行，由上图可知 promise 新建后立即执行，所以 promise 构造函数里代码同步执行的，\n\nthen 方法指向的回调将在当前脚本所有同步任务执行完成后执行，\n\n那么 then 为什么比 settimeout 执行的早呢，因为 settimeout（fun,0）不是真的立即执行，\n\n经过测试得出结论：执行顺序为：同步执行的代码-》promise.then->settimeout\n\n- ### 有了解过事件模型吗，DOM0 级和 DOM2 级有什么区别，DOM 的分级是什么\n\n参考回答：\n\nJSDOM 事件流存在如下三个阶段： 事件捕获阶段\n\n处于目标阶段事件冒泡阶段\n\nJSDOM 标准事件流的触发的先后顺序为：先捕获再冒泡，点击 DOM 节点时，事件传播顺序：事件捕获阶段，从上往下传播，然后到达事件目标节点，最后是冒泡阶段，从下往上传播\n\nDOM 节点添加事件监听方法 addEventListener，中参数 capture 可以指定该监听是添加在事件捕获阶段还是事件冒泡阶段，为 false 是事件冒泡，为 true\n是事件捕获，并非所有的事件都支持冒泡，比如 focus，blur 等等，我们可以通过 event.bubbles 来判断\n\n事件模型有三个常用方法：\n\nevent.stopPropagation:阻止捕获和冒泡阶段中，当前事件的进一步传播， event.stopImmediatePropagetion，阻止调用相同事件的其他侦听器，\n\nevent.preventDefault，取消该事件（假如事件是可取消的）而不停止事件的进一步传播，\n\nevent.target：指向触发事件的元素，在事件冒泡过程中这个值不变event.currentTarget = this，时间帮顶的当前元素，只有被点击时目标元素的target 才会等于\ncurrentTarget，\n\n最后，对于执行顺序的问题，如果 DOM\n节点同时绑定了两个事件监听函数，一个用于捕获，一个用于冒泡，那么两个事件的执行顺序真的是先捕获在冒泡吗，答案是否定的，绑定在被点击元素的事件是按照代码添加顺序执行的，其他函数是先捕获再冒泡\n\n- ### 平时是怎么调试 JS 的\n\n参考回答：\n\n一般用 Chrome 自带的控制台\n\n- ### JS 的基本数据类型有哪些，基本数据类型和引用数据类型的区别，NaN 是什么的缩写，JS 的作用域类型，undefined==null 返回的结果是什么，undefined 与 null 的区别在哪，写一个函数判断变量类型\n\n参考回答：\n\nJS 的基本数据类型有字符串，数字，布尔，数组，对象，Null，Undefined,基本数据类型是按值访问的，也就是说我们可以操作保存在变量中的实际的值，\n\n基本数据类型和引用数据类型的区别如下：\n\n基本数据类型的值是不可变的，任何方法都无法改变一个基本类型的值，当这个变量重新赋值后看起来变量的值是改变了，但是这里变量名只是指向变量的一个指针，所以改变的是指针的指向改变，该变量是不变的，但是引用类型可以改变\n\n基本数据类型不可以添加属性和方法，但是引用类型可以\n\n基本数据类型的赋值是简单赋值，如果从一个变量向另一个变量赋值基本类型的值， 会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上，引用数据类型的赋值是对象引用，\n\n基本数据类型的比较是值的比较，引用类型的比较是引用的比较，比较对象的内存地址是否相同\n\n基本数据类型是存放在栈区的，引用数据类型同事保存在栈区和堆区\n\nNaN 是 JS 中的特殊值，表示非数字，NaN 不是数字，但是他的数据类型是数字，它不等于任何值，包括自身，在布尔运算时被当做 false，NaN 与任何数运算得到的结果都是\nNaN，党员算失败或者运算无法返回正确的数值的就会返回 NaN，一些数学函数的运算结果也会出现 NaN ,\n\nJS 的作用域类型：\n\n一般认为的作用域是词法作用域，此外 JS 还提供了一些动态改变作用域的方法，常见的作用域类型有：\n\n函数作用域，如果在函数内部我们给未定义的一个变量赋值，这个变量会转变成为一个全局变量，\n\n块作用域：块作用域吧标识符限制在{}中， 改变函数作用域的方法：\n\neval（），这个方法接受一个字符串作为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码，\n\nwith 关键字：通常被当做重复引用同一个对象的多个属性的快捷方式\n\nundefined 与 null：目前 null 和 undefined 基本是同义的，只有一些细微的差别， null 表示没有对象，undefined\n表示缺少值，就是此处应该有一个值但是还没有定义，因此 undefined==null 返回 false\n\n此外了解== 和===的区别：\n\n在做==比较时。不同类型的数据会先转换成一致后在做比较，===中如果类型不一致就直接返回 false，一致的才会比较\n\n类型判断函数，使用 typeof 即可，首先判断是否为 null，之后用 typeof 哦按段，如果是 object 的话，再用 array.isarray 判断是否为数组，如果是数字的话用\nisNaN 判断是否是 NaN 即可\n\n扩展学习：\n\nJS 采用的是词法作用域，也就是静态作用域，所以函数的作用域在函数定义的时候就决定了，\n\n看如下例子：\n\n### var value = 1; function foo() { console.log(value)\n\n> }\n\n> function bar() { var value = 2; foo();\n\n> } bar();\n\n假设 JavaScript 采用静态作用域，让我们分析下执行过程：\n\n执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。\n\n假设 JavaScript 采用动态作用域，让我们分析下执行过程：\n\n执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印\n2。前面我们已经说了，JavaScript 采用的是静态作用域，所以这个例子的结果是 1。\n\n- ### setTimeout(fn,100);100 毫秒是如何权衡的\n\n参考回答：\n\nsetTimeout()函数只是将事件插入了任务列表，必须等到当前代码执行完，主线程才会去执行它指定的回调函数，有可能要等很久，所以没有办法保证回调函数一定会在setTimeout\n指定的时间内执行，100 毫秒是插入队列的时间+等待的时间\n\n- ### JS 的垃圾回收机制\n\n参考回答：\n\nGC（garbage collection），GC 执行时，中断代码，停止其他操作，遍历所有对象， 对于不可访问的对象进行回收，在 V8 引擎中使用两种优化方法，\n\n分代回收，2、增量 GC，目的是通过对象的使用频率，存在时长来区分新生代和老生代对象，多回收新生代区，少回收老生代区，减少每次遍历的时间，从而减少 GC 的耗时回收方法：\n\n引用计次，当对象被引用的次数为零时进行回收，但是循环引用时，两个对象都至少被引用了一次，因此导致内存泄漏，\n\n标记清除\n\n- ### 写一个 newBind 函数，完成 bind 的功能\n\n参考回答：\n\n> bind（）方法，创建一个新函数，当这个新函数被调用时，bind（）的第一个参数将作为它运行时的\n> this，之后的一序列参数将会在传递的实参前传入作为它的参数Function.prototype.bind2 = function (context) {\n\n### if (typeof this !== \"function\") {\n\n> throw new Error(\"Function.prototype.bind - what is trying to be bound is not callable\");\n\n> }\n\n> var self = this;\n\n> var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () {};\n\n> var fbound = function () {\n\n> self.apply(this instanceof self ? this : context,\n> args.concat(Array.prototype.slice.call(arguments)));\n\n> }\n\n> fNOP.prototype = this.prototype; fbound.prototype = new fNOP(); return fbound;\n\n> }\n\n- ### 怎么获得对象上的属性：比如说通过 Object.key（）\n\n参考回答：\n\n从 ES5 开始，有三种方法可以列出对象的属性\n\nfor（let I in\nobj）该方法依次访问一个对象及其原型链中所有可枚举的类型object.keys:返回一个数组，包括所有可枚举的属性名称object.getOwnPropertyNames:返回一个数组包含不可枚举的属性\n\n- ### 简单讲一讲 ES6 的一些新特性\n\n参考回答：\n\nES6 在变量的声明和定义方面增加了 let、const 声明变量，有局部变量的概念，赋值中有比较吸引人的结构赋值，同时 ES6 对字符串、\n数组、正则、对象、函数等拓展了一些方法，如字符串方面的模板字符串、函数方面的默认参数、对象方面属性的简洁表达方式，ES6 也 引入了新的数据类型 symbol，新的数据结构 set 和\nmap,symbol 可以通过 typeof 检测出来，为解决异步回调问题，引入了 promise 和 generator，还有最为吸引人了实现 Class 和模块，通过 Class\n可以更好的面向对象编程，使用模块加载方便模块化编程，当然考虑到 浏览器兼容性，我们在实际开发中需要使用 babel 进行编译\n\n重要的特性：\n\n块级作用域：ES5 只有全局作用域和函数作用域，块级作用域的好处是不再需要立即执行的函数表达式，循环体中的闭包不再有问题\n\nrest 参数：用于获取函数的多余参数，这样就不需要使用 arguments 对象了， promise:一种异步编程的解决方案，比传统的解决方案回调函数和事件更合理强大\n模块化：其模块功能主要有两个命令构成，export 和 import，export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能\n\n- ### call 和 apply 是用来做什么？\n\n参考回答：\n\nCall 和 apply 的作用是一模一样的，只是传参的形式有区别而已1、改变 this 的指向\n\n2、借用别的对象的方法，\n\n3、调用函数，因为 apply，call 方法会使函数立即执行\n\n- ### 了解事件代理吗，这样做有什么好处\n\n参考回答：\n\n事件代理/事件委托：利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的事件，\n\n简而言之：事件代理就是说我们将事件添加到本来要添加的事件的父节点，将事件委托给父节点来触发处理函数，这通常会使用在大量的同级元素需要添加同一类事件的时候，比如一个动态的非常多的列表，需要为每个列表项都添加点击事件，这时就可以使用事件代理，通过判断\ne.target.nodeName 来判断发生的具体元素，这样做的好处是减少事件绑定，同事动态的 DOM 结构任然可以监听，事件代理发生在冒泡阶段\n\n- ### 如何写一个继承？\n\n参考回答： 原型链继承\n\n核心： 将父类的实例作为子类的原型特点：\n\n非常纯粹的继承关系，实例是子类的实例，也是父类的实例父类新增原型方法/原型属性，子类都能访问到\n\n简单，易于实现缺点：\n\n要想为子类新增属性和方法，不能放到构造器中无法实现多继承\n\n来自原型对象的所有属性被所有实例共享 创建子类实例时，无法向父类构造函数传参\n\n构造继承\n\n核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）\n\n特点：\n\n解决了子类实例共享父类引用属性的问题创建子类实例时，可以向父类传递参数 可以实现多继承（call 多个父类对象） 缺点：\n\n实例并不是父类的实例，只是子类的实例\n\n只能继承父类的实例属性和方法，不能继承原型属性/方法\n\n无法实现函数复用，每个子类都有父类实例函数的副本，影响性能\n\n实例继承\n\n核心：为父类实例添加新特性，作为子类实例返回特点：\n\n不限制调用方式，不管是 new 子类()还是子类(),返回的对象具有相同的效果\n\n缺点：\n\n实例是父类的实例，不是子类的实例不支持多继承\n\n拷贝继承特点：\n\n支持多继承缺点：\n\n效率较低，内存占用高（因为要拷贝父类的属性）\n\n组合继承\n\n核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n特点：\n\n可以继承实例属性/方法，也可以继承原型属性/方法既是子类的实例，也是父类的实例\n\n不存在引用属性共享问题可传参\n\n函数可复用\n\n寄生组合继承\n\n核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n参考 [_https://www.cnblogs.com/humin/p/4556820.html_](https://www.cnblogs.com/humin/p/4556820.html)\n\n- ### 给出以下代码，输出的结果是什么？原因？ for(var i=0;i\\<5;i++)\n\n> { setTimeout(function(){ console.log(i); },1000); } console.log(i)\n\n参考回答：\n\n在一秒后输出 5 个 5\n\n每次 for 循环的时候 setTimeout 都会执行，但是里面的 function 则不会执行被放入任务队列，因此放了 5 次；for 循环的 5 次执行完之后不到 1000 毫秒；1000\n毫秒后全部执行任务队列中的函数，所以就是输出 5 个 5。\n\n- ### 给两个构造函数 A 和 B，如何实现 A 继承 B？\n\n参考回答：\n\n### function A(...) {} A.prototype\n\n> function B(...) {} B.prototype... A.prototype = Object.create(B.prototype);\n\n> // 再在A 的构造函数里 new B(props); for(var i = 0; i \\< lis.length; i++) {\n\n> lis\\[i\\].addEventListener('click', function(e) { alert(i);\n\n> }, false)\n\n> }\n\n- ### 问能不能正常打印索引\n\n参考回答：\n\n在 click 的时候，已经变成 length 了\n\n- ### 如果已经有三个 promise，A、B 和 C，想串行执行，该怎么写？\n\n参考回答：\n\n### // promise A.then(B).then(C).catch(...)\n\n> // async/await (async ()=>{ await a(); await b(); await c();\n\n> })()\n\n- ### 知道 private 和 public 吗\n\n参考回答：\n\npublic：public 表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用\n\nprivate：private 表示私有，私有的意思就是除了 class 自己之外，任何人都不可以直接使用\n\n- ### 基础的 js\n\n参 考 回 答 ： Function.prototype.a = 1; Object.prototype.b = 2; function A() {}\n\nvar a = new A();\n\nconsole.log(a.a, a.b); // undefined, 2 console.log(A.a, A.b); // 1, 2\n\n- ### async 和 await 具体该怎么用？\n\n参考回答：\n\n### (async () = \\> { await new promise()\n\n> })()\n\n- ### 知道哪些 ES6，ES7 的语法\n\n参考回答：\n\npromise，await/async，let、const、块级作用域、箭头函数\n\n- ### promise 和 await/async 的关系\n\n参考回答：\n\n都是异步编程的解决方案\n\n- ### JS 的数据类型\n\n参考回答：\n\n字符串，数字，布尔，数组，null，Undefined，symbol，对象。\n\n- ### JS 加载过程阻塞，解决方法\n\n参考回答：\n\n指定 script 标签的 async 属性。\n\n如果 async=\"async\"，脚本相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本将被执行）\n\n如果不使用 async 且 defer=\"defer\"：脚本将在页面完成解析时执行\n\n- ### JS 对象类型，基本对象类型以及引用对象类型的区别\n\n参考回答：\n\n分为基本对象类型和引用对象类型\n\n基本数据类型：按值访问，可操作保存在变量中的实际的值。基本类型值指的是简单的数据段。基本数据类型有这六种:undefined、null、string、number、boolean、symbol。\n\n引用类型：当复制保存着对象的某个变量时，操作的是对象的引用，但在为对象添加属性时，操作的是实际的对象。引用类型值指那些可能为多个值构成的对象。\n\n引用类型有这几种：Object、Array、RegExp、Date、Function、特殊的基本包装类型\n\n(String、Number、Boolean)以及单体内置对象(Global、Math)。\n\n- ### JavaScript 中的轮播实现原理？假如一个页面上有两个轮播，你会怎么实现？\n\n参考回答：\n\n图片轮播的原理就是图片排成一行，然后准备一个只有一张图片大小的容器，对这个容器设置超出部分隐藏，在控制定时器来让这些图片整体左移或右移，这样呈现出来的效果就是图片在轮播了。\n\n如果有两个轮播，可封装一个轮播组件，供两处调用\n\n- ### 怎么实现一个计算一年中有多少周？\n\n参考回答：\n\n首先你得知道是不是闰年，也就是一年是 365 还是 366.\n\n其次你得知道当年 1 月 1 号是周几。假如是周五，一年 365 天把 1 号 2 号 3 号减去， 也就是把第一个不到一周的天数减去等于 362\n\n还得知道最后一天是周几，加入是周五，需要把周一到周五减去，也就是 362-5=357.\n\n正常情况 357 这个数计算出来是 7 的倍数。357/7=51 。即为周数。\n\n- ### 面向对象的继承方式\n\n参考回答： 原型链继承\n\n核心： 将父类的实例作为子类的原型特点：\n\n非常纯粹的继承关系，实例是子类的实例，也是父类的实例父类新增原型方法/原型属性，子类都能访问到\n\n简单，易于实现缺点：\n\n要想为子类新增属性和方法，不能放到构造器中无法实现多继承\n\n来自原型对象的所有属性被所有实例共享 创建子类实例时，无法向父类构造函数传参\n\n构造继承\n\n核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）\n\n特点：\n\n解决了子类实例共享父类引用属性的问题创建子类实例时，可以向父类传递参数 可以实现多继承（call 多个父类对象） 缺点：\n\n实例并不是父类的实例，只是子类的实例\n\n只能继承父类的实例属性和方法，不能继承原型属性/方法\n\n无法实现函数复用，每个子类都有父类实例函数的副本，影响性能\n\n实例继承\n\n核心：为父类实例添加新特性，作为子类实例返回特点：\n\n不限制调用方式，不管是 new 子类()还是子类(),返回的对象具有相同的效果\n\n缺点：\n\n实例是父类的实例，不是子类的实例不支持多继承\n\n拷贝继承特点：\n\n支持多继承\n\n缺点：\n\n效率较低，内存占用高（因为要拷贝父类的属性）\n\n组合继承\n\n核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n特点：\n\n可以继承实例属性/方法，也可以继承原型属性/方法既是子类的实例，也是父类的实例\n\n不存在引用属性共享问题可传参\n\n函数可复用\n\n寄生组合继承\n\n核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n参考 [_https://www.cnblogs.com/humin/p/4556820.html_](https://www.cnblogs.com/humin/p/4556820.html)\n\n- ### JS 的数据类型\n\n参考回答：\n\n字符串，数字，布尔，数组，null，Undefined，symbol，对象。\n\n- ### 引用类型常见的对象\n\n参考回答：\n\nObject、Array、RegExp、Date、Function、特殊的基本包装类型(String、Number、Boolean)以及单体内置对象(Global、Math)等\n\n- ### es6 的常用\n\n参考回答：\n\npromise，await/async，let、const、块级作用域、箭头函数\n\n- ### class\n\n参考回答：\n\nES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过 class 关键字，可以定义类。\n\n- ### 口述数组去重\n\n参考回答：\n\n法一：indexOf 循环去重\n\n法二：ES6 Set 去重；Array.from(new Set(array))\n\n法三：Object 键值对去重；把数组的值存成 Object 的 key 值，比如Object\\[value1\\] = true，在判断另一个值的时候，如果 Object\\[value2\\]存在的话，\n就说明该值是重复的。\n\n- ### 继承\n\n参考回答： 原型链继承\n\n核心： 将父类的实例作为子类的原型特点：\n\n非常纯粹的继承关系，实例是子类的实例，也是父类的实例父类新增原型方法/原型属性，子类都能访问到\n\n简单，易于实现缺点：\n\n要想为子类新增属性和方法，不能放到构造器中无法实现多继承\n\n来自原型对象的所有属性被所有实例共享 创建子类实例时，无法向父类构造函数传参\n\n构造继承\n\n核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）\n\n特点：\n\n解决了子类实例共享父类引用属性的问题创建子类实例时，可以向父类传递参数 可以实现多继承（call 多个父类对象） 缺点：\n\n实例并不是父类的实例，只是子类的实例\n\n只能继承父类的实例属性和方法，不能继承原型属性/方法\n\n无法实现函数复用，每个子类都有父类实例函数的副本，影响性能\n\n实例继承\n\n核心：为父类实例添加新特性，作为子类实例返回特点：\n\n不限制调用方式，不管是 new 子类()还是子类(),返回的对象具有相同的效果\n\n缺点：\n\n实例是父类的实例，不是子类的实例不支持多继承\n\n拷贝继承特点：\n\n支持多继承缺点：\n\n效率较低，内存占用高（因为要拷贝父类的属性）\n\n组合继承\n\n核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n特点：\n\n可以继承实例属性/方法，也可以继承原型属性/方法既是子类的实例，也是父类的实例\n\n不存在引用属性共享问题可传参\n\n函数可复用\n\n寄生组合继承\n\n核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n参考 [_https://www.cnblogs.com/humin/p/4556820.html_](https://www.cnblogs.com/humin/p/4556820.html)\n\n- ### call 和 apply 的区别\n\n参考回答：\n\napply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即 A 对象应用B 对象的方法。\n\ncall：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即 A 对象调用B 对象的方法。\n\n- ### es6 的常用特性\n\n参考回答：\n\npromise，await/async，let、const、块级作用域、箭头函数\n\n- ### 箭头函数和 function 有什么区别\n\n参考回答：\n\n箭头函数根本就没有绑定自己的 this，在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用\n\n- ### new 操作符原理\n\n参考回答：\n\n1. 创建一个类的实例：创建一个空对象 obj，然后把这个空对象的 proto 设置为构造函数的 prototype。\n\n2. 初始化实例：构造函数被传入参数并调用，关键字 this 被设定指向该实例 obj。\n\n3. 返回实例 obj。\n\n- ### bind,apply,call\n\n参考回答：\n\napply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即 A 对象应用B 对象的方法。\n\ncall：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即 A 对象调用B 对象的方法。\n\nbind 除了返回是函数以外，它的参数和 call 一样。\n\n- ### bind 和 apply 的区别\n\n参考回答：\n\n返回不同：bind 返回是函数\n\n参数不同：apply(A, arguments)，bind(A, args1,args2)\n\n- ### 数组的去重\n\n参考回答：\n\n法一：indexOf 循环去重\n\n法二：ES6 Set 去重；Array.from(new Set(array))\n\n法三：Object 键值对去重；把数组的值存成 Object 的 key 值，比如Object\\[value1\\] = true，在判断另一个值的时候，如果 Object\\[value2\\]存在的话，\n就说明该值是重复的。\n\n- ### 闭包\n\n参考回答：\n\n1. 什么是闭包：\n\n闭包是指有权访问另外一个函数作用域中的变量的函数。\n\n闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。当在一个函数内定义另外一个函数就会产生闭包。\n\n2. 为什么要用：\n\n匿名自执行函数：我们知道所有的变量，如果不加上 var 关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可\n\n能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用 var\n关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，可以用闭包。 结果缓存：我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对\n象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。\n\n- ### promise 实现\n\n参 考 回 答 ： Promise 实现如下\n\n### function Promise(fn) { var state = 'pending', value = null, callbacks = \\[\\]\n\n> this.then = function (onFulfilled, onRejected) { return new Promise(function (resolve, reject) {\n> handle({\n\n> onFulfilled: onFulfilled \\|\\| null, onRejected: onRejected \\|\\| null, resolve: resolve,\n\n> reject: reject\n\n> });\n\n> });\n\n> };\n\n> function handle(callback) { if (state === 'pending') { callbacks.push(callback); return;\n\n> }\n\n> var cb = state === 'fulfilled' ? callback.onFulfilled : callback.onRejected,\n\n> ret;\n\n> if (cb === null) {\n\n> cb = state === 'fulfilled' ? callback.resolve : callback.reject; cb(value);\n\n> return;\n\n> }\n\n> ret = cb(value); callback.resolve(ret);\n\n> }\n\n> function resolve(newValue) {\n\n> if (newValue && (typeof newValue === 'object' \\|\\| typeof newValue === 'function')) {\n\n> var then = newValue.then;\n\n> if (typeof then === 'function') { then.call(newValue, resolve, reject); return;\n\n> }\n\n> }\n\n> state = 'fulfilled'; value = newValue; execute();\n\n> }\n\n> function reject(reason) { state = 'rejected';\n\n> value = reason; execute();\n\n> }\n\n> function execute() { setTimeout(function () { callbacks.forEach(function (callback) {\n> handle(callback);\n\n> });\n\n> }, 0);\n\n> }\n\n> fn(resolve, reject);\n\n> }\n\n- ### assign 的深拷贝\n\n参考回答：\n\n### function clone( obj ) { var copy\n\n> switch( typeof obj ) { case \"undefined\": break;\n\n> case \"number\": copy = obj - 0; break;\n\n> case \"string\": copy = obj + \"\"; break;\n\n> case \"boolean\":\n\n> copy = obj; break;\n\ncase \"object\": //object 分为两种情况 对象（Object）和数组（Array）\n\n- ### 说 promise，没有 promise 怎么办\n\n参考回答：\n\n没有 promise，可以用回调函数代替\n\n- ### 事件委托\n\n参考回答：\n\n把一个元素响应事件（click、keydown. ）的函数委托到另一个元素；\n\n优点：减少内存消耗、动态绑定事件。\n\n- ### 箭头函数和 function 的区别\n\n参考回答：\n\n箭头函数根本就没有绑定自己的 this，在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用\n\n- ### arguments\n\n参考回答：\n\narguments 是类数组对象，有 length 属性，不能调用数组方法可用 Array.from()转换\n\n- ### 箭头函数获取 arguments\n\n参考回答：\n\n可用…rest 参数获取\n\n- ### Promise\n\n参考回答：\n\nPromise 对象是 CommonJS 工作组提出的一种规范，目的是为异步编程提供统一接口。每一个异步任务返回一个 Promise 对象，该对象有一个 then 方法，允许指定回调函数。\n\nf1().then(f2);\n\n一个 promise 可能有三种状态：等待（pending）、已完成（resolved，又称\n\nfulfilled）、已拒绝（rejected）。\n\npromise 必须实现 then 方法（可以说，then 就是 promise 的核心），而且 then 必须返回一个 promise，同一个 promise 的 then\n可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致。\n\nthen 方法接受两个参数，第一个参数是成功时的回调，在 promise 由“等待”态转换到“完成”态时调用，另一个是失败时的回调，在 promise\n由“等待”态转换到“拒绝”态时调用。同时，then 可以接受另一个 promise 传入，也接受一个“类then”的对象或方法，即 thenable 对象。\n\n- ### 事件代理\n\n参考回答：\n\n事件代理是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div>ul>li>a; 比如给最里面的a 加一个 click\n点击事件，那么这个事件就会一层一层的往外执行， 执行顺序 a>li>ul>div，有这样一个机制，那么我们给最外面的 div 加点击事件，那么里面的 ul，li，a\n做点击事件的时候，都会冒泡到最外层的 div 上，所以都会触发， 这就是事件代理，代理它们父级代为执行事件。\n\n- ### Eventloop\n\n参考回答：\n\n任务队列中，在每一次事件循环中，macrotask 只会提取一个执行，而 microtask 会一直提取，直到 microsoft 队列为空为止。\n\n也就是说如果某个 microtask 任务被推入到执行中，那么当主线程任务执行完成后， 会循环调用该队列任务中的下一个任务来执行，直到该任务队列到最后一个任务为 止。而事件循环每次只会入栈一个\nmacrotask,主线程执行完成该任务后又会检查microtasks 队列并完成里面的所有任务后再执行macrotask 的任务。\n\nmacrotasks: setTimeout, setInterval, setImmediate, I/O, UI rendering microtasks: process.nextTick,\nPromise, MutationObserver\n\n# 2 \\| 前端核心\n\n1. ## | 服务端编程\n\n- ### JSONP 的缺点\n\n参考回答：\n\nJSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。\n\n- ### 跨域（jsonp，ajax）\n\n参考回答：\n\nJSONP：ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数\n\n据，而是返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。\n\n- ### 如何实现跨域\n\n参考回答：\n\nJSONP：通过动态创建 script，再请求一个带参网址实现跨域通信。document.domain\n\n- iframe 跨域：两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域。\n\nlocation.hash + iframe 跨域：a 欲与b 跨域相互通信，通过中间页c 来实现。 三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 js\n访问来通信。\n\nwindow.name + iframe 跨域：通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。\n\npostMessage 跨域：可以跨域操作的 window 属性之一。\n\nCORS：服务端设置 Access-Control-Allow-Origin 即可，前端无须设置，若要带\n\ncookie 请求，前后端都需要设置。\n\n代理跨域：起一个代理服务器，实现数据的转发\n\n- ### dom 是什么，你的理解？\n\n参考回答：\n\n文档对象模型（Document Object Model，简称 DOM），是 W3C\n组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为 DOM。\n\n- ### 关于 dom 的 api 有什么\n\n参考回答：\n\n节点创建型 api，页面修改型 API，节点查询型 API，节点关系型 api，元素属性型api，元素样式型 api 等\n\n2. ## | Ajax\n\n- ### ajax 返回的状态\n\n参考回答：\n\n0 － （未初始化）还没有调用 send()方法\n\n1 － （载入）已调用 send()方法，正在发送请求\n\n2 － （载入完成）send()方法执行完成，已经接收到全部响应内容\n\n3 － （交互）正在解析响应内容\n\n4 － （完成）响应内容解析完成，可以在客户端调用了\n\n- ### 实现一个 Ajax\n\n参考回答：\n\nAJAX 创建异步对象 XMLHttpRequest\n\n操作 XMLHttpRequest 对象\n\n1. 设置请求参数（请求方式，请求页面的相对路径，是否异步）\n\n2. 设置回调函数，一个处理服务器响应的函数，使用 onreadystatechange ，类似函数指针\n\n3. 获取异步对象的 readyState 属性：该属性存有服务器响应的状态信息。每当readyState 改变时，onreadystatechange 函数就会被执行。\n\n4. 判断响应报文的状态，若为 200 说明服务器正常运行并返回响应数据。\n\n5. 读取响应数据，可以通过 responseText 属性来取回由服务器返回的数据。\n\n- ### 如何实现 ajax 请求，假如我有多个请求，我需要让这些 ajax 请求按照某种顺序一次执行，有什么办法呢？如何处理 ajax 跨域\n\n参考回答：\n\n通过实例化一个 XMLHttpRequest 对象得到一个实例，调用实例的 open 方法为这次ajax 请求设定相应的 http 方法，相应的地址和是否异步，以异步为例，调用 send\n方法，这个方法可以设定需要发送的报文主体，然后通过监听 readystatechange 事件， 通过这个实例 的 readyState 属性来判断这个 ajax 请求状态，其中分为 0，1，2，3，\n4 这四种状态（0 未初始化，1 载入/正在发送请求 2 载入完成/数据接收，3 交互/解析数据，4 接收数据完成），当状态为 4 的时候也就是接受数据完成的时候，这时候可以通过实例的 status\n属性判断这个请求是否成功\n\n### var xhr = new XMLHttpRequest(); xhr.open('get', 'aabb.php', true); xhr.send(null); xhr.onreadystatechange = function() { if(xhr.readyState==4) { if(xhr.status==200) { console.log(xhr.responseText)\n\n> }\n\n> }\n\n> }\n\n使 ajax 请求按照队列顺序执行，通过调用递归函数：\n\n//按顺序执行多个 ajax 命令，因为数量不定，所以采用递归\n\n### function send(action, arg2) {\n\n> //将多个命令按顺序封装成数组对象，递归执行\n\n> //利用了 deferred 对象控制回调函数的特点\n\n> $.when(send_action(action\\[0\\], arg2))\n\n> .done(function () {\n\n> //前一个 ajax 回调函数完毕之后判断队列长度\n\n> if (action.length \\> 1) {\n\n> //队列长度大于 1，则弹出第一个，继续递归执行该队列\n\n> action.shift();\n\n> send(action, arg2);\n\n> }\n\n> }).fail(function (){\n\n> //队列中元素请求失败后的逻辑\n\n> //\n\n> //重试发送\n\n> //send(action, arg2);\n\n> //\n\n> //忽略错误进行下个\n\n> //if (action.length \\> 1) {\n\n> //队列长度大于 1，则弹出第一个，继续递归执行该队列\n\n> // action.shift();\n\n> // send(action, arg2);\n\n> //}\n\n> });\n\n> }\n\n> //处理每个命令的 ajax 请求以及回调函数function send_action(command, arg2) {\n\n> var dtd = \\$.Deferred();//定义 deferred 对象\n\n> $.post( \"url\",\n\n> {\n\n> command: command, arg2: arg2\n\n> }\n\n> ).done(function (json) { json = \\$.parseJSON(json);\n\n> //每次请求回调函数的处理逻辑\n\n> //\n\n> //\n\n> //\n\n> //逻辑结束\n\n> dtd.resolve();\n\n> }).fail(function (){\n\n> //ajax 请求失败的逻辑dtd.reject();\n\n> });\n\n> return dtd.promise();//返回 Deferred 对象的 promise，防止在外部\n\n- ### 写出原生 Ajax\n\n参考回答：\n\nAjax 能够在不重新加载整个页面的情况下与服务器交换数据并更新部分网页内容，实现局部刷新，大大降低了资源的浪费，是一门用于快速创建动态网页的技术，ajax 的使用分为四部分：\n\n1、创建 XMLHttpRequest 对象 var xhr = new XMLHttpRequest();\n\n2、向服务器发送请求，使用 xmlHttpRequest 对象的 open 和 send 方法， 3、监听状态变化，执行相应回调函数\n\n### var xhr = new XMLHttpRequest(); xhr.open('get', 'aabb.php', true); xhr.send(null); xhr.onreadystatechange = function() { if(xhr.readyState==4) { if(xhr.status==200) { console.log(xhr.responseText)\n\n> }\n\n> }\n\n> }\n\n- ### 如何实现一个 ajax 请求？如果我想发出两个有顺序的 ajax 需要怎么做？\n\n参考回答：\n\nAJAX 创建异步对象 XMLHttpRequest\n\n操作 XMLHttpRequest 对象\n\n1. 设置请求参数（请求方式，请求页面的相对路径，是否异步）\n\n2. 设置回调函数，一个处理服务器响应的函数，使用 onreadystatechange ，类似函数指针\n\n3. 获取异步对象的 readyState 属性：该属性存有服务器响应的状态信息。每当readyState 改变时，onreadystatechange 函数就会被执行。\n\n4. 判断响应报文的状态，若为 200 说明服务器正常运行并返回响应数据。\n\n5. 读取响应数据，可以通过 responseText 属性来取回由服务器返回的数据。\n\n发出两个有顺序的 ajax，可以用回调函数，也可以使用 Promise.then 或者 async 等。\n\n- ### Fetch 和 Ajax 比有什么优缺点？\n\n参考回答：\n\npromise 方便异步，在不想用 jQuery 的情况下，相比原生的 ajax，也比较好写。\n\n- ### 原生 JS 的 ajax\n\n参考回答：\n\nAJAX 创建异步对象 XMLHttpRequest\n\n操作 XMLHttpRequest 对象\n\n1. 设置请求参数（请求方式，请求页面的相对路径，是否异步）\n\n2. 设置回调函数，一个处理服务器响应的函数，使用 onreadystatechange ，类似函数指针\n\n3. 获取异步对象的 readyState 属性：该属性存有服务器响应的状态信息。每当readyState 改变时，onreadystatechange 函数就会被执行。\n\n4. 判断响应报文的状态，若为 200 说明服务器正常运行并返回响应数据。\n\n5. 读取响应数据，可以通过 responseText 属性来取回由服务器返回的数据。\n\n6. ## | 移动 web 开发\n\n- ### 知道 PWA 吗\n\n参考回答：\n\nPWA 全称 Progressive Web App，即渐进式 WEB 应用。一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和\nService Worker 来实现 PWA 的安装和离线等功能\n\n- ### 移动布局方案\n\n参 考 回 答 ：\n[_https://juejin.im/post/599970f4518825243a78b9d5#heading-22_](https://links.jianshu.com/go?to=https%3A%2F%2Fjuejin.im%2Fpost%2F599970f4518825243a78b9d5%23heading-22)\n\n> ![](media/image9.jpeg)\n\n- ### Rem, Em\n\n参 考 回 答 ：\n[_https://blog.csdn.net/romantic_love/article/details/80875462_](https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fromantic_love%2Farticle%2Fdetails%2F80875462)\n一、rem 单位如何转换为像素值\n\n1. 当使用 rem 单位的时候，页面转换为像素大小取决于叶根元素的字体大小，即 HTML 元素的字体大小。根元素字体大小乘 rem 的值。例如，根元素的字体大小为 16px，那么 10rem\n   就等同于 10\\*16=160px。\n\n二、em 是如何转换成 px 的\n\n当使用 em 单位的时候，像素值是将 em 值乘以使用 em 单位的元素的字体大小。例如一个 div 的字体为 18px，设置它的宽高为 10em，那么此时宽高就是 18px\\*10em=180px。\n\n### .test{\n\n> width: 10em;\n\n> height: 10em;\n\n> background-color: #ff7d42;\n\n> font-size: 18px;\n\n> }\n\n一定要记住的是，em 是根据使用它的元素的 font-size 的大小来变化的，而不是根据父元素字体大小。有些元素大小是父元素的多少倍那是因为继承了父元素中 font-size\n的设定，所以才起到的作用。\n\n2. em 单位的继承效果。\n\n使用 em 单位存在继承的时候，每个元素将自动继承其父元素的字体大小，继承的效果只能被明确的字体单位覆盖，比如 px 和 vw。只要父级元素上面一直有 fontsize 为 em\n单位，则会一直继承，但假如自己设置了 font-size 的单位为 px 的时候，则会直接使用自己的 px 单位的值。\n\n三、根 html 的元素将会继承浏览器中设置的字体大小\n\n除非显式的设置固定值去覆盖。所以 html 元素的字体大小虽然是直接确定 rem 的值， 但这个字体大小首先是来源于浏览器的设置。（所以一定要设置 html\n的值的大小，因为有可能用户的浏览器字体大小是不一致的。）\n\n四、当 em 单位设置在 html 元素上时\n\n它将转换为 em 值乘以浏览器字体大小的设置。例如：\n\n### html{\n\n> font-size: 1.5em;\n\n> }\n\n可以看到，因为浏览器默认字体大小为 16px，所以当设置 HTML 的 fontsize 的值为\n\n5. em 的售后，其对应的 px 的值为 16\\*1.5=24px\n\n所以此时，再设置其他元素的 rem 的值的时候，其对应的像素值为 n\\*24px。\n\n例如，test 的 rem 的值为 10，\n\n### .test{\n\n> width: 10rem;\n\n> height: 10rem;\n\n> background-color: #ff7d42;\n\n> }\n\n![](media/image10.jpeg)\n\n可以看到 test 的 font-size 继承了 html 的值 24px，而此时宽高为 24\\*10=240px\n\n总结\n\n1. rem 单位翻译为像素值的时候是由 html 元素的字体大小决定的。此字体大小会被浏览器中字体大小的设置影响，除非显式的在 html 为 font-size 重写一个单位。\n\n2. em 单位转换为像素值的时候，取决于使用它们的元素的 font-size 的大小，但是有因为有继承关系，所以比较复杂。\n\n优缺点\n\nem 可以让我们的页面更灵活，更健壮，比起到处写死的 px 值，em 似乎更有张力，改动父元素的字体大小，子元素会等比例变化，这一变化似乎预示了无限可能,\n\nem 做弹性布局的缺点还在于牵一发而动全身，一旦某个节点的字体大小发生变化，那么其后代元素都得重新计算\n\n- ### flex 布局及优缺点\n\n参 考 回 答 ：\n[_https://juejin.im/post/599970f4518825243a78b9d5#heading-22_](https://links.jianshu.com/go?to=https%3A%2F%2Fjuejin.im%2Fpost%2F599970f4518825243a78b9d5%23heading-22)\n\ncss3 引入的，flex 布局；优点在于其容易上手，根据 flex 规则很容易达到某个布局效果，然而缺点是：浏览器兼容性比较差，只能兼容到 ie9 及以上；\n\n![](media/image11.jpeg)\n\n![](media/image12.jpeg)\n\n- ### Rem 布局及其优缺点\n\n参考回答：\n\n首先 Rem 相对于根(html)的 font-size 大小来计算。简单的说它就是一个相对单例如:font-size:10px;,那么（1rem = 10px）了解计算原理后\n\n首先解决怎么在不同设备上设置 html 的 font-size 大小。其实 rem 布局的本质是等比缩放，一般是基于宽度。\n\n优点\n\n可以快速适用移动端布局 字体图片 高度缺点\n\n①目前 ie 不支持，对 pc 页面来讲使用次数不多；\n\n②数据量大：所有的图片，盒子都需要我们去给一个准确的值；才能保证不同机型的适配；\n\n③在响应式布局中，必须通过 js 来动态控制根元素 font-size 的大小。\n\n也就是说 css 样式和 js 代码有一定的耦合性。且必须将改变 font-size 的代码放在\n\ncss 样式之前。\n\n- ### 百分比布局\n\n参考回答： 1、具体分析\n\n除了用 px 结合媒体查询实现响应式布局外，我们也可以通过百分比单位 \" % \"\n来实现响应式的效果。比如当浏览器的宽度或者高度发生变化时，通过百分比单位，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。为了了解百分比布局，首先要了解的问题是：css\n中的子元素中的百分比\n\n（%）到底是谁的百分比？\n\n直观的理解，我们可能会认为子元素的百分比完全相对于直接父元素，height 百分比相对于 height，width 百分比相对于 width。当然这种理解是正确的，但是根据 css 的盒式模型，除了\nheight、width 属性外，还具有 padding、border、margin 等等属\n\n性。那么这些属性设置成百分比，是根据父元素的那些属性呢？此外还有 border- radius 和 translate 等属性中的百分比，又是相对于什么呢？下面来具体分析。\n\npadding、border、margin 等等属不论是垂直方向还是水平方向，都相对于直接父元素的 width。\n\n除了 border-radius 外，还有比如 translate、background-size 等都是相对于自身的。\n\n2、百分比单位布局应用\n\n比如我们要实现一个固定长宽比的长方形，比如要实现一个长宽比为 4:3 的长方形,我们可以根据 padding 属性来实现，因为 padding\n不管是垂直方向还是水平方向，百分比单位都相对于父元素的宽度，因此我们可以设置 padding-top 为百分比来实现，长宽自适应的长方形：\n\n### .trangle{\n\n> height:0;\n\n> width:100%;\n\n> padding-top:75%;\n\n> }\n\n3、百分比单位缺点\n\n从上述对于百分比单位的介绍我们很容易看出如果全部使用百分比单位来实现响应式的布局，有明显的以下两个缺点：\n\n1. 计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。\n\n2. 从小节 1 可以看出，各个属性中如果使用百分比，相对父元素的属性并不是唯一的。比如 width 和 height 相对于父元素的 width 和 height，而 margin、padding\n   不管垂直还是水平方向都相对比父元素的宽度、border-radius 则是相对于元素自身等等， 造成我们使用百分比单位容易使布局问题变得复杂。\n\n![](media/image13.jpeg) ![](media/image14.jpeg)\n\n- ### 移动端适配 1px 的问题\n\n参 考 回 答 ：\n[_https://blog.csdn.net/weixin_43675871/article/details/84023447_](https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fweixin_43675871%2Farticle%2Fdetails%2F84023447)\n首先，我们了解 devicePixelRatio（DPR）这个东西\n\n### 在 window 对象中有一个 devicePixelRatio 属性，他可以反应 css 中的像素与设备的像素比。然而 1px 在不同的移动设备上都等于这个移动设备的 1px，这是因为不同的移动设备有不同的像素密度。有关这个属性，它的官方的定义 为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素 1px 变粗的原因：viewport 的设置和屏幕物理分辨率是按比例而不是相同的. 移动端 window 对象有个 devicePixelRatio 属性,它表示设备\n\n> 物理像素和 css 像素的比例, 在 retina 屏的iphone 手机上, 这个值为 2 或\n\n> 3,css 里写的 1px 长度映射到物理像素上就有 2px 或 3px 那么长\n\n1. 用小数来写 px 值 （不推荐）\n\nIOS8 下已经支持带小数的 px 值, media query 对应 devicePixelRatio 有个查询值 - webkit-min-device-pixel-ratio, css\n可以写成这样\n\n通过-webkit-min-device-pixel-ratio 设置。\n\n### .border { border: 1px solid #999 }\n\n> @media screen and (-webkit-min-device-pixel-ratio: 2) {\n\n> .border { border: 0.5px solid #999 }\n\n> }\n\n> @media screen and (-webkit-min-device-pixel-ratio: 3) {\n\n> .border { border: 0.333333px solid #999 }\n\n> }\n\n如果使用 less/sass 的话只是加了 1 句 mixin\n\n缺点: 安卓与低版本 IOS 不适用, 这个或许是未来的标准写法, 现在不做指望 2、flexible.js\n\n这是淘宝移动端采取的方案, github\n的地址:[_https://github.com/amfe/lib-_](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Famfe%2Flib-flexible)\n[_flexible_](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Famfe%2Flib-flexible). 前面已经说过\n1px 变粗的原因就在于一刀切的设置 viewport 宽度, 如果能把 viewport 宽度设置为实际的设备物理宽度, css 里的 1px 不就等于实际 1px 长了么. flexible.js\n就是这样干的.\n\n<meta name=”viewport”>里面的 scale 值指的是对 ideal viewport 的缩放, flexible.js 检测到 IOS 机型, 会算出 scale =\n1/devicePixelRatio, 然后设置viewport\n\n3、伪类+transform 实现\n\n对于解决 1px 边框问题，我个人觉得最完美的解决办法还是伪类+transform 比较好。原理：是把原先元素的 border 去掉，然后利用 :before 或者 :after 重做\n\nborder ，并 transform 的 scale 缩小一半，原先的元素相对定位，新做的 border\n\n绝对定位。media query\n\n通过媒体查询，可以通过给不同分辨率的设备编写不同的样式来实现响应式的布局， 比如我们为不同分辨率的屏幕，设置不同的背景图片。比如给小屏幕手机设置@2x 图， 为大屏幕手机设置@3x\n图，通过媒体查询就能很方便的实现。\n\n但是媒体查询的缺点也很明显，如果在浏览器大小改变时，需要改变的样式太多，那么多套样式代码会很繁琐。\n\n### @media screen and (min-width: 320px) {\n\n> html {\n\n> font-size: 50px;\n\n> }\n\n> }\n\n@media\n\n方便应用广泛 适用于 pc 端 手机页面，通常做自适应布局时 我们比较常用。缺点：相对于代码要重复很多，得知道设备的宽度，手机的分辨率很多所以麻烦了点，不过性能方面肯定最高； 可能存在闪屏的问题\n\n@media 处理手机和 pc 端界面兼容的问题，在 IE 上的访问出现问题，百度方法，找找两 种 ， 一 种 是 respond.js， 另 一 种 是\n[_css3-_](https://links.jianshu.com/go?to=css3-mediaquerieshttp%3A%2F%2Fblog.csdn.net%2Fsmall_tu%2Farticle%2Fdetails%2F47317453)\n[_mediaquerieshttp://blog.csdn.net/small_tu/article/details/47317453_](https://links.jianshu.com/go?to=css3-mediaquerieshttp%3A%2F%2Fblog.csdn.net%2Fsmall_tu%2Farticle%2Fdetails%2F47317453)\n\n- ### 移动端性能优化相关经验\n\n参 考 回 答 ：\n[_https://blog.csdn.net/tangxiujiang/article/details/79791545_](https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Ftangxiujiang%2Farticle%2Fdetails%2F79791545)\n\n- ### toB 和 toC 项目的区别\n\n参考回答：\n\nto B（business）即面向企业，to C（ customer）即面向普通用户\n\n简单的事情重复去做，重复的事情用心去做，长期坚持，自然功成，无论是 B 端还是C\n\n端都同样适用。Tob 与 Toc 的区别\n\n作者 猪八戒网 • 10-11 10:18:49 阅读 419 oB 产品价值何来？\n\n最近团队在 toB 产品研究的过程中，得出结论，相对于 toC 产品与服务，toC 产品更注重产品用户的共性而淡化角色关系，而 toB 产品则更强调面向用户、客户的角色关\n\n系，而淡化共性提取。实际上，这是由服务对象所引起的，C 端产品的服务对象，由终端所限，是一个面向个体的服务。而B 端服务使用最终是面向一个系统体系组织，在干系人间配合使用中发挥产品价值。\n\n一个好的产品 toB 可以让组织的系统变得更好，最终反哺于系统中的各个单位。需求动力之不同 toC\n的产品方法论，用户体验是几乎最为重要的需求来源，腾讯此前，也以\"以用户体验为归依\"来驱动企业产品打造。\n\n但B 端产品则不同，B 端在一个商业的背景之下，B 端的决策思路是，\"以企业获益为归依\"，系统是否有利于企业的生产力，竞争力等，单纯的用户体验，仅能让员工得到片刻的享受，\n但无法说服企业，企业并不会为一个不能\"赚钱\"的东西买单。\n\n需求动力的不同，引发的这是购买使用决策体系的变化。\n\ntoB 产品应更考虑 获益与系统性价值，部分情况还有可能会牺牲掉局部个体的利益， 对于使用者而言应该是自律或他律的，toC\n产品则更考虑的是个体用户的偏好，并长时间内，基于技术效率的提升，产品的服务中心更多地围绕着更高效地帮助用户的\"欲望\"释放进行设计，对于使用者而言是一个释放自我的存在。\n\n- ### 移动端兼容性\n\n参 考 回 答 ：\n[_https://zhuanlan.zhihu.com/p/28206065_](https://links.jianshu.com/go?to=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F28206065)\n1.IOS 移动端 click 事件 300ms 的延迟相应\n\n3. h5 底部输入框被键盘遮挡问题\n\n10.CSS 动画页面闪白,动画卡顿\n\n### 解决方法\n\n1. 尽可能地使用合成属性 transform 和 opacity 来设计 CSS3 动画，不使用\n\n> position 的 left 和 top 来定位\n\n2. 开启硬件加速\n\n3. 上下拉动滚动条时卡顿、慢\n\n### body {-webkit-overflow-scrolling: touch;overflow-scrolling: touch;}\n\n> Android3+和 iOS5+支持 CSS3 的新属性为 overflow-scrolling\n\n- 小程序\n\n参考回答： 移动端手势\n\n> ![](media/image15.jpeg)\n\n![](media/image16.jpeg)\n\n- ### 2X 图 3X 图适配\n\n参考回答：\n\n实际程序开发当中，我们代码中用的值是指逻辑分辨率 pt，而不是像素分辨率 px，比如我们定义一个按钮的高度为 45，这个 45 指的是 45pt 而不是 45px。在非 Retina 屏下 1pt =\n1px，4 和 4.7 寸 Retina 屏下 1pt = 2px，5.5 和x 下 1pt = 3px.我们制作不同尺寸的图片，比如@1x 为 22px，则@2x 为 44px，@3x 为\n66px，命名分别为image.png，在项目的 Assets.xcassets 中新建 New Image Set，修改名字为 image， 并把相应尺寸的图片拖放至相应位置。\n\n/\\* 根据 dpr 显示 2x 图/3x 图 \\*/\n\n###\n\n> .bg-image(@url){\n\n> background-image:\\~\"url('@{url}@2x.png')\";\n\n> @media (-webkit-min-device-pixel-ratio: 3),(min-device-pixel- ratio: 3){\n\n> background-image:\\~\"url('@{url}@3x.png')\";\n\n> }\n\n> }\n\n> .bg-color(@color) {\n\n> background-color: @color;\n\n> }\n\n- 图片在安卓上，有些设备模糊问题\n\n![](media/image17.jpeg) 参考回答：\n\n- ### 固定定位布局键盘挡住输入框内容\n\n参考回答：\n\n![](media/image18.jpeg) ![](media/image19.jpeg)\n\n- ### click 的 300ms 延迟问题和点击穿透问题\n\n![](media/image20.jpeg) 参 考 回 答 ：\n[_https://www.jianshu.com/p/6e2b68a93c88_](https://www.jianshu.com/p/6e2b68a93c88)\n\n方案二：FastClick\n\n![](media/image21.jpeg)\n[_FastClick_](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fftlabs%2Ffastclick) 是\n[_FT Labs_](https://links.jianshu.com/go?to=http%3A%2F%2Flabs.ft.com%2F) 专门为解决移动端浏览器 300\n毫秒点击延迟问题所开发的一个轻量级的库。FastClick 的实现原理是在检测到 touchend 事件的时候，会通过 DOM 自定义事件立即出发模拟一个 click 事件，并把浏览器在 300ms\n之后的 click 事件阻止掉。\n\n- ### phone 及 ipad 下输入框默认内阴影\n\n![](media/image22.jpeg) 参考回答：\n\n- ### 防止手机中页面放大和缩小\n\n参考回答：\n\n### <meta name=\"viewport\" content=\"user-scalable=no\">\n\n> <meta name=\"viewport\" content=\"initial-scale=1,maximum-scale=1\">\n\n- px、em、rem、%、vw、vh、vm 这些单位的区别\n\n参 考 回 答 ： [_https://www.jianshu.com/p/ba26509bc5b3_](https://www.jianshu.com/p/ba26509bc5b3)\n\n- ### 移动端适配- dpr 浅析\n\n参 考 回 答 ： [_https://www.jianshu.com/p/cf600c2930cb_](https://www.jianshu.com/p/cf600c2930cb) dpr =\n物理像素 / css 像素\n\n在 dpr = 2； 1px 的 css 像素在设备中是 2px 的物理像素，这会导致在设备上看上去\n\n1px 的边框是 2px\n\n解决方法：\n\n### 用 transfrom： scale（）缩小 dpr 倍数在 meta 标签中设定 scale 缩小两倍\n\n- 移动端扩展点击区域\n\n参考回答： 父级代理事件\n\n将a 标签设置成块级元素\n\n- ### 上下拉动滚动条时卡顿、慢\n\n参考回答：\n\n> ![](media/image23.jpeg)\n\n- ### 长时间按住页面出现闪退\n\n参考回答：\n\n![](media/image24.jpeg)\n\n- ### ios 和 android 下触摸元素时出现半透明灰色遮罩\n\n![](media/image25.jpeg) 参考回答：\n\n- ### active 兼容处理 即 伪类：active 失效\n\n参 考 回 答 ：\n[_https://blog.csdn.net/diaobuwei1238/article/details/101716814_](https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fdiaobuwei1238%2Farticle%2Fdetails%2F101716814)\n\n将 :visited 放到最后，则会导致以下结果：若链接已经被访问过，a:visited 会覆盖:active 和:hover\n的样式声明，链接将总是呈现为紫色，无论鼠标悬停还是按下激活，链接都将保持为紫色。\n\n基于此原因，上述代码必须按照顺序定义，一般称为 LVHA-order: :link — :visited\n\n— :hover — :active，为方便记忆，可记为“LOVE HATE”\n\n![](media/image26.jpeg)\n\n- ### webkit mask 兼容处理\n\n参 考 回 答 ：\n[_https://segmentfault.com/a/1190000011838367_](https://links.jianshu.com/go?to=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000011838367)\n\n> ![](media/image27.jpeg)\n\n![](media/image28.jpeg)\n\n- ### transiton 闪屏\n\n参考回答：\n\n### //设置内联的元素在 3D 空间如何呈现：保留 3D-webkit-transform- style:preserve-3D\n\n> //设置进行转换的元素的背面在面对用户时是否可见：隐藏-webkit-backface- visibility:hidden;\n\n- 圆角 bug\n\n![](media/image29.jpeg) 参考回答：\n\n### 作者：Aniugel\n\n> 链接：[_https://www.jianshu.com/p/610123c6ed45_](https://www.jianshu.com/p/610123c6ed45) 来源：简书\n\n# 3 \\| 前端进阶\n\n1. ## | 前端工程化\n\n- ### Babel 的原理是什么?\n\n参考回答：\n\nbabel 的转译过程也分为三个阶段，这三步具体是：\n\n- 解析 Parse: 将代码解析生成抽象语法树( 即 AST )，即词法分析与语法分析的过程\n\n- 转换 Transform: 对于 AST 进行变换一系列的操作，babel 接受得到AST 并通过 babel-traverse 对其进行遍历，在此过程中进行添加、更新及移除等操作\n\n- 生成 Generate: 将变换后的 AST 再转换为 JS 代码, 使用到的模块是babel-generator\n\n![](media/image30.jpeg)\n\n- ### 如何写一个 babel 插件?\n\n参考回答：\n\nBabel 解析成 AST，然后插件更改 AST，最后由 Babel 输出代码\n\n那么 Babel 的插件模块需要你暴露一个 function，function 内返回 visitor\n\n### module.export = function(babel){\n\n> return {\n\n> visitor:{\n\n> }\n\n> }\n\n> }\n\n> visitor 是对各类型的 AST 节点做处理的地方，那么我们怎么知道 Babel 生成了的 AST 有哪些节点呢？\n\n> 很简单，你可以把 Babel 转换的结果打印出来，或者这里有传送门:[_AST_](https://astexplorer.net/)\n> [_explorer_](https://astexplorer.net/)\n\n![](media/image31.jpeg)\n\n> 这里我们看到 const result = 1 + 2 中的 1 + 1 是一个 BinaryExpression 节点， 那么在 visitor 中，我们就处理这个节点\n\n### var babel = require('babel-core'); var t = require('babel-types'); const visitor = {\n\n> BinaryExpression(path) {\n\n> const node = path.node;\n\n> let result;\n\n> // 判断表达式两边，是否都是数字\n\n> if (t.isNumericLiteral(node.left) && t.isNumericLiteral(node.right)) {\n\n> // 根据不同的操作符作运算\n\n> switch (node.operator) {\n\n> case \"+\":\n\n> result = node.left.value + node.right.value;\n\n> break\n\n> case \"-\":\n\n> result = node.left.value - node.right.value;\n\n> break;\n\n> case \"\\*\":\n\n> result = node.left.value \\* node.right.value;\n\n> break;\n\n> case \"/\":\n\n> result = node.left.value / node.right.value;\n\n> break;\n\n> case \"\\*\\*\":\n\n> let i = node.right.value;\n\n> while (--i) {\n\n> result = result \\|\\| node.left.value;\n\n> result = result \\* node.left.value;\n\n> }\n\n> break;\n\n> default:\n\n> }\n\n> }\n\n> // 如果上面的运算有结果的话\n\n> if (result !== undefined) {\n\n> // 把表达式节点替换成 number 字面量\n\n> path.replaceWith(t.numericLiteral(result));\n\n> }\n\n> }\n\n> };\n\n> module.exports = function (babel) {\n\n> return {\n\n> visitor\n\n> };\n\n> }\n\n> 插件写好了，我们运行下插件试试\n\n> const babel = require(\"babel-core\");\n\n> const result = babel.transform(\"const result = 1 + 2;\",{\n\n> plugins:\\[\n\n> require(\"./index\")\n\n> ]\n\n> });\n\n> console.log(result.code); // const result = 3;\n\n> 与预期一致，那么转换 const result = 1 + 2 + 3 + 4 + 5;呢?\n\n### 结果是: const result = 3 + 3 + 4 + 5\n\n这就奇怪了，为什么只计算了 1 + 2 之后，就没有继续往下运算了? 我们看一下这个表达式的 AST 树\n\n![](media/image32.jpeg)\n\n你会发现 Babel 解析成表达式里面再嵌套表达式。\n\n### 表达式( 表达式( 表达式( 表达式(1 + 2) + 3) + 4) + 5) 而我们的判断条件并不符合所有的，只符合 1 + 2\n\n> // 判断表达式两边，是否都是数字\n\n> if (t.isNumericLiteral(node.left) && t.isNumericLiteral(node.right)) {}\n\n那么我们得改一改\n\n> 第一次计算 1 + 2 之后，我们会得到这样的表达式\n\n### 表达式( 表达式( 表达式(3 + 3) + 4) + 5)\n\n其中 3 + 3 又符合了我们的条件， 我们通过向上递归的方式遍历父级节点又转换成这样:\n\n### 表达式( 表达式(6 + 4) + 5) 表达式(10 + 5)\n\n> 15\n\n### // 如果上面的运算有结果的话\n\n> if (result !== undefined) {\n\n> // 把表达式节点替换成 number 字面量\n\n> path.replaceWith(t.numericLiteral(result));\n\n> let parentPath = path.parentPath;\n\n> // 向上遍历父级节点\n\n> parentPath && visitor.BinaryExpression.call(this, parentPath);\n\n> }\n\n> 到这里，我们就得出了结果 const result = 15;\n\n### 那么其他运算呢\n\n> const result = 100 + 10 - 50>\\>\\>const result = 60; const result = (100 / 2) + 50>\\>\\>const result\n> = 100;\n\n> const result = (((100 / 2) + 50 \\* 2) / 50) \\*\\* 2>\\>\\>const result = 9;\n\n- ### 你的 git 工作流是怎样的?\n\n参考回答：\n\nGitFlow 是由 Vincent Driessen 提出的一个 git 操作流程标准。包含如下几个关键分支：\n\nmaster 主分支 develop 主开发分支，包含确定即将发布的代码\n\nfeature 新功能分支，一般一个新功能对应一个分支，对于功能的拆分需要比较合理， 以避免一些后面不必要的代码冲突\n\nrelease 发布分支，发布时候用的分支，一般测试时候发现的\n\nbug 在这个分支进行修复 hotfixhotfix 分支，紧急修 bug 的时候用GitFlow 的优势有如下几点：\n\n- 并行开发：GitFlow 可以很方便的实现并行开发：每个新功能都会建立一个新的 feature 分支，从而和已经完成的功能隔离开来，而且只有在新功能完成开发的情况下，其对应的 feature\n  分支才会合并到主开发分支上（也就是我们经常说的 develop 分支）。另外，如果你正在开发某个功能，同时又有一个新的功能需要开发，你只需要提交当前 feature 的代码，然后创建另外一个\n  feature 分支并完成新功能开发。然后再切回之前\n\n> 的 feature 分支即可继续完成之前功能的开发。\n\n- 协作开发：GitFlow 还支持多人协同开发，因为每个 feature 分支上改动的代码都只是为了让某个新的 feature 可以独立运行。同时我们也很容易知道每个人都在干啥。\n\n- 发布阶段：当一个新 feature 开发完成的时候，它会被合并\n\n> 到 develop 分支，这个分支主要用来暂时保存那些还没有发布的内容，所以如果需要再开发新的 feature，我们只需要从 develop 分支创建新分支，即可包含所有已经完成的 feature\n> 。\n\n- 支持紧急修复：GitFlow 还包含了 hotfix 分支。这种类型的分支是从某个已经发布的 tag 上创建出来并做一个紧急的修复，而且这个紧急修复只影响这个已经发布的\n  tag，而不会影响到你正在开发的新 feature。\n\n然后就是 GitFlow 最经典的几张流程图，一定要理解：\n\n![](media/image33.jpeg)\n\n> feature 分支都是从 develop 分支创建，完成后再合并到 develop 分支上， 等待发布。\n\n![](media/image34.jpeg)\n\n> 当需要发布时，我们从 develop 分支创建一个 release 分支\n\n![](media/image35.jpeg)\n\n然后这个 release 分支会发布到测试环境进行测试，如果发现问题就在这个分支直接进行修复。在所有问题修复之前，我们会不停的重复发布->测试->修复->重新发布->重新测试这个流程。\n\n> 发布结束后，这个 release 分支会合并到 develop 和 master 分支，从而保证不会有代码丢失。\n\n![](media/image36.jpeg)\n\n> master 分支只跟踪已经发布的代码，合并到 master 上的 commit 只能来自 release 分支和 hotfix 分支。\n\n> hotfix 分支的作用是紧急修复一些 Bug。\n\n> 它们都是从 master 分支上的某个 tag 建立，修复结束后再合并到 develop 和 master 分 支 上 。\n\n- ### rebase 与 merge 的区别?\n\n参考回答：\n\ngit rebase 和 git merge 一样都是用于从一个分支获取并且合并到当前分支. 假设一个场景,就是我们开发的\\[feature/todo\\]分支要合并到 master\n主分支,那么用rebase 或者 merge 有什么不同呢?\n\n![](media/image37.jpeg)\n\n- marge 特点：自动创建一个新的 commit 如果合并的时候遇到冲突，仅需要修改后重新 commit\n\n- 优点：记录了真实的 commit 情况，包括每个分支的详情\n\n- 缺点：因为每次 merge 会自动产生一个 merge commit，所以在使用一些 git 的 GUI tools，特别是 commit 比较频繁时，看到分支很杂乱。\n\n> ![](media/image38.jpeg)\n\n- rebase 特点：会合并之前的 commit 历史\n\n- 优点：得到更简洁的项目历史，去掉了 merge commit\n\n- 缺点：如果合并出现代码问题不容易定位，因为 re-write 了 history\n\n因此,当需要保留详细的合并信息的时候建议使用 git merge，特别是需要将分支合并\n\n进入 master 分支时；当发现自己修改某个功能时，频繁进行了 git commit 提交时， 发现其实过多的提交信息没有必要时，可以尝试 git rebase.\n\n- ### git reset、git revert 和 git checkout 有什么区别\n\n参考回答：\n\n这个问题同样也需要先了解 git 仓库的三个组成部分：工作区（Working Directory）、暂存区（Stage）和历史记录区（History）。\n\n- 工作区：在 git 管理下的正常目录都算是工作区，我们平时的编辑工作都是在工作区完成\n\n- 暂存区：临时区域。里面存放将要提交文件的快照\n\n- 历史记录区：git commit 后的记录区三个区的转换关系以及转换所使用的命令：\n\n> ![](media/image39.jpeg)\n\ngit reset、git revert 和 git checkout 的共同点：用来撤销代码仓库中的某些更改。\n\n然后是不同点：\n\n首先，从 commit 层面来说：\n\n- git reset 可以将一个分支的末端指向之前的一个 commit。然后再下次 git 执行垃圾回收的时候，会把这个 commit 之后的 commit 都扔掉。git reset\n  还支持三种标记，用来标记 reset 指令影响的范围：\n\n  - --mixed：会影响到暂存区和历史记录区。也是默认选项\n\n  - --soft：只影响历史记录区\n\n  - --hard：影响工作区、暂存区和历史记录区\n\n### 注意：因为 git reset 是直接删除 commit 记录，从而会影响到其他开发人员的分支，所以不要在公共分支（比如 develop）做这个操作\n\n- git checkout 可以将 HEAD 移到一个新的分支，并更新工作目录。因为可能会覆盖本地的修改，所以执行这个指令之前，你需要 stash 或者 commit 暂存区和工作区的更改。\n\n- git revert 和 git reset 的目的是一样的，但是做法不同，它会以创建新的 commit 的方式来撤销 commit，这样能保留之前的 commit\n  历史，比较安全。另外，同样因为可能会覆盖本地的修改，所以执行这个指令之前，你需要 stash 或者 commit 暂存区和工作区的更改。\n\n> 然后，从文件层面来说：\n\n- git reset 只是把文件从历史记录区拿到暂存区，不影响工作区的内容，而且不支持 --mixed、--soft 和 --hard。\n\n- git checkout 则是把文件从历史记录拿到工作区，不影响暂存区的内容。\n\n- git revert 不支持文件层面的操作。\n\n### 版权声明：本文为取经猿作者的原创文章，转载请附上原文出处链接及本声明\n\n> 原文链接：[_https://www.teaspect.com/detail/5623?pn=21_](https://www.teaspect.com/detail/5623?pn=21)\n\n- ### webpack 和 gulp 区别（模块化与流的区别）\n\n参考回答：\n\ngulp 强调的是前端开发的工作流程，我们可以通过配置一系列的 task，定义 task 处理的事务（例如文件压缩合并、雪碧图、启动 server、版本控制等），然后定义执行顺序，来让 gulp\n执行这些 task，从而构建项目的整个前端开发流程。\n\nwebpack 是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js 文件、css 文件等）都看成模块，通过 loader（加载器）和 plugins（插件）\n对资源进行处理，打包成符合生产环境部署的前端资源。\n\n1. ## | Vue 框架\n\n- ### 有使用过 Vue 吗？说说你对 Vue 的理解\n\n参考回答：\n\nVue 是一个构建数据驱动的渐进性框架，它的目标是通过 API 实现响应数据绑定和视图更新。\n\n- ### 说说 Vue 的优缺点\n\n参考回答：\n\n> 优点：\n\n### 1、数据驱动视图，对真实 dom 进行抽象出 virtual dom（本质就是一个 js 对象），并配合 diff 算法、响应式和观察者、异步队列等手段以最小代价更新dom，渲染页面\n\n> 2、组件化，组件用单文件的形式进行代码的组织编写，使得我们可以在一个文件里编写 html\\\\css（scoped 属性配置 css 隔离）\\\\js 并且配合 Vue-loader\n> 之后，支持更强大的预处理器等功能\n\n> 3、强大且丰富的 API 提供一系列的 api 能满足业务开发中各类需求\n\n> 4、由于采用虚拟 dom，让 Vue ssr 先天就足\n\n> 5、生命周期钩子函数，选项式的代码组织方式，写熟了还是蛮顺畅的，但仍然有优化空间（Vue3 composition-api）\n\n> 6、生态好，社区活跃\n\n> 缺点：\n\n### 1、由于底层基于 Object.defineProperty 实现响应式，而这个 api 本身不支持\n\n> IE8 及以下浏览器\n\n> 2、csr 的先天不足，首屏性能问题（白屏）\n\n> 3、由于百度等搜索引擎爬虫无法爬取 js 中的内容，故 spa 先天就对 seo 优化心有余力不足（谷歌的 puppeteer 就挺牛逼的，实现预渲染底层也是用到了这个工具）\n\n- ### Vue 和 React 有什么不同？使用场景分别是什么？\n\n参考回答：\n\n1、Vue 是完整一套由官方维护的框架，核心库主要有由尤雨溪大神独自维护，而 React 是不要脸的书维护（很多库由社区维护），曾经一段时间很多人质疑 Vue 的后续维护性，似乎这并不是问题。\n\n2、Vue 上手简单，进阶式框架，白话说你可以学一点，就可以在你项目中去用一点， 你不一定需要一次性学习整个 Vue 才能去使用它，而 React，恐怕如果你这样会面对项目束手无策。\n\n3、语法上 Vue 并不限制你必须 es6+完全 js 形式编写页面，可以视图和 js 逻辑尽可能分离，减少很多人看不惯 React-jsx 的恶心嵌套，毕竟都是作为前端开发者，还是更习惯于 html\n干净。\n\n4、很多人说 React 适合大型项目，适合什么什么，Vue 轻量级，适合移动端中小型项目，其实我想说，说这话的人是心里根本没点逼数，Vue 完全可以应对复杂的大型应用，甚至于说如果你 React\n学的不是很好，写出来的东西或根本不如 Vue 写的，毕竟Vue 跟着官方文档撸就行，自有人帮你规范，而 React 比较懒散自由，可以自由发挥5、Vue 在国内人气明显胜过\nReact，这很大程度上得益于它的很多语法包括编程思维更符合国人思想。\n\n- ### 什么是虚拟 DOM？\n\n参考回答：\n\n虚拟 dom 是相对于浏览器所渲染出来的真实 dom 的，在 react，vue 等技术出现之\n\n前，我们要改变页面展示的内容只能通过遍历查询 dom 树的方式找到需要修改的 dom 然后修改样式行为或者结构，来达到更新 ui 的目的。\n\n这种方式相当消耗计算资源，因为每次查询 dom 几乎都需要遍历整颗 dom 树，如果建立一个与 dom 树对应的虚拟 dom 对象（ js 对象），以对象嵌套的方式来表示dom 树，那么每次 dom\n的更改就变成了 js 对象的属性的更改，这样一来就能查找js 对象的属性变化要比查询 dom 树的性能开销小。\n\n- ### 请描述下 vue 的生命周期是什么？\n\n参考回答：\n\n- 生命周期就是 vue 从开始创建到销毁的过程，分为四大步（创建，挂载，更新，销毁），每一步又分为两小步，如 beforeCreate， created。beforeCreate 前，也就是 new\n  Vue 的时候会初始化事件和生命周期；beforeCreate 和 created 之间会挂载 Data，绑定事件；接下来会根据 el 挂载页面元素，如果没有设置 el\n  则生命周期结束，直到手动挂载；el 挂载结束后，根据 templete/outerHTML(el)渲染页面；在beforeMount 前虚拟 DOM 已经创建完成；之后在 mounted 前，将\n  vm.\\$el 替换掉页面元素 el;mounted 将虚拟 dom 挂载到真实页面（此时页面已经全部渲染完成）；之后发生数据变化时触发 beforeUpdate 和updated\n  进行一些操作；最后主动调用销毁函数或者组件自动销毁时\n\n> beforeDestroy，手动撤销监听事件，计时器等；destroyed 时仅存在Dom 节点，其他所有东西已自动销毁。这就是我所理解的 vue 的一个完整的生命周期。\n\n-\n\n![](media/image40.jpeg)\n\n- ### vue 如何监听键盘事件？\n\n参考回答：\n\n1. @keyup\\. 方 法\n\n### <template>\n\n> <input ref=\"myInput\" type=\"text\" value=\"hello world\" autofocus @keyup.enter=\"handleKey\">\n\n> </template>\n\n> <script>\n\n> export default {\n\n> methods: {\n\n> handleKey(e) {\n\n> console.log(e)\n\n> }\n\n> }\n\n> }\n\n> </script>\n\n2. addEventListener\n\n### <script>\n\n> export default {\n\n> mounted() {\n\n> document.addEventListener('keyup', this.handleKey)\n\n> },\n\n> beforeDestroy() {\n\n> document.removeEventListener('keyup', this.handleKey)\n\n> },\n\n> methods: {\n\n> handleKey(e) {\n\n> console.log(e)\n\n> }\n\n> }\n\n> }\n\n> </script><script>\n\n> export default {\n\n> mounted() {\n\n> document.addEventListener('keyup', this.handleKey)\n\n> },\n\n> beforeDestroy() {\n\n> document.removeEventListener('keyup', this.handleKey)\n\n> },\n\n> methods: {\n\n> handleKey(e) {\n\n> console.log(e)\n\n> }\n\n> }\n\n> }\n\n> </script>\n\n- ### watch 怎么深度监听对象变化\n\n参考回答：\n\ndeep 设置为 true 就可以监听到对象的变化\n\n### let vm=new Vue({\n\n> el:\"#first\",\n\n> data:{msg:{name:'北京'}},\n\n> watch:{\n\n> msg:{\n\n> handler (newMsg,oldMsg){\n\n> console.log(newMsg);\n\n> },\n\n> immediate:true,\n\n> deep:true\n\n> }\n\n> }\n\n> })\n\n- ### 删除数组用 delete 和 Vue.delete 有什么区别？\n\n参考回答：\n\n- delete：只是被删除数组成员变为 empty / undefined，其他元素键值不变\n\n- Vue.delete：直接删了数组成员，并改变了数组的键值（对象是响应式的，确保删除能触发更新视图，这个方法主要用于避开 Vue 不能检测到属性被删除的限制）\n\n- ### watch 和计算属性有什么区别？\n\n参考回答：\n\n通俗来讲，既能用 computed 实现又可以用 watch 监听来实现的功能，推荐用computed，重点在于 computed 的缓存功能\n\ncomputed 计算属性是用来声明式的描述一个值依赖了其它的值，当所依赖的值或者变量改变时，计算属性也会跟着改变；\n\nwatch 监听的是已经在 data 中定义的变量，当该变量变化时，会触发 watch 中的方法。\n\n- ### Vue 双向绑定原理\n\n参考回答：\n\nVue 数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。利用了Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)。\n\n- ### v-model 是什么？有什么用呢？\n\n参考回答：\n\n一则语法糖，相当于v-bind:value=\"xxx\" 和 @input，意思是绑定了一个 value 属性的值，子组件可对 value 属性监听，通过\\$emit('input',\nxxx)的方式给父组件通讯。自己实现v-model 方式的组件也是这样的思路。\n\n- ### axios 是什么？怎样使用它？怎么解决跨域的问题？\n\n参考回答：\n\naxios 的是一种异步请求，用法和 ajax 类似，安装 npm install axios --save 即可使用，请求中包括 get,post,put, patch ,delete\n等五种请求方式，解决跨域可以在请求头中添加 Access-Control-Allow-Origin，也可以在 index.js 文件中更改proxyTable 配置等解决跨域问题。\n\n- ### 在 vue 项目中如何引入第三方库（比如 jQuery）？有哪些方法可以做到？\n\n参考回答：\n\n1、绝对路径直接引入\n\n在 index.html 中用 script 引入\n\n### <script src=\"./static/jquery-1.12.4.js\"></script>\n\n> 然 后 在 webpack 中 配 置 external externals: { 'jquery': 'jQuery' } 在组件中使用时 import\n\n> import \\$ from 'jquery' 2 、在 webpack 中配置 alias\n\n### resolve: { extensions: \\['.js', '.vue', '.json'\\], alias: { '@': resolve('src'), 'jquery': resolve('static/jquery-1.12.4.js') } } 然后在组件中 import\n\n3、在 webpack 中配置 plugins\n\n### plugins: \\[ new webpack.ProvidePlugin({ \\$: 'jquery' }) \\]\n\n全局使用，但在使用 eslint 情况下会报错，需要在使用了 \\$ 的代码前添加 /\\* eslint-disable\\*/ 来去掉 ESLint 的检查。\n\n- ### 说说 Vue React angularjs jquery 的区别\n\n参考回答：\n\nJQuery 与另外几者最大的区别是，JQuery 是事件驱动，其他两者是数据驱动。JQuery 业务逻辑和 UI 更改该混在一起， UI 里面还参杂这交互逻辑，让本来混乱的逻辑更加混乱。\n\nAngular，Vue 是双向绑定，而 React 不是其他还有设计理念上的区别等\n\n- Vue3.0 里为什么要用 Proxy API 替代 defineProperty API？\n\n参考回答： 响应式优化。\n\n1. defineProperty API 的局限性最大原因是它只能针对单例属性做监听。\n\nVue2.x 中的响应式实现正是基于 defineProperty 中的 descriptor，对 data 中的属性做了遍历 + 递归，为每个属性设置了 getter、setter。\n\n这也就是为什么 Vue 只能对 data 中预定义过的属性做出响应的原因，在 Vue 中使用下标的方式直接修改属性的值或者添加一个预先不存在的对象属性是无法做到 setter 监听的，这是\ndefineProperty 的局限性。\n\n2. Proxy API 的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，\n\n这就完全可以代理所有属性，将会带来很大的性能提升和更优的代码。\n\nProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。\n\n3. 响应式是惰性的\n\n在 Vue.js 2.x 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的变化，就需要递归遍历这个对象，执行 Object.defineProperty\n把每一层对象数据都变成响应式的，这无疑会有很大的性能消耗。\n\n在 Vue.js 3.0 中，使用 Proxy API 并不能监听到对象内部深层次的属性变化，因此它的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部属性才会\n\n变成响应式，简单的可以说是按需实现响应式，减少性能消耗。基础用法：\n\n![](media/image41.jpeg)\n\n- Vue3.0 编译做了哪些优化？\n\n参考回答：\n\n1. 生成 Block tree\n\n![](media/image42.jpeg) Vue.js 2.x 的数据更新并触发重新渲染的粒度是组件级的，单个组件内部 需要遍历该组件的整个 vnode 树。在 2.0\n里，渲染效率的快慢与组件大小成正相关：组件越大， 渲染效率越慢。并且，对于一些静态节点，又无数据更新，这些遍历都是性能浪费。Vue.js 3.0 做到了通过编译阶段对静态模板的分析，编译生成了\nBlock tree。 Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个 区块内部的节点结构是固定的，每个区块只需要追踪自身包含的动态节点。所以，在 3.0\n里，渲染效率不再与模板大小成正相关，而是与模板中动态节点的数量成正相关。\n\n2. slot 编译优化\n\nVue.js 2.x 中，如果有一个组件传入了 slot，那么每次父组件更新的时候，会强制使子组件 update，造成性能的浪费。\n\nVue.js 3.0 优化了 slot 的生成，使得非动态 slot 中属性的更新只会触发子组件的更\n\n新。动态 slot 指的是在 slot 上面使用 v-if，v-for，动态 slot 名字等会导致 slot 产\n\n生运行时动态变化但是又无法被子组件 track 的操作。c. diff 算法优化\n\n- Vue3.0 新特性 —— Composition API 与 React.js 中 Hooks 的异同点\n\n参考回答：\n\n1. React.js 中的 Hooks 基本使用\n\nReact Hooks 允许你 \"勾入\" 诸如组件状态和副作用处理等 React 功能中。Hooks 只能用在函数组件中，并允许我们在不需要创建类的情况下将状态、副作用处理和更多东西带入组件中。\n\nReact 核心团队奉上的采纳策略是不反对类组件，所以你可以升级 React 版本、在新组件中开始尝试 Hooks，并保持既有组件不做任何更改。\n\n案例：\n\n> ![](media/image43.jpeg)\n\nuseState 和 useEffect 是 React Hooks 中的一些例子，使得函数组件中也能增加状态和运行副作用。\n\n我们也可以自定义一个 Hooks，它打开了代码复用性和扩展性的新大门。\n\n2. Vue Composition API 基本使用\n\nVue Composition API 围绕一个新的组件选项 setup 而创建。setup() 为 Vue 组件提供了状态、计算值、watcher 和生命周期钩子。\n\n并没有让原来的 API（Options-based API）消失。允许开发者 结合使用新旧两种 API\n\n（向下兼容）。\n\n> ![](media/image44.jpeg)\n\n3. 原理\n\nReact hook 底层是基于链表实现，调用的条件是每次组件被 render 的时候都会顺序执行所有的 hooks。\n\nVue hook 只会被注册调用一次，Vue 能避开这些麻烦的问题，原因在于它对数据的响\n\n应是基于 proxy 的，对数据直接代理观察。（这种场景下，只要任何一个更改 data 的\n\n地方，相关的 function 或者 template 都会被重新计算，因此避开了 React 可能遇到的性能上的问题）。\n\nReact 中，数据更改的时候，会导致重新 render，重新 render 又会重新把 hooks 重新注册一次，所以 React 复杂程度会高一些。\n\n- ### Vue3.0 是如何变得更快的？（底层，源码）\n\n参考回答：\n\n1. diff 方法优化\n\nVue2.x 中的虚拟 dom 是进行全量的对比。\n\nVue3.0 中新增了静态标记（PatchFlag）：在与上次虚拟结点进行对比的时候，值对比带有 patch flag 的节点，并且可以通过 flag 的信息得知当前节点要对比的具体内容化。\n\n2. hoistStatic 静态提升\n\nVue2.x : 无论元素是否参与更新，每次都会重新创建。\n\nVue3.0 : 对不参与更新的元素，只会被创建一次，之后会在每次渲染时候被不停的复用。\n\n3. cacheHandlers 事件侦听器缓存\n\n默认情况下 onClick 会被视为动态绑定，所以每次都会去追踪它的变化但是因为是同一个函数，所以没有追踪变化，直接缓存起来复用即可。\n\n原作者姓名： 欧阳呀\n\n- ### vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？\n\n参考回答：\n\n按 钮 级 别 的 权 限 ：\n[_https://panjiachen.github.io/vue-element-admin-_](https://panjiachen.github.io/vue-element-admin-site/zh/guide/essentials/permission.html#%E6%8C%87%E4%BB%A4%E6%9D%83%E9%99%90)\n\n[_site/zh/guide/essentials/permission.html#%E6%8C%87%E4%BB%A4%E6%9D%83%E9%99%_](https://panjiachen.github.io/vue-element-admin-site/zh/guide/essentials/permission.html#%E6%8C%87%E4%BB%A4%E6%9D%83%E9%99%90)\n[_90_](https://panjiachen.github.io/vue-element-admin-site/zh/guide/essentials/permission.html#%E6%8C%87%E4%BB%A4%E6%9D%83%E9%99%90)\n\n- ### vue 在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？\n\n参考回答：\n\n看实际情况，一般在 created（或 beforeRouter） 里面就可以，如果涉及到需要页面加载完成之后的话就用 mounted。\n\n在 created 的时候，视图中的 html 并没有渲染出来，所以此时如果直接去操作 html\n\n的 dom 节点，一定找不到相关的元素\n\n而在 mounted 中，由于此时 html 已经渲染出来了，所以可以直接操作 dom 节点，（此时 document.getelementById 即可生效了）。\n\n- ### 说说你对 proxy 的理解\n\n参考回答：\n\nvue 的数据劫持有两个缺点:\n\n1、无法监听通过索引修改数组的值的变化\n\n2、无法监听 object 也就是对象的值的变化所以 vue2.x 中才会有\\$set 属性的存在\n\nproxy 是 es6 中推出的新 api，可以弥补以上两个缺点，所以 vue3.x 版本用 proxy 替换 object.defineproperty。\n\n1. ## | React 框架\n\n- ### angularJs 和 React 区别\n\n参考回答：\n\nReact 对比 Angular 是思想上的转变，它也并不是一个库，是一种开发理念，组件化， 分治的管理，数据与 view 的一体化。它只有一个中心,发出状态，渲染 view，对于虚拟 dom\n它并没有提高渲染页面的性能，它提供更多的是利用 jsx 便捷生成 dom 元素， 利用组件概念进行分治管理页面每个部分(例如 header section footer slider)\n\n- ### redux 中间件\n\n参考回答：\n\n中间件提供第三方插件的模式，自定义拦截 action -> reducer 的过程。变为action -> middlewares -> reducer\n。这种机制可以让我们改变数据流，实现如异步action ，action 过滤，日志输出，异常报告等功能。\n\n常见的中间件： redux-logger：提供日志输出；redux-thunk：处理异步操作；\n\nredux-promise：处理异步操作；actionCreator 的返回值是 promise\n\n- ### redux 有什么缺点\n\n参考回答：\n\n1. 一个组件所需要的数据，必须由父组件传过来，而不能像 flux 中直接从 store 取。\n\n2. 当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新render，可能会有效率影响，或者需要写复杂的 shouldComponentUpdate 进行判断。\n\n- ### React 组件的划分业务组件技术组件？\n\n参考回答：\n\n根据组件的职责通常把组件分为 UI 组件和容器组件。UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。两者通过 React-Redux 提供 connect 方法联系起来。\n\n- ### React 生命周期函数\n\n参考回答：\n\n一、初始化阶段：\n\ngetDefaultProps:获取实例的默认属性\n\ngetInitialState:获取每个实例的初始化状态\n\ncomponentWillMount：组件即将被装载、渲染到页面上\n\nrender:组件在这里生成虚拟的 DOM 节点\n\ncomponentDidMount:组件真正在被装载之后\n\n二、运行中状态：\n\ncomponentWillReceiveProps:组件将要接收到属性的时候调用\n\nshouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）\n\ncomponentWillUpdate:组件即将更新不能修改属性和状态\n\nrender:组件重新描绘\n\ncomponentDidUpdate:组件已经更新\n\n三、销毁阶段：\n\ncomponentWillUnmount:组件即将销毁\n\n- ### React 性能优化是哪个周期函数？\n\n参考回答：\n\nshouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate\n方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。\n\n- ### 为什么虚拟 dom 会提高性能?\n\n参考回答：\n\n虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。\n\n具体实现步骤如下：\n\n1. 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM\n\n树，插到文档当中；\n\n2. 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较， 记录两棵树差异；\n\n把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。\n\n- ### diff 算法?\n\n参考回答：\n\n1. 把树形结构按照层级分解，只比较同级元素。\n\n2. 给列表结构的每个单元添加唯一的 key 属性，方便比较。\n\n3. React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）\n\n4. 合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.\n\n到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.\n\n6. 选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。\n\n- ### React 性能优化方案\n\n参考回答：\n\n1. 重写 shouldComponentUpdate 来避免不必要的 dom 操作。\n\n2. 使用 production 版本的 React.js。\n\n3. 使用 key 来帮助 React 识别列表中所有子组件的最小变化\n\n- ### 简述 flux 思想\n\n参考回答：\n\nFlux 的最大特点，就是数据的\"单向流动\"。\n\n1. 用户访问 View\n\n2. View 发出用户的 Action\n\n3. Dispatcher 收到 Action，要求 Store 进行相应的更新\n\n4. Store 更新后，发出一个\"change\"事件\n\n5. View 收到\"change\"事件后，更新页面\n\n- ### React 项目用过什么脚手架？Mern? Yeoman?\n\n参考回答：\n\nMern：MERN 是脚手架的工具，它可以很容易地使用 Mongo, Express, React and NodeJS 生成同构 JS\n应用。它最大限度地减少安装时间，并得到您使用的成熟技术来加速开发。\n\n- ### 你了解 React 吗？\n\n参考回答：\n\n了解，React 是 facebook 搞出来的一个轻量级的组件库，用于解决前端视图层的一些问题，就是 MVC 中V 层的问题，它内部的 Instagram 网站就是用 React 搭建的。\n\n- ### React 解决了什么问题？\n\n参考回答：\n\n解决了三个问题： 1.组件复用问题， 2.性能问题，3.兼容性问题：\n\n- ### React 的协议？\n\n参考回答：\n\nReact 遵循的协议是“BSD 许可证 + 专利开源协议”，这个协议比较奇葩，如果你的产品跟 facebook 没有竞争关系，你可以自由的使用 React，但是如果有竞争关系，你的 React\n的使用许可将会被取消\n\n- ### 了解 shouldComponentUpdate 吗？\n\n参考回答：\n\nReact 虚拟 dom 技术要求不断的将 dom 和虚拟 dom 进行 diff 比较，如果 dom 树比价大，这种比较操作会比较耗时，因此 React 提供了\nshouldComponentUpdate 这种补丁函数，如果对于一些变化，如果我们不希望某个组件刷新，或者刷新后跟原来其实一样，就可以使用这个函数直接告诉 React，省去 diff\n操作，进一步的提高了效率。\n\n- ### React 的工作原理？\n\n参考回答：\n\nReact 会创建一个虚拟 DOM(virtual DOM)。当一个组件中的状态改变时，React 首先会通过 \"diffing\" 算法来标记虚拟 DOM\n中的改变，第二步是调节(reconciliation)，会用 diff 的结果来更新 DOM。\n\n- ### 使用 React 有何优点？\n\n参考回答：\n\n1. 只需查看 render 函数就会很容易知道一个组件是如何被渲染的\n\n2. JSX 的引入，使得组件的代码更加可读，也更容易看懂组件的布局，或者组件之间是如何互相引用的\n\n3. 支持服务端渲染，这可以改进 SEO 和性能\n\n4. 易于测试\n\n5. React 只关注 View 层，所以可以和其它任何框架(如 Backbone.js, Angular.js)一起使用\n\n- ### 展示组件(Presentational component)和容器组件(Container component)之间有何不同？\n\n参考回答：\n\n1. 展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。\n\n2. 容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 Flux\n   actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源\n\n- ### 类组件(Class component)和函数式组件(Functional component)之间有何不同？\n\n参考回答：\n\n1. 类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态\n\n2. 当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 '无状态组件(stateless\n   component)'，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件\n\n- ### (组件的)状态(state)和属性(props)之间有何不同？\n\n参考回答：\n\n1. State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。\n\n2. Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的\n   props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据--回调函数也可以通过 props 传递。\n\n- ### 应该在 React 组件的何处发起 Ajax 请求？\n\n参考回答：\n\n在 React 组件中，应该在 componentDidMount 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到\nDOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在\ncomponentDidMount 中发起网络请求将保证这有一个组件可以更新了。\n\n- ### 在 React 中，refs 的作用是什么？\n\n参考回答：\n\nRefs 可以用于获取一个 DOM 节点或者 React 组件的引用。何时使用 refs 的好的示例有管理焦点/文本选择，触发命令动画，或者和第三方 DOM 库集成。你应该避免使用 String\n类型的 Refs 和内联的 ref 回调。Refs 回调是 React 所推荐的。\n\n- ### 何为高阶组件(higher order component)？\n\n参考回答：\n\n高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC 最好的方式是共享\nReact 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。\n\n- ### 使用箭头函数(arrow functions)的优点是什么？\n\n参考回答：\n\n1. 作用域安全：在箭头函数之前，每一个新创建的函数都有定义自身的 this 值(在构造函数中是新对象；在严格模式下，函数调用中的 this 是未定义的；如果函数被\n\n称为“对象方法”，则为基础对象等)，但箭头函数不会，它会使用封闭执行上下文的this 值。\n\n2. 简单：箭头函数易于阅读和书写\n\n3. 清晰：当一切都是一个箭头函数，任何常规函数都可以立即用于定义作用域。开发者总是可以查找 next-higher 函数语句，以查看 this 的值\n\n- ### 为什么建议传递给 setState 的参数是一个 callback 而不是一个对象？\n\n参考回答：\n\n因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state。\n\n- ### 除了在构造函数中绑定 this，还有其它方式吗？\n\n参考回答：\n\n可以使用属性初始值设定项(property initializers)来正确绑定回调，create- React-app\n也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。\n\n- ### 怎么阻止组件的渲染？\n\n参考回答：\n\n在组件的 render 方法中返回 null 并不会影响触发组件的生命周期方法\n\n- ### 当渲染一个列表时，何为 key？设置 key 的目的是什么？\n\n参考回答：\n\nKeys 会有助于 React 识别哪些 items 改变了，被添加了或者被移除了。Keys 应该被赋予数组内的元素以赋予(DOM)元素一个稳定的标识，选择一个 key\n的最佳方法是使用一个字符串，该字符串能惟一地标识一个列表项。很多时候你会使用数据中的 IDs 作为 keys，当你没有稳定的 IDs 用于被渲染的 items 时，可以使用项目索引作为渲染项的\nkey，但这种方式并不推荐，如果 items 可以重新排序，就会导致 re- render 变慢\n\n- (在构造函数中)调用 super(props) 的目的是什么？\n\n参考回答：\n\n在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在constructor 中调用 super()。传递 props 给 super()\n的原因则是便于(在子类中) 能在 constructor 访问 this.props。\n\n- ### 何为 JSX ？\n\n参考回答：\n\nJSX 是 JavaScript 语法的一种语法扩展，并拥有 JavaScript 的全部功能。JSX 生产 React \"元素\"，你可以将任何的 JavaScript\n表达式封装在花括号里，然后将其嵌入到 JSX 中。在编译完成之后，JSX 表达式就变成了常规的 JavaScript 对象，这意味着你可以在 if 语句和 for 循环内部使用\nJSX，将它赋值给变量，接受它作为参数，并从函数中返回它。\n","source":"_posts/0_1前端工程师面试题2-md.md","raw":"---\ntitle: 0.1前端工程师面试题2.md\nindex_img: /img/index-img.png\ndate: 2022-02-15 10:14:34\ntags: 前端\ncategories: 面试\nabbrlink: vdfge343\n---\n\n## | HTTP/HTML/浏览器\n\n### 说一下 http 和 https\n\n参考回答：\n\nhttps 的 SSL 加密是在传输层实现的。(1)http 和 https 的基本概念\n\nhttp: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW\n服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。\n\nhttps: 是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL\n\n层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。\n\nhttps 协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。\n\n2. http 和 https 的区别？\n\nhttp 传输的数据都是未加密的，也就是明文的，网景公司设置了 SSL 协议来对 http 协议传输的数据进行加密处理，简单来说 https 协议是由 http 和 ssl\n协议构建的可进行加密传输和身份认证的网络协议，比 http 协议的安全性更高。\n\n主要的区别如下：\n\nHttps 协议需要 ca 证书，费用较高。\n\nhttp 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。\n\n使用不同的链接方式，端口也不同，一般而言，http 协议的端口为 80，https 的端口为 443\n\nhttp 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。\n\n3. https 协议的工作原理\n\n客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤，如图所示。客户使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。\n\nweb 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。\n\n客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。\n\n客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。\n\nweb 服务器通过自己的私钥解密出会话密钥。\n\nweb 服务器通过会话密钥加密与客户端之间的通信。(4)https 协议的优点\n\n使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；\n\nHTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比http 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。HTTPS\n是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。\n\n谷歌曾在 2014 年 8 月份调整搜索引擎算法，并称“比起同等 HTTP 网站，采用 HTTPS\n\n加密的网站在搜索结果中的排名将会更高”。(5)https 协议的缺点\n\nhttps 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%\\~20%的耗电。https 缓存不如 http 高效，会增加数据开销。\n\nSSL 证书也需要钱，功能越强大的证书费用越高。\n\nSSL 证书需要绑定 IP，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。\n\n### tcp 三次握手，一句话概括\n\n参考回答：\n\n客户端和服务端都需要直到各自可收发，因此需要三次握手。简化三次握手：\n\n<img width=\"487\" alt=\"2018-07-10 3 42 11\"\nsrc=\"[_https://user-_](https://user-images.githubusercontent.com/17233651/42496289-1c6d668a-8458-11e8-98b3-65db50f64d48.png)\n[_images.githubusercontent.com/17233651/42496289-1c6d668a-8458-11e8-98b3-_](https://user-images.githubusercontent.com/17233651/42496289-1c6d668a-8458-11e8-98b3-65db50f64d48.png)\n[_65db50f64d48.png_](https://user-images.githubusercontent.com/17233651/42496289-1c6d668a-8458-11e8-98b3-65db50f64d48.png)\">\n\n从图片可以得到三次握手可以简化为：C 发起请求连接S 确认，也发起连接C 确认我们再看看每次握手的作用：第一次握手：S 只可以确认 自己可以接受C 发送的报文段第二次握手：C 可以确认 S\n收到了自己发送的报文段，并且可以确认 自己可以接受S 发送的报文段第三次握手：S 可以确认 C 收到了自己发送的报文段\n\n- ### TCP 和 UDP 的区别\n\n参考回答：\n\n1. TCP 是面向连接的，udp 是无连接的即发送数据前不需要先建立链接。\n\n2. TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失， 不重复，且按序到达;UDP 尽最大努力交付，即不保证可靠交付。 并且因为 tcp 可靠，\n   面向连接，不会丢失数据因此适合大数据量的交换。\n\n3. TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低\n\n（因此会出现丢包，对实时的应用比如 IP 电话和视频会议等）。\n\n4. TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多。\n\n5. TCP 的首部较大为 20 字节，而 UDP 只有 8 字节。\n\n6. TCP 是面向连接的可靠性传输，而 UDP 是不可靠的。\n\n- ### WebSocket 的实现和应用\n\n参考回答：\n\n1. 什么是 WebSocket?\n\nWebSocket 是 HTML5 中的协议，支持持久连续，http 协议不支持持久性连接。Http1.0 和 HTTP1.1 都不支持持久性的链接，HTTP1.1 中的 keep-alive，将多个\nhttp 请求合并为 1 个\n\n2. WebSocket 是什么样的协议，具体有什么优点？\n\nHTTP 的生命周期通过 Request 来界定，也就是 Request 一个 Response，那么在Http1.0 协议中，这次 Http 请求就结束了。在 Http1.1\n中进行了改进，是的有一个connection：Keep-alive，也就是说，在一个 Http 连接中，可以发送多个 Request， 接收多个 Response。但是必须记住，在 Http 中一个\nRequest 只能对应有一个Response，而且这个 Response 是被动的，不能主动发起。\n\nWebSocket 是基于 Http 协议的，或者说借用了 Http 协议来完成一部分握手，在握手阶段与 Http 是相同的。我们来看一个 websocket 握手协议的实现，基本是 2 个属性，\nupgrade，connection。\n\n基本请求如下：\n\n### GET /chat HTTP/1.1\n\n> Host: server.example.com Upgrade: websocket Connection: Upgrade\n\n> Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== Sec-WebSocket-Protocol: chat, superchat\n> Sec-WebSocket-Version: 13\n\n> [Origin: http://example.com](http://example.com/)\n\n多了下面 2 个属性：\n\n告诉服务器发送的是 websocket\n\n- ### HTTP 请求的方式，HEAD 方式\n\n参考回答：\n\nhead：类似于 get 请求，只不过返回的响应中没有具体的内容，用户获取报头options：允许客户端查看服务器的性能，比如说服务器支持的请求方式等等。\n\n- ### 一个图片 url 访问后直接下载怎样实现？\n\n参考回答：\n\n请求的返回头里面，用于浏览器解析的重要参数就是 OSS 的 API 文档里面的返回 http\n\n头，决定用户下载行为的参数。下载的情况下：\n\n1. x-oss-object-type: Normal\n\n2. x-oss-request-id: 598D5ED34F29D01FE2925F41\n\n3. x-oss-storage-class: Standard\n\n- ### 说一下 web Quality（无障碍）\n\n参考回答：\n\n能够被残障人士使用的网站才能称得上一个易用的（易访问的）网站。残障人士指的是那些带有残疾或者身体不健康的用户。\n\n使用 alt 属性：\n\n<img src=\"person.jpg\" alt=\"this is a person\"/>\n\n有时候浏览器会无法显示图像。具体的原因有： 用户关闭了图像显示\n\n浏览器是不支持图形显示的迷你浏览器\n\n浏览器是语音浏览器（供盲人和弱视人群使用）\n\n如果您使用了 alt 属性，那么浏览器至少可以显示或读出有关图像的描述。\n\n- ### 几个很实用的 BOM 属性对象方法?\n\n参考回答：\n\n什么是 Bom? Bom 是浏览器对象。有哪些常用的 Bom 属性呢？ (1)location 对象\n\nlocation.href-- 返 回 或 设 置 当 前 文 档 的 URL location.search -- 返回 URL 中的查询字符串部分。例\n\n如\n[_http://www.dreamdu.com/dreamdu.php?id=5&name=dreamdu_](http://www.dreamdu.com/dreamdu.php?id=5&name=dreamdu)\n返回包括(?)后面的内容?id=5&name=dreamdu\n\nlocation.hash -- 返回 URL#后面的内容，如果没有#，返回空location.host -- 返回 URL 中的域名部分，例如\n[_www.dreamdu.com_](http://www.dreamdu.com/) location.hostname -- 返回 URL 中的主域名部分，例如 dreamdu.com\nlocation.pathname -- 返回 URL 的域名后的部分。例\n\n如 [_http://www.dreamdu.com/xhtml/_](http://www.dreamdu.com/xhtml/) 返回/xhtml/ location.port -- 返回 URL\n中的端口部分。例\n\n如 _<http://www.dreamdu.com:8080/xhtml/>_ 返 回 8080\n\nlocation.protocol -- 返回 URL 中的协议部分。例\n\n如 _<http://www.dreamdu.com:8080/xhtml/>_ 返回(//)前面的内容 http: location.assign -- 设置当前文档的 URL\n\nlocation.replace() -- 设置当前文档的 URL，并且在 history 对象的地址列表中移除这个 URL location.replace(url);\n\nlocation.reload() -- 重载当前页面(2)history 对象\n\nhistory.go() -- 前进或后退指定的页面数 history.go(num); history.back() -- 后退一页\n\nhistory.forward() -- 前进一页(3)Navigator 对象\n\nnavigator.userAgent -- 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)\n\nnavigator.cookieEnabled -- 返回浏览器是否支持(启用)cookie\n\n- ### 说一下 HTML5 drag api\n\n参考回答：\n\ndragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发，。darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。dragend：事件主体是被拖放元素，在整个拖放操作结束时触发\n\n- ### 说一下 http2.0\n\n参考回答：\n\n首先补充一下，http 和 https 的区别，相比于 http,https 是基于 ssl 加密的 http 协议\n\n简要概括：http2.0 是基于 1999 年发布的 http1.0 之后的首次更新。\n\n提升访问速度（可以对于，请求资源所需时间更少，访问速度更快，相比 http1.0） 允许多路复用：多路复用允许同时通过单一的 HTTP/2 连接发送多重请求-响应信息。改善了：在 http1.1\n中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。\n\n二进制分帧：HTTP2.0 会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码\n\n首部压缩\n\n服务器端推送\n\n- ### 补充 400 和 401、403 状态码\n\n参考回答：\n\n(1)400 状态码：请求无效产生原因：\n\n前端提交数据的字段名称和字段类型与后台的实体没有保持一致\n\n前端提交到后台的数据应该是 json 字符串类型，但是前端没有将对象 JSON.stringify\n\n转化成字符串。解决方法：\n\n对照字段的名称，保持一致性\n\n将 obj 对象通过 JSON.stringify 实现序列化(2)401 状态码：当前请求需要用户验证\n\n3. 403 状态码：服务器已经得到请求，但是拒绝执行\n\n- ### fetch 发送 2 次请求的原因\n\n参考回答：\n\nfetch 发送 post 请求的时候，总是发送 2 次，第一次状态码是 204，第二次才成功？ 原因很简单，因为你用 fetch 的 post 请求的时候，导致 fetch\n第一次发送了一个Options 请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。\n\n- ### Cookie、sessionStorage、localStorage 的区别\n\n参考回答：\n\n共同点：都是保存在浏览器端，并且是同源的\n\nCookie：cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递。而 sessionStorage 和 localStorage\n不会自动把数据发给服务器，仅在本地保存。cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下,存储的大小很小只有 4K 左右。\n（key：可以在浏览器和服务器端来回传递，存储容量小，只有大约 4K 左右）\n\nsessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持， localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据； cookie 只在设置的\ncookie 过期时间之前一直有效，即使窗口或浏览器关闭。（key： 本身就是一个回话过程，关闭浏览器后消失，session 为一个回话，当页面不同即使是同一页面打开两次，也被视为同一次回话）\n\nlocalStorage：localStorage 在所有同源窗口中都是共享的；cookie\n也是在所有同源窗口中都是共享的。（key：同源窗口都会共享，并且不会失效，不管窗口或者浏览器关闭与否都会始终生效）\n\n补充说明一下 cookie 的作用：\n\n保存用户登录状态。例如将用户 id 存储于一个 cookie 内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie\n还可以设置过期时间，当超过时间期限后，cookie 就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。\n\n跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了 cookie 后就会显得很人性化了，\n系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后\n台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便定制页面。如果网站提供了换肤或更换布局的功能， 那么可以使用 cookie\n来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。\n\n- ### 说一下 web worker\n\n参考回答：\n\n在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面你的性能。并且通过\npostMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。\n\n如何创建 web worker：\n\n检测浏览器对于 web worker 的支持性\n\n创建 web worker 文件（js，回传函数等） 创建 web worker 对象\n\n- ### 对 HTML 语义化标签的理解\n\n参考回答：\n\nHTML5 语义化标签是指正确的标签包含了正确的内容，结构良好，便于阅读，比如 nav\n\n表示导航条，类似的还有 article、header、footer 等等标签。\n\n- ### iframe 是什么？有什么缺点？\n\n参考回答：\n\n定义：iframe 元素会创建包含另一个文档的内联框架\n\n提示：可以将提示文字放在\\<iframe>\\</iframe>之间，来提示某些不支持 iframe 的浏览器\n\n缺点：\n\n会阻塞主页面的 onload 事件\n\n搜索引擎无法解读这种页面，不利于 SEO\n\niframe 和主页面共享连接池，而浏览器对相同区域有限制所以会影响性能。\n\n- ### Doctype 作用?严格模式与混杂模式如何区分？它们有何意义?\n\n参考回答：\n\nDoctype 声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。\n\n严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。\n\n混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。\n\n- ### Cookie 如何防范 XSS 攻击\n\n参考回答：\n\nXSS（跨站脚本攻击）是指攻击者在返回的 HTML 中嵌入 javascript 脚本，为了减轻这些攻击，需要在 HTTP 头部配上，set-cookie：\n\nhttponly-这个属性可以防止 XSS,它会禁止 javascript 脚本来访问 cookie。secure - 这个属性告诉浏览器仅在请求为 https 的时候发送 cookie。\n\n结果应该是这样的：Set-Cookie=\\<cookie-value>.\n\n- ### Cookie 和 session 的区别\n\n参考回答：\n\nHTTP 是一个无状态协议，因此 Cookie 的最大的作用就是存储 sessionId 用来唯一标识用户。\n\n- ### 一句话概括 RESTFUL\n\n参考回答：\n\n就是用 URL 定位资源，用 HTTP 描述操作。\n\n- ### 讲讲 viewport 和移动端布局\n\n参考回答：\n\n可以参考这篇文章：\n\n[_响应式布局的常用解决方案对比(媒体查询、百分比、rem 和 vw/vh）_](https://github.com/forthealllight/blog/issues/13)\n\n- ### click 在 ios 上有 300ms 延迟，原因及如何解决？\n\n参考回答：\n\n1. 粗暴型，禁用缩放\n\n<meta name=\"viewport\" content=\"width=device-width, user-scalable=no\"> (2)利用 FastClick，其原理是：\n\n检测到 touchend 事件后，立刻出发模拟 click 事件，并且把浏览器 300 毫秒之后真正出发的事件给阻断掉\n\n- ### addEventListener 参数\n\n参考回答：\n\naddEventListener(event, function, useCapture)\n\n其中，event 指定事件名；function 指定要事件触发时执行的函数；useCapture 指定事件是否在捕获或冒泡阶段执行。\n\n- ### cookie sessionStorage localStorage 区别\n\n参考回答：\n\ncookie 数据始终在同源的 http 请求中携带(即使不需要)，即 cookie 在浏览器和服务器间来回传递\n\ncookie 数据还有路径（path）的概念，可以限制。cookie 只属于某个路径下\n\n存储大小限制也不同，cookie 数据不能超过 4K，同时因为每次 http 请求都会携带\n\ncookie，所以 cookie 只适合保存很小的数据，如回话标识。\n\nwebStorage 虽然也有存储大小的限制，但是比 cookie 大得多，可以达到 5M 或更大数据的有效期不同 sessionStorage：仅在当前的浏览器窗口关闭有效；\nlocalStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据； cookie：只在设置的 cookie 过期时间之前一直有效，即使窗口和浏览器关闭\n\n作用域不同 sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面； localStorage：在所有同源窗口都是共享的；cookie：也是在所有同源窗口中共享的\n\n- ### cookie session 区别\n\n参考回答：\n\n1. cookie 数据存放在客户的浏览器上，session 数据放在服务器上。\n\n2. cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗\n\n考虑到安全应当使用 session。\n\n3. session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能\n\n考虑到减轻服务器性能方面，应当使用 COOKIE。\n\n4. 单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个cookie。\n\n- ### 介绍知道的 http 返回的状态码\n\n参考回答：\n\n100 Continue 继续。客户端应继续其请求\n\n101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议\n\n200 OK 请求成功。一般用于 GET 与 POST 请求\n\n201 Created 已创建。成功请求并创建了新的资源\n\n202 Accepted 已接受。已经接受请求，但未处理完成\n\n203 Non-Authoritative Information 非授权信息。请求成功。但返回的 meta 信息不在原始的服务器，而是一个副本\n\n204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档\n\n205 Reset Content 重置内容。服务器处理成功，用户终端（例如： 浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域\n\n206 Partial Content 部分内容。服务器成功处理了部分 GET 请求\n\n300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择\n\n301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替\n\n302 Found 临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有 URI\n\n303 See Other 查看其它地址。与 301 类似。使用 GET 和 POST 请求查看\n\n304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源\n\n305 Use Proxy 使用代理。所请求的资源必须通过代理访问\n\n306 Unused 已经被废弃的 HTTP 状态码\n\n307 Temporary Redirect 临时重定向。与 302 类似。使用 GET 请求重定向\n\n400 Bad Request 客户端请求的语法错误，服务器无法理解401 Unauthorized 请求要求用户的身份认证\n\n402 Payment Required 保留，将来使用\n\n403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求\n\n404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面\n\n405 Method Not Allowed 客户端请求中的方法被禁止\n\n406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求407 Proxy Authentication Required 请求要求代理的身份认证，与401\n类似，但请求者应当使用代理进行授权\n\n408 Request Time-out 服务器等待客户端发送的请求时间过长，超时\n\n409 Conflict 服务器完成客户端的 PUT 请求是可能返回此代码，服务器处理请求时发生了冲突\n\n410 Gone 客户端请求的资源已经不存在。410 不同于 404，如果资源以前有现在被永久删除了可使用 410 代码，网站设计人员可通过 301 代码指定资源的新位置\n\n411 Length Required 服务器无法处理客户端发送的不带 Content- Length 的请求信息\n\n412 Precondition Failed 客户端请求信息的先决条件错误\n\n413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个\nRetry-After 的响应信息\n\n414 Request-URI Too Large 请求的 URI 过长（URI 通常为网址），服务器无法处理\n\n415 Unsupported Media Type 服务器无法处理请求附带的媒体格式416 Requested range not satisfiable 客户端请求的范围无效417\nExpectation Failed 服务器无法满足 Expect 的请求头信息 500 Internal Server Error 服务器内部错误，无法完成请求\n\n501 Not Implemented 服务器不支持请求的功能，无法完成请求\n\n502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时， 从远程服务器接收到了一个无效的响应\n\n503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中\n\n504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求\n\n505 HTTP Version not supported 服务器不支持请求的 HTTP 协议的版本，无法完成处理\n\n- ### http 常用请求头\n\n参考回答：\n\n[TABLE]\n\n[TABLE]\n\n[TABLE]\n\n- ### 强，协商缓存\n\n参考回答：\n\n缓存分为两种：强缓存和协商缓存，根据响应的 header 内容来决定。\n\n[TABLE]\n\n强缓存相关字段有 expires，cache-control。如果 cache-control 与 expires 同时存在的话，cache-control 的优先级高于 expires。\n\n协商缓存相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match\n\n- ### 讲讲 304\n\n参考回答：\n\n304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个 304 状态\n\n码。\n\n- ### 强缓存、协商缓存什么时候用哪个\n\n参考回答：\n\n因为服务器上的资源不是一直固定不变的，大多数情况下它会更新，这个时候如果我们还访问本地缓存，那么对用户来说，那就相当于资源没有更新，用户看到的还是旧的资源；所以我们希望服务器上的资源更新了浏览器就请求新的资源，没有更新就使用本地的缓存，以最大程度的减少因网络请求而产生的资源浪费。\n\n![](media/image1.jpeg)\n\n参考 [_https://segmentfault.com/a/1190000008956069_](https://segmentfault.com/a/1190000008956069)\n\n- ### 前端优化\n\n参考回答：\n\n降低请求量：合并资源，减少 HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。\n\n加快请求速度：预解析 DNS，减少域名数，并行加载，CDN 分发。\n\n缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage。\n\n渲染：JS/CSS 优化，加载顺序，服务端渲染，pipeline。\n\n- ### GET 和 POST 的区别\n\n参考回答：\n\nget 参数通过 url 传递，post 放在 request body 中。\n\nget 请求在 url 中传递的参数是有长度限制的，而 post 没有。\n\nget 比 post 更不安全，因为参数直接暴露在 url 中，所以不能用来传递敏感信息。get 请求只能进行 url 编码，而 post 支持多种编码方式\n\nget 请求会浏览器主动 cache，而 post 支持多种编码方式。\n\nget 请求参数会被完整保留在浏览历史记录里，而 post 中的参数不会被保留。\n\nGET 和 POST 本质上就是 TCP 链接，并无差别。但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。\n\nGET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。\n\n- ### 301 和 302 的区别\n\n参考回答：\n\n301 Moved Permanently 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI\n之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。\n\n302 Found 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires\n中进行了指定的情况下，这个响应才是可缓存的。\n\n字面上的区别就是 301 是永久重定向，而 302 是临时重定向。\n\n301 比较常用的场景是使用域名跳转。302 用来做临时跳转 比如未登陆的用户访问用户中心重定向到登录页面。\n\n- ### HTTP 支持的方法\n\n参考回答：\n\n### GET, POST, HEAD, OPTIONS, PUT, DELETE, TRACE, CONNECT\n\n- ### 如何画一个三角形\n\n参考回答：\n\n三角形原理：边框的均分原理\n\n### div { width:0px; height:0px\n\n> border-top:10px solid red;\n\n> border-right:10px solid transparent; border-bottom:10px solid transparent; border-left:10px solid\n> transparent;\n\n> }\n\n- ### 状态码 304 和 200\n\n参考回答：\n\n状态码 200：请求已成功，请求所希望的响应头或数据体将随此响应返回。即返回的数据为全量的数据，如果文件不通过 GZIP 压缩的话，文件是多大，则要有多大传输量。状态码\n304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状\n态码。即客户端和服务器端只需要传输很少的数据量来做文件的校验，如果文件没有 修改过，则不需要返回全量的数据。\n\n- ### 说一下浏览器缓存\n\n参考回答：\n\n缓存分为两种：强缓存和协商缓存，根据响应的 header 内容来决定。\n\n强缓存相关字段有 expires，cache-control。如果 cache-control 与 expires 同时存在的话，cache-control 的优先级高于 expires。\n\n协商缓存相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match\n\n- ### HTML5 新增的元素\n\n参考回答：\n\n首先 html5 为了更好的实践 web 语义化，增加了 header，footer，nav,aside,section\n\n等语义化标签，在表单方面，为了增强表单，为 input 增加了 color，\n\nemial,data ,range 等类型，在存储方面，提供了\nsessionStorage，localStorage,和离线存储，通过这些存储方式方便数据在客户端的存储和获取，在多媒体方面规定了音频和视频元素 audio 和\nvedio，另外还有地理定位，canvas 画布，拖放，多线程编程的 web worker 和 websocket 协议。\n\n- ### 在地址栏里输入一个 URL,到这个页面呈现出来，中间会发生什么？\n\n参考回答：\n\n这是一个必考的面试问题，\n\n输入 url 后，首先需要找到这个 url 域名的服务器 ip,为了寻找这个 ip，浏览器首先会寻找缓存，查看缓存中是否有记录，缓存的查找记录为：浏览器缓存-》系统缓存\n\n-》路由器缓存，缓存中没有则查找系统的 hosts 文件中是否有记录，如果没有则查询DNS 服务器，得到服务器的 ip 地址后，浏览器根据这个 ip 以及相应的端口号，构造一个 http\n请求，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并将这个 http 请求封装在一个 tcp 包中，这个 tcp\n包会依次经过传输层，网络层，数据链路层，物理层到达服务器，服务器解析这个请求来作出响应，返回相应的 html 给浏览器，因为 html 是一个树形结构，浏览器根据这个 html 来构建DOM 树，在\ndom 树的构建过程中如果遇到 JS 脚本和外部 JS 连接，则会停止构建 DOM 树来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐 JS 代码应该放在 html\n代码的后面，之后根据外部央视，内部央视，内联样式构建一个 CSS 对象模型树 CSSOM 树，构建完成后和 DOM 树合并为渲染树，这里主要做的是排除非视觉节点，比如\n\nscript，meta 标签和排除 display 为 none 的节点，之后进行布局，布局主要是确定各个元素的位置和尺寸，之后是渲染页面，因为 html 文件中会含有图片，视频，音频等资源，在解析\nDOM 的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是 4-6 个，当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过\nCache-Control、Last-Modify、Expires 等首部字段控制。Cache-Control 和 Expires 的区别在于 Cache-Control 使用相对时间，Expires\n使用的是基于服务器 端的绝对时间，因为存在时差问题，一般采用 Cache-Control，在请求这些有设置了缓存的数据时，会先\n查看是否过期，如果没有过期则直接使用本地缓存，过期则请求并在服务器校验文件是否修改，如果上一次 响应设置了 ETag 值会在这次请求的时候作为 If-None-Match\n的值交给服务器校验，如果一致，继续校验Last-Modified，没有设置 ETag 则直接验证 Last-Modified，再决定是否返回 304。\n\n- ### cookie 和 session 的区别，localstorage 和 sessionstorage 的区别\n\n参考回答：\n\nCookie 和 session 都可用来存储用户信息，cookie 存放于客户端，session 存放于服务器端，因为cookie 存放于客户端有可能被窃取，所以 cookie\n一般用来存放不敏感的信息，比如用户设置的网站主题，敏感的信息用 session 存储，比如用户的登陆信息，session 可以存放于文件，数据库，内存中都可以，cookie\n可以服务器端响应的时候设置，也可以客户端通过 JS 设置 cookie 会在请求时在 http 首部发送给客户端， cookie 一般在客户端有大小限制，一般为 4K，\n\n下面从几个方向区分一下 cookie，localstorage，sessionstorage 的区别1、生命周期：\n\nCookie：可设置失效时间，否则默认为关闭浏览器后失效Localstorage:除非被手动清除，否则永久保存\n\nSessionstorage：仅在当前网页会话下有效，关闭页面或浏览器后就会被清除 2、存放数据：\n\nCookie：4k 左右\n\nLocalstorage 和 sessionstorage：可以保存 5M 的信息3、http 请求：\n\nCookie：每次都会携带在 http 头中，如果使用 cookie 保存过多数据会带来性能问题其他两个：仅在客户端即浏览器中保存，不参与和服务器的通信\n\n4、易用性：\n\nCookie：需要程序员自己封装，原生的 cookie 接口不友好其他两个：即可采用原生接口，亦可再次封装\n\n5、应用场景：\n\n从安全性来说，因为每次 http 请求都回携带 cookie 信息，这样子浪费了带宽，所以cookie 应该尽可能的少用，此外 cookie\n还需要指定作用域，不可以跨域调用，限制很多，但是用户识别用户登陆来说，cookie 还是比storage 好用，其他情况下可以用storage，localstorage\n可以用来在页面传递参数，sessionstorage 可以用来保存一些临时的数据，防止用户刷新页面后丢失了一些参数。\n\n- ### 常见的 HTTP 的头部\n\n参考回答：\n\n可以将 http 首部分为通用首部，请求首部，响应首部，实体首部通用首部表示一些通用信息，比如 date 表示报文创建时间，\n\n请求首部就是请求报文中独有的，如 cookie，和缓存相关的如 if-Modified-Since\n\n响应首部就是响应报文中独有的，如 set-cookie，和重定向相关的 location，\n\n实体首部用来描述实体部分，如 allow 用来描述可执行的请求方法，content-type 描述主题类型，content-Encoding 描述主体的编码方式。\n\n- ### HTTP2.0 的特性\n\n参考回答：\n\nhttp2.0 的特性如下：\n\n1、内容安全，应为 http2.0 是基于 https 的，天然具有安全特性，通过 http2.0 的特性可以避免单纯使用 https 的性能下降\n\n2、二进制格式，http1.X 的解析是基于文本的，http2.0 将所有的传输信息分割为更小的消息和帧，并对他们采用二进制格式编码，基于二进制可以让协议有更多的扩展性，比如引入了帧来传输数据和指令\n\n3、多路复用，这个功能相当于是长连接的增强，每个 request 请求可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里\n面，另外多路复用中也支持了流的优先级，允许客户端告诉服务器那些内容是更优先级的资源，可以优先传输。\n\n- ### cache-control 的值有哪些\n\n参考回答：\n\ncache-control 是一个通用消息头字段被用于 HTTP 请求和响应中，通过指定指令来实现缓存机制，这个缓存指令是单向的，常见的取值有\nprivate、no-cache、max-age、must-revalidate 等，默认为 private。\n\n- ### 浏览器在生成页面的时候，会生成那两颗树？\n\n参考回答：\n\n构造两棵树，DOM 树和 CSSOM 规则树，\n\n当浏览器接收到服务器相应来的 HTML 文档后，会遍历文档节点，生成 DOM 树， CSSOM 规则树由浏览器解析 CSS 文件生成。\n\n- ### csrf 和 xss 的网络攻击及防范\n\n参考回答：\n\nCSRF：跨站请求伪造，可以理解为攻击者盗用了用户的身份，以用户的名义发送了恶意请求，比如用户登录了一个网站后，立刻在另一个ｔａｂ页面访问量攻击者用来制\n\n造攻击的网站，这个网站要求访问刚刚登陆的网站，并发送了一个恶意请求，这时候CSRF\n就产生了，比如这个制造攻击的网站使用一张图片，但是这种图片的链接却是可以修改数据库的，这时候攻击者就可以以用户的名义操作这个数据库，防御方式的 话：使用验证码，检查 https 头部的\nrefer，使用 token XSS：跨站脚本攻击，是说攻击者通过注入恶意的脚本，在用户浏览网页的时候进行攻击，比如获取\ncookie，或者其他用户身份信息，可以分为存储型和反射型，存储型是攻击者输入一些数据并且存储到了数据库中，其他浏览者看到的时候进行攻击，反射型的话不存储在数据库中，往往表现为将攻击代码放在 url\n地址的请求参数中，防御的话为 cookie 设置 httpOnly 属性，对用户的输入进行检查，进行特殊字符过滤。\n\n- ### 怎么看网站的性能如何\n\n参考回答：\n\n检测页面加载时间一般有两种方式，一种是被动去测：就是在被检测的页面置入脚本或探针，当用户访问网页时，探针自动采集数据并传回数据库进行分析，另一种主动监测的方式，即主动的搭建分布式受控环境，模拟用户发起页面访问请求，主动采集性能数据并分析，在检测的精准度上，专业的第三方工具效果更佳，比如说性能极\n客。\n\n- ### 介绍 HTTP 协议(特征)\n\n参考回答：\n\nHTTP 是一个基于 TCP/IP 通信协议来传递数据（HTML 文件, 图片文件, 查询结果等） HTTP 是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于\n1990 年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在 WWW 中使用的是 HTTP/1.0 的第六版，HTTP/1.1 的规范化工作正在进行之中，而且 HTTP-NG(Next\nGeneration of HTTP)的建议已经提出。HTTP 协议工作于客户端-服务端架构为上。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器发送所有请求。Web\n服务器根据接收到的请求后，向客户端发送响应信息。\n\n- ### 输入 URL 到页面加载显示完成发生了什么?\n\n参考回答： DNS 解析TCP 连接\n\n发送 HTTP 请求\n\n服务器处理请求并返回 HTTP 报文浏览器解析渲染页面\n\n连接结束\n\n- ### 说一下对 Cookie 和 Session 的认知，Cookie 有哪些限制？\n\n参考回答：\n\n1. cookie 数据存放在客户的浏览器上，session 数据放在服务器上。\n\n2. cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗\n\n考虑到安全应当使用 session。\n\n3. session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能\n\n考虑到减轻服务器性能方面，应当使用 COOKIE。\n\n4. 单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个cookie。\n\n- ### 描述一下 XSS 和 CRSF 攻击？防御方法？\n\n参考回答：\n\nXSS, 即为（Cross Site Scripting）, 中文名为跨站脚本, 是发生在目标用户的浏览器层面上的，当渲染 DOM 树的过程成发生了不在预期内执行的 JS 代码时，就发生了XSS\n攻击。大多数 XSS 攻击的主要方式是嵌入一段远程或者第三方域上的 JS 代码。实际上是在目标网站的作用域下执行了这段 JS 代码。\n\nCSRF（Cross Site Request Forgery，跨站请求伪造），字面理解意思就是在别的站点伪造了一个请求。专业术语来说就是在受害者访问一个网站时，其 Cookie\n还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。\n\nXSS 防御的总体思路是：对输入(和 URL 参数)进行过滤，对输出进行编码。也就是对提交的所有内容进行过滤，对 url\n中的参数进行过滤，过滤掉会导致脚本执行的相关内容；然后对动态输出到页面的内容进行 html 编码，使脚本无法在浏览器中执行。虽然对输入过滤可以被绕过，但是也还是会拦截很大一部分的 XSS 攻击。\n\n防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token\n\n并验证；在 HTTP 头中自定义属性并验证。\n\n- ### 知道 304 吗，什么时候用 304？\n\n参考回答：\n\n304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个 304 状态\n\n码。\n\n- ### 具体有哪些请求头是跟缓存相关的\n\n参考回答：\n\n缓存分为两种：强缓存和协商缓存，根据响应的 header 内容来决定。\n\n强缓存相关字段有 expires，cache-control。如果 cache-control 与 expires 同时存在的话，cache-control 的优先级高于 expires。\n\n协商缓存相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match\n\n- ### cookie 和 session 的区别\n\n参考回答：\n\n1. cookie 数据存放在客户的浏览器上，session 数据放在服务器上。\n\n2. cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗\n\n考虑到安全应当使用 session。\n\n3. session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能\n\n考虑到减轻服务器性能方面，应当使用 COOKIE。\n\n4. 单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个cookie。\n\n- ### cookie 有哪些字段可以设置\n\n参考回答：\n\nname 字段为一个 cookie 的名称。value 字段为一个 cookie 的值。\n\ndomain 字段为可以访问此 cookie 的域名。\n\n非顶级域名，如二级域名或者三级域名，设置的 cookie 的 domain 只能为顶级域名或者二级域名或者三级域名本身，不能设置其他二级域名的 cookie，否则 cookie 无法生成。\n\n顶级域名只能设置 domain 为顶级域名，不能设置为二级域名或者三级域名，否则\n\ncookie 无法生成。\n\n二级域名能读取设置了 domain 为顶级域名或者自身的 cookie，不能读取其他二级域名domain 的 cookie。所以要想 cookie 在多个二级域名中共享，需要设置 domain\n为顶级域名，这样就可以在所有二级域名里面或者到这个 cookie 的值了。\n\n顶级域名只能获取到 domain 设置为顶级域名的 cookie，其他 domain 设置为二级域名的无法获取。\n\npath 字段为可以访问此 cookie 的页面路径。 比如 domain 是 abc.com,path 是/test， 那么只有/test 路径下的页面可以读取此 cookie。\n\nexpires/Max-Age 字段为此 cookie 超时时间。若设置其值为一个时间，那么当到达此时间后，此 cookie 失效。不设置的话默认值是 Session，意思是 cookie\n会和session 一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie 失效。\n\nSize 字段 此 cookie 大小。\n\nhttp 字段 cookie 的 httponly 属性。若此属性为 true，则只有在 http 请求头中会带有此 cookie 的信息，而不能通过 document.cookie 来访问此\ncookie。\n\nsecure 字段 设置是否只能通过 https 来传递此条 cookie\n\n- ### cookie 有哪些编码方式？\n\n参 考 回 答 ： encodeURI（）\n\n- ### 除了 cookie，还有什么存储方式。说说 cookie 和 localStorage 的区别\n\n参考回答：\n\n还有 localStorage，sessionStorage，indexdDB 等cookie 和 localStorage 的区别：\n\ncookie 数据始终在同源的 http 请求中携带(即使不需要)，即 cookie 在浏览器和服务器间来回传递\n\ncookie 数据还有路径（path）的概念，可以限制。cookie 只属于某个路径下\n\n存储大小限制也不同，cookie 数据不能超过 4K，同时因为每次 http 请求都会携带\n\ncookie，所以 cookie 只适合保存很小的数据，如回话标识。\n\nlocalStorage 虽然也有存储大小的限制，但是比cookie 大得多，可以达到 5M 或更大localStorage 始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie\n只在设置的 cookie 过期时间之前一直有效，即使窗口和浏览器关闭。\n\n- ### 浏览器输入网址到页面渲染全过程\n\n参考回答： DNS 解析TCP 连接\n\n发送 HTTP 请求\n\n服务器处理请求并返回 HTTP 报文浏览器解析渲染页面\n\n连接结束\n\n- ### HTML5 和 CSS3 用的多吗？你了解它们的新属性吗？有在项目中用过吗？\n\n参考回答： html5： 1）标签增删\n\n8 个语义元素 header section footer aside nav main article figure 内容元素 mark 高亮 progress 进度\n\n新的表单控件 calander date time email url search\n\n新的 input 类型 color date datetime datetime-local email 移除过时标签 big font frame frameset\n\n2）canvas 绘图，支持内联 SVG。支持 MathML 3）多媒体 audio video source embed track\n\n4. 本地离线存储，把需要离线存储在本地的文件列在一个 manifest 配置文件\n\n5. web 存储。localStorage、SessionStorage\n\ncss3：\n\nCSS3 边框如 border-radius，box-shadow 等；CSS3 背景如 background-size， background-origin 等；CSS3 2D，3D 转换如\ntransform 等；CSS3 动画如 animation 等。 参考\n[_https://www.cnblogs.com/xkweb/p/5862612.html_](https://www.cnblogs.com/xkweb/p/5862612.html)\n\n- ### http 常见的请求方法\n\n参考回答：\n\nget、post，这两个用的是最多的，还有很多比如 patch、delete、put、options 等等\n\n- ### get 和 post 的区别\n\n参考回答：\n\nGET - 从指定的资源请求数据。\n\nPOST - 向指定的资源提交要被处理的数据。\n\nGET：不同的浏览器和服务器不同，一般限制在 2\\~8K 之间，更加常见的是 1k 以内。GET 和 POST 的底层也是 TCP/IP，GET/POST 都是 TCP 链接。\n\nGET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。\n\n对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应\n\n200（返回数据）；\n\n而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送data，服务器响应 200 ok（返回数据）。\n\n- ### 说说 302，301，304 的状态码\n\n参考回答：\n\n301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替\n\n302 Found 临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有 URI\n\n304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源\n\n- ### web 性能优化\n\n参考回答：\n\n降低请求量：合并资源，减少 HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。\n\n加快请求速度：预解析 DNS，减少域名数，并行加载，CDN 分发。\n\n缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage。\n\n渲染：JS/CSS 优化，加载顺序，服务端渲染，pipeline。\n\n- ### 浏览器缓存机制\n\n参考回答：\n\n缓存分为两种：强缓存和协商缓存，根据响应的 header 内容来决定。\n\n强缓存相关字段有 expires，cache-control。如果 cache-control 与 expires 同时存在的话，cache-control 的优先级高于 expires。\n\n协商缓存相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match\n\n- ### post 和 get 区别\n\n参考回答：\n\nGET - 从指定的资源请求数据。\n\nPOST - 向指定的资源提交要被处理的数据。\n\nGET：不同的浏览器和服务器不同，一般限制在 2\\~8K 之间，更加常见的是 1k 以内。GET 和 POST 的底层也是 TCP/IP，GET/POST 都是 TCP 链接。\n\nGET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。\n\n对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应\n\n200（返回数据）；\n\n而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送data，服务器响应 200 ok（返回数据）。\n\n## 1.2 \\| CSS\n\n- ### 说一下 css 盒模型\n\n参考回答：\n\n简介：就是用来装页面上的元素的矩形区域。CSS 中的盒子模型包括 IE 盒子模型和标准的 W3C 盒子模型。\n\nbox-sizing(有 3 个值哦)：border-box,padding-box,content-box. 标准盒子模型：\n\n![](media/image2.jpeg)\n\n![](media/image3.jpeg) IE 盒子模型：\n\n区别：从图中我们可以看出，这两种盒子模型最主要的区别就是 width 的包含范围， 在标准的盒子模型中，width 指 content 部分的宽度，在 IE 盒子模型中，width\n表示content+padding+border 这三个部分的宽度，故这使得在计算整个盒子的宽度时存在着差异：\n\n标准盒子模型的盒子宽度：左右 border+左右 padding+width IE 盒子模型的盒子宽度：width\n\n在 CSS3 中引入了 box-sizing 属性，box-sizing:content-box;表示标准的盒子模型，\n\nbox-sizing:border-box 表示的是 IE 盒子模型\n\n最后，前面我们还提到了，box-sizing:padding-box,这个属性值的宽度包含了左右\n\npadding+width\n\n也很好理解性记忆，包含什么，width 就从什么开始算起。\n\n- ### 画一条 0.5px 的线\n\n参考回答：\n\n采用 meta viewport 的方式\n\n<meta name=\"viewport\" content=\"initial-scale=1.0, maximum-scale=1.0, user- scalable=no\" />\n\n采用 border-image 的方式\n\n采用 transform: scale()的方式\n\n- ### link 标签和 import 标签的区别\n\n参考回答：\n\nlink 属于 html 标签，而@import 是 css 提供的\n\n页面被加载时，link 会同时被加载，而@import 引用的 css 会等到页面加载结束后加载。\n\nlink 是 html 标签，因此没有兼容性，而@import 只有 IE5 以上才能识别。link 方式样式的权重高于@import 的。\n\n- ### transition 和 animation 的区别\n\n参考回答：\n\nAnimation 和 transition 大部分属性是相同的，他们都是随时间改变元素的属性值， 他们的主要区别是 transition 需要触发一个事件才能改变属性，而 animation\n不需要触发任何事件的情况下才会随时间改变属性值，并且 transition 为 2 帧，从\n\nfrom to，而 animation 可以一帧一帧的。\n\n- ### Flex 布局\n\n参考回答： 文章链接：\n\n[_http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool_](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool%EF%BC%88%E8%AF%AD%E6%B3%95%E7%AF%87%EF%BC%89)\n\n[_（语法篇）_](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool%EF%BC%88%E8%AF%AD%E6%B3%95%E7%AF%87%EF%BC%89)\n\n[_http://www.ruanyifeng.com/blog/2015/07/flex-examples.html（实例篇）_](http://www.ruanyifeng.com/blog/2015/07/flex-examples.html%EF%BC%88%E5%AE%9E%E4%BE%8B%E7%AF%87%EF%BC%89)Flex\n是\n\nFlexible Box 的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。\n\n布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。\n\n简单的分为容器属性和元素属性容器的属性：\n\nflex-direction：决定主轴的方向（即子 item 的排列方法）\n\n.box {\n\nflex-direction: row \\| row-reverse \\| column \\| column-reverse;\n\n}\n\nflex-wrap：决定换行规则\n\n.box{\n\nflex-wrap: nowrap \\| wrap \\| wrap-reverse;\n\n}\n\nflex-flow：\n\n.box {\n\nflex-flow: \\<flex-direction> \\|\\| \\<flex-wrap>;\n\n}\n\njustify-content：对其方式，水平主轴对齐方式align-items：对齐方式，竖直轴线方向\n\n项目的属性（元素的属性）：\n\norder 属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为 0 flex-grow 属性：定义项目的放大比例，即使存在空间，也不会放大\n\nflex-shrink 属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果定义个 item 的 flow-shrink 为 0，则为不缩小\n\nflex-basis 属性：定义了在分配多余的空间，项目占据的空间。\n\nflex：是 flex-grow 和 flex-shrink、flex-basis 的简写，默认值为 0 1 auto。align-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖\nalign-items，默认属性为 auto，表示继承父元素的 align-items\n\n比如说，用 flex 实现圣杯布局\n\n- ### BFC（块级格式化上下文，用于清楚浮动，防止 margin 重叠等）\n\n参考回答：\n\n直译成：块级格式化上下文，是一个独立的渲染区域，并且有一定的布局规则。BFC 区域不会与 float box 重叠\n\nBFC 是页面上的一个独立容器，子元素不会影响到外面计算 BFC 的高度时，浮动元素也会参与计算\n\n那些元素会生成 BFC：\n\n根元素\n\nfloat 不为 none 的元素\n\nposition 为 fixed 和 absolute 的元素\n\ndisplay 为 inline-block、table-cell、table-caption，flex，inline-flex 的元素overflow 不为 visible 的元素\n\n- ### 垂直居中的方法\n\n参 考 回 答 ： (1)margin:auto 法css:\n\n### div{\n\n> width: 400px; height: 400px; position: relative;\n\n> border: 1px solid #465468;\n\n> } img{\n\n> position: absolute; margin: auto;\n\n> top: 0; left: 0; right: 0; bottom: 0;\n\n> } html:\n\n> <div>\n\n> <img src=\"mm.jpg\">\n\n> </div>\n\n定位为上下左右为 0，margin：0 可以实现脱离文档流的居中. (2)margin 负值法\n\n### .container{ width: 500px; height: 400px\n\n> border: 2px solid #379; position: relative;\n\n> }\n\n> .inner{ width: 480px;\n\n> height: 380px; background-color: #746; position: absolute; top: 50%;\n\n> left: 50%;\n\nmargin-top: -190px; /\\*height 的一半\\*/ margin-left: -240px; /\\*width 的一半\\*/\n\n}\n\n补充：其实这里也可以将 marin-top 和 margin-left 负值替换成， transform：translateX(-50%) 和 transform：translateY(-50%)\n(3)table-cell（未脱离文档流的）\n\n设置父元素的 display:table-cell,并且 vertical-align:middle，这样子元素可以实现垂直居中。\n\n### css: div{\n\n> width: 300px; height: 300px;\n\n> border: 3px solid #555; display: table-cell; vertical-align: middle; text-align: center;\n\n> } img{\n\n> vertical-align: middle;\n\n> }\n\n4. 利用 flex\n\n将父元素设置为 display:flex，并且设置 align-items:center;justify- content:center;\n\n- ### 关于 JS 动画和 css3 动画的差异性\n\n参考回答：\n\n渲染线程分为 main thread 和 compositor thread，如果 css 动画只改变 transform 和opacity，这时整个 CSS 动画得以在 compositor\ntrhead 完成（而 JS 动画则会在 main thread 执行，然后出发 compositor thread 进行下一步操作），特别注意的是如果改变 transform 和 opacity\n是不会 layout 或者 paint 的。\n\n区别：\n\n功能涵盖面，JS 比 CSS 大\n\n实现/重构难度不一，CSS3 比 JS 更加简单，性能跳优方向固定对帧速表现不好的低版本浏览器，css3 可以做到自然降级\n\ncss 动画有天然事件支持css3 有兼容性问题\n\n- ### 说一下块元素和行元素\n\n参考回答：\n\n块元素：独占一行，并且有自动填满父元素，可以设置 margin 和 pading 以及高度和宽度\n\n行元素：不会独占一行，width 和 height 会失效，并且在垂直方向的 padding 和\n\nmargin 会失效。\n\n- ### 多行元素的文本省略号\n\n参考回答：\n\n- ### visibility=hidden, opacity=0，display:none\n\n参考回答：\n\nopacity=0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如 click 事件，那么点击该区域，也能触发点击事件的 visibility=hidden，\n该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件display=none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样。\n\n- ### 双边距重叠问题（外边距折叠）\n\n参考回答：\n\n多个相邻（兄弟或者父子关系）普通流的块元素垂直方向 marigin 会重叠折叠的结果为：\n\n两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。\n\n- ### position 属性 比较\n\n参考回答：\n\n固定定位 fixed：\n\n元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重\n\n叠。\n\n相对定位 relative：\n\n如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。\n在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 绝对定位 absolute：\n\n绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素， 那么它的位置相对于\\<html>。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute\n定位的元素和其他元素重叠。\n\n粘性定位 sticky：\n\n元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和containing\nblock（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。\n\n默认定位 Static：\n\n默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者z-index 声明）。\n\ninherit:\n\n规定应该从父元素继承 position 属性的值。\n\n- ### 浮动清除\n\n参考回答：\n\n方法一：使用带 clear 属性的空元素\n\n在浮动元素后使用一个空元素如\\<div class=\"clear\">\\</div>，并在 CSS 中赋\n\n予.clear{clear:both;}属性即可清理浮动。亦可使用\\<br class=\"clear\" />或\\<hr class=\"clear\" />来进行清理。\n\n方法二：使用 CSS 的 overflow 属性\n\n给浮动元素的容器添加 overflow:hidden;或 overflow:auto;可以清除浮动，另外在IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。\n\n在添加 overflow 属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。\n\n方法三：给浮动的元素的容器添加浮动\n\n给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动， 影响布局，不推荐使用。\n\n方法四：使用邻接元素处理\n\n什么都不做，给浮动元素后面的元素添加 clear 属性。方法五：使用 CSS 的:after 伪元素\n\n结合:after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素） 和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发hasLayout。\n\n给浮动元素的容器添加一个 clearfix 的 class，然后给这个 class 添加一个:after 伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。\n\n参考\n[_https://www.cnblogs.com/ForEvErNoME/p/3383539.html_](https://www.cnblogs.com/ForEvErNoME/p/3383539.html)\n\n- ### css3 新特性\n\n参考回答：\n\n开放题。CSS3 边框如 border-radius，box-shadow 等；CSS3 背景如 background- size，background-origin 等；CSS3 2D，3D 转换如\ntransform 等；CSS3 动画如animation 等。\n\n参考 [_https://www.cnblogs.com/xkweb/p/5862612.html_](https://www.cnblogs.com/xkweb/p/5862612.html)\n\n- ### CSS 选择器有哪些，优先级呢\n\n参考回答：\n\nid 选择器，class 选择器，标签选择器，伪元素选择器，伪类选择器等\n\n同一元素引用了多个样式时，排在后面的样式属性的优先级高；\n\n样式选择器的类型不同时，优先级顺序为：id 选择器 \\> class 选择器 \\> 标签选择器；\n\n标签之间存在层级包含关系时，后代元素会继承祖先元素的样式。如果后代元素定义了与祖先元素相同的样式，则祖先元素的相同的样式属性会被覆盖。继承的样式的优先级比较低，至少比标签选择器的优先级低；\n\n带有!important 标记的样式属性的优先级最高；\n\n样式表的来源不同时，优先级顺序为：内联样式> 内部样式 \\> 外部样式 \\> 浏览器用户自定义样式 \\> 浏览器默认样式\n\n- ### 清除浮动的方法，能讲讲吗\n\n参考回答：\n\n方法一：使用带 clear 属性的空元素\n\n在浮动元素后使用一个空元素如\\<div class=\"clear\">\\</div>，并在 CSS 中赋\n\n予.clear{clear:both;}属性即可清理浮动。亦可使用\\<br class=\"clear\" />或\\<hr class=\"clear\" />来进行清理。\n\n方法二：使用 CSS 的 overflow 属性\n\n给浮动元素的容器添加 overflow:hidden;或 overflow:auto;可以清除浮动，另外在IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。\n\n在添加 overflow 属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。\n\n方法三：给浮动的元素的容器添加浮动\n\n给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动， 影响布局，不推荐使用。\n\n方法四：使用邻接元素处理\n\n什么都不做，给浮动元素后面的元素添加 clear 属性。方法五：使用 CSS 的:after 伪元素\n\n结合:after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素） 和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发hasLayout。\n\n给浮动元素的容器添加一个 clearfix 的 class，然后给这个 class 添加一个:after 伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。\n\n参考\n[_https://www.cnblogs.com/ForEvErNoME/p/3383539.html_](https://www.cnblogs.com/ForEvErNoME/p/3383539.html)\n\n- ### 怎么样让一个元素消失，讲讲\n\n参考回答：\n\ndisplay:none; visibility:hidden; opacity: 0; 等等\n\n- ### 介绍一下盒模型\n\n参考回答：\n\nCSS 盒模型本质上是一个盒子，封装周围的 HTML 元素，它包括：边距，边框，填充， 和实际内容。\n\n标准盒模型：一个块的总宽度=width+margin(左右)+padding(左右)+border(左右) 怪异盒模型：一个块的总宽度=width+margin（左右）（既 width 已经包含了\npadding 和 border 值）\n\n设置盒模型：box-sizing:border-box\n\n- ### position 相关属性\n\n参考回答：\n\n固定定位 fixed：\n\n元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重\n\n叠。\n\n相对定位 relative：\n\n如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。\n在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 绝对定位 absolute：\n\n绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素， 那么它的位置相对于\\<html>。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute\n定位的元素和其他元素重叠。\n\n粘性定位 sticky：\n\n元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和containing\nblock（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。\n\n默认定位 Static：\n\n默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者z-index 声明）。\n\ninherit:\n\n规定应该从父元素继承 position 属性的值。\n\n- ### css 动画如何实现\n\n参考回答：\n\n创建动画序列，需要使用 animation 属性或其子属性，该属性允许配置动画时间、时长以及其他动画细节，但该属性不能配置动画的实际表现，动画的实际表现是\n\n由 @keyframes 规则实现，具体情况参见使用 keyframes 定义动画序列小节部分。transition 也可实现动画。transition\n强调过渡，是元素的一个或多个属性发生变化时产生的过渡效果，同一个元素通过两个不同的途径获取样式，而第二个途径当某种改变发生（例如 hover）时才能获取样式，这样就会产生过渡动画。\n\n- ### 如何实现图片在某个容器中居中的？\n\n参考回答：\n\n父元素固定宽高，利用定位及设置子元素 margin 值为自身的一半。\n\n父元素固定宽高，子元素设置 position: absolute，margin：auto 平均分配 margin css3 属 性 transform 。 子 元 素 设 置 position:\nabsolute; left: 50%; top: 50%;transform: translate(-50%,-50%);即可。\n\n将父元素设置成 display: table, 子元素设置为单元格 display: table-cell。\n\n弹性布局 display: flex。设置 align-items: center; justify-content: center\n\n- ### 如何实现元素的垂直居中\n\n参考回答：\n\n法一：父元素 display:flex,align-items:center;\n\n法二：元素绝对定位，top:50%，margin-top：-（高度/2）\n\n法三：高度不确定用 transform：translateY（-50%）\n\n法四：父元素 table 布局，子元素设置 vertical-align:center;\n\n- ### CSS3 中对溢出的处理\n\n参考回答： cnkOhu\n\ntext-overflow 属性，值为 clip 是修剪文本；ellipsis 为显示省略符号来表被修剪的文本；string 为使用给定的字符串来代表被修剪的文本。\n\n- ### float 的元素，display 是什么\n\n参 考 回 答 ： display 为 block\n\n- ### 隐藏页面中某个元素的方法\n\n参考回答：\n\ndisplay:none; visibility:hidden; opacity: 0; position 移到外部，z-index 涂层遮盖等等\n\n- ### 三栏布局的实现方式，尽可能多写，浮动布局时，三个 div 的生成顺序有没有影响\n\n参考回答：\n\n三列布局又分为两种，两列定宽一列自适应，以及两侧定宽中间自适应两列定宽一列自适应：\n\n1、使用 float+margin：\n\n给 div 设置 float：left，left 的 div 添加属性 margin-right：left 和 center 的间隔 px,right 的 div 添加属性\nmargin-left：left 和 center 的宽度之和加上间隔\n\n2、使用 float+overflow：\n\n给 div 设置 float：left，再给 right 的 div 设置 overflow:hidden。这样子两个盒子浮动，另一个盒子触发 bfc 达到自适应\n\n3、使用 position：\n\n父级 div 设置 position：relative，三个子级 div 设置 position：absolute，这个要计算好盒子的宽度和间隔去设置位置，兼容性比较好，\n\n4、使用 table 实现：\n\n父级 div 设置 display：table，设置 border-spacing：10px//设置间距，取值随意, 子级 div 设置\ndisplay:table-cell，这种方法兼容性好，适用于高度宽度未知的情况，但是 margin 失效，设计间隔比较麻烦，\n\n5、flex 实现：\n\nparent 的 div 设置 display：flex；left 和 center 的 div 设置 margin-right；然后right 的 div 设置 flex：1；这样子 right\n自适应，但是 flex 的兼容性不好\n\n6、grid 实现：\n\nparent 的 div 设置 display：grid，设置 grid-template-columns 属性，固定第一列第二列宽度，第三列 auto，\n\n对于两侧定宽中间自适应的布局，对于这种布局需要把 center 放在前面，可以采用双飞翼布局：圣杯布局，来实现，也可以使用上述方法中的 grid，table，flex， position 实现\n\n- ### 什么是 BFC\n\n参考回答：\n\nBFC 也就是常说的块格式化上下文，这是一个独立的渲染区域，规定了内部如何布局， 并且这个区域的子元素不会影响到外面的元素，其中比较重要的布局规则有内部 box 垂直放置，计算 BFC\n的高度的时候，浮动元素也参与计算，触发 BFC 的规则有根元\n\n素，浮动元素，position 为 absolute 或 fixed 的元素，display 为 inline-block，\ntable-cell，table-caption，flex，inline-flex，overflow 不为 visible 的元素\n\n- ### calc 属性\n\n参考回答：\n\nCalc 用户动态计算长度值，任何长度值都可以使用 calc()函数计算，需要注意的是， 运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；\n\n- ### 有一个 width300，height300，怎么实现在屏幕上垂直水平居中\n\n参考回答：\n\n对于行内块级元素，\n\n1、父级元素设置 text-alig：center，然后设置 line-height 和 vertical-align 使其垂直居中，最后设置 font-size：0 消除近似居中的 bug\n\n2、父级元素设置 display：table-cell，vertical-align：middle 达到水平垂直居中3、采用绝对定位，原理是子绝父相，父元素设置\nposition：relative，子元素设置position：absolute，然后通过 transform 或 margin 组合使用达到垂直居中效果，设置\ntop：50%，left：50%，transform：translate（-50%，-50%）\n\n4、绝对居中，原理是当 top,bottom 为 0 时，margin-top&bottom 设置 auto 的话会无限延伸沾满空间并平分，当 left，right 为 0\n时,margin-left&right 设置 auto 会无限延伸占满空间并平分，\n\n5、采用 flex，父元素设置 display：flex，子元素设置 margin：auto\n\n6、视窗居中，vh 为视口单位，50vh 即是视口高度的 50/100，设置 margin：50vh auto 0，transform：translate(-50%)\n\n- ### display：table 和本身的 table 有什么区别\n\n参考回答：\n\nDisplay:table 和本身 table 是相对应的，区别在于，display：table 的 css 声明能够让一个 html 元素和它的子节点像 table 元素一样，使用基于表格的 css\n布局，是我们能够轻松定义一个单元格的边界，背景等样式，而不会产生因为使用了 table 那样的制表标签导致的语义化问题。\n\n之所以现在逐渐淘汰了 table 系表格元素，是因为用 div+css 编写出来的文件比用table 边写出来的文件小，而且 table 必须在页面完全加载后才显示，div 则是逐行显示，table\n的嵌套性太多，没有 div 简洁\n\n- ### position 属性的值有哪些及其区别\n\n参考回答：\n\nPosition 属性把元素放置在一个静态的，相对的，绝对的，固定的位置中， Static：位置设置为 static 的元素，他始终处于页面流给予的位置，static 元素会忽略任何\ntop,buttom,left,right 声明\n\nRelative：位置设置为 relative 的元素，可将其移至相对于其正常位置的地方，因此\n\nleft：20 会将元素移至元素正常位置左边 20 个像素的位置\n\nAbsolute：此元素可定位于相对包含他的元素的指定坐标，此元素可通过 left，top\n\n等属性规定\n\nFixed：位置被设为 fiexd 的元素，可定为与相对浏览器窗口的指定坐标，可以通过\n\nleft，top，right 属性来定位\n\n- ### z-index 的定位方法\n\n参考回答：\n\n26. index 属性设置元素的堆叠顺序，拥有更好堆叠顺序的元素会处于较低顺序元素之前，z-index 可以为负，且z-index 只能在定位元素上奏效，该属性设置一个定位元素沿z\n    轴的位置，如果为正数，离用户越近，为负数，离用户越远，它的属性值有auto，默认，堆叠顺序与父元素相等，number，inherit，从父元素继承 z-index 属性的值\n\n- ### 如果想要改变一个 DOM 元素的字体颜色，不在它本身上进行操作？\n\n参考回答：\n\n可以更改父元素的 color\n\n- ### 对 CSS 的新属性有了解过的吗？\n\n参考回答：\n\nCSS3 的新特性中，在布局方面新增了 flex 布局，在选择器方面新增了例如 first-of- type,nth-child 等选择器，在盒模型方面添加了box-sizing\n来改变盒模型，在动画方面增加了 animation，2d 变换，3d 变换等，在颜色方面添加透明，rbga 等，在字体方面允许嵌入字体和设置字体阴影，最后还有媒体查讯等\n\n- ### 用的最多的 css 属性是啥？\n\n参考回答：\n\n用的目前来说最多的是 flex 属性，灵活但是兼容性方面不强。\n\n- ### line-height 和 height 的区别\n\n参考回答：\n\nline-height 一般是指布局里面一段文字上下行之间的高度，是针对字体来设置的，\n\nheight 一般是指容器的整体高度。\n\n- ### 设置一个元素的背景颜色，背景颜色会填充哪些区域？\n\n参考回答：\n\nbackground-color 设置的背景颜色会填充元素的content、padding、border 区域。\n\n- ### 知道属性选择器和伪类选择器的优先级吗\n\n参考回答：\n\n属性选择器和伪类选择器优先级相同\n\n- ### inline-block、inline 和 block 的区别；为什么 img 是 inline 还可以设置宽高\n\n参考回答：\n\nBlock 是块级元素，其前后都会有换行符，能设置宽度，高度，margin/padding 水平垂直方向都有效。\n\nInline：设置 width 和 height 无效，margin 在竖直方向上无效，padding 在水平方向垂直方向都有效，前后无换行符\n\nInline-block：能设置宽度高度，margin/padding 水平垂直方向 都有效，前后无换行符\n\n- ### 用 css 实现一个硬币旋转的效果\n\n参考回答：\n\n虽然不认为很多人能在面试中写出来\n\n### #euro { width: 150px\n\n> height: 150px; margin-left: -75px; margin-top: -75px; position: absolute; top: 50%;\n\n> left: 50%;\n\n> transform-style: preserve-3d; animation: spin 2.5s linear infinite;\n\n> }\n\n> .back {\n\n> background-image: url(\"/uploads/160101/backeuro.png\"); width: 150px;\n\n> height: 150px;\n\n> }\n\n> .middle {\n\n> background-image: url(\"/uploads/160101/faceeuro.png\"); width: 150px;\n\n> height: 150px;\n\n> transform: translateZ(1px); position: absolute;\n\n> top: 0;\n\n> }\n\n> .front {\n\n> background-image: url(\"/uploads/160101/faceeuro.png\"); height: 150px;\n\n> position: absolute; top: 0;\n\n> transform: translateZ(10px); width: 150px;\n\n> }\n\n> @keyframes spin { 0% {\n\n> transform: rotateY(0deg);\n\n> }\n\n> 100% {\n\n> transform: rotateY(360deg);\n\n> }\n\n> }\n\n- ### 了解重绘和重排吗，知道怎么去减少重绘和重排吗，让文档脱离文档流有哪些方法\n\n参考回答：\n\nDOM 的变化影响到了预算内宿的几何属性比如宽高，浏览器重新计算元素的几何属性， 其他元素的几何属性也会受到影响，浏览器需要重新构造渲染书，这个过程称之为重排，浏览器将受到影响的部分重新绘制在屏幕上\n的过程称为重绘，引起重排重绘的原因有：\n\n添加或者删除可见的 DOM 元素， 元素尺寸位置的改变\n\n浏览器页面初始化，\n\n浏览器窗口大小发生改变，重排一定导致重绘，重绘不一定导致重排， 减少重绘重排的方法有：\n\n不在布局信息改变时做 DOM 查询，\n\n使用 csstext,className 一次性改变属性使用 fragment\n\n对于多次重排的元素，比如说动画。使用绝对定位脱离文档流，使其不影响其他元素\n\n- ### CSS 画正方体，三角形\n\n参考回答： 画三角形\n\n### #triangle02{ width: 0; height: 0\n\n> border-top: 50px solid blue; border-right: 50px solid red; border-bottom: 50px solid green;\n> border-left: 50px solid yellow;\n\n> }\n\n画正方体：\n\n### <!DOCTYPE html>\n\n> <html lang=\"en\">\n\n> <head>\n\n> <meta charset=\"UTF-8\">\n\n> <title>perspective\\</title>\n\n> <style>\n\n> .wrapper{ width: 50%; float: left;\n\n> }\n\n> .cube{\n\n> font-size: 4em; width: 2em;\n\n> margin: 1.5em auto; transform-style:preserve-3d;\n\n> transform:rotateX(-35deg) rotateY(30deg);\n\n> }\n\n> .side{\n\n> position: absolute; width: 2em;\n\n> height: 2em;\n\n> background: rgba(255,99,71,0.6); border: 1px solid rgba(0,0,0,0.5); color: white;\n\n> text-align: center; line-height: 2em;\n\n> }\n\n> .front{ transform:translateZ(1em);\n\n> }\n\n> .bottom{\n\n> transform:rotateX(-90deg) translateZ(1em);\n\n> }\n\n> .top{\n\n> transform:rotateX(90deg) translateZ(1em);\n\n> }\n\n> .left{\n\n> transform:rotateY(-90deg) translateZ(1em);\n\n> }\n\n> .right{\n\n> transform:rotateY(90deg) translateZ(1em);\n\n> }\n\n> .back{ transform:translateZ(-1em);\n\n> }\n\n> </style>\n\n> </head>\n\n> <body>\n\n> <div class=\"wrapper w1\">\n\n> <div class=\"cube\">\n\n> <div class=\"side front\">1\\</div>\n\n> <div class=\"side back\">6\\</div>\n\n> <div class=\"side right\">4\\</div>\n\n> <div class=\"side left\">3\\</div>\n\n> <div class=\"side top\">5\\</div>\n\n> <div class=\"side bottom\">2\\</div>\n\n> </div>\n\n> </div>\n\n> <div class=\"wrapper w2\">\n\n> <div class=\"cube\">\n\n> <div class=\"side front\">1\\</div>\n\n> <div class=\"side back\">6\\</div>\n\n> <div class=\"side right\">4\\</div>\n\n> <div class=\"side left\">3\\</div>\n\n> <div class=\"side top\">5\\</div>\n\n> <div class=\"side bottom\">2\\</div>\n\n> </div>\n\n> </div>\n\n> </body>\n\n> </html>\n\n- ### overflow 的原理\n\n参考回答：\n\n要讲清楚这个解决方案的原理，首先需要了解块格式化上下文，A block formatting context is a part of a visual CSS rendering of a Web\npage. It is the region in which the layout of block boxes occurs and in which floats interact with\neach other.翻译过来就是块格式化上下文是 CSS 可视化渲染的一部分，它是一块区域，规定了内部块盒 的渲染方式，以及浮动相互之间的影响关系\n\n当元素设置了 overflow 样式且值部位 visible 时，该元素就构建了一个 BFC，BFC 在计算高度时，内部浮动元素的高度也要计算在内，也就是说技术 BFC 区域内只有一个浮动元素，BFC\n的高度也不会发生塌缩，所以达到了清除浮动的目的。\n\n- ### 清除浮动的方法\n\n参考回答：\n\n给要清除浮动的元素添加样式 clear，\\\\\n\n父元素结束标签钱插入清除浮动的块级元素，给该元素添加样式 clear\n\n添加伪元素，在父级元素的最后，添加一个伪元素，通过清除伪元素的浮动，注意该伪元素的 display 为 block，\n\n父元素添加样式 overflow 清除浮动，overflow 设置除 visible 以外的任何位置\n\n- ### box-sizing 的语法和基本用处\n\n参考回答：\n\nbox-sizing 规定两个并排的带边框的框，语法为box-sizing：content-box/border- box/inherit\n\ncontent-box：宽度和高度分别应用到元素的内容框，在宽度和高度之外绘制元素的内边距和边框\n\nborder-box：为元素设定的宽度和高度决定了元素的边框盒， inherit：继承父元素的 box-sizing\n\n- ### 使元素消失的方法有哪些？\n\n参考回答：\n\n1. opacity：0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如 click 事件，那么点击该区域，也能触发点击事件的\n\n2. visibility：hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件\n\n3. display：none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉。\n\n- ### 两个嵌套的 div，position 都是 absolute，子 div 设置 top 属性，那么这个 top 是相对于父元素的哪个位置定位的\n\n参 考 回 答 ： margin 的外边缘\n\n- ### 说说盒子模型\n\n参考回答：\n\nCSS 盒模型本质上是一个盒子，封装周围的 HTML 元素，它包括：边距，边框，填充， 和实际内容。\n\n标准盒模型：一个块的总宽度=width+margin(左右)+padding(左右)+border(左右) 怪异盒模型：一个块的总宽度=width+margin（左右）（既 width 已经包含了\npadding 和 border 值）\n\n如何设置：box-sizing:border-box\n\n- ### display\n\n参考回答：\n\n主要取值有 none,block,inline-block,inline,flex 等。具体可参考\n\n[_https://developer.mozilla.org/zh-CN/docs/Web/CSS/display_](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display)\n\n- ### 怎么隐藏一个元素\n\n参考回答：\n\n1. opacity：0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如 click 事件，那么点击该区域，也能触发点击事件的\n\n2. visibility：hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件\n\n3. display：none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉。\n\n- ### display:none 和 visibilty:hidden 的区别\n\n参考回答：\n\n1. visibility：hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件\n\n2. display：none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉。\n\n- ### 相对布局和绝对布局，position:relative 和 obsolute\n\n参考回答：\n\n相对定位 relative：\n\n如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。\n在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 绝对定位 absolute：\n\n绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素， 那么它的位置相对于\\<html>。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute\n定位的元素和其他元素重叠。\n\n- ### flex 布局\n\n参考回答：\n\nflex 是 Flexible Box 的缩写，意为\"弹性布局\"。指定容器 display: flex\n即可。容器有以下属性：flex-direction，flex-wrap，flex-flow，justify-content， align-items，align-content。\n\nflex-direction 属性决定主轴的方向；\n\nflex-wrap 属性定义，如果一条轴线排不下，如何换行；\n\nflex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap；\n\njustify-content 属性定义了项目在主轴上的对齐方式。align-items 属性定义项目在交叉轴上如何对齐。\n\nalign-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n\n项目（子元素）也有一些属性：order，flex-grow，flex-shrink，flex-basis，\n\nflex，align-self。\n\norder 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。\n\nflex-grow 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。\n\nflex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为\n0 1 auto。后两个属性可选。\n\nalign-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于\nstretch。\n\n参考\n[_http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html_](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)\n\n- ### block、inline、inline-block 的区别\n\n参考回答：\n\nblock 元素会独占一行，多个 block 元素会各自新起一行。默认情况下，block 元素宽度自动填满其父元素宽度。\n\nblock 元素可以设置 width,height 属性。块级元素即使设置了宽度,仍然是独占一行。block 元素可以设置 margin 和 padding 属性。\n\ninline 元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。\n\ninline 元素设置 width,height 属性无效。\n\ninline 元素的 margin 和 padding 属性，水平方向的 padding-left, padding-right, margin-left, margin-right\n都产生边距效果；但竖直方向的 padding-top, padding- bottom, margin-top, margin-bottom 不会产生边距效果。\n\ninline-block：简单来说就是将对象呈现为 inline 对象，但是对象的内容作为 block\n\n对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个 link（a 元\n\n素）inline-block 属性值，使其既具有 block 的宽度高度特性又具有 inline 的同行特性。\n\n- ### css 的常用选择器\n\n参考回答：\n\nid 选择器，类选择器，伪类选择器等\n\n- ### css 布局\n\n参考回答：\n\n六种布局方式总结：圣杯布局、双飞翼布局、Flex 布局、绝对定位布局、表格布局、网格布局。\n\n圣杯布局是指布局从上到下分为 header、container、footer，然后 container 部分定为三栏布局。这种布局方式同样分为\nheader、container、footer。圣杯布局的缺陷在于 center 是在 container 的 padding 中的，因此宽度小的时候会出现混乱。\n\n双飞翼布局给 center 部分包裹了一个 main 通过设置 margin 主动地把页面撑开。Flex 布局是由 CSS3 提供的一种方便的布局方式。\n\n绝对定位布局是给 container 设置 position: relative 和 overflow: hidden，因为绝对定位的元素的参照物为第一个 postion 不为 static\n的祖先元素。 left 向左浮动，right 向右浮动。center 使用绝对定位，通过设置 left 和 right 并把两边撑开。 center 设置 top: 0 和 bottom: 0\n使其高度撑开。\n\n表格布局的好处是能使三栏的高度统一。\n\n网格布局可能是最强大的布局方式了，使用起来极其方便，但目前而言，兼容性并不好。网格布局，可以将页面分割成多个区域，或者用来定义内部元素的大小，位置， 图层关系。\n\n- ### css 定位\n\n参考回答：\n\n固定定位 fixed：\n\n元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重\n\n叠。\n\n相对定位 relative：\n\n如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。\n在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 绝对定位 absolute：\n\n绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素， 那么它的位置相对于\\<html>。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute\n定位的元素和其他元素重叠。\n\n粘性定位 sticky：\n\n元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和containing\nblock（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。\n\n默认定位 Static：\n\n默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者z-index 声明）。\n\ninherit:\n\n规定应该从父元素继承 position 属性的值。\n\n- ### relative 定位规则\n\n参考回答：\n\n如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。\n在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。\n\n- ### 垂直居中\n\n参考回答：\n\n父元素固定宽高，利用定位及设置子元素 margin 值为自身的一半。\n\n父元素固定宽高，子元素设置 position: absolute，margin：auto 平均分配 margin css3 属 性 transform 。 子 元 素 设 置 position:\nabsolute; left: 50%; top: 50%;transform: translate(-50%,-50%);即可。\n\n将父元素设置成 display: table, 子元素设置为单元格 display: table-cell。\n\n弹性布局 display: flex。设置 align-items: center; justify-content: center;\n\n- ### css 预处理器有什么\n\n参考回答： less，sass 等\n\n3. ## | JavaScript\n\n- ### get 请求传参长度的误区\n\n参考回答：\n\n误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。\n\n实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或 web 服务器，浏览器或 web 服务器限制了 url\n的长度。为了明确这个概念，我们必须再次强调下面几点:\n\nHTTP 协议 未规定 GET 和 POST 的长度限制\n\nGET 的最大长度显示是因为 浏览器和 web 服务器限制了 URI 的长度不同的浏览器和 WEB 服务器，限制的最大长度不一样\n\n要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte\n\n- ### 补充 get 和 post 请求在缓存方面的区别\n\n参考回答：\n\npost/get 的请求区别，具体不再赘述。\n\n补充补充一个 get 和 post 在缓存方面的区别：\n\nget 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。\n\npost 不同，post 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此 get 请求适合于请求缓存。\n\n- ### 说一下闭包\n\n参考回答：\n\n一句话可以概括：闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放。\n\n- ### 说一下类的创建和继承\n\n参考回答：\n\n1. 类的创建（es5）：new 一个 function，在这个 function 的 prototype 里面增加属性和方法。\n\n下面来创建一个 Animal 类：\n\n// 定义一个动物类function Animal (name) {\n\n// 属性\n\nthis.name = name \\|\\| 'Animal';\n\n// 实例方法\n\nthis.sleep = function(){ console.log(this.name + '正在睡觉！');\n\n}\n\n}\n\n// 原型方法\n\nAnimal.prototype.eat = function(food) { console.log(this.name + '正在吃：' + food);\n\n};\n\n这样就生成了一个 Animal 类，实力化生成对象后，有方法和属性。\n\n2. 类的继承——原型链继承\n\n--原型链继承\n\n### function Cat(){ } Cat.prototype = new Animal(); Cat.prototype.name = 'cat'\n\n> // Test Code\n\n> var cat = new Cat(); console.log(cat.name); console.log(cat.eat('fish'));\n> console.log(cat.sleep());\n\n> console.log(cat instanceof Animal); //true console.log(cat instanceof Cat); //true\n\n介绍：在这里我们可以看到 new 了一个空对象,这个空对象指向 Animal 并且\n\nCat.prototype 指向了这个空对象，这种就是基于原型链的继承。特点：基于原型链，既是父类的实例，也是子类的实例\n\n缺点：无法实现多继承\n\n3. 构造继承：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）\n\n### function Cat(name){ Animal.call(this); this.name = name \\|\\| 'Tom'\n\n> }\n\n> // Test Code\n\n> var cat = new Cat(); console.log(cat.name); console.log(cat.sleep());\n\n> console.log(cat instanceof Animal); // false console.log(cat instanceof Cat); // true\n\n特点：可以实现多继承\n\n缺点：只能继承父类实例的属性和方法，不能继承原型上的属性和方法。\n\n4. 实例继承和拷贝继承\n\n实例继承：为父类实例添加新特性，作为子类实例返回拷贝继承：拷贝父类元素上的属性和方法\n\n上述两个实用性不强，不一一举例。\n\n5. 组合继承：相当于构造继承和原型链继承的组合体。通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用function Cat(name){\n\n### Animal.call(this); this.name = name \\|\\| 'Tom'\n\n> }\n\n> Cat.prototype = new Animal(); Cat.prototype.constructor = Cat;\n\n> // Test Code\n\n> var cat = new Cat(); console.log(cat.name); console.log(cat.sleep());\n\n> console.log(cat instanceof Animal); // true console.log(cat instanceof Cat); // true\n\n特点：可以继承实例属性/方法，也可以继承原型属性/方法缺点：调用了两次父类构造函数，生成了两份实例\n\n6. 寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性\n\n### function Cat(name){ Animal.call(this); this.name = name \\|\\| 'Tom'\n\n> }\n\n> (function(){\n\n// 创建一个没有实例方法的类\n\n### var Super = function(){}; Super.prototype = Animal.prototype\n\n//将实例作为子类的原型\n\n### Cat.prototype = new Super()\n\n> })();\n\n> // Test Code\n\n> var cat = new Cat(); console.log(cat.name); console.log(cat.sleep());\n\n> console.log(cat instanceof Animal); // true console.log(cat instanceof Cat); //true\n\n较为推荐\n\n- ### 如何解决异步回调地狱\n\n参考回答：\n\n- ### 说说前端中的事件流\n\n参考回答：\n\nHTML 中与 javascript 交互是通过事件驱动来实现的，例如鼠标点击事件 onclick、页面的滚动事件 onscroll\n等等，可以向文档或者文档中的元素添加事件侦听器来预订事件。想要知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概\n\n念。\n\n什么是事件流：事件流描述的是从页面中接收事件的顺序,DOM2 级事件流包括下面几个阶段。\n\n事件捕获阶段处于目标阶段事件冒泡阶段\n\naddEventListener：addEventListener 是 DOM2 级事件新增的指定事件处理程序的操作，这个方法接收 3\n个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。\n\nIE 只支持事件冒泡。\n\n- ### 如何让事件先冒泡后捕获\n\n参考回答：\n\n在 DOM 标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间。\n\n- ### 说一下事件委托\n\n参考回答：\n\n简介：事件委托指的是，不在事件的发生地（直接 dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素 DOM\n的类型，来做出不同的响应。\n\n举例：最经典的就是 ul 和 li 标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在 li 标签上直接添加，而是在 ul 父元素上添加。\n\n好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。\n\n- ### 说一下图片的懒加载和预加载\n\n参考回答：\n\n预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。\n\n懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。\n\n两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。\n\n- ### mouseover 和 mouseenter 的区别\n\n参考回答：\n\nmouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是 mouseout\n\nmouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是 mouseleave\n\n- ### JS 的 new 操作符做了哪些事情\n\n参考回答：\n\nnew 操作符新建了一个空对象，这个对象原型指向构造函数的 prototype，执行构造函数后返回这个对象。\n\n- ### 改变函数内部 this 指针的指向函数（bind，apply，call 的区别）\n\n参考回答：\n\n通过 apply 和 call 改变函数的 this 指向，他们两个函数的第一个参数都是一样的表示要改变指向的那个对象，第二个参数，apply 是数组，而 call 则是\narg1,arg2...这种形式。通过 bind 改变 this 作用域会返回一个新的函数，这个函数不会马上执行。\n\n- ### JS 的各种位置，比如 clientHeight,scrollHeight,offsetHeight ,以及 scrollTop, offsetTop,clientTop 的区别？\n\n参考回答：\n\nclientHeight：表示的是可视区域的高度，不包含 border 和滚动条offsetHeight：表示可视区域的高度，包含了 border\n和滚动条scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分。clientTop：表示边框 border 的厚度，在未指定的情况下一般为 0\n\nscrollTop：滚动后被隐藏的高度，获取对象相对于由 offsetParent 属性指定的父坐标(css 定位的元素或 body 元素)距离顶端的高度。\n\n- ### JS 拖拽功能的实现\n\n参考回答：\n\n首先是三个事件，分别是 mousedown，mousemove，mouseup\n\n当鼠标点击按下的时候，需要一个 tag 标识此时已经按下，可以执行 mousemove 里面的具体方法。\n\nclientX，clientY 标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用\n\noffsetX 和 offsetY 来表示元素的元素的初始坐标，移动的举例应该是：\n\n鼠标移动时候的坐标-鼠标按下去时候的坐标。\n\n也就是说定位信息为：\n\n鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的 offetLeft.\n\n还有一点也是原理性的东西，也就是拖拽的同时是绝对定位，我们改变的是绝对定位条件下的 left\n\n以及 top 等等值。\n\n补充：也可以通过 html5 的拖放（Drag 和 drop）来实现\n\n- ### 异步加载 JS 的方法\n\n参考回答：\n\ndefer：只支持 IE 如果您的脚本不会改变文档的内容，可将 defer 属性加入到\n\n<script>标签中，以便加快处理文档的速度。因为浏览器知道它将能够安全地读取文档的剩余部分而不用执行脚本，它将推迟对脚本的解释，直到文档已经显示给用户为止。\n\nasync，HTML5 属性仅适用于外部脚本，并且如果在 IE 中，同时存在 defer 和 async， 那么 defer 的优先级比较高，脚本将在页面完成时执行。\n\n创建 script 标签，插入到 DOM 中\n\n- ### Ajax 解决浏览器缓存问题\n\n参考回答：\n\n在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(\"If-Modified- Since\",\"0\")。\n\n在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(\"Cache-Control\",\"no- cache\")。\n\n在 URL 后面加上一个随机数： \"fresh=\" + Math.random()。\n\n在 URL 后面加上时间搓：\"nowtime=\" + new Date().getTime()。\n\n如果是使用 jQuery，直接这样就可以了 \\$.ajaxSetup({cache:false})。这样页面的所有 ajax 都会执行这条语句就是不需要保存缓存记录。\n\n- ### JS 的节流和防抖\n\n参 考 回 答 ：\n[_http://www.cnblogs.com/coco1s/p/5499469.html_](http://www.cnblogs.com/coco1s/p/5499469.html)\n\n- ### JS 中的垃圾回收机制\n\n参考回答：\n\n必要性：由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript\n程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript\n的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。\n\n这段话解释了为什么需要系统需要垃圾回收，JS 不像 C/C++，他有自己的一套垃圾回收机制（Garbage Collection）。JavaScript\n的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。例如：\n\n### var a=\"hello world\"; var b=\"world\"\n\n> var a=b;\n\n//这时，会释放掉\"hello world\"，释放内存以便再引用\n\n垃圾回收的方法：标记清除、计数引用。标记清除\n\n这是最常见的垃圾回收方式，当变量进入环境时，就标记这个变量为”进入环境“,从逻辑上讲，永远不能释放进入环境的变量所占的内存，永远不能释放进入环境变量所占用的内存，只要执行流程进入相应的环境，就可能用到他们。当离开环境时，就标记为离开环境。\n\n垃圾回收器在运行的时候会给存储在内存中的变量都加上标记（所有都加），然后去掉环境变量中的变量，以及被环境变量中的变量所引用的变量（条件性去除标记），\n删除所有被标记的变量，删除的变量无法在环境变量中被访问所以会被删除，最后垃圾回收器，完成了内存的清除工作，并回收他们所占用的内存。\n\n引用计数法\n\n另一种不太常见的方法就是引用计数法，引用计数法的意思就是每个值没引用的次 数，当声明了一个变量，并用一个引用类型的值赋值给改变量，则这个值的引用次数为\n1,；相反的，如果包含了对这个值引用的变量又取得了另外一个值，则原先的引用\n\n值引用次数就减 1，当这个值的引用次数为 0 的时候，说明没有办法再访问这个值了， 因此就把所占的内存给回收进来，这样垃圾收集器再次运行的时候，就会释放引用次数为 0 的这些值。\n\n用引用计数法会存在内存泄露，下面来看原因：\n\n### function problem() {\n\n> var objA = new Object(); var objB = new Object();\n\n> objA.someOtherObject = objB; objB.anotherObject = objA;\n\n> }\n\n在这个例子里面，objA 和 objB 通过各自的属性相互引用，这样的话，两个对象的引用次数都为 2，在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，因为计数不为\n0，这样的相互引用如果大量存在就会导致内存泄露。\n\n特别是在 DOM 对象中，也容易存在这种问题：\n\n### var element=document.getElementById（’‘）； var myObj=new Object(); myObj.element=element; element.someObject=myObj\n\n这样就不会有垃圾回收的过程。\n\n- ### eval 是做什么的\n\n参考回答：\n\n它的功能是将对应的字符串解析成 JS 并执行，应该避免使用 JS，因为非常消耗性能\n\n（2 次，一次解析成 JS，一次执行）\n\n- ### 如何理解前端模块化\n\n参考回答：\n\n前端模块化就是复杂的文件编程一个一个独立的模块，比如 JS 文件等等，分成独立的模块有利于重用（复用性）和维护（版本迭代），这样会引来模块之间相互依赖的问题，所以有了 commonJS\n规范，AMD，CMD 规范等等，以及用于 JS 打包（编译等处理） 的工具webpack\n\n- ### 说一下 CommonJS、AMD 和 CMD\n\n参考回答：\n\n一个模块是能实现特定功能的文件，有了模块就可以方便的使用别人的代码，想要什么功能就能加载什么模块。\n\nCommonJS：开始于服务器端的模块化，同步定义的模块化，每个模块都是一个单独的作用域，模块输出，modules.exports，模块加载 require()引入模块。\nAMD：中文名异步模块定义的意思。\n\nrequireJS 实现了 AMD 规范，主要用于解决下述两个问题。\n\n1. 多个文件有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器\n\n2. 加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应的时间越长。语法：requireJS 定义了一个函数 define，它是全局变量，用来定义模块。requireJS 的例子：\n\n//定义模块\n\n### define(\\['dependency'\\], function(){ var name = 'Byron'\n\n> function printName(){ console.log(name);\n\n> }\n\n> return {\n\n> printName: printName\n\n> };\n\n> });\n\n//加载模块\n\n### require(\\['myModule'\\], function (my){ my.printName()\n\n> }\n\nRequireJS 定义了一个函数 define,它是全局变量，用来定义模块：\n\ndefine(id?dependencies?,factory) 在页面上使用模块加载函数： require(\\[dependencies\\],factory)；\n\n总结 AMD 规范：require（）函数在加载依赖函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块加载成功，才会去执行。\n\n因为网页在加载 JS 的时候会停止渲染，因此我们可以通过异步的方式去加载 JS,而如果需要依赖某些，也是异步去依赖，依赖后再执行某些方法。\n\n- ### 对象深度克隆的简单实现\n\n参考回答：\n\n### function deepClone(obj){\n\n> var newObj= obj instanceof Array ? \\[\\]:{}; for(var item in obj){\n\n> var temple= typeof obj\\[item\\] == 'object' ? deepClone(obj\\[item\\]):obj\\[item\\]; newObj\\[item\\] =\n> temple;\n\n> }\n\n> return newObj;\n\n> }\n\nES5 的常用的对象克隆的一种方式。注意数组是对象，但是跟对象又有一定区别，所以我们一开始判断了一些类型，决定 newObj 是对象还是数组。\n\n- ### 实现一个 once 函数，传入函数参数只执行一次\n\n参考回答：\n\n### function ones(func){ var tag=true\n\n> return function(){ if(tag==true){ func.apply(null,arguments); tag=false;\n\n> }\n\n> return undefined\n\n> }\n\n> }\n\n- ### 将原生的 ajax 封装成 promise\n\n参考回答：\n\n### var myNewAjax=function(url){\n\n> return new Promise(function(resolve,reject){\n\n> var xhr = new XMLHttpRequest(); xhr.open('get',url); xhr.send(data);\n> xhr.onreadystatechange=function(){ if(xhr.status==200&&readyState==4){\n\n> var json=JSON.parse(xhr.responseText); resolve(json)\n\n> }else if(xhr.readyState==4&&xhr.status!=200){ reject('error');\n\n> }\n\n> }\n\n> })\n\n> }\n\n- ### JS 监听对象属性的改变\n\n参考回答：\n\n我们假设这里有一个 user 对象,\n\n1. 在 ES5 中可以通过 Object.defineProperty 来实现已有属性的监听Object.defineProperty(user,'name',{\n   set：function(key,value){\n\n### }\n\n> })\n\n缺点：如果 id 不在 user 对象中，则不能监听 id 的变化(2)在 ES6 中可以通过 Proxy 来实现\n\n### var user = new Proxy({}，{ set：function(target,key,value,receiver){\n\n> }\n\n> })\n\n这样即使有属性在 user 中不存在，通过 user.id 来定义也同样可以这样监听这个属性的变化哦。\n\n- ### 如何实现一个私有变量，用 getName 方法可以访问，不能直接访问\n\n参考回答：\n\n1. 通过 defineProperty 来实现\n\n### obj={ name:yuxiaoliang, getName:function(){ return this.name\n\n> }\n\n> } object.defineProperty(obj,\"name\",{\n\n//不可枚举不可配置\n\n});\n\n2. 通过函数的创建形式\n\n### function product(){\n\n> var name='yuxiaoliang'; this.getName=function(){ return name;\n\n> }\n\n> }\n\n> var obj=new product();\n\n### • ==和===、以及 Object.is 的区别\n\n参考回答： (1) ==\n\n主要存在：强制转换成 number,null==undefined \" \"==0 //true\n\n\"0\"==0 //true \" \" !=\"0\" //true\n\n123==\"123\" //true null==undefined //true (2)Object.js\n\n主要的区别就是+0！=-0 而 NaN==NaN (相对比===和==的改进)\n\n- ### setTimeout、setInterval 和 requestAnimationFrame 之间的区别\n\n参考回答：\n\n这里有一篇文章讲的是 requestAnimationFrame：\n[_http://www.cnblogs.com/xiaohuochai/p/5777186.html_](http://www.cnblogs.com/xiaohuochai/p/5777186.html)\n\n与 setTimeout 和 setInterval 不同，requestAnimationFrame 不需要设置时间间隔， 大多数电脑显示器的刷新频率是 60Hz，大概相当于每秒钟重绘 60\n次。大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。因此，最平滑动画的最佳循环间隔是 1000ms/60，约等于 16.6ms。RAF\n采用的是系统时间间隔，不会因为前面的任务，不会影响 RAF，但是如果前面的任务多的话，\n\n会响应 setTimeout 和 setInterval 真正运行时的时间间隔。特点：\n\n1. requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。\n\n2. 在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量\n\n3. requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销。\n\n- ### 实现一个两列等高布局，讲讲思路\n\n参考回答：\n\n为了实现两列等高，可以给每列加上 padding-bottom:9999px; margin-bottom:-9999px;同时父元素设置 overflow:hidden;\n\n- ### 自己实现一个 bind 函数\n\n参考回答：\n\n原理：通过 apply 或者 call 方法来实现。(1)初始版本\n\n### Function.prototype.bind=function(obj,arg){\n\n> var arg=Array.prototype.slice.call(arguments,1); var context=this;\n\n> return function(newArg){ arg=arg.concat(Array.prototype.slice.call(newArg)); return\n> context.apply(obj,arg);\n\n> }\n\n> }\n\n2. 考虑到原型链\n\n为什么要考虑？因为在 new 一个 bind 过生成的新函数的时候，必须的条件是要继承原函数的原型\n\n### Function.prototype.bind=function(obj,arg){\n\n> var arg=Array.prototype.slice.call(arguments,1); var context=this;\n\n> var bound=function(newArg){ arg=arg.concat(Array.prototype.slice.call(newArg)); return\n> context.apply(obj,arg);\n\n> }\n\n> var F=function(){}\n\n> //这里需要一个寄生组合继承F.prototype=context.prototype; bound.prototype=new F(); return bound;\n\n> }\n\n- ### 用 setTimeout 来实现 setInterval\n\n参考回答：\n\n1. 用 setTimeout()方法来模拟 setInterval()与 setInterval()之间的什么区别？ 首先来看 setInterval 的缺陷，使用\n   setInterval()创建的定时器确保了定时器代码规则地插入队列中。这个问题在于：如果定时器代码在代码再次添加到队列之前还没完成执行，结果就会导致定时器代码连续运行好几次。而之间没有间隔。不过幸运的\n\n是：javascript 引擎足够聪明，能够避免这个问题。当且仅当没有该定时器的如何代码实例时，才会将定时器代码添加到队列中。这确保了定时器代码加入队列中最小的时间间隔为指定时间。\n\n这种重复定时器的规则有两个问题：1.某些间隔会被跳过 2.多个定时器的代码执行时间可能会比预期小。\n\n下面举例子说明：\n\n假设，某个 onclick 事件处理程序使用啦 setInterval()来设置了一个 200ms 的重复定时器。如果事件处理程序花了 300ms 多一点的时间完成。\n\n<img width=\"626\" alt=\"2018-07-10 11 36 43\"\nsrc=\"[_https://user-_](https://user-images.githubusercontent.com/17233651/42487876-92656f2c-8435-11e8-8a5f-0a97918039da.png)\n[_images.githubusercontent.com/17233651/42487876-92656f2c-8435-11e8-8a5f-_](https://user-images.githubusercontent.com/17233651/42487876-92656f2c-8435-11e8-8a5f-0a97918039da.png)\n[_0a97918039da.png_](https://user-images.githubusercontent.com/17233651/42487876-92656f2c-8435-11e8-8a5f-0a97918039da.png)\">\n\n这个例子中的第一个定时器是在 205ms 处添加到队列中，但是要过 300ms 才能执行。在 405ms 又添加了一个副本。在一个间隔，605ms 处，第一个定时器代码还在执行中，\n而且队列中已经有了一个定时器实例，结果是 605ms 的定时器代码不会添加到队列\n\n中。结果是在 5ms 处添加的定时器代码执行结束后，405 处的代码立即执行。\n\n### function say(){\n\n> //something setTimeout(say,200);\n\n> } setTimeout(say,200) 或者\n\n> setTimeout(function(){\n\n> //do something setTimeout(arguments.callee,200);\n\n> },200);\n\n- ### JS 怎么控制一次加载一张图片，加载完后再加载下一张\n\n参考回答： (1)方法 1\n\n### <script type=\"text/javascript\"> var obj=new Image()\n\n> [obj.src=\"http://www.phpernote.com/uploadfiles/editor/2011072405022011](http://www.phpernote.com/uploadfiles/editor/2011072405022011)\n> 79.jpg\";\n\n> obj.onload=function(){\n\nalert('图片的宽度为：'+obj.width+'；图片的高度为：'+obj.height);\n\n### document.getElementById(\"mypic\").innnerHTML=\"\\<img src='\"+this.src+\"'\n\n> />\";\n\n> }\n\n> </script>\n\n> <div id=\"mypic\">onloading……\\</div>\n\n2. 方法 2\n\n### <script type=\"text/javascript\"> var obj=new Image()\n\n> [obj.src=\"http://www.phpernote.com/uploadfiles/editor/2011072405022011](http://www.phpernote.com/uploadfiles/editor/2011072405022011)\n> 79.jpg\";\n\n> obj.onreadystatechange=function(){ if(this.readyState==\"complete\"){\n\nalert('图片的宽度为：'+obj.width+'；图片的高度为：'+obj.height);\n\n### document.getElementById(\"mypic\").innnerHTML=\"\\<img src='\"+this.src+\"'\n\n> />\";\n\n> }\n\n> }\n\n> </script>\n\n> <div id=\"mypic\">onloading……\\</div>\n\n- ### 代码的执行顺序\n\n> 参 考 回 答 ： setTimeout(function(){console.log(1)},0); new Promise(function(resolve,reject){\n> console.log(2);\n\n> resolve();\n\n> }).then(function(){console.log(3)\n\n> }).then(function(){console.log(4)}); process.nextTick(function(){console.log(5)}); console.log(6);\n\n//输出 2,6,5,3,4,1\n\n为什么呢？具体请参考这篇文章：\n\n[_从 promise、process.nextTick、setTimeout 出发，谈谈 Event Loop 中的 Job\nqueue_](https://github.com/forthealllight/blog/issues/5)\n\n- ### 如何实现 sleep 的效果（es5 或者 es6）\n\n参 考 回 答 ： (1)while 循环的方式\n\n### function sleep(ms){\n\n> var start=Date.now(),expire=start+ms; while(Date.now()\\<expire); console.log('1111');\n\n> return;\n\n> }\n\n执行 sleep(1000)之后，休眠了 1000ms 之后输出了 1111。上述循环的方式缺点很明显，容易造成死循环。\n\n2. 通过 promise 来实现\n\n### function sleep(ms){\n\n> var temple=new Promise( (resolve)=>{\n\n> console.log(111);setTimeout(resolve,ms)\n\n> });\n\n> return temple\n\n> } sleep(500).then(function(){\n\n> //console.log(222)\n\n> })\n\n//先输出了 111，延迟 500ms 后输出 222 (3)通过 async 封装\n\n### function sleep(ms){\n\n> return new Promise((resolve)=>setTimeout(resolve,ms));\n\n> }\n\n> async function test(){\n\n> var temple=await sleep(1000); console.log(1111)\n\n> return temple\n\n> } test();\n\n> //延迟 1000ms 输出了 1111 (4).通过 generate 来实现function\\* sleep(ms){\n\n### yield new Promise(function(resolve,reject){ console.log(111)\n\n> setTimeout(resolve,ms);\n\n> })\n\n> } sleep(500).next().value.then(function(){console.log(2222)})\n\n- ### 简单的实现一个 promise\n\n参考回答：\n\n[_首先明确什么是 promiseA+规范，参考规范的地址：primise_](https://promisesaplus.com/) A+规范\n\n如何实现一个 promise，参考这篇文章：\n\n[_实现一个完美符合 Promise/A+规范的 Promise_](https://github.com/forthealllight/blog/issues/4)\n\n一般不会问的很详细，只要能写出上述文章中的 v1.0 版本的简单 promise 即可。\n\n- ### Function.\\_proto\\_(getPrototypeOf)是什么？\n\n参考回答：\n\n获取一个对象的原型，在 chrome 中可以通过_proto_的形式，或者在 ES6 中可以通过\n\nObject.getPrototypeOf 的形式。\n\n那么 Function.proto 是什么么？也就是说 Function 由什么对象继承而来，我们来做如下判别。\n\nFunction. proto ==Object.prototype //false Function. proto ==Function.prototype//true 我们发现 Function\n的原型也是 Function。\n\n我们用图可以来明确这个关系：\n\n<img width=\"646\" alt=\"2018-07-10 2 38 27\"\nsrc=\"[_https://user-_](https://user-images.githubusercontent.com/17233651/42493275-f55d0860-844e-11e8-983f-e04189a4f3d8.png)\n[_images.githubusercontent.com/17233651/42493275-f55d0860-844e-11e8-983f-_](https://user-images.githubusercontent.com/17233651/42493275-f55d0860-844e-11e8-983f-e04189a4f3d8.png)\n[_e04189a4f3d8.png_](https://user-images.githubusercontent.com/17233651/42493275-f55d0860-844e-11e8-983f-e04189a4f3d8.png)\">\n\n- ### 实现 JS 中所有对象的深度克隆（包装对象，Date 对象，正则对象）\n\n参考回答：\n\n通过递归可以简单实现对象的深度克隆，但是这种方法不管是 ES6 还是 ES5 实现，都有同样的缺陷，就是只能实现特定的 object 的深度复制（比如数组和函数），不能实现包装对象\nNumber，String ， Boolean，以及 Date 对象，RegExp 对象的复制。(1)前文的方法\n\n### function deepClone(obj){\n\n> var newObj= obj instanceof Array?\\[\\]:{}; for(var i in obj){\n\n> newObj\\[i\\]=typeof obj\\[i\\]=='object'? deepClone(obj\\[i\\]):obj\\[i\\];\n\n> }\n\n> return newObj;\n\n> }\n\n这种方法可以实现一般对象和数组对象的克隆，比如：\n\n### var arr=\\[1,2,3\\]\n\n> var newArr=deepClone(arr);\n\n> // newArr->\\[1,2,3\\] var obj={\n\n> x:1, y:2\n\n> }\n\n> var newObj=deepClone(obj);\n\n> // newObj={x:1,y:2}\n\n但是不能实现例如包装对象 Number,String,Boolean,以及正则对象 RegExp 和 Date 对象的克隆，比如：\n\n//Number 包装对象\n\n### var num=new Number(1)\n\n> typeof num // \"object\"\n\n> var newNum=deepClone(num);\n\n//newNum -> {} 空 对 象\n\n//String 包装对象\n\n### var str=new String(\"hello\"); typeof str //\"object\"\n\n> var newStr=deepClone(str);\n\n> //newStr-> {0:'h',1:'e',2:'l',3:'l',4:'o'};\n\n//Boolean 包装对象\n\n### var bol=new Boolean(true); typeof bol //\"object\"\n\n> var newBol=deepClone(bol);\n\n// newBol ->{} 空对象\n\n....\n\n2. valueof()函数\n\n所有对象都有 valueOf 方法，valueOf 方法对于：如果存在任意原始值，它就默认将对象转换为表示它的原始值。对象是复合值，而且大多数对象无法真正表示为一个原始值，因此默认的\nvalueOf()方法简单地返回对象本身，而不是返回一个原始值。数组、函数和正则表达式简单地继承了这个默认方法，调用这些类型的实例的 valueOf()方法只是简单返回这个对象本身。\n\n### 对于原始值或者包装类： function baseClone(base){ return base.valueOf()\n\n> }\n\n> //Number\n\n> var num=new Number(1);\n\n> var newNum=baseClone(num);\n\n> //newNum->1\n\n> //String\n\n> var str=new String('hello'); var newStr=baseClone(str);\n\n> // newStr->\"hello\"\n\n> //Boolean\n\n> var bol=new Boolean(true); var newBol=baseClone(bol);\n\n> //newBol-> true\n\n其实对于包装类，完全可以用=号来进行克隆，其实没有深度克隆一说， 这里用 valueOf 实现，语法上比较符合规范。\n\n对于 Date 类型：\n\n因为 valueOf 方法，日期类定义的 valueOf()方法会返回它的一个内部表示：1970 年 1\n\n月 1 日以来的毫秒数.因此我们可以在 Date 的原型上定义克隆的方法：\n\n### Date.prototype.clone=function(){ return new Date(this.valueOf())\n\n> }\n\n> var date=new Date('2010'); var newDate=date.clone();\n\n> // newDate-> Fri Jan 01 2010 08:00:00 GMT+0800\n\n> 对 于 正 则 对 象 RegExp： RegExp.prototype.clone = function() { var pattern = this.valueOf();\n\n### var flags = ''\n\n> flags += pattern.global ? 'g' : ''; flags += pattern.ignoreCase ? 'i' : ''; flags +=\n> pattern.multiline ? 'm' : '';\n\n> return new RegExp(pattern.source, flags);\n\n> };\n\n> var reg=new RegExp('/111/'); var newReg=reg.clone();\n\n> //newReg-> /\\\\/111\\\\//\n\n- ### 简单实现 Node 的 Events 模块\n\n参考回答：\n\n简介：观察者模式或者说订阅模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。\n\nnode 中的 Events 模块就是通过观察者模式来实现的：\n\n### var events=require('events')\n\n> var eventEmitter=new events.EventEmitter(); eventEmitter.on('say',function(name){\n> console.log('Hello',name);\n\n> })\n\n> eventEmitter.emit('say','Jony yu');\n\n这样，eventEmitter 发出 say 事件，通过 On 接收，并且输出结果，这就是一个订阅模式的实现，下面我们来简单的实现一个 Events 模块的 EventEmitter。\n\n1. 实现简单的 Event 模块的 emit 和 on 方法function Events(){ this.on=function(eventName,callBack){\n   if(!this.handles){\n\n### this.handles={}\n\n> } if(!this.handles\\[eventName\\]){ this.handles\\[eventName\\]=\\[\\];\n\n> }\n\n> this.handles\\[eventName\\].push(callBack);\n\n> } this.emit=function(eventName,obj){ if(this.handles\\[eventName\\]){\n\n> for(var i=0;o\\<this.handles\\[eventName\\].length;i++){ this.handles\\[eventName\\]\\[i\\](obj);\n\n> }\n\n> }\n\n> }\n\n> return this;\n\n> }\n\n> 这样我们就定义了 Events，现在我们可以开始来调用： var events=new Events(); events.on('say',function(name){\n> console.log('Hello',nama)\n\n### })\n\n> events.emit('say','Jony yu');\n\n//结果就是通过 emit 调用之后，输出了 Jony yu (2)每个对象是独立的\n\n因为是通过 new 的方式，每次生成的对象都是不相同的，因此：\n\n### var event1=new Events(); var event2=new Events(); event1.on('say',function(){ console.log('Jony event1')\n\n> });\n\n> event2.on('say',function(){ console.log('Jony event2');\n\n> }) event1.emit('say'); event2.emit('say');\n\n//event1、event2 之间的事件监听互相不影响\n\n//输出结果为'Jony event1' 'Jony event2'\n\n- ### 箭头函数中 this 指向举例\n\n参考回答：\n\n### var a=11; function test2(){ this.a=22\n\n> let b=()=>{console.log(this.a)} b();\n\n> }\n\n> var x=new test2();\n\n//输出 22\n\n定义时绑定。\n\n- ### JS 判断类型\n\n参考回答：\n\n判断方法：typeof()，instanceof，Object.prototype.toString.call()等\n\n- ### 数组常用方法\n\n参 考 回 答 ： push()，pop()，shift()，unshift()，splice()，sort()，reverse()，map()等\n\n- ### 数组去重\n\n参考回答：\n\n法一：indexOf 循环去重\n\n法二：ES6 Set 去重；Array.from(new Set(array))\n\n法三：Object 键值对去重；把数组的值存成 Object 的 key 值，比如Object\\[value1\\] = true，在判断另一个值的时候，如果 Object\\[value2\\]存在的话，\n就说明该值是重复的。\n\n- ### 闭包 有什么用\n\n参考回答：\n\n1. 什么是闭包：\n\n闭包是指有权访问另外一个函数作用域中的变量的函数。\n\n闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。当在一个函数内定义另外一个函数就会产生闭包。\n\n2. 为什么要用：\n\n匿名自执行函数：我们知道所有的变量，如果不加上 var\n关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用\nvar 关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，可以用闭包。 结果缓存：我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对\n象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。\n\n封装：实现类和继承等。\n\n- ### 事件代理在捕获阶段的实际应用\n\n参考回答：\n\n可以在父元素层面阻止事件向子元素传播，也可代替子元素执行某些操作。\n\n- ### 去除字符串首尾空格\n\n参考回答：\n\n使用正则(^\\\\s\\*)\\|(\\\\s\\*\\$)即可\n\n- ### 性能优化\n\n参考回答： 减少 HTTP 请求\n\n使用内容发布网络（CDN） 添加本地缓存\n\n压缩资源文件\n\n将 CSS 样式表放在顶部，把 javascript 放在底部（浏览器的运行机制决定） 避免使用 CSS 表达式\n\n减少 DNS 查询\n\n使用外部 javascript 和 CSS\n\n避免重定向 图片 lazyLoad\n\n- ### 来讲讲 JS 的闭包吧\n\n参考回答：\n\n闭包是指有权访问另外一个函数作用域中的变量的函数。\n\n闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。当在一个函数内定义另外一个函数就会产生闭包。\n\n2. 为什么要用：\n\n匿名自执行函数：我们知道所有的变量，如果不加上 var\n关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用\nvar 关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，可以用闭包。 结果缓存：我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对\n象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用\n\n这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。\n\n- ### 能来讲讲 JS 的语言特性吗\n\n参考回答：\n\n运行在客户端浏览器上；\n\n不用预编译，直接解析执行代码； 是弱类型语言，较为灵活；\n\n与操作系统无关，跨平台的语言； 脚本语言、解释性语言\n\n- ### 如何判断一个数组(讲到 typeof 差点掉坑里)\n\n> 参 考 回 答 ： Object.prototype.call.toString() instanceof\n\n- ### 你说到 typeof，能不能加一个限制条件达到判断条件\n\n参考回答：\n\ntypeof 只能判断是 object,可以判断一下是否拥有数组的方法\n\n- ### JS 实现跨域\n\n参考回答：\n\nJSONP：通过动态创建 script，再请求一个带参网址实现跨域通信。document.domain\n\n- iframe 跨域：两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域。\n\nlocation.hash + iframe 跨域：a 欲与b 跨域相互通信，通过中间页c 来实现。 三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 js\n访问来通信。\n\nwindow.name + iframe 跨域：通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。\n\npostMessage 跨域：可以跨域操作的 window 属性之一。\n\nCORS：服务端设置 Access-Control-Allow-Origin 即可，前端无须设置，若要带\n\ncookie 请求，前后端都需要设置。\n\n代理跨域：启一个代理服务器，实现数据的转发\n\n参考 [_https://segmentfault.com/a/1190000011145364_](https://segmentfault.com/a/1190000011145364)\n\n- ### JS 基本数据类型\n\n参考回答：\n\n基本数据类型：undefined、null、number、boolean、string、symbol\n\n- ### JS 深度拷贝一个元素的具体实现\n\n参考回答：\n\n### var deepCopy = function(obj) {\n\n> if (typeof obj !== 'object') return;\n\n> var newObj = obj instanceof Array ? \\[\\] : {}; for (var key in obj) {\n\n> if (obj.hasOwnProperty(key)) {\n\n> newObj\\[key\\] = typeof obj\\[key\\] === 'object' ? deepCopy(obj\\[key\\]) : obj\\[key\\];\n\n> }\n\n> }\n\n> return newObj;\n\n> }\n\n- ### 之前说了 ES6set 可以数组去重，是否还有数组去重的方法\n\n参考回答：\n\n法一：indexOf 循环去重\n\n法二：Object 键值对去重；把数组的值存成 Object 的 key 值，比如Object\\[value1\\] = true，在判断另一个值的时候，如果 Object\\[value2\\]存在的话，\n就说明该值是重复的。\n\n- ### 重排和重绘，讲讲看\n\n参考回答：\n\n重绘（repaint 或\nredraw）：当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。\n\n触发重绘的条件：改变元素外观属性。如：color，background-color 等。\n\n注意：table 及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值， 比同等元素要多花两倍时间，这就是我们尽量避免使用 table\n布局页面的原因之一。重排（重构/回流/reflow）：当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建,\n这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。\n\n重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。所以，重排必定会引发重绘，但重绘不一定会引发重排。\n\n- ### JS 的全排列\n\n参考回答：\n\n### function permutate(str) { var result = \\[\\]; if(str.length \\> 1) {\n\n> var left = str\\[0\\];\n\n> var rest = str.slice(1, str.length); var preResult = permutate(rest); for(var i=0;\n> i\\<preResult.length; i++) {\n\n> for(var j=0; j\\<preResult\\[i\\].length; j++) {\n\n> var tmp = preResult\\[i\\],slice(0, j) + left + preResult\\[i\\].slice(j, preResult\\[i\\].length);\n\n> result.push(tmp);\n\n> }\n\n> }\n\n> } else if (str.length == 1) { return \\[str\\];\n\n> }\n\n> return result;\n\n> }\n\n- ### 跨域的原理\n\n参考回答：\n\n跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对 JavaScript\n实施的安全限制，那么只要协议、域名、端口有任何一个不同，都被当作是不同的域。跨域原理，即是通过各种方式，避开浏览器的安全限制。\n\n- ### 不同数据类型的值的比较，是怎么转换的，有什么规则\n\n参考回答：\n\n![](media/image4.jpeg)\n\n- ### null == undefined 为什么\n\n参考回答：\n\n要比较相等性之前，不能将 null 和 undefined 转换成其他任何值，但 null == undefined 会返回 true 。ECMAScript 规范中是这样定义的。\n\n- ### this 的指向 哪几种\n\n参考回答：\n\n默认绑定：全局环境中，this 默认绑定到 window。\n\n隐式绑定：一般地，被直接对象所包含的函数调用时，也称为方法调用，this 隐式绑定到该直接对象。\n\n隐式丢失：隐式丢失是指被隐式绑定的函数丢失绑定对象，从而默认绑定到 window。显式绑定：通过 call()、apply()、bind()方法把对象绑定到 this 上，叫做显式绑定。\n\nnew 绑定：如果函数或者方法调用之前带有关键字 new，它就构成构造函数调用。对于this 绑定来说，称为 new 绑定。\n\n【1】构造函数通常不使用 return 关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。\n\n【2】如果构造函数使用 return 语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果。\n\n【3】如果构造函数显式地使用 return 语句返回一个对象，那么调用表达式的值就是这个对象。\n\n- ### 暂停死区\n\n参考回答：\n\n在代码块内，使用 let、const 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”\n\n- ### 写一个深度拷贝\n\n参考回答：\n\n### function clone( obj ) { var copy\n\n> switch( typeof obj ) { case \"undefined\": break;\n\n> case \"number\": copy = obj - 0; break;\n\n> case \"string\": copy = obj + \"\"; break;\n\n> case \"boolean\": copy = obj; break;\n\ncase \"object\": //object 分为两种情况 对象（Object）和数组（Array）\n\n### if(obj === null) { copy = null\n\n> } else {\n\n> if( Object.prototype.toString.call(obj).slice(8, -1) === \"Array\") { copy = \\[\\];\n\n> for( var i = 0 ; i \\< obj.length ; i++ ) { copy.push(clone(obj\\[i\\]));\n\n> }\n\n> } else { copy = {};\n\n> for( var j in obj) { copy\\[j\\] = clone(obj\\[j\\]);\n\n> }\n\n> }\n\n> } break; default:\n\n> copy = obj; break;\n\n> }\n\n> return copy;\n\n> }\n\n- ### 简历中提到了 requestAnimationFrame，请问是怎么使用的\n\n参考回答：\n\nrequestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。\n\n- ### 有一个游戏叫做 Flappy Bird，就是一只小鸟在飞，前面是无尽的沙漠，上下不断有钢管生成，你要躲避钢管。然后小明在玩这个游戏时候老是卡顿甚至崩溃，说出原因（3-5 个）以及解决办法（3-5 个）\n\n参考回答： 原因可能是：\n\n1. 内存溢出问题。\n\n2. 资源过大问题。\n\n3. 资源加载问题。4.canvas 绘制频率问题解决办法：\n\n4. 针对内存溢出问题，我们应该在钢管离开可视区域后，销毁钢管，让垃圾收集器回收钢管，因为不断生成的钢管不及时清理容易导致内存溢出游戏崩溃。\n\n5. 针对资源过大问题，我们应该选择图片文件大小更小的图片格式，比如使用 webp、png 格式的图片，因为绘制图片需要较大计算量。\n\n6. 针对资源加载问题，我们应该在可视区域之前就预加载好资源，如果在可视区域生成钢管的话，用户的体验就认为钢管是卡顿后才生成的，不流畅。\n\n7. 针对 canvas 绘制频率问题，我们应该需要知道大部分显示器刷新频率为 60 次/s,因此游戏的每一帧绘制间隔时间需要小于 1000/60=16.7ms，才能让用户觉得不卡顿。\n\n（注意因为这是单机游戏，所以回答与网络无关）\n\n- ### 编写代码，满足以下条件： （1）Hero(\"37er\");执行结果为 Hi! This is 37er （2）Hero(\"37er\").kill(1).recover(30);执行结果为 Hi! This is 37er Kill 1 bug Recover 30 bloods （3） Hero(\"37er\").sleep(10).kill(2)执行结果为 Hi! This is 37er //等待 10s 后 Kill 2 bugs //注意为 bugs （双斜线后的为提示信息，不需要打印）\n\n参考回答：\n\n### function Hero(name){ let o=new Object(); o.name=name; o.time=0\n\n> console.log(\"Hi! This is \"+o.name); o.kill=function(bugs) { if(bugs==1){\n\n> console.log(\"Kill \"+(bugs)+\" bug\");\n\n> }else { setTimeout(function () {\n\n> console.log(\"Kill \" + (bugs) + \" bugs\");\n\n> }, 1000 \\* this.time);\n\n> }\n\n> return o;\n\n> };\n\n18. ecover=function (bloods) { console.log(\"Recover \"+(bloods)+\" bloods\"); return o;\n\n> }\n\n19. leep=function (sleepTime) { o.time=sleepTime;\n\n> return o;\n\n> }\n\n> return o;\n\n> }\n\n- ### 什么是按需加载\n\n参考回答：\n\n当用户触发了动作时才加载对应的功能。触发的动作，是要看具体的业务场景而言， 包括但不限于以下几个情况：鼠标点击、输入文字、拉动滚动条，鼠标移动、窗口大小更改等。加载的文件，可以是\nJS、图片、CSS、HTML 等。\n\n- ### 说一下什么是 virtual dom\n\n参考回答：\n\n用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树， 插到文档当中 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异\n把所记录的差异应用到所构建的真正的 DOM 树上，视图就更新了。Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。\n\n- ### webpack 用来干什么的\n\n参考回答：\n\nwebpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency\ngraph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。\n\n- ### ant-design 优点和缺点\n\n参考回答：\n\n优点：组件非常全面，样式效果也都比较不错。\n\n缺点：框架自定义程度低，默认 UI 风格修改困难。\n\n- ### JS 中继承实现的几种方式\n\n参考回答：\n\n1、原型链继承，将父类的实例作为子类的原型，他的特点是实例是子类的实例也是父类的实例，父类新增的原型方法/属性，子类都能够访问，并且原型链继承简单易于实现，缺点是来自原型对象的所有属性被所有实例共享，无法实现多继承，无法向父类构造函数传参。\n\n2、构造继承，使用父类的构造函数来增强子类实例，即复制父类的实例属性给子类， 构造继承可以向父类传递参数，可以实现多继承，通过 call\n多个父类对象。但是构造继承只能继承父类的实例属性和方法，不能继承原型属性和方法，无法实现函数服\n\n用，每个子类都有父类实例函数的副本，影响性能\n\n3、实例继承，为父类实例添加新特性，作为子类实例返回，实例继承的特点是不限制调用方法，不管是 new 子类（）还是子类（）返回的对象具有相同的效果，缺点是实例是父类的实例，不是子类的实例，不支持多继承\n\n4、拷贝继承：特点：支持多继承，缺点：效率较低，内存占用高（因为要拷贝父类的属性）无法获取父类不可枚举的方法（不可枚举方法，不能使用 for in 访问到）\n\n5、组合继承：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n6、寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点\n\n- ### 写一个函数，第一秒打印 1，第二秒打印 2\n\n参考回答：\n\n> 两个方法，第一个是用 let 块级作用域for(let i=0;i\\<5;i++){ setTimeout(function(){ console.log(i)\n\n### },1000\\*i)\n\n> }\n\n第二个方法闭包\n\n### for(var i=0;i\\<5;i++){ (function(i){ setTimeout(function(){ console.log(i)\n\n> },1000\\*i)\n\n> })(i)\n\n> }\n\n- ### Vue 的生命周期\n\n参考回答：\n\nVue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是 Vue 的生命周期。通俗说就是 Vue\n实例从创建到销毁的过程，就是生命周期。\n\n每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁。\n\n实例、组件通过 new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行beforeCreate 钩子函数，这个时候，数据还没有挂载呢，只是一个空壳，无法访问到数据和真实的\ndom，一般不做操作\n\n挂载数据，绑定事件等等，然后执行 created 函数，这个时候已经可以使用到数据， 也可以更改数据,在这里更改数据不会触发 updated\n函数，在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取\n\n接下来开始找实例或者组件对应的模板，编译模板为虚拟 dom 放入到 render 函数中准备渲染，然后执行 beforeMount 钩子函数，在这个函数中虚拟 dom\n已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发 updated，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取 接下来开始\nrender，渲染出真实 dom，然后执行 mounted 钩子函数，此时，组件已经出现在页面中，数据、真实 dom 都已经处理好了,事件都已经挂载好了，可以在这里操作真实 dom 等事情...\n\n当组件或实例的数据更改之后，会立即执行 beforeUpdate，然后 Vue 的虚拟 dom 机制会重新构建虚拟 dom 与上一次的虚拟 dom 树利用 diff\n算法进行对比之后重新渲染，一般不做什么事儿\n\n当更新完成后，执行 updated，数据已经更改完成，dom 也重新 render 完成，可以操作更新后的虚拟 dom\n\n当经过某种途径调用\\$destroy 方法后，立即执行beforeDestroy，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等\n\n组件的数据绑定、监听...去掉后只剩下 dom 空壳，这个时候，执行 destroyed，在这里做善后工作也可以\n\n- ### 简单介绍一下 symbol\n\n参考回答：\n\nSymbol 是 ES6 的新增属性，代表用给定名称作为唯一标识，这种类型的值可以这样创建，let id=symbol(“id”)\n\nSymbl 确保唯一，即使采用相同的名称，也会产生不同的值，我们创建一个字段，仅为知道对应 symbol 的人能访问，使用 symbol 很有用，symbol 并不是 100%隐藏，有内置方法\nObject.getOwnPropertySymbols(obj)可以获得所有的 symbol。\n\n也有一个方法 Reflect.ownKeys(obj)返回对象所有的键，包括 symbol。\n\n所以并不是真正隐藏。但大多数库内置方法和语法结构遵循通用约定他们是隐藏的。\n\n- ### 什么是事件监听\n\n参考回答：\n\naddEventListener()方法，用于向指定元素添加事件句柄，它可以更简单的控制事件，语法为\n\nelement.addEventListener(event, function, useCapture);\n\n第一个参数是事件的类型(如 \"click\" 或 \"mousedown\"). 第二个参数是事件触发后调用的函数。\n\n第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。事件传递有两种方式，冒泡和捕获\n\n事件传递定义了元素事件触发的顺序，如果你将P 元素插入到 div 元素中，用户点击P\n\n元素，\n\n在冒泡中，内部元素先被触发，然后再触发外部元素， 捕获中，外部元素先被触发，在触发内部元素。\n\n- ### 介绍一下 promise，及其底层如何实现\n\n参考回答：\n\nPromise 是一个对象，保存着未来将要结束的事件，她有两个特征:\n\n1、对象的状态不受外部影响，Promise 对象代表一个异步操作，有三种状态，pending 进行中，fulfilled 已成功，rejected\n已失败，只有异步操作的结果，才可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也就是 promise 名字的由来2、一旦状态改变，就不会再变，promise 对象状态改变只有两种可能，从\npending 改到 fulfilled 或者从 pending 改到 rejected，只要这两种情况发生，状态就凝固了， 不会再改变，这个时候就称为定型 resolved,\n\nPromise 的基本用法，\n\n### let promise1 = new Promise(function(resolve,reject){ setTimeout(function(){\n\n> resolve('ok')\n\n> },1000)\n\n> })\n\n> promise1.then(function success(val){ console.log(val)\n\n> })\n\n> 最简单代码实现 promise class PromiseM { constructor (process) { this.status = 'pending' this.msg = ''\n\n> process(this.resolve.bind(this), this.reject.bind(this)) return this\n\n> }\n\n> resolve (val) { this.status = 'fulfilled' this.msg = val\n\n> }\n\n> reject (err) { this.status = 'rejected' this.msg = err\n\n> }\n\n> then (fufilled, reject) { if(this.status === 'fulfilled') { fufilled(this.msg)\n\n> }\n\n> if(this.status === 'rejected') { reject(this.msg)\n\n> }\n\n> }\n\n> }\n\n//测试代码\n\n### var mm=new PromiseM(function(resolve,reject){ resolve('123')\n\n> });\n\n> mm.then(function(success){ console.log(success);\n\n> },function(){\n\n> console.log('fail!');\n\n> });\n\n- ### 说说 C++,Java，JavaScript 这三种语言的区别\n\n参考回答：\n\n从静态类型还是动态类型来看\n\n静态类型，编译的时候就能够知道每个变量的类型，编程的时候也需要给定类型，如\n\nJava 中的整型 int，浮点型 float 等。C、C++、Java 都属于静态类型语言。\n\n动态类型，运行的时候才知道每个变量的类型，编程的时候无需显示指定类型，如JavaScript 中的 var、PHP 中的\\$。JavaScript、Ruby、Python\n都属于动态类型语言。静态类型还是动态类型对语言的性能有很大影响。\n\n对于静态类型，在编译后会大量利用已知类型的优势，如 int 类型，占用 4 个字节， 编译后的代码就可以用内存地址加偏移量的方法存取变量，而地址加偏移量的算法汇编很容易实现。\n\n对于动态类型，会当做字符串通通存下来，之后存取就用字符串匹配。从编译型还是解释型来看\n\n编译型语言，像C、C++，需要编译器编译成本地可执行程序后才能运行，由开发人员在编写完成后手动实施。用户只使用这些编译好的本地代码，这些本地代码由系统加载器执行，由操作系统的 CPU\n直接执行，无需其他额外的虚拟机等。\n\n源代码=》抽象语法树=》中间表示=》本地代码\n\n解释性语言，像 JavaScript、Python，开发语言写好后直接将代码交给用户，用户使用脚本解释器将脚本文件解释执行。对于脚本语言，没有开发人员的编译过程，当 然，也不绝对。\n\n源代码=》抽象语法树=》解释器解释执行。\n\n对于 JavaScript，随着 Java 虚拟机 JIT 技术的引入，工作方式也发生了改变。可以将抽象语法树转成中间表示（字节码），再转成本地代码，如\nJavaScriptCore，这样可以大大提高执行效率。也可以从抽象语法树直接转成本地代码，如 V8\n\nJava 语言，分为两个阶段。首先像 C++语言一样，经过编译器编译。和 C++的不同， C++编译生成本地代码，Java 编译后，生成字节码，字节码与平台无关。第二阶段，由Java 的运行环境也就是\nJava 虚拟机运行字节码，使用解释器执行这些代码。一般情况下，Java 虚拟机都引入了 JIT 技术，将字节码转换成本地代码来提高执行效率。\n\n注意，在上述情况中，编译器的编译过程没有时间要求，所以编译器可以做大量的代码优化措施。\n\n对于 JavaScript 与 Java 它们还有的不同：\n\n对于 Java，Java 语言将源代码编译成字节码，这个同执行阶段是分开的。也就是从源代码到抽象语法树到字节码这段时间的长短是无所谓的。\n\n对于 JavaScript，这些都是在网页和 JavaScript 文件下载后同执行阶段一起在网页的加载和渲染过程中实施的，所以对于它们的处理时间有严格要求。\n\n- ### JS 原型链，原型链的顶端是什么？Object 的原型是什么？Object 的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法\n\n参考回答：\n\n能够把这个讲清楚弄明白是一件很困难的事，\n\n首先明白原型是什么，在 ES6 之前，JS 没有类和继承的概念，JS 是通过原型来实现继承的，在 JS 中一个构造函数默认带有一个 prototype 属性，这个的属性值是一个对象，同时这个\nprototype 对象自带有一个 constructor 属性，这个属性指向这个构造函数，同时每一个实例都会有一个_proto_属性指向这个 prototype\n对象，我们可以把这个叫做隐式原型，我们在使用一个实例的方法的时候，会先检查这个实例中是否有这个方法，没有的话就会检查这个 prototype 对象是否有这个方法，\n\n基于这个规则，如果让原型对象指向另一个类型的实例，即constructor1.protoytpe=instance2，这时候如果试图引用 constructor1 构造的实例instance1\n的某个属性 p1,\n\n首先会在 instance1 内部属性中找一遍，\n\n接着会在 instance1.\\_proto\\_（constructor1.prototype）即是 instance2 中寻找 p1\n\n搜寻轨迹：\n\ninstance1->instance2->constructor2.prototype……->Object.prototype;这即是原型链，原型链顶端是 Object.prototype\n\n补充学习：\n\n每个函数都有一个 prototype 属性，这个属性指向了一个对象，这个对象正是调用该函数而创建的实例的原型，那么什么是原型呢，可以这样理解，每一个 JavaScript\n对象在创建的时候就会预制管理另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型继承属性，如图：\n\n![](media/image5.jpeg)\n\n那么怎么表示实例与实例原型的关系呢，这时候就要用到第二个属性_proto\\_ 这是每一个 JS 对象都会有的一个属性，指向这个对象的原型，如图：\n\n> ![](media/image6.jpeg)\n\n既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢，指向实例是没有的，因为一个构造函数可以生成多个实例，但是原型有属性可以直接指向构造函数，通过constructor 即可\n\n接下来讲解实例和原型的关系：\n\n当读取实例的属性时，如果找不到，就会查找与对象相关的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层，那么原型的原型是什么呢，首先，原型也是一个对象，既然是对象，我们就可以通过构造函数的方式创建它，所以原型对象就是通过\nObject 构造函数生成的，如图：\n\n![](media/image7.jpeg)\n\n那么 Object.prototype 的原型呢，我们可以打印\n\nconsole.log(Object.prototype. proto === null)，返回 true\n\nnull 表示没有对象，即该处不应有值，所以 Object.prototype 没有原型，如图：\n\n![](media/image8.jpeg)\n\n图中这条蓝色的线即是原型链， 最 后 补 充 三 点 ： constructor：\n\nfunction Person(){\n\n}\n\nvar person = new Person(); console.log(Person === person.constructor);\n\n原本 person 中没有 constructor 属性，当不能读取到 constructor 属性时，会从\n\nperson 的原型中读取，所以指向构造函数 Person\n\nproto ：\n\n绝大部分浏览器支持这个非标准的方法访问原型，然而它并不存在与Person.prototype 中，实际上它来自 Object.prototype，当使用 obj. proto 时， 可以理解为返回来\nObject.getPrototype(obj)\n\n继承：\n\n前面说到，每个对象都会从原型继承属性，但是引用《你不知道的 JS》中的话，继承意味着复制操作，然而 JS 默认不会复制对象的属性，相反，JS\n只是在两个对象之间创建一个关联，这样子一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，叫委托更合适。\n\n- ### 什么是 js 的闭包？有什么作用，用闭包写个单例模式\n\n参考回答：\n\nMDN 对闭包的定义是：闭包是指那些能够访问自由变量的函数，自由变量是指在函数中使用的，但既不是函数参数又不是函数的局部变量的变量，由此可以看出，闭包=函数\n\n+函数能够访问的自由变量，所以从技术的角度讲，所有 JS 函数都是闭包，但是这是理论上的闭包，还有一个实践角度上的闭包，从实践角度上来说，只有满足\n1、即使创建它的上下文已经销毁，它仍然存在，2、在代码中引入了自由变量，才称为闭包\n\n闭包的应用：\n\n模仿块级作用域。2、保存外部函数的变量。3、封装私有变量单例模式：\n\n### var Singleton = (function(){ var instance\n\n> var CreateSingleton = function (name) { this.name = name;\n\n> if(instance) { return instance;\n\n> }\n\n// 打印实例名字\n\n### this.getName()\n\n> // instance = this;\n\n> // return instance; return instance = this;\n\n> }\n\n> // 获取实例的名字CreateSingleton.prototype.getName = function() { console.log(this.name)\n\n> }\n\n> return CreateSingleton;\n\n> })();\n\n// 创建实例对象 1\n\n### var a = new Singleton('a')\n\n// 创建实例对象 2\n\n### var b = new Singleton('b'); console.log(a===b)\n\n- ### promise+Generator+Async 的使用\n\n参考回答： Promise\n\n解决的问题:回调地狱Promise 规范:\n\npromise 有三种状态，等待（pending）、已完成（fulfilled/resolved）、已拒绝\n\n（rejected）.Promise 的状态只能从“等待”转到“完成”或者“拒绝”，不能逆向转换，同时“完成”和“拒绝”也不能相互转换.\n\npromise 必须提供一个 then 方法以访问其当前值、终值和据因。promise.then(resolve, reject),resolve 和 reject 都是可选参数。如果 resolve\n或 reject 不是函数，其必须被忽略.\n\nthen 方法必须返回一个 promise 对象.\n\n使用:\n\n实例化 promise 对象需要传入函数(包含两个参数),resolve 和 reject,内部确定状态.resolve 和 reject 函数可以传入参数在回调函数中使用.\n\n> resolve 和 reject 都是函数,传入的参数在 then 的回调函数中接收. var promise = new Promise(function(resolve, reject) {\n> setTimeout(function(){\n\n### resolve('好哈哈哈哈')\n\n> });\n\n> });\n\n> promise.then(function(val){ console.log(val)\n\n> })\n\nthen 接收两个函数,分别对应 resolve 和 reject 状态的回调,函数中接收实例化时传入的参数.\n\n### promise.then(val=>{\n\n> //resolved\n\n> },reason=>{\n\n> //rejected\n\n> })\n\ncatch 相当于.then(null, rejection)\n\n当 then 中没有传入 rejection 时,错误会冒泡进入 catch 函数中,若传入了 rejection, 则错误会被 rejection 捕获,而且不会进入 catch.此外,then\n中的回调函数中发生的错误只会在下一级的 then 中被捕获,不会影响该 promise 的状态.\n\n### new Promise((resolve,reject)=>{ throw new Error('错误')\n\n> }).then(null,(err)=>{ console.log(err,1);//此处捕获\n\n> }).catch((err)=>{ console.log(err,2);\n\n> });\n\n### // 对比\n\n> new Promise((resolve,reject)=>{\n\n> throw new Error('错误')\n\n> }).then(null,null).catch((err)=>{ console.log(err,2);//此处捕获\n\n> });\n\n> // 错误示例\n\n> new Promise((resolve,reject)=>{ resolve('正常');\n\n> }).then((val)=>{\n\n> throw new Error('回调函数中错误')\n\n> },(err)=>{ console.log(err,1);\n\n> }).then(null,(err)=>{ console.log(err,2);//此处捕获,也可用 catch\n\n> });\n\n两者不等价的情况:\n\n此时，catch 捕获的并不是 p1 的错误，而是 p2 的错误，\n\n### p1().then(res=>{\n\n> return p2()//p2 返回一个 promise 对象\n\n> }).catch(err=> console.log(err))\n\n一个错误捕获的错误用例:\n\n该函数调用中即使发生了错误依然会进入 then 中的 resolve 的回调函数,因为函数 p1 中实例化 promise 对象时已经调用了 catch,若发生错误会进入 catch\n中,此时会返回一个新的 promise,因此即使发生错误依然会进入 p1 函数的 then 链中的 resolve 回调函数.\n\n### function p1(val){\n\n> return new Promise((resolve,reject)=>{ if(val){\n\n> var len = val.length;//传入 null 会发生错误,进入 catch 捕获错resolve(len);\n\n> }else{ reject();\n\n> }\n\n> }).catch((err)=>{ console.log(err)\n\n> })\n\n> }; p1(null).then((len)=>{\n\n> console.log(len,'resolved');\n\n> },()=>{\n\n> console.log('rejected');\n\n> }).catch((err)=>{\n\n> console.log(err,'catch');\n\n> })\n\nPromise 回调链:\n\npromise 能够在回调函数里面使用 return 和 throw， 所以在 then 中可以 return 出一个 promise 对象或其他值，也可以 throw 出一个错误对象，但如果没有\nreturn，将默认返回 undefined，那么后面的 then 中的回调参数接收到的将是 undefined. function p1(val){\n\n### return new Promise((resolve,reject)=>{ val==1?resolve(1):reject()\n\n> })\n\n> };\n\n> function p2(val){\n\n> return new Promise((resolve,reject)=>{ val==2?resolve(2):reject();\n\n> })\n\n> };\n\n> let promimse = new Promise(function(resolve,reject){ resolve(1)\n\n> })\n\n> .then(function(data1) {\n\n> return p1(data1)//如果去掉 return,则返回 undefined 而不是 p1 的返回值, 会导致报错\n\n> })\n\n> .then(function(data2){ return p2(data2+1)\n\n> })\n\n> .then(res=>console.log(res))\n\nGenerator 函 数 ： generator 函数使用:\n\n1、分段执行，可以暂停\n\n2、可以控制阶段和每个阶段的返回值\n\n3、可以知道是否执行到结尾\n\n### function\\* g() { var o = 1; yield o++; yield o++\n\n> }\n\n> var gen = g();\n\n> console.log(gen.next()); // Object {value: 1, done: false} var xxx = g();\n\n> console.log(gen.next()); // Object {value: 2, done: false} console.log(xxx.next()); // Object\n> {value: 1, done: false} console.log(gen.next()); // Object {value: undefined, done: true}\n\ngenerator 和异步控制:\n\n利用 Generator 函数的暂停执行的效果，可以把异步操作写在 yield 语句里面，等到调用 next 方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在\nyield 语句下面，反正要等到调用 next 方法时再执行。所以， Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。\n\nasync 和异步: 用法:\n\nasync 表示这是一个 async 函数，await 只能用在这个函数里面。await 表示在这里等待异步操作返回结果，再继续执行。\n\nawait 后一般是一个 promise 对象\n\n示例:async 用于定义一个异步函数，该函数返回一个 Promise。\n\n如果 async 函数返回的是一个同步的值，这个值将被包装成一个理解 resolve 的\n\nPromise，等同于 return Promise.resolve(value)。\n\nawait 用于一个异步操作之前，表示要“等待”这个异步操作的返回值。await 也可以用于一个同步的值。\n\n### let timer = async function timer(){ return new Promise((resolve,reject) => { setTimeout(() => {\n\n> resolve('500');\n\n> },500);\n\n> });\n\n> }\n\n> timer().then(result => { console.log(result); //500\n\n> }).catch(err => { console.log(err.message);\n\n> });\n\n> //返回一个同步的值\n\n> let sayHi = async function sayHi(){ let hi = await 'hello world';\n\n> return hi; //等同于 return Promise.resolve(hi);\n\n> }\n\n> sayHi().then(result => { console.log(result);\n\n> });\n\n- ### 事件委托以及冒泡原理\n\n参考回答：\n\n事件委托是利用冒泡阶段的运行机制来实现的，就是把一个元素响应事件的函数委托到另一个元素，一般是把一组元素的事件委托到他的父元素上，委托的优点是\n\n减少内存消耗，节约效率动态绑定事件\n\n事件冒泡，就是元素自身的事件被触发后，如果父元素有相同的事件，如 onclick 事件，那么元素本身的触发状态就会传递，也就是冒到父元素，父元素的相同事件也会一级一级根据嵌套关系向外触发，直到\ndocument/window，冒泡过程结束。\n\n- ### 写个函数，可以转化下划线命名到驼峰命名\n\n参考回答：\n\n### public static String UnderlineToHump(String para){ StringBuilder result=new StringBuilder()\n\n> String a\\[\\]=para.split(\"\\_\"); for(String s:a){ if(result.length()==0){\n> result.append(s.toLowerCase());\n\n> }else{\n\n> result.append(s.substring(0, 1).toUpperCase()); result.append(s.substring(1).toLowerCase());\n\n> }\n\n> }\n\n> return result.toString();\n\n> }\n\n> }\n\n- ### 深浅拷贝的区别和实现\n\n参考回答：\n\n数组的浅拷贝：\n\n如果是数组，我们可以利用数组的一些方法，比如 slice，concat 方法返回一个新数组的特性来实现拷贝，但假如数组嵌套了对象或者数组的话，使用 concat\n方法克隆并不完整，如果数组元素是基本类型，就会拷贝一份，互不影响，而如果是对象或数\n组，就会只拷贝对象和数组的引用，这样我们无论在新旧数组进行了修改，两者都会发生变化，我们把这种复制引用的拷贝方法称为浅拷贝，\n\n深拷贝就是指完全的拷贝一个对象，即使嵌套了对象，两者也互相分离，修改一个对象的属性，不会影响另一个\n\n如何深拷贝一个数组\n\n### 1、这里介绍一个技巧，不仅适用于数组还适用于对象！那就是： var arr = \\['old', 1, true, \\['old1', 'old2'\\], {old: 1}\\] var new_arr = JSON.parse( JSON.stringify(arr) ); console.log(new_arr)\n\n原理是 JOSN 对象中的 stringify 可以把一个 js 对象序列化为一个 JSON 字符串， parse 可以把 JSON 字符串反序列化为一个 js\n对象，通过这两个方法，也可以实现对象的深复制。\n\n但是这个方法不能够拷贝函数浅拷贝的实现：\n\n以上三个方法 concat,slice ,JSON.stringify\n都是技巧类，根据实际项目情况选择使用，我们可以思考下如何实现一个对象或数组的浅拷贝，遍历对象，然后把属性和属性值都放在一个新的对象里即可\n\n### var shallowCopy = function(obj) {\n\n> // 只拷贝对象\n\n> if (typeof obj !== 'object') return;\n\n> // 根据 obj 的类型判断是新建一个数组还是对象var newObj = obj instanceof Array ? \\[\\] : {};\n\n> // 遍历 obj，并且判断是 obj 的属性才拷贝\n\n> for (var key in obj) {\n\n> if (obj.hasOwnProperty(key)) { newObj\\[key\\] = obj\\[key\\];\n\n> }\n\n> }\n\n> return newObj;\n\n深拷贝的实现\n\n那如何实现一个深拷贝呢？说起来也好简单，我们在拷贝的时候判断一下属性值的类型，如果是对象，我们递归调用深拷贝函数不就好了\\~\n\n### var deepCopy = function(obj) {\n\n> if (typeof obj !== 'object') return;\n\n> var newObj = obj instanceof Array ? \\[\\] : {}; for (var key in obj) {\n\n> if (obj.hasOwnProperty(key)) {\n\n> newObj\\[key\\] = typeof obj\\[key\\] === 'object' ? deepCopy(obj\\[key\\]) : obj\\[key\\];\n\n> }\n\n> }\n\n> return newObj;\n\n> }\n\n- ### JS 中 string 的 startwith 和 indexof 两种方法的区别\n\n参考回答：\n\nJS 中 startwith 函数，其参数有 3 个，stringObj,要搜索的字符串对象，str，搜索的字符串，position，可选，从哪个位置开始搜索，如果以 position\n开始的字符串以搜索字符串开头，则返回 true，否则返回 false\n\nIndexof 函数，indexof 函数可返回某个指定字符串在字符串中首次出现的位置。\n\n- ### JS 字符串转数字的方法\n\n参考回答：\n\n通过函数 parseInt（），可解析一个字符串，并返回一个整数，语法为 parseInt\n\n（string ,radix） string：被解析的字符串\n\nradix：表示要解析的数字的基数，默认是十进制，如果 radix\\<2 或>36,则返回 NaN\n\n- ### let const var 的区别 ，什么是块级作用域，如何用 ES5 的方法实现块级作用域（立即执行函数），ES6 呢\n\n参考回答：\n\n提起这三个最明显的区别是 var 声明的变量是全局或者整个函数块的，而 let,const 声明的变量是块级的变量，var 声明的变量存在变量提升，let,const 不存在，let\n声明的变量允许重新赋值，const 不允许。\n\n- ### ES6 箭头函数的特性\n\n参考回答：\n\nES6 增加了箭头函数，基本语法为let func = value => value;\n\n相当于\n\nlet func = function (value) { return value;\n\n};\n\n箭头函数与普通函数的区别在于：\n\n1、箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值，这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this，\n\n2、箭头函数没有自己的 arguments 对象，但是可以访问外围函数的 arguments 对象3、不能通过 new 关键字调用，同样也没有 new.target 值和原型\n\n- ### setTimeout 和 Promise 的执行顺序\n\n参考回答：\n\n首先我们来看这样一道题：\n\n### setTimeout(function() {\n\n> console.log(1)\n\n> }, 0);\n\n> new Promise(function(resolve, reject) { console.log(2)\n\n> for (var i = 0; i \\< 10000; i++) { if(i === 10) {console.log(10)}\n\n> i == 9999 && resolve();\n\n> } console.log(3)\n\n> }).then(function() { console.log(4)\n\n> }) console.log(5);\n\n输出答案为 2 10 3 5 4 1\n\n要先弄清楚 settimeout（fun,0）何时执行，promise 何时执行，then 何时执行settimeout\n这种异步操作的回调，只有主线程中没有执行任何同步代码的前提下，才会执行异步回调，而 settimeout（fun,0）表示立刻执行，也就是用来改变任务的执行顺序，要求浏览器尽可能快的进行回调\n\npromise 何时执行，由上图可知 promise 新建后立即执行，所以 promise 构造函数里代码同步执行的，\n\nthen 方法指向的回调将在当前脚本所有同步任务执行完成后执行，\n\n那么 then 为什么比 settimeout 执行的早呢，因为 settimeout（fun,0）不是真的立即执行，\n\n经过测试得出结论：执行顺序为：同步执行的代码-》promise.then->settimeout\n\n- ### 有了解过事件模型吗，DOM0 级和 DOM2 级有什么区别，DOM 的分级是什么\n\n参考回答：\n\nJSDOM 事件流存在如下三个阶段： 事件捕获阶段\n\n处于目标阶段事件冒泡阶段\n\nJSDOM 标准事件流的触发的先后顺序为：先捕获再冒泡，点击 DOM 节点时，事件传播顺序：事件捕获阶段，从上往下传播，然后到达事件目标节点，最后是冒泡阶段，从下往上传播\n\nDOM 节点添加事件监听方法 addEventListener，中参数 capture 可以指定该监听是添加在事件捕获阶段还是事件冒泡阶段，为 false 是事件冒泡，为 true\n是事件捕获，并非所有的事件都支持冒泡，比如 focus，blur 等等，我们可以通过 event.bubbles 来判断\n\n事件模型有三个常用方法：\n\nevent.stopPropagation:阻止捕获和冒泡阶段中，当前事件的进一步传播， event.stopImmediatePropagetion，阻止调用相同事件的其他侦听器，\n\nevent.preventDefault，取消该事件（假如事件是可取消的）而不停止事件的进一步传播，\n\nevent.target：指向触发事件的元素，在事件冒泡过程中这个值不变event.currentTarget = this，时间帮顶的当前元素，只有被点击时目标元素的target 才会等于\ncurrentTarget，\n\n最后，对于执行顺序的问题，如果 DOM\n节点同时绑定了两个事件监听函数，一个用于捕获，一个用于冒泡，那么两个事件的执行顺序真的是先捕获在冒泡吗，答案是否定的，绑定在被点击元素的事件是按照代码添加顺序执行的，其他函数是先捕获再冒泡\n\n- ### 平时是怎么调试 JS 的\n\n参考回答：\n\n一般用 Chrome 自带的控制台\n\n- ### JS 的基本数据类型有哪些，基本数据类型和引用数据类型的区别，NaN 是什么的缩写，JS 的作用域类型，undefined==null 返回的结果是什么，undefined 与 null 的区别在哪，写一个函数判断变量类型\n\n参考回答：\n\nJS 的基本数据类型有字符串，数字，布尔，数组，对象，Null，Undefined,基本数据类型是按值访问的，也就是说我们可以操作保存在变量中的实际的值，\n\n基本数据类型和引用数据类型的区别如下：\n\n基本数据类型的值是不可变的，任何方法都无法改变一个基本类型的值，当这个变量重新赋值后看起来变量的值是改变了，但是这里变量名只是指向变量的一个指针，所以改变的是指针的指向改变，该变量是不变的，但是引用类型可以改变\n\n基本数据类型不可以添加属性和方法，但是引用类型可以\n\n基本数据类型的赋值是简单赋值，如果从一个变量向另一个变量赋值基本类型的值， 会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上，引用数据类型的赋值是对象引用，\n\n基本数据类型的比较是值的比较，引用类型的比较是引用的比较，比较对象的内存地址是否相同\n\n基本数据类型是存放在栈区的，引用数据类型同事保存在栈区和堆区\n\nNaN 是 JS 中的特殊值，表示非数字，NaN 不是数字，但是他的数据类型是数字，它不等于任何值，包括自身，在布尔运算时被当做 false，NaN 与任何数运算得到的结果都是\nNaN，党员算失败或者运算无法返回正确的数值的就会返回 NaN，一些数学函数的运算结果也会出现 NaN ,\n\nJS 的作用域类型：\n\n一般认为的作用域是词法作用域，此外 JS 还提供了一些动态改变作用域的方法，常见的作用域类型有：\n\n函数作用域，如果在函数内部我们给未定义的一个变量赋值，这个变量会转变成为一个全局变量，\n\n块作用域：块作用域吧标识符限制在{}中， 改变函数作用域的方法：\n\neval（），这个方法接受一个字符串作为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码，\n\nwith 关键字：通常被当做重复引用同一个对象的多个属性的快捷方式\n\nundefined 与 null：目前 null 和 undefined 基本是同义的，只有一些细微的差别， null 表示没有对象，undefined\n表示缺少值，就是此处应该有一个值但是还没有定义，因此 undefined==null 返回 false\n\n此外了解== 和===的区别：\n\n在做==比较时。不同类型的数据会先转换成一致后在做比较，===中如果类型不一致就直接返回 false，一致的才会比较\n\n类型判断函数，使用 typeof 即可，首先判断是否为 null，之后用 typeof 哦按段，如果是 object 的话，再用 array.isarray 判断是否为数组，如果是数字的话用\nisNaN 判断是否是 NaN 即可\n\n扩展学习：\n\nJS 采用的是词法作用域，也就是静态作用域，所以函数的作用域在函数定义的时候就决定了，\n\n看如下例子：\n\n### var value = 1; function foo() { console.log(value)\n\n> }\n\n> function bar() { var value = 2; foo();\n\n> } bar();\n\n假设 JavaScript 采用静态作用域，让我们分析下执行过程：\n\n执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。\n\n假设 JavaScript 采用动态作用域，让我们分析下执行过程：\n\n执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印\n2。前面我们已经说了，JavaScript 采用的是静态作用域，所以这个例子的结果是 1。\n\n- ### setTimeout(fn,100);100 毫秒是如何权衡的\n\n参考回答：\n\nsetTimeout()函数只是将事件插入了任务列表，必须等到当前代码执行完，主线程才会去执行它指定的回调函数，有可能要等很久，所以没有办法保证回调函数一定会在setTimeout\n指定的时间内执行，100 毫秒是插入队列的时间+等待的时间\n\n- ### JS 的垃圾回收机制\n\n参考回答：\n\nGC（garbage collection），GC 执行时，中断代码，停止其他操作，遍历所有对象， 对于不可访问的对象进行回收，在 V8 引擎中使用两种优化方法，\n\n分代回收，2、增量 GC，目的是通过对象的使用频率，存在时长来区分新生代和老生代对象，多回收新生代区，少回收老生代区，减少每次遍历的时间，从而减少 GC 的耗时回收方法：\n\n引用计次，当对象被引用的次数为零时进行回收，但是循环引用时，两个对象都至少被引用了一次，因此导致内存泄漏，\n\n标记清除\n\n- ### 写一个 newBind 函数，完成 bind 的功能\n\n参考回答：\n\n> bind（）方法，创建一个新函数，当这个新函数被调用时，bind（）的第一个参数将作为它运行时的\n> this，之后的一序列参数将会在传递的实参前传入作为它的参数Function.prototype.bind2 = function (context) {\n\n### if (typeof this !== \"function\") {\n\n> throw new Error(\"Function.prototype.bind - what is trying to be bound is not callable\");\n\n> }\n\n> var self = this;\n\n> var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () {};\n\n> var fbound = function () {\n\n> self.apply(this instanceof self ? this : context,\n> args.concat(Array.prototype.slice.call(arguments)));\n\n> }\n\n> fNOP.prototype = this.prototype; fbound.prototype = new fNOP(); return fbound;\n\n> }\n\n- ### 怎么获得对象上的属性：比如说通过 Object.key（）\n\n参考回答：\n\n从 ES5 开始，有三种方法可以列出对象的属性\n\nfor（let I in\nobj）该方法依次访问一个对象及其原型链中所有可枚举的类型object.keys:返回一个数组，包括所有可枚举的属性名称object.getOwnPropertyNames:返回一个数组包含不可枚举的属性\n\n- ### 简单讲一讲 ES6 的一些新特性\n\n参考回答：\n\nES6 在变量的声明和定义方面增加了 let、const 声明变量，有局部变量的概念，赋值中有比较吸引人的结构赋值，同时 ES6 对字符串、\n数组、正则、对象、函数等拓展了一些方法，如字符串方面的模板字符串、函数方面的默认参数、对象方面属性的简洁表达方式，ES6 也 引入了新的数据类型 symbol，新的数据结构 set 和\nmap,symbol 可以通过 typeof 检测出来，为解决异步回调问题，引入了 promise 和 generator，还有最为吸引人了实现 Class 和模块，通过 Class\n可以更好的面向对象编程，使用模块加载方便模块化编程，当然考虑到 浏览器兼容性，我们在实际开发中需要使用 babel 进行编译\n\n重要的特性：\n\n块级作用域：ES5 只有全局作用域和函数作用域，块级作用域的好处是不再需要立即执行的函数表达式，循环体中的闭包不再有问题\n\nrest 参数：用于获取函数的多余参数，这样就不需要使用 arguments 对象了， promise:一种异步编程的解决方案，比传统的解决方案回调函数和事件更合理强大\n模块化：其模块功能主要有两个命令构成，export 和 import，export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能\n\n- ### call 和 apply 是用来做什么？\n\n参考回答：\n\nCall 和 apply 的作用是一模一样的，只是传参的形式有区别而已1、改变 this 的指向\n\n2、借用别的对象的方法，\n\n3、调用函数，因为 apply，call 方法会使函数立即执行\n\n- ### 了解事件代理吗，这样做有什么好处\n\n参考回答：\n\n事件代理/事件委托：利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的事件，\n\n简而言之：事件代理就是说我们将事件添加到本来要添加的事件的父节点，将事件委托给父节点来触发处理函数，这通常会使用在大量的同级元素需要添加同一类事件的时候，比如一个动态的非常多的列表，需要为每个列表项都添加点击事件，这时就可以使用事件代理，通过判断\ne.target.nodeName 来判断发生的具体元素，这样做的好处是减少事件绑定，同事动态的 DOM 结构任然可以监听，事件代理发生在冒泡阶段\n\n- ### 如何写一个继承？\n\n参考回答： 原型链继承\n\n核心： 将父类的实例作为子类的原型特点：\n\n非常纯粹的继承关系，实例是子类的实例，也是父类的实例父类新增原型方法/原型属性，子类都能访问到\n\n简单，易于实现缺点：\n\n要想为子类新增属性和方法，不能放到构造器中无法实现多继承\n\n来自原型对象的所有属性被所有实例共享 创建子类实例时，无法向父类构造函数传参\n\n构造继承\n\n核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）\n\n特点：\n\n解决了子类实例共享父类引用属性的问题创建子类实例时，可以向父类传递参数 可以实现多继承（call 多个父类对象） 缺点：\n\n实例并不是父类的实例，只是子类的实例\n\n只能继承父类的实例属性和方法，不能继承原型属性/方法\n\n无法实现函数复用，每个子类都有父类实例函数的副本，影响性能\n\n实例继承\n\n核心：为父类实例添加新特性，作为子类实例返回特点：\n\n不限制调用方式，不管是 new 子类()还是子类(),返回的对象具有相同的效果\n\n缺点：\n\n实例是父类的实例，不是子类的实例不支持多继承\n\n拷贝继承特点：\n\n支持多继承缺点：\n\n效率较低，内存占用高（因为要拷贝父类的属性）\n\n组合继承\n\n核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n特点：\n\n可以继承实例属性/方法，也可以继承原型属性/方法既是子类的实例，也是父类的实例\n\n不存在引用属性共享问题可传参\n\n函数可复用\n\n寄生组合继承\n\n核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n参考 [_https://www.cnblogs.com/humin/p/4556820.html_](https://www.cnblogs.com/humin/p/4556820.html)\n\n- ### 给出以下代码，输出的结果是什么？原因？ for(var i=0;i\\<5;i++)\n\n> { setTimeout(function(){ console.log(i); },1000); } console.log(i)\n\n参考回答：\n\n在一秒后输出 5 个 5\n\n每次 for 循环的时候 setTimeout 都会执行，但是里面的 function 则不会执行被放入任务队列，因此放了 5 次；for 循环的 5 次执行完之后不到 1000 毫秒；1000\n毫秒后全部执行任务队列中的函数，所以就是输出 5 个 5。\n\n- ### 给两个构造函数 A 和 B，如何实现 A 继承 B？\n\n参考回答：\n\n### function A(...) {} A.prototype\n\n> function B(...) {} B.prototype... A.prototype = Object.create(B.prototype);\n\n> // 再在A 的构造函数里 new B(props); for(var i = 0; i \\< lis.length; i++) {\n\n> lis\\[i\\].addEventListener('click', function(e) { alert(i);\n\n> }, false)\n\n> }\n\n- ### 问能不能正常打印索引\n\n参考回答：\n\n在 click 的时候，已经变成 length 了\n\n- ### 如果已经有三个 promise，A、B 和 C，想串行执行，该怎么写？\n\n参考回答：\n\n### // promise A.then(B).then(C).catch(...)\n\n> // async/await (async ()=>{ await a(); await b(); await c();\n\n> })()\n\n- ### 知道 private 和 public 吗\n\n参考回答：\n\npublic：public 表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用\n\nprivate：private 表示私有，私有的意思就是除了 class 自己之外，任何人都不可以直接使用\n\n- ### 基础的 js\n\n参 考 回 答 ： Function.prototype.a = 1; Object.prototype.b = 2; function A() {}\n\nvar a = new A();\n\nconsole.log(a.a, a.b); // undefined, 2 console.log(A.a, A.b); // 1, 2\n\n- ### async 和 await 具体该怎么用？\n\n参考回答：\n\n### (async () = \\> { await new promise()\n\n> })()\n\n- ### 知道哪些 ES6，ES7 的语法\n\n参考回答：\n\npromise，await/async，let、const、块级作用域、箭头函数\n\n- ### promise 和 await/async 的关系\n\n参考回答：\n\n都是异步编程的解决方案\n\n- ### JS 的数据类型\n\n参考回答：\n\n字符串，数字，布尔，数组，null，Undefined，symbol，对象。\n\n- ### JS 加载过程阻塞，解决方法\n\n参考回答：\n\n指定 script 标签的 async 属性。\n\n如果 async=\"async\"，脚本相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本将被执行）\n\n如果不使用 async 且 defer=\"defer\"：脚本将在页面完成解析时执行\n\n- ### JS 对象类型，基本对象类型以及引用对象类型的区别\n\n参考回答：\n\n分为基本对象类型和引用对象类型\n\n基本数据类型：按值访问，可操作保存在变量中的实际的值。基本类型值指的是简单的数据段。基本数据类型有这六种:undefined、null、string、number、boolean、symbol。\n\n引用类型：当复制保存着对象的某个变量时，操作的是对象的引用，但在为对象添加属性时，操作的是实际的对象。引用类型值指那些可能为多个值构成的对象。\n\n引用类型有这几种：Object、Array、RegExp、Date、Function、特殊的基本包装类型\n\n(String、Number、Boolean)以及单体内置对象(Global、Math)。\n\n- ### JavaScript 中的轮播实现原理？假如一个页面上有两个轮播，你会怎么实现？\n\n参考回答：\n\n图片轮播的原理就是图片排成一行，然后准备一个只有一张图片大小的容器，对这个容器设置超出部分隐藏，在控制定时器来让这些图片整体左移或右移，这样呈现出来的效果就是图片在轮播了。\n\n如果有两个轮播，可封装一个轮播组件，供两处调用\n\n- ### 怎么实现一个计算一年中有多少周？\n\n参考回答：\n\n首先你得知道是不是闰年，也就是一年是 365 还是 366.\n\n其次你得知道当年 1 月 1 号是周几。假如是周五，一年 365 天把 1 号 2 号 3 号减去， 也就是把第一个不到一周的天数减去等于 362\n\n还得知道最后一天是周几，加入是周五，需要把周一到周五减去，也就是 362-5=357.\n\n正常情况 357 这个数计算出来是 7 的倍数。357/7=51 。即为周数。\n\n- ### 面向对象的继承方式\n\n参考回答： 原型链继承\n\n核心： 将父类的实例作为子类的原型特点：\n\n非常纯粹的继承关系，实例是子类的实例，也是父类的实例父类新增原型方法/原型属性，子类都能访问到\n\n简单，易于实现缺点：\n\n要想为子类新增属性和方法，不能放到构造器中无法实现多继承\n\n来自原型对象的所有属性被所有实例共享 创建子类实例时，无法向父类构造函数传参\n\n构造继承\n\n核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）\n\n特点：\n\n解决了子类实例共享父类引用属性的问题创建子类实例时，可以向父类传递参数 可以实现多继承（call 多个父类对象） 缺点：\n\n实例并不是父类的实例，只是子类的实例\n\n只能继承父类的实例属性和方法，不能继承原型属性/方法\n\n无法实现函数复用，每个子类都有父类实例函数的副本，影响性能\n\n实例继承\n\n核心：为父类实例添加新特性，作为子类实例返回特点：\n\n不限制调用方式，不管是 new 子类()还是子类(),返回的对象具有相同的效果\n\n缺点：\n\n实例是父类的实例，不是子类的实例不支持多继承\n\n拷贝继承特点：\n\n支持多继承\n\n缺点：\n\n效率较低，内存占用高（因为要拷贝父类的属性）\n\n组合继承\n\n核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n特点：\n\n可以继承实例属性/方法，也可以继承原型属性/方法既是子类的实例，也是父类的实例\n\n不存在引用属性共享问题可传参\n\n函数可复用\n\n寄生组合继承\n\n核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n参考 [_https://www.cnblogs.com/humin/p/4556820.html_](https://www.cnblogs.com/humin/p/4556820.html)\n\n- ### JS 的数据类型\n\n参考回答：\n\n字符串，数字，布尔，数组，null，Undefined，symbol，对象。\n\n- ### 引用类型常见的对象\n\n参考回答：\n\nObject、Array、RegExp、Date、Function、特殊的基本包装类型(String、Number、Boolean)以及单体内置对象(Global、Math)等\n\n- ### es6 的常用\n\n参考回答：\n\npromise，await/async，let、const、块级作用域、箭头函数\n\n- ### class\n\n参考回答：\n\nES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过 class 关键字，可以定义类。\n\n- ### 口述数组去重\n\n参考回答：\n\n法一：indexOf 循环去重\n\n法二：ES6 Set 去重；Array.from(new Set(array))\n\n法三：Object 键值对去重；把数组的值存成 Object 的 key 值，比如Object\\[value1\\] = true，在判断另一个值的时候，如果 Object\\[value2\\]存在的话，\n就说明该值是重复的。\n\n- ### 继承\n\n参考回答： 原型链继承\n\n核心： 将父类的实例作为子类的原型特点：\n\n非常纯粹的继承关系，实例是子类的实例，也是父类的实例父类新增原型方法/原型属性，子类都能访问到\n\n简单，易于实现缺点：\n\n要想为子类新增属性和方法，不能放到构造器中无法实现多继承\n\n来自原型对象的所有属性被所有实例共享 创建子类实例时，无法向父类构造函数传参\n\n构造继承\n\n核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）\n\n特点：\n\n解决了子类实例共享父类引用属性的问题创建子类实例时，可以向父类传递参数 可以实现多继承（call 多个父类对象） 缺点：\n\n实例并不是父类的实例，只是子类的实例\n\n只能继承父类的实例属性和方法，不能继承原型属性/方法\n\n无法实现函数复用，每个子类都有父类实例函数的副本，影响性能\n\n实例继承\n\n核心：为父类实例添加新特性，作为子类实例返回特点：\n\n不限制调用方式，不管是 new 子类()还是子类(),返回的对象具有相同的效果\n\n缺点：\n\n实例是父类的实例，不是子类的实例不支持多继承\n\n拷贝继承特点：\n\n支持多继承缺点：\n\n效率较低，内存占用高（因为要拷贝父类的属性）\n\n组合继承\n\n核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n特点：\n\n可以继承实例属性/方法，也可以继承原型属性/方法既是子类的实例，也是父类的实例\n\n不存在引用属性共享问题可传参\n\n函数可复用\n\n寄生组合继承\n\n核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n参考 [_https://www.cnblogs.com/humin/p/4556820.html_](https://www.cnblogs.com/humin/p/4556820.html)\n\n- ### call 和 apply 的区别\n\n参考回答：\n\napply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即 A 对象应用B 对象的方法。\n\ncall：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即 A 对象调用B 对象的方法。\n\n- ### es6 的常用特性\n\n参考回答：\n\npromise，await/async，let、const、块级作用域、箭头函数\n\n- ### 箭头函数和 function 有什么区别\n\n参考回答：\n\n箭头函数根本就没有绑定自己的 this，在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用\n\n- ### new 操作符原理\n\n参考回答：\n\n1. 创建一个类的实例：创建一个空对象 obj，然后把这个空对象的 proto 设置为构造函数的 prototype。\n\n2. 初始化实例：构造函数被传入参数并调用，关键字 this 被设定指向该实例 obj。\n\n3. 返回实例 obj。\n\n- ### bind,apply,call\n\n参考回答：\n\napply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即 A 对象应用B 对象的方法。\n\ncall：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即 A 对象调用B 对象的方法。\n\nbind 除了返回是函数以外，它的参数和 call 一样。\n\n- ### bind 和 apply 的区别\n\n参考回答：\n\n返回不同：bind 返回是函数\n\n参数不同：apply(A, arguments)，bind(A, args1,args2)\n\n- ### 数组的去重\n\n参考回答：\n\n法一：indexOf 循环去重\n\n法二：ES6 Set 去重；Array.from(new Set(array))\n\n法三：Object 键值对去重；把数组的值存成 Object 的 key 值，比如Object\\[value1\\] = true，在判断另一个值的时候，如果 Object\\[value2\\]存在的话，\n就说明该值是重复的。\n\n- ### 闭包\n\n参考回答：\n\n1. 什么是闭包：\n\n闭包是指有权访问另外一个函数作用域中的变量的函数。\n\n闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。当在一个函数内定义另外一个函数就会产生闭包。\n\n2. 为什么要用：\n\n匿名自执行函数：我们知道所有的变量，如果不加上 var 关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可\n\n能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用 var\n关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，可以用闭包。 结果缓存：我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对\n象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。\n\n- ### promise 实现\n\n参 考 回 答 ： Promise 实现如下\n\n### function Promise(fn) { var state = 'pending', value = null, callbacks = \\[\\]\n\n> this.then = function (onFulfilled, onRejected) { return new Promise(function (resolve, reject) {\n> handle({\n\n> onFulfilled: onFulfilled \\|\\| null, onRejected: onRejected \\|\\| null, resolve: resolve,\n\n> reject: reject\n\n> });\n\n> });\n\n> };\n\n> function handle(callback) { if (state === 'pending') { callbacks.push(callback); return;\n\n> }\n\n> var cb = state === 'fulfilled' ? callback.onFulfilled : callback.onRejected,\n\n> ret;\n\n> if (cb === null) {\n\n> cb = state === 'fulfilled' ? callback.resolve : callback.reject; cb(value);\n\n> return;\n\n> }\n\n> ret = cb(value); callback.resolve(ret);\n\n> }\n\n> function resolve(newValue) {\n\n> if (newValue && (typeof newValue === 'object' \\|\\| typeof newValue === 'function')) {\n\n> var then = newValue.then;\n\n> if (typeof then === 'function') { then.call(newValue, resolve, reject); return;\n\n> }\n\n> }\n\n> state = 'fulfilled'; value = newValue; execute();\n\n> }\n\n> function reject(reason) { state = 'rejected';\n\n> value = reason; execute();\n\n> }\n\n> function execute() { setTimeout(function () { callbacks.forEach(function (callback) {\n> handle(callback);\n\n> });\n\n> }, 0);\n\n> }\n\n> fn(resolve, reject);\n\n> }\n\n- ### assign 的深拷贝\n\n参考回答：\n\n### function clone( obj ) { var copy\n\n> switch( typeof obj ) { case \"undefined\": break;\n\n> case \"number\": copy = obj - 0; break;\n\n> case \"string\": copy = obj + \"\"; break;\n\n> case \"boolean\":\n\n> copy = obj; break;\n\ncase \"object\": //object 分为两种情况 对象（Object）和数组（Array）\n\n- ### 说 promise，没有 promise 怎么办\n\n参考回答：\n\n没有 promise，可以用回调函数代替\n\n- ### 事件委托\n\n参考回答：\n\n把一个元素响应事件（click、keydown. ）的函数委托到另一个元素；\n\n优点：减少内存消耗、动态绑定事件。\n\n- ### 箭头函数和 function 的区别\n\n参考回答：\n\n箭头函数根本就没有绑定自己的 this，在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用\n\n- ### arguments\n\n参考回答：\n\narguments 是类数组对象，有 length 属性，不能调用数组方法可用 Array.from()转换\n\n- ### 箭头函数获取 arguments\n\n参考回答：\n\n可用…rest 参数获取\n\n- ### Promise\n\n参考回答：\n\nPromise 对象是 CommonJS 工作组提出的一种规范，目的是为异步编程提供统一接口。每一个异步任务返回一个 Promise 对象，该对象有一个 then 方法，允许指定回调函数。\n\nf1().then(f2);\n\n一个 promise 可能有三种状态：等待（pending）、已完成（resolved，又称\n\nfulfilled）、已拒绝（rejected）。\n\npromise 必须实现 then 方法（可以说，then 就是 promise 的核心），而且 then 必须返回一个 promise，同一个 promise 的 then\n可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致。\n\nthen 方法接受两个参数，第一个参数是成功时的回调，在 promise 由“等待”态转换到“完成”态时调用，另一个是失败时的回调，在 promise\n由“等待”态转换到“拒绝”态时调用。同时，then 可以接受另一个 promise 传入，也接受一个“类then”的对象或方法，即 thenable 对象。\n\n- ### 事件代理\n\n参考回答：\n\n事件代理是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div>ul>li>a; 比如给最里面的a 加一个 click\n点击事件，那么这个事件就会一层一层的往外执行， 执行顺序 a>li>ul>div，有这样一个机制，那么我们给最外面的 div 加点击事件，那么里面的 ul，li，a\n做点击事件的时候，都会冒泡到最外层的 div 上，所以都会触发， 这就是事件代理，代理它们父级代为执行事件。\n\n- ### Eventloop\n\n参考回答：\n\n任务队列中，在每一次事件循环中，macrotask 只会提取一个执行，而 microtask 会一直提取，直到 microsoft 队列为空为止。\n\n也就是说如果某个 microtask 任务被推入到执行中，那么当主线程任务执行完成后， 会循环调用该队列任务中的下一个任务来执行，直到该任务队列到最后一个任务为 止。而事件循环每次只会入栈一个\nmacrotask,主线程执行完成该任务后又会检查microtasks 队列并完成里面的所有任务后再执行macrotask 的任务。\n\nmacrotasks: setTimeout, setInterval, setImmediate, I/O, UI rendering microtasks: process.nextTick,\nPromise, MutationObserver\n\n# 2 \\| 前端核心\n\n1. ## | 服务端编程\n\n- ### JSONP 的缺点\n\n参考回答：\n\nJSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。\n\n- ### 跨域（jsonp，ajax）\n\n参考回答：\n\nJSONP：ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数\n\n据，而是返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。\n\n- ### 如何实现跨域\n\n参考回答：\n\nJSONP：通过动态创建 script，再请求一个带参网址实现跨域通信。document.domain\n\n- iframe 跨域：两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域。\n\nlocation.hash + iframe 跨域：a 欲与b 跨域相互通信，通过中间页c 来实现。 三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 js\n访问来通信。\n\nwindow.name + iframe 跨域：通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。\n\npostMessage 跨域：可以跨域操作的 window 属性之一。\n\nCORS：服务端设置 Access-Control-Allow-Origin 即可，前端无须设置，若要带\n\ncookie 请求，前后端都需要设置。\n\n代理跨域：起一个代理服务器，实现数据的转发\n\n- ### dom 是什么，你的理解？\n\n参考回答：\n\n文档对象模型（Document Object Model，简称 DOM），是 W3C\n组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为 DOM。\n\n- ### 关于 dom 的 api 有什么\n\n参考回答：\n\n节点创建型 api，页面修改型 API，节点查询型 API，节点关系型 api，元素属性型api，元素样式型 api 等\n\n2. ## | Ajax\n\n- ### ajax 返回的状态\n\n参考回答：\n\n0 － （未初始化）还没有调用 send()方法\n\n1 － （载入）已调用 send()方法，正在发送请求\n\n2 － （载入完成）send()方法执行完成，已经接收到全部响应内容\n\n3 － （交互）正在解析响应内容\n\n4 － （完成）响应内容解析完成，可以在客户端调用了\n\n- ### 实现一个 Ajax\n\n参考回答：\n\nAJAX 创建异步对象 XMLHttpRequest\n\n操作 XMLHttpRequest 对象\n\n1. 设置请求参数（请求方式，请求页面的相对路径，是否异步）\n\n2. 设置回调函数，一个处理服务器响应的函数，使用 onreadystatechange ，类似函数指针\n\n3. 获取异步对象的 readyState 属性：该属性存有服务器响应的状态信息。每当readyState 改变时，onreadystatechange 函数就会被执行。\n\n4. 判断响应报文的状态，若为 200 说明服务器正常运行并返回响应数据。\n\n5. 读取响应数据，可以通过 responseText 属性来取回由服务器返回的数据。\n\n- ### 如何实现 ajax 请求，假如我有多个请求，我需要让这些 ajax 请求按照某种顺序一次执行，有什么办法呢？如何处理 ajax 跨域\n\n参考回答：\n\n通过实例化一个 XMLHttpRequest 对象得到一个实例，调用实例的 open 方法为这次ajax 请求设定相应的 http 方法，相应的地址和是否异步，以异步为例，调用 send\n方法，这个方法可以设定需要发送的报文主体，然后通过监听 readystatechange 事件， 通过这个实例 的 readyState 属性来判断这个 ajax 请求状态，其中分为 0，1，2，3，\n4 这四种状态（0 未初始化，1 载入/正在发送请求 2 载入完成/数据接收，3 交互/解析数据，4 接收数据完成），当状态为 4 的时候也就是接受数据完成的时候，这时候可以通过实例的 status\n属性判断这个请求是否成功\n\n### var xhr = new XMLHttpRequest(); xhr.open('get', 'aabb.php', true); xhr.send(null); xhr.onreadystatechange = function() { if(xhr.readyState==4) { if(xhr.status==200) { console.log(xhr.responseText)\n\n> }\n\n> }\n\n> }\n\n使 ajax 请求按照队列顺序执行，通过调用递归函数：\n\n//按顺序执行多个 ajax 命令，因为数量不定，所以采用递归\n\n### function send(action, arg2) {\n\n> //将多个命令按顺序封装成数组对象，递归执行\n\n> //利用了 deferred 对象控制回调函数的特点\n\n> $.when(send_action(action\\[0\\], arg2))\n\n> .done(function () {\n\n> //前一个 ajax 回调函数完毕之后判断队列长度\n\n> if (action.length \\> 1) {\n\n> //队列长度大于 1，则弹出第一个，继续递归执行该队列\n\n> action.shift();\n\n> send(action, arg2);\n\n> }\n\n> }).fail(function (){\n\n> //队列中元素请求失败后的逻辑\n\n> //\n\n> //重试发送\n\n> //send(action, arg2);\n\n> //\n\n> //忽略错误进行下个\n\n> //if (action.length \\> 1) {\n\n> //队列长度大于 1，则弹出第一个，继续递归执行该队列\n\n> // action.shift();\n\n> // send(action, arg2);\n\n> //}\n\n> });\n\n> }\n\n> //处理每个命令的 ajax 请求以及回调函数function send_action(command, arg2) {\n\n> var dtd = \\$.Deferred();//定义 deferred 对象\n\n> $.post( \"url\",\n\n> {\n\n> command: command, arg2: arg2\n\n> }\n\n> ).done(function (json) { json = \\$.parseJSON(json);\n\n> //每次请求回调函数的处理逻辑\n\n> //\n\n> //\n\n> //\n\n> //逻辑结束\n\n> dtd.resolve();\n\n> }).fail(function (){\n\n> //ajax 请求失败的逻辑dtd.reject();\n\n> });\n\n> return dtd.promise();//返回 Deferred 对象的 promise，防止在外部\n\n- ### 写出原生 Ajax\n\n参考回答：\n\nAjax 能够在不重新加载整个页面的情况下与服务器交换数据并更新部分网页内容，实现局部刷新，大大降低了资源的浪费，是一门用于快速创建动态网页的技术，ajax 的使用分为四部分：\n\n1、创建 XMLHttpRequest 对象 var xhr = new XMLHttpRequest();\n\n2、向服务器发送请求，使用 xmlHttpRequest 对象的 open 和 send 方法， 3、监听状态变化，执行相应回调函数\n\n### var xhr = new XMLHttpRequest(); xhr.open('get', 'aabb.php', true); xhr.send(null); xhr.onreadystatechange = function() { if(xhr.readyState==4) { if(xhr.status==200) { console.log(xhr.responseText)\n\n> }\n\n> }\n\n> }\n\n- ### 如何实现一个 ajax 请求？如果我想发出两个有顺序的 ajax 需要怎么做？\n\n参考回答：\n\nAJAX 创建异步对象 XMLHttpRequest\n\n操作 XMLHttpRequest 对象\n\n1. 设置请求参数（请求方式，请求页面的相对路径，是否异步）\n\n2. 设置回调函数，一个处理服务器响应的函数，使用 onreadystatechange ，类似函数指针\n\n3. 获取异步对象的 readyState 属性：该属性存有服务器响应的状态信息。每当readyState 改变时，onreadystatechange 函数就会被执行。\n\n4. 判断响应报文的状态，若为 200 说明服务器正常运行并返回响应数据。\n\n5. 读取响应数据，可以通过 responseText 属性来取回由服务器返回的数据。\n\n发出两个有顺序的 ajax，可以用回调函数，也可以使用 Promise.then 或者 async 等。\n\n- ### Fetch 和 Ajax 比有什么优缺点？\n\n参考回答：\n\npromise 方便异步，在不想用 jQuery 的情况下，相比原生的 ajax，也比较好写。\n\n- ### 原生 JS 的 ajax\n\n参考回答：\n\nAJAX 创建异步对象 XMLHttpRequest\n\n操作 XMLHttpRequest 对象\n\n1. 设置请求参数（请求方式，请求页面的相对路径，是否异步）\n\n2. 设置回调函数，一个处理服务器响应的函数，使用 onreadystatechange ，类似函数指针\n\n3. 获取异步对象的 readyState 属性：该属性存有服务器响应的状态信息。每当readyState 改变时，onreadystatechange 函数就会被执行。\n\n4. 判断响应报文的状态，若为 200 说明服务器正常运行并返回响应数据。\n\n5. 读取响应数据，可以通过 responseText 属性来取回由服务器返回的数据。\n\n6. ## | 移动 web 开发\n\n- ### 知道 PWA 吗\n\n参考回答：\n\nPWA 全称 Progressive Web App，即渐进式 WEB 应用。一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和\nService Worker 来实现 PWA 的安装和离线等功能\n\n- ### 移动布局方案\n\n参 考 回 答 ：\n[_https://juejin.im/post/599970f4518825243a78b9d5#heading-22_](https://links.jianshu.com/go?to=https%3A%2F%2Fjuejin.im%2Fpost%2F599970f4518825243a78b9d5%23heading-22)\n\n> ![](media/image9.jpeg)\n\n- ### Rem, Em\n\n参 考 回 答 ：\n[_https://blog.csdn.net/romantic_love/article/details/80875462_](https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fromantic_love%2Farticle%2Fdetails%2F80875462)\n一、rem 单位如何转换为像素值\n\n1. 当使用 rem 单位的时候，页面转换为像素大小取决于叶根元素的字体大小，即 HTML 元素的字体大小。根元素字体大小乘 rem 的值。例如，根元素的字体大小为 16px，那么 10rem\n   就等同于 10\\*16=160px。\n\n二、em 是如何转换成 px 的\n\n当使用 em 单位的时候，像素值是将 em 值乘以使用 em 单位的元素的字体大小。例如一个 div 的字体为 18px，设置它的宽高为 10em，那么此时宽高就是 18px\\*10em=180px。\n\n### .test{\n\n> width: 10em;\n\n> height: 10em;\n\n> background-color: #ff7d42;\n\n> font-size: 18px;\n\n> }\n\n一定要记住的是，em 是根据使用它的元素的 font-size 的大小来变化的，而不是根据父元素字体大小。有些元素大小是父元素的多少倍那是因为继承了父元素中 font-size\n的设定，所以才起到的作用。\n\n2. em 单位的继承效果。\n\n使用 em 单位存在继承的时候，每个元素将自动继承其父元素的字体大小，继承的效果只能被明确的字体单位覆盖，比如 px 和 vw。只要父级元素上面一直有 fontsize 为 em\n单位，则会一直继承，但假如自己设置了 font-size 的单位为 px 的时候，则会直接使用自己的 px 单位的值。\n\n三、根 html 的元素将会继承浏览器中设置的字体大小\n\n除非显式的设置固定值去覆盖。所以 html 元素的字体大小虽然是直接确定 rem 的值， 但这个字体大小首先是来源于浏览器的设置。（所以一定要设置 html\n的值的大小，因为有可能用户的浏览器字体大小是不一致的。）\n\n四、当 em 单位设置在 html 元素上时\n\n它将转换为 em 值乘以浏览器字体大小的设置。例如：\n\n### html{\n\n> font-size: 1.5em;\n\n> }\n\n可以看到，因为浏览器默认字体大小为 16px，所以当设置 HTML 的 fontsize 的值为\n\n5. em 的售后，其对应的 px 的值为 16\\*1.5=24px\n\n所以此时，再设置其他元素的 rem 的值的时候，其对应的像素值为 n\\*24px。\n\n例如，test 的 rem 的值为 10，\n\n### .test{\n\n> width: 10rem;\n\n> height: 10rem;\n\n> background-color: #ff7d42;\n\n> }\n\n![](media/image10.jpeg)\n\n可以看到 test 的 font-size 继承了 html 的值 24px，而此时宽高为 24\\*10=240px\n\n总结\n\n1. rem 单位翻译为像素值的时候是由 html 元素的字体大小决定的。此字体大小会被浏览器中字体大小的设置影响，除非显式的在 html 为 font-size 重写一个单位。\n\n2. em 单位转换为像素值的时候，取决于使用它们的元素的 font-size 的大小，但是有因为有继承关系，所以比较复杂。\n\n优缺点\n\nem 可以让我们的页面更灵活，更健壮，比起到处写死的 px 值，em 似乎更有张力，改动父元素的字体大小，子元素会等比例变化，这一变化似乎预示了无限可能,\n\nem 做弹性布局的缺点还在于牵一发而动全身，一旦某个节点的字体大小发生变化，那么其后代元素都得重新计算\n\n- ### flex 布局及优缺点\n\n参 考 回 答 ：\n[_https://juejin.im/post/599970f4518825243a78b9d5#heading-22_](https://links.jianshu.com/go?to=https%3A%2F%2Fjuejin.im%2Fpost%2F599970f4518825243a78b9d5%23heading-22)\n\ncss3 引入的，flex 布局；优点在于其容易上手，根据 flex 规则很容易达到某个布局效果，然而缺点是：浏览器兼容性比较差，只能兼容到 ie9 及以上；\n\n![](media/image11.jpeg)\n\n![](media/image12.jpeg)\n\n- ### Rem 布局及其优缺点\n\n参考回答：\n\n首先 Rem 相对于根(html)的 font-size 大小来计算。简单的说它就是一个相对单例如:font-size:10px;,那么（1rem = 10px）了解计算原理后\n\n首先解决怎么在不同设备上设置 html 的 font-size 大小。其实 rem 布局的本质是等比缩放，一般是基于宽度。\n\n优点\n\n可以快速适用移动端布局 字体图片 高度缺点\n\n①目前 ie 不支持，对 pc 页面来讲使用次数不多；\n\n②数据量大：所有的图片，盒子都需要我们去给一个准确的值；才能保证不同机型的适配；\n\n③在响应式布局中，必须通过 js 来动态控制根元素 font-size 的大小。\n\n也就是说 css 样式和 js 代码有一定的耦合性。且必须将改变 font-size 的代码放在\n\ncss 样式之前。\n\n- ### 百分比布局\n\n参考回答： 1、具体分析\n\n除了用 px 结合媒体查询实现响应式布局外，我们也可以通过百分比单位 \" % \"\n来实现响应式的效果。比如当浏览器的宽度或者高度发生变化时，通过百分比单位，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。为了了解百分比布局，首先要了解的问题是：css\n中的子元素中的百分比\n\n（%）到底是谁的百分比？\n\n直观的理解，我们可能会认为子元素的百分比完全相对于直接父元素，height 百分比相对于 height，width 百分比相对于 width。当然这种理解是正确的，但是根据 css 的盒式模型，除了\nheight、width 属性外，还具有 padding、border、margin 等等属\n\n性。那么这些属性设置成百分比，是根据父元素的那些属性呢？此外还有 border- radius 和 translate 等属性中的百分比，又是相对于什么呢？下面来具体分析。\n\npadding、border、margin 等等属不论是垂直方向还是水平方向，都相对于直接父元素的 width。\n\n除了 border-radius 外，还有比如 translate、background-size 等都是相对于自身的。\n\n2、百分比单位布局应用\n\n比如我们要实现一个固定长宽比的长方形，比如要实现一个长宽比为 4:3 的长方形,我们可以根据 padding 属性来实现，因为 padding\n不管是垂直方向还是水平方向，百分比单位都相对于父元素的宽度，因此我们可以设置 padding-top 为百分比来实现，长宽自适应的长方形：\n\n### .trangle{\n\n> height:0;\n\n> width:100%;\n\n> padding-top:75%;\n\n> }\n\n3、百分比单位缺点\n\n从上述对于百分比单位的介绍我们很容易看出如果全部使用百分比单位来实现响应式的布局，有明显的以下两个缺点：\n\n1. 计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。\n\n2. 从小节 1 可以看出，各个属性中如果使用百分比，相对父元素的属性并不是唯一的。比如 width 和 height 相对于父元素的 width 和 height，而 margin、padding\n   不管垂直还是水平方向都相对比父元素的宽度、border-radius 则是相对于元素自身等等， 造成我们使用百分比单位容易使布局问题变得复杂。\n\n![](media/image13.jpeg) ![](media/image14.jpeg)\n\n- ### 移动端适配 1px 的问题\n\n参 考 回 答 ：\n[_https://blog.csdn.net/weixin_43675871/article/details/84023447_](https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fweixin_43675871%2Farticle%2Fdetails%2F84023447)\n首先，我们了解 devicePixelRatio（DPR）这个东西\n\n### 在 window 对象中有一个 devicePixelRatio 属性，他可以反应 css 中的像素与设备的像素比。然而 1px 在不同的移动设备上都等于这个移动设备的 1px，这是因为不同的移动设备有不同的像素密度。有关这个属性，它的官方的定义 为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素 1px 变粗的原因：viewport 的设置和屏幕物理分辨率是按比例而不是相同的. 移动端 window 对象有个 devicePixelRatio 属性,它表示设备\n\n> 物理像素和 css 像素的比例, 在 retina 屏的iphone 手机上, 这个值为 2 或\n\n> 3,css 里写的 1px 长度映射到物理像素上就有 2px 或 3px 那么长\n\n1. 用小数来写 px 值 （不推荐）\n\nIOS8 下已经支持带小数的 px 值, media query 对应 devicePixelRatio 有个查询值 - webkit-min-device-pixel-ratio, css\n可以写成这样\n\n通过-webkit-min-device-pixel-ratio 设置。\n\n### .border { border: 1px solid #999 }\n\n> @media screen and (-webkit-min-device-pixel-ratio: 2) {\n\n> .border { border: 0.5px solid #999 }\n\n> }\n\n> @media screen and (-webkit-min-device-pixel-ratio: 3) {\n\n> .border { border: 0.333333px solid #999 }\n\n> }\n\n如果使用 less/sass 的话只是加了 1 句 mixin\n\n缺点: 安卓与低版本 IOS 不适用, 这个或许是未来的标准写法, 现在不做指望 2、flexible.js\n\n这是淘宝移动端采取的方案, github\n的地址:[_https://github.com/amfe/lib-_](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Famfe%2Flib-flexible)\n[_flexible_](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Famfe%2Flib-flexible). 前面已经说过\n1px 变粗的原因就在于一刀切的设置 viewport 宽度, 如果能把 viewport 宽度设置为实际的设备物理宽度, css 里的 1px 不就等于实际 1px 长了么. flexible.js\n就是这样干的.\n\n<meta name=”viewport”>里面的 scale 值指的是对 ideal viewport 的缩放, flexible.js 检测到 IOS 机型, 会算出 scale =\n1/devicePixelRatio, 然后设置viewport\n\n3、伪类+transform 实现\n\n对于解决 1px 边框问题，我个人觉得最完美的解决办法还是伪类+transform 比较好。原理：是把原先元素的 border 去掉，然后利用 :before 或者 :after 重做\n\nborder ，并 transform 的 scale 缩小一半，原先的元素相对定位，新做的 border\n\n绝对定位。media query\n\n通过媒体查询，可以通过给不同分辨率的设备编写不同的样式来实现响应式的布局， 比如我们为不同分辨率的屏幕，设置不同的背景图片。比如给小屏幕手机设置@2x 图， 为大屏幕手机设置@3x\n图，通过媒体查询就能很方便的实现。\n\n但是媒体查询的缺点也很明显，如果在浏览器大小改变时，需要改变的样式太多，那么多套样式代码会很繁琐。\n\n### @media screen and (min-width: 320px) {\n\n> html {\n\n> font-size: 50px;\n\n> }\n\n> }\n\n@media\n\n方便应用广泛 适用于 pc 端 手机页面，通常做自适应布局时 我们比较常用。缺点：相对于代码要重复很多，得知道设备的宽度，手机的分辨率很多所以麻烦了点，不过性能方面肯定最高； 可能存在闪屏的问题\n\n@media 处理手机和 pc 端界面兼容的问题，在 IE 上的访问出现问题，百度方法，找找两 种 ， 一 种 是 respond.js， 另 一 种 是\n[_css3-_](https://links.jianshu.com/go?to=css3-mediaquerieshttp%3A%2F%2Fblog.csdn.net%2Fsmall_tu%2Farticle%2Fdetails%2F47317453)\n[_mediaquerieshttp://blog.csdn.net/small_tu/article/details/47317453_](https://links.jianshu.com/go?to=css3-mediaquerieshttp%3A%2F%2Fblog.csdn.net%2Fsmall_tu%2Farticle%2Fdetails%2F47317453)\n\n- ### 移动端性能优化相关经验\n\n参 考 回 答 ：\n[_https://blog.csdn.net/tangxiujiang/article/details/79791545_](https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Ftangxiujiang%2Farticle%2Fdetails%2F79791545)\n\n- ### toB 和 toC 项目的区别\n\n参考回答：\n\nto B（business）即面向企业，to C（ customer）即面向普通用户\n\n简单的事情重复去做，重复的事情用心去做，长期坚持，自然功成，无论是 B 端还是C\n\n端都同样适用。Tob 与 Toc 的区别\n\n作者 猪八戒网 • 10-11 10:18:49 阅读 419 oB 产品价值何来？\n\n最近团队在 toB 产品研究的过程中，得出结论，相对于 toC 产品与服务，toC 产品更注重产品用户的共性而淡化角色关系，而 toB 产品则更强调面向用户、客户的角色关\n\n系，而淡化共性提取。实际上，这是由服务对象所引起的，C 端产品的服务对象，由终端所限，是一个面向个体的服务。而B 端服务使用最终是面向一个系统体系组织，在干系人间配合使用中发挥产品价值。\n\n一个好的产品 toB 可以让组织的系统变得更好，最终反哺于系统中的各个单位。需求动力之不同 toC\n的产品方法论，用户体验是几乎最为重要的需求来源，腾讯此前，也以\"以用户体验为归依\"来驱动企业产品打造。\n\n但B 端产品则不同，B 端在一个商业的背景之下，B 端的决策思路是，\"以企业获益为归依\"，系统是否有利于企业的生产力，竞争力等，单纯的用户体验，仅能让员工得到片刻的享受，\n但无法说服企业，企业并不会为一个不能\"赚钱\"的东西买单。\n\n需求动力的不同，引发的这是购买使用决策体系的变化。\n\ntoB 产品应更考虑 获益与系统性价值，部分情况还有可能会牺牲掉局部个体的利益， 对于使用者而言应该是自律或他律的，toC\n产品则更考虑的是个体用户的偏好，并长时间内，基于技术效率的提升，产品的服务中心更多地围绕着更高效地帮助用户的\"欲望\"释放进行设计，对于使用者而言是一个释放自我的存在。\n\n- ### 移动端兼容性\n\n参 考 回 答 ：\n[_https://zhuanlan.zhihu.com/p/28206065_](https://links.jianshu.com/go?to=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F28206065)\n1.IOS 移动端 click 事件 300ms 的延迟相应\n\n3. h5 底部输入框被键盘遮挡问题\n\n10.CSS 动画页面闪白,动画卡顿\n\n### 解决方法\n\n1. 尽可能地使用合成属性 transform 和 opacity 来设计 CSS3 动画，不使用\n\n> position 的 left 和 top 来定位\n\n2. 开启硬件加速\n\n3. 上下拉动滚动条时卡顿、慢\n\n### body {-webkit-overflow-scrolling: touch;overflow-scrolling: touch;}\n\n> Android3+和 iOS5+支持 CSS3 的新属性为 overflow-scrolling\n\n- 小程序\n\n参考回答： 移动端手势\n\n> ![](media/image15.jpeg)\n\n![](media/image16.jpeg)\n\n- ### 2X 图 3X 图适配\n\n参考回答：\n\n实际程序开发当中，我们代码中用的值是指逻辑分辨率 pt，而不是像素分辨率 px，比如我们定义一个按钮的高度为 45，这个 45 指的是 45pt 而不是 45px。在非 Retina 屏下 1pt =\n1px，4 和 4.7 寸 Retina 屏下 1pt = 2px，5.5 和x 下 1pt = 3px.我们制作不同尺寸的图片，比如@1x 为 22px，则@2x 为 44px，@3x 为\n66px，命名分别为image.png，在项目的 Assets.xcassets 中新建 New Image Set，修改名字为 image， 并把相应尺寸的图片拖放至相应位置。\n\n/\\* 根据 dpr 显示 2x 图/3x 图 \\*/\n\n###\n\n> .bg-image(@url){\n\n> background-image:\\~\"url('@{url}@2x.png')\";\n\n> @media (-webkit-min-device-pixel-ratio: 3),(min-device-pixel- ratio: 3){\n\n> background-image:\\~\"url('@{url}@3x.png')\";\n\n> }\n\n> }\n\n> .bg-color(@color) {\n\n> background-color: @color;\n\n> }\n\n- 图片在安卓上，有些设备模糊问题\n\n![](media/image17.jpeg) 参考回答：\n\n- ### 固定定位布局键盘挡住输入框内容\n\n参考回答：\n\n![](media/image18.jpeg) ![](media/image19.jpeg)\n\n- ### click 的 300ms 延迟问题和点击穿透问题\n\n![](media/image20.jpeg) 参 考 回 答 ：\n[_https://www.jianshu.com/p/6e2b68a93c88_](https://www.jianshu.com/p/6e2b68a93c88)\n\n方案二：FastClick\n\n![](media/image21.jpeg)\n[_FastClick_](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fftlabs%2Ffastclick) 是\n[_FT Labs_](https://links.jianshu.com/go?to=http%3A%2F%2Flabs.ft.com%2F) 专门为解决移动端浏览器 300\n毫秒点击延迟问题所开发的一个轻量级的库。FastClick 的实现原理是在检测到 touchend 事件的时候，会通过 DOM 自定义事件立即出发模拟一个 click 事件，并把浏览器在 300ms\n之后的 click 事件阻止掉。\n\n- ### phone 及 ipad 下输入框默认内阴影\n\n![](media/image22.jpeg) 参考回答：\n\n- ### 防止手机中页面放大和缩小\n\n参考回答：\n\n### <meta name=\"viewport\" content=\"user-scalable=no\">\n\n> <meta name=\"viewport\" content=\"initial-scale=1,maximum-scale=1\">\n\n- px、em、rem、%、vw、vh、vm 这些单位的区别\n\n参 考 回 答 ： [_https://www.jianshu.com/p/ba26509bc5b3_](https://www.jianshu.com/p/ba26509bc5b3)\n\n- ### 移动端适配- dpr 浅析\n\n参 考 回 答 ： [_https://www.jianshu.com/p/cf600c2930cb_](https://www.jianshu.com/p/cf600c2930cb) dpr =\n物理像素 / css 像素\n\n在 dpr = 2； 1px 的 css 像素在设备中是 2px 的物理像素，这会导致在设备上看上去\n\n1px 的边框是 2px\n\n解决方法：\n\n### 用 transfrom： scale（）缩小 dpr 倍数在 meta 标签中设定 scale 缩小两倍\n\n- 移动端扩展点击区域\n\n参考回答： 父级代理事件\n\n将a 标签设置成块级元素\n\n- ### 上下拉动滚动条时卡顿、慢\n\n参考回答：\n\n> ![](media/image23.jpeg)\n\n- ### 长时间按住页面出现闪退\n\n参考回答：\n\n![](media/image24.jpeg)\n\n- ### ios 和 android 下触摸元素时出现半透明灰色遮罩\n\n![](media/image25.jpeg) 参考回答：\n\n- ### active 兼容处理 即 伪类：active 失效\n\n参 考 回 答 ：\n[_https://blog.csdn.net/diaobuwei1238/article/details/101716814_](https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fdiaobuwei1238%2Farticle%2Fdetails%2F101716814)\n\n将 :visited 放到最后，则会导致以下结果：若链接已经被访问过，a:visited 会覆盖:active 和:hover\n的样式声明，链接将总是呈现为紫色，无论鼠标悬停还是按下激活，链接都将保持为紫色。\n\n基于此原因，上述代码必须按照顺序定义，一般称为 LVHA-order: :link — :visited\n\n— :hover — :active，为方便记忆，可记为“LOVE HATE”\n\n![](media/image26.jpeg)\n\n- ### webkit mask 兼容处理\n\n参 考 回 答 ：\n[_https://segmentfault.com/a/1190000011838367_](https://links.jianshu.com/go?to=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000011838367)\n\n> ![](media/image27.jpeg)\n\n![](media/image28.jpeg)\n\n- ### transiton 闪屏\n\n参考回答：\n\n### //设置内联的元素在 3D 空间如何呈现：保留 3D-webkit-transform- style:preserve-3D\n\n> //设置进行转换的元素的背面在面对用户时是否可见：隐藏-webkit-backface- visibility:hidden;\n\n- 圆角 bug\n\n![](media/image29.jpeg) 参考回答：\n\n### 作者：Aniugel\n\n> 链接：[_https://www.jianshu.com/p/610123c6ed45_](https://www.jianshu.com/p/610123c6ed45) 来源：简书\n\n# 3 \\| 前端进阶\n\n1. ## | 前端工程化\n\n- ### Babel 的原理是什么?\n\n参考回答：\n\nbabel 的转译过程也分为三个阶段，这三步具体是：\n\n- 解析 Parse: 将代码解析生成抽象语法树( 即 AST )，即词法分析与语法分析的过程\n\n- 转换 Transform: 对于 AST 进行变换一系列的操作，babel 接受得到AST 并通过 babel-traverse 对其进行遍历，在此过程中进行添加、更新及移除等操作\n\n- 生成 Generate: 将变换后的 AST 再转换为 JS 代码, 使用到的模块是babel-generator\n\n![](media/image30.jpeg)\n\n- ### 如何写一个 babel 插件?\n\n参考回答：\n\nBabel 解析成 AST，然后插件更改 AST，最后由 Babel 输出代码\n\n那么 Babel 的插件模块需要你暴露一个 function，function 内返回 visitor\n\n### module.export = function(babel){\n\n> return {\n\n> visitor:{\n\n> }\n\n> }\n\n> }\n\n> visitor 是对各类型的 AST 节点做处理的地方，那么我们怎么知道 Babel 生成了的 AST 有哪些节点呢？\n\n> 很简单，你可以把 Babel 转换的结果打印出来，或者这里有传送门:[_AST_](https://astexplorer.net/)\n> [_explorer_](https://astexplorer.net/)\n\n![](media/image31.jpeg)\n\n> 这里我们看到 const result = 1 + 2 中的 1 + 1 是一个 BinaryExpression 节点， 那么在 visitor 中，我们就处理这个节点\n\n### var babel = require('babel-core'); var t = require('babel-types'); const visitor = {\n\n> BinaryExpression(path) {\n\n> const node = path.node;\n\n> let result;\n\n> // 判断表达式两边，是否都是数字\n\n> if (t.isNumericLiteral(node.left) && t.isNumericLiteral(node.right)) {\n\n> // 根据不同的操作符作运算\n\n> switch (node.operator) {\n\n> case \"+\":\n\n> result = node.left.value + node.right.value;\n\n> break\n\n> case \"-\":\n\n> result = node.left.value - node.right.value;\n\n> break;\n\n> case \"\\*\":\n\n> result = node.left.value \\* node.right.value;\n\n> break;\n\n> case \"/\":\n\n> result = node.left.value / node.right.value;\n\n> break;\n\n> case \"\\*\\*\":\n\n> let i = node.right.value;\n\n> while (--i) {\n\n> result = result \\|\\| node.left.value;\n\n> result = result \\* node.left.value;\n\n> }\n\n> break;\n\n> default:\n\n> }\n\n> }\n\n> // 如果上面的运算有结果的话\n\n> if (result !== undefined) {\n\n> // 把表达式节点替换成 number 字面量\n\n> path.replaceWith(t.numericLiteral(result));\n\n> }\n\n> }\n\n> };\n\n> module.exports = function (babel) {\n\n> return {\n\n> visitor\n\n> };\n\n> }\n\n> 插件写好了，我们运行下插件试试\n\n> const babel = require(\"babel-core\");\n\n> const result = babel.transform(\"const result = 1 + 2;\",{\n\n> plugins:\\[\n\n> require(\"./index\")\n\n> ]\n\n> });\n\n> console.log(result.code); // const result = 3;\n\n> 与预期一致，那么转换 const result = 1 + 2 + 3 + 4 + 5;呢?\n\n### 结果是: const result = 3 + 3 + 4 + 5\n\n这就奇怪了，为什么只计算了 1 + 2 之后，就没有继续往下运算了? 我们看一下这个表达式的 AST 树\n\n![](media/image32.jpeg)\n\n你会发现 Babel 解析成表达式里面再嵌套表达式。\n\n### 表达式( 表达式( 表达式( 表达式(1 + 2) + 3) + 4) + 5) 而我们的判断条件并不符合所有的，只符合 1 + 2\n\n> // 判断表达式两边，是否都是数字\n\n> if (t.isNumericLiteral(node.left) && t.isNumericLiteral(node.right)) {}\n\n那么我们得改一改\n\n> 第一次计算 1 + 2 之后，我们会得到这样的表达式\n\n### 表达式( 表达式( 表达式(3 + 3) + 4) + 5)\n\n其中 3 + 3 又符合了我们的条件， 我们通过向上递归的方式遍历父级节点又转换成这样:\n\n### 表达式( 表达式(6 + 4) + 5) 表达式(10 + 5)\n\n> 15\n\n### // 如果上面的运算有结果的话\n\n> if (result !== undefined) {\n\n> // 把表达式节点替换成 number 字面量\n\n> path.replaceWith(t.numericLiteral(result));\n\n> let parentPath = path.parentPath;\n\n> // 向上遍历父级节点\n\n> parentPath && visitor.BinaryExpression.call(this, parentPath);\n\n> }\n\n> 到这里，我们就得出了结果 const result = 15;\n\n### 那么其他运算呢\n\n> const result = 100 + 10 - 50>\\>\\>const result = 60; const result = (100 / 2) + 50>\\>\\>const result\n> = 100;\n\n> const result = (((100 / 2) + 50 \\* 2) / 50) \\*\\* 2>\\>\\>const result = 9;\n\n- ### 你的 git 工作流是怎样的?\n\n参考回答：\n\nGitFlow 是由 Vincent Driessen 提出的一个 git 操作流程标准。包含如下几个关键分支：\n\nmaster 主分支 develop 主开发分支，包含确定即将发布的代码\n\nfeature 新功能分支，一般一个新功能对应一个分支，对于功能的拆分需要比较合理， 以避免一些后面不必要的代码冲突\n\nrelease 发布分支，发布时候用的分支，一般测试时候发现的\n\nbug 在这个分支进行修复 hotfixhotfix 分支，紧急修 bug 的时候用GitFlow 的优势有如下几点：\n\n- 并行开发：GitFlow 可以很方便的实现并行开发：每个新功能都会建立一个新的 feature 分支，从而和已经完成的功能隔离开来，而且只有在新功能完成开发的情况下，其对应的 feature\n  分支才会合并到主开发分支上（也就是我们经常说的 develop 分支）。另外，如果你正在开发某个功能，同时又有一个新的功能需要开发，你只需要提交当前 feature 的代码，然后创建另外一个\n  feature 分支并完成新功能开发。然后再切回之前\n\n> 的 feature 分支即可继续完成之前功能的开发。\n\n- 协作开发：GitFlow 还支持多人协同开发，因为每个 feature 分支上改动的代码都只是为了让某个新的 feature 可以独立运行。同时我们也很容易知道每个人都在干啥。\n\n- 发布阶段：当一个新 feature 开发完成的时候，它会被合并\n\n> 到 develop 分支，这个分支主要用来暂时保存那些还没有发布的内容，所以如果需要再开发新的 feature，我们只需要从 develop 分支创建新分支，即可包含所有已经完成的 feature\n> 。\n\n- 支持紧急修复：GitFlow 还包含了 hotfix 分支。这种类型的分支是从某个已经发布的 tag 上创建出来并做一个紧急的修复，而且这个紧急修复只影响这个已经发布的\n  tag，而不会影响到你正在开发的新 feature。\n\n然后就是 GitFlow 最经典的几张流程图，一定要理解：\n\n![](media/image33.jpeg)\n\n> feature 分支都是从 develop 分支创建，完成后再合并到 develop 分支上， 等待发布。\n\n![](media/image34.jpeg)\n\n> 当需要发布时，我们从 develop 分支创建一个 release 分支\n\n![](media/image35.jpeg)\n\n然后这个 release 分支会发布到测试环境进行测试，如果发现问题就在这个分支直接进行修复。在所有问题修复之前，我们会不停的重复发布->测试->修复->重新发布->重新测试这个流程。\n\n> 发布结束后，这个 release 分支会合并到 develop 和 master 分支，从而保证不会有代码丢失。\n\n![](media/image36.jpeg)\n\n> master 分支只跟踪已经发布的代码，合并到 master 上的 commit 只能来自 release 分支和 hotfix 分支。\n\n> hotfix 分支的作用是紧急修复一些 Bug。\n\n> 它们都是从 master 分支上的某个 tag 建立，修复结束后再合并到 develop 和 master 分 支 上 。\n\n- ### rebase 与 merge 的区别?\n\n参考回答：\n\ngit rebase 和 git merge 一样都是用于从一个分支获取并且合并到当前分支. 假设一个场景,就是我们开发的\\[feature/todo\\]分支要合并到 master\n主分支,那么用rebase 或者 merge 有什么不同呢?\n\n![](media/image37.jpeg)\n\n- marge 特点：自动创建一个新的 commit 如果合并的时候遇到冲突，仅需要修改后重新 commit\n\n- 优点：记录了真实的 commit 情况，包括每个分支的详情\n\n- 缺点：因为每次 merge 会自动产生一个 merge commit，所以在使用一些 git 的 GUI tools，特别是 commit 比较频繁时，看到分支很杂乱。\n\n> ![](media/image38.jpeg)\n\n- rebase 特点：会合并之前的 commit 历史\n\n- 优点：得到更简洁的项目历史，去掉了 merge commit\n\n- 缺点：如果合并出现代码问题不容易定位，因为 re-write 了 history\n\n因此,当需要保留详细的合并信息的时候建议使用 git merge，特别是需要将分支合并\n\n进入 master 分支时；当发现自己修改某个功能时，频繁进行了 git commit 提交时， 发现其实过多的提交信息没有必要时，可以尝试 git rebase.\n\n- ### git reset、git revert 和 git checkout 有什么区别\n\n参考回答：\n\n这个问题同样也需要先了解 git 仓库的三个组成部分：工作区（Working Directory）、暂存区（Stage）和历史记录区（History）。\n\n- 工作区：在 git 管理下的正常目录都算是工作区，我们平时的编辑工作都是在工作区完成\n\n- 暂存区：临时区域。里面存放将要提交文件的快照\n\n- 历史记录区：git commit 后的记录区三个区的转换关系以及转换所使用的命令：\n\n> ![](media/image39.jpeg)\n\ngit reset、git revert 和 git checkout 的共同点：用来撤销代码仓库中的某些更改。\n\n然后是不同点：\n\n首先，从 commit 层面来说：\n\n- git reset 可以将一个分支的末端指向之前的一个 commit。然后再下次 git 执行垃圾回收的时候，会把这个 commit 之后的 commit 都扔掉。git reset\n  还支持三种标记，用来标记 reset 指令影响的范围：\n\n  - --mixed：会影响到暂存区和历史记录区。也是默认选项\n\n  - --soft：只影响历史记录区\n\n  - --hard：影响工作区、暂存区和历史记录区\n\n### 注意：因为 git reset 是直接删除 commit 记录，从而会影响到其他开发人员的分支，所以不要在公共分支（比如 develop）做这个操作\n\n- git checkout 可以将 HEAD 移到一个新的分支，并更新工作目录。因为可能会覆盖本地的修改，所以执行这个指令之前，你需要 stash 或者 commit 暂存区和工作区的更改。\n\n- git revert 和 git reset 的目的是一样的，但是做法不同，它会以创建新的 commit 的方式来撤销 commit，这样能保留之前的 commit\n  历史，比较安全。另外，同样因为可能会覆盖本地的修改，所以执行这个指令之前，你需要 stash 或者 commit 暂存区和工作区的更改。\n\n> 然后，从文件层面来说：\n\n- git reset 只是把文件从历史记录区拿到暂存区，不影响工作区的内容，而且不支持 --mixed、--soft 和 --hard。\n\n- git checkout 则是把文件从历史记录拿到工作区，不影响暂存区的内容。\n\n- git revert 不支持文件层面的操作。\n\n### 版权声明：本文为取经猿作者的原创文章，转载请附上原文出处链接及本声明\n\n> 原文链接：[_https://www.teaspect.com/detail/5623?pn=21_](https://www.teaspect.com/detail/5623?pn=21)\n\n- ### webpack 和 gulp 区别（模块化与流的区别）\n\n参考回答：\n\ngulp 强调的是前端开发的工作流程，我们可以通过配置一系列的 task，定义 task 处理的事务（例如文件压缩合并、雪碧图、启动 server、版本控制等），然后定义执行顺序，来让 gulp\n执行这些 task，从而构建项目的整个前端开发流程。\n\nwebpack 是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js 文件、css 文件等）都看成模块，通过 loader（加载器）和 plugins（插件）\n对资源进行处理，打包成符合生产环境部署的前端资源。\n\n1. ## | Vue 框架\n\n- ### 有使用过 Vue 吗？说说你对 Vue 的理解\n\n参考回答：\n\nVue 是一个构建数据驱动的渐进性框架，它的目标是通过 API 实现响应数据绑定和视图更新。\n\n- ### 说说 Vue 的优缺点\n\n参考回答：\n\n> 优点：\n\n### 1、数据驱动视图，对真实 dom 进行抽象出 virtual dom（本质就是一个 js 对象），并配合 diff 算法、响应式和观察者、异步队列等手段以最小代价更新dom，渲染页面\n\n> 2、组件化，组件用单文件的形式进行代码的组织编写，使得我们可以在一个文件里编写 html\\\\css（scoped 属性配置 css 隔离）\\\\js 并且配合 Vue-loader\n> 之后，支持更强大的预处理器等功能\n\n> 3、强大且丰富的 API 提供一系列的 api 能满足业务开发中各类需求\n\n> 4、由于采用虚拟 dom，让 Vue ssr 先天就足\n\n> 5、生命周期钩子函数，选项式的代码组织方式，写熟了还是蛮顺畅的，但仍然有优化空间（Vue3 composition-api）\n\n> 6、生态好，社区活跃\n\n> 缺点：\n\n### 1、由于底层基于 Object.defineProperty 实现响应式，而这个 api 本身不支持\n\n> IE8 及以下浏览器\n\n> 2、csr 的先天不足，首屏性能问题（白屏）\n\n> 3、由于百度等搜索引擎爬虫无法爬取 js 中的内容，故 spa 先天就对 seo 优化心有余力不足（谷歌的 puppeteer 就挺牛逼的，实现预渲染底层也是用到了这个工具）\n\n- ### Vue 和 React 有什么不同？使用场景分别是什么？\n\n参考回答：\n\n1、Vue 是完整一套由官方维护的框架，核心库主要有由尤雨溪大神独自维护，而 React 是不要脸的书维护（很多库由社区维护），曾经一段时间很多人质疑 Vue 的后续维护性，似乎这并不是问题。\n\n2、Vue 上手简单，进阶式框架，白话说你可以学一点，就可以在你项目中去用一点， 你不一定需要一次性学习整个 Vue 才能去使用它，而 React，恐怕如果你这样会面对项目束手无策。\n\n3、语法上 Vue 并不限制你必须 es6+完全 js 形式编写页面，可以视图和 js 逻辑尽可能分离，减少很多人看不惯 React-jsx 的恶心嵌套，毕竟都是作为前端开发者，还是更习惯于 html\n干净。\n\n4、很多人说 React 适合大型项目，适合什么什么，Vue 轻量级，适合移动端中小型项目，其实我想说，说这话的人是心里根本没点逼数，Vue 完全可以应对复杂的大型应用，甚至于说如果你 React\n学的不是很好，写出来的东西或根本不如 Vue 写的，毕竟Vue 跟着官方文档撸就行，自有人帮你规范，而 React 比较懒散自由，可以自由发挥5、Vue 在国内人气明显胜过\nReact，这很大程度上得益于它的很多语法包括编程思维更符合国人思想。\n\n- ### 什么是虚拟 DOM？\n\n参考回答：\n\n虚拟 dom 是相对于浏览器所渲染出来的真实 dom 的，在 react，vue 等技术出现之\n\n前，我们要改变页面展示的内容只能通过遍历查询 dom 树的方式找到需要修改的 dom 然后修改样式行为或者结构，来达到更新 ui 的目的。\n\n这种方式相当消耗计算资源，因为每次查询 dom 几乎都需要遍历整颗 dom 树，如果建立一个与 dom 树对应的虚拟 dom 对象（ js 对象），以对象嵌套的方式来表示dom 树，那么每次 dom\n的更改就变成了 js 对象的属性的更改，这样一来就能查找js 对象的属性变化要比查询 dom 树的性能开销小。\n\n- ### 请描述下 vue 的生命周期是什么？\n\n参考回答：\n\n- 生命周期就是 vue 从开始创建到销毁的过程，分为四大步（创建，挂载，更新，销毁），每一步又分为两小步，如 beforeCreate， created。beforeCreate 前，也就是 new\n  Vue 的时候会初始化事件和生命周期；beforeCreate 和 created 之间会挂载 Data，绑定事件；接下来会根据 el 挂载页面元素，如果没有设置 el\n  则生命周期结束，直到手动挂载；el 挂载结束后，根据 templete/outerHTML(el)渲染页面；在beforeMount 前虚拟 DOM 已经创建完成；之后在 mounted 前，将\n  vm.\\$el 替换掉页面元素 el;mounted 将虚拟 dom 挂载到真实页面（此时页面已经全部渲染完成）；之后发生数据变化时触发 beforeUpdate 和updated\n  进行一些操作；最后主动调用销毁函数或者组件自动销毁时\n\n> beforeDestroy，手动撤销监听事件，计时器等；destroyed 时仅存在Dom 节点，其他所有东西已自动销毁。这就是我所理解的 vue 的一个完整的生命周期。\n\n-\n\n![](media/image40.jpeg)\n\n- ### vue 如何监听键盘事件？\n\n参考回答：\n\n1. @keyup\\. 方 法\n\n### <template>\n\n> <input ref=\"myInput\" type=\"text\" value=\"hello world\" autofocus @keyup.enter=\"handleKey\">\n\n> </template>\n\n> <script>\n\n> export default {\n\n> methods: {\n\n> handleKey(e) {\n\n> console.log(e)\n\n> }\n\n> }\n\n> }\n\n> </script>\n\n2. addEventListener\n\n### <script>\n\n> export default {\n\n> mounted() {\n\n> document.addEventListener('keyup', this.handleKey)\n\n> },\n\n> beforeDestroy() {\n\n> document.removeEventListener('keyup', this.handleKey)\n\n> },\n\n> methods: {\n\n> handleKey(e) {\n\n> console.log(e)\n\n> }\n\n> }\n\n> }\n\n> </script><script>\n\n> export default {\n\n> mounted() {\n\n> document.addEventListener('keyup', this.handleKey)\n\n> },\n\n> beforeDestroy() {\n\n> document.removeEventListener('keyup', this.handleKey)\n\n> },\n\n> methods: {\n\n> handleKey(e) {\n\n> console.log(e)\n\n> }\n\n> }\n\n> }\n\n> </script>\n\n- ### watch 怎么深度监听对象变化\n\n参考回答：\n\ndeep 设置为 true 就可以监听到对象的变化\n\n### let vm=new Vue({\n\n> el:\"#first\",\n\n> data:{msg:{name:'北京'}},\n\n> watch:{\n\n> msg:{\n\n> handler (newMsg,oldMsg){\n\n> console.log(newMsg);\n\n> },\n\n> immediate:true,\n\n> deep:true\n\n> }\n\n> }\n\n> })\n\n- ### 删除数组用 delete 和 Vue.delete 有什么区别？\n\n参考回答：\n\n- delete：只是被删除数组成员变为 empty / undefined，其他元素键值不变\n\n- Vue.delete：直接删了数组成员，并改变了数组的键值（对象是响应式的，确保删除能触发更新视图，这个方法主要用于避开 Vue 不能检测到属性被删除的限制）\n\n- ### watch 和计算属性有什么区别？\n\n参考回答：\n\n通俗来讲，既能用 computed 实现又可以用 watch 监听来实现的功能，推荐用computed，重点在于 computed 的缓存功能\n\ncomputed 计算属性是用来声明式的描述一个值依赖了其它的值，当所依赖的值或者变量改变时，计算属性也会跟着改变；\n\nwatch 监听的是已经在 data 中定义的变量，当该变量变化时，会触发 watch 中的方法。\n\n- ### Vue 双向绑定原理\n\n参考回答：\n\nVue 数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。利用了Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)。\n\n- ### v-model 是什么？有什么用呢？\n\n参考回答：\n\n一则语法糖，相当于v-bind:value=\"xxx\" 和 @input，意思是绑定了一个 value 属性的值，子组件可对 value 属性监听，通过\\$emit('input',\nxxx)的方式给父组件通讯。自己实现v-model 方式的组件也是这样的思路。\n\n- ### axios 是什么？怎样使用它？怎么解决跨域的问题？\n\n参考回答：\n\naxios 的是一种异步请求，用法和 ajax 类似，安装 npm install axios --save 即可使用，请求中包括 get,post,put, patch ,delete\n等五种请求方式，解决跨域可以在请求头中添加 Access-Control-Allow-Origin，也可以在 index.js 文件中更改proxyTable 配置等解决跨域问题。\n\n- ### 在 vue 项目中如何引入第三方库（比如 jQuery）？有哪些方法可以做到？\n\n参考回答：\n\n1、绝对路径直接引入\n\n在 index.html 中用 script 引入\n\n### <script src=\"./static/jquery-1.12.4.js\"></script>\n\n> 然 后 在 webpack 中 配 置 external externals: { 'jquery': 'jQuery' } 在组件中使用时 import\n\n> import \\$ from 'jquery' 2 、在 webpack 中配置 alias\n\n### resolve: { extensions: \\['.js', '.vue', '.json'\\], alias: { '@': resolve('src'), 'jquery': resolve('static/jquery-1.12.4.js') } } 然后在组件中 import\n\n3、在 webpack 中配置 plugins\n\n### plugins: \\[ new webpack.ProvidePlugin({ \\$: 'jquery' }) \\]\n\n全局使用，但在使用 eslint 情况下会报错，需要在使用了 \\$ 的代码前添加 /\\* eslint-disable\\*/ 来去掉 ESLint 的检查。\n\n- ### 说说 Vue React angularjs jquery 的区别\n\n参考回答：\n\nJQuery 与另外几者最大的区别是，JQuery 是事件驱动，其他两者是数据驱动。JQuery 业务逻辑和 UI 更改该混在一起， UI 里面还参杂这交互逻辑，让本来混乱的逻辑更加混乱。\n\nAngular，Vue 是双向绑定，而 React 不是其他还有设计理念上的区别等\n\n- Vue3.0 里为什么要用 Proxy API 替代 defineProperty API？\n\n参考回答： 响应式优化。\n\n1. defineProperty API 的局限性最大原因是它只能针对单例属性做监听。\n\nVue2.x 中的响应式实现正是基于 defineProperty 中的 descriptor，对 data 中的属性做了遍历 + 递归，为每个属性设置了 getter、setter。\n\n这也就是为什么 Vue 只能对 data 中预定义过的属性做出响应的原因，在 Vue 中使用下标的方式直接修改属性的值或者添加一个预先不存在的对象属性是无法做到 setter 监听的，这是\ndefineProperty 的局限性。\n\n2. Proxy API 的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，\n\n这就完全可以代理所有属性，将会带来很大的性能提升和更优的代码。\n\nProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。\n\n3. 响应式是惰性的\n\n在 Vue.js 2.x 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的变化，就需要递归遍历这个对象，执行 Object.defineProperty\n把每一层对象数据都变成响应式的，这无疑会有很大的性能消耗。\n\n在 Vue.js 3.0 中，使用 Proxy API 并不能监听到对象内部深层次的属性变化，因此它的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部属性才会\n\n变成响应式，简单的可以说是按需实现响应式，减少性能消耗。基础用法：\n\n![](media/image41.jpeg)\n\n- Vue3.0 编译做了哪些优化？\n\n参考回答：\n\n1. 生成 Block tree\n\n![](media/image42.jpeg) Vue.js 2.x 的数据更新并触发重新渲染的粒度是组件级的，单个组件内部 需要遍历该组件的整个 vnode 树。在 2.0\n里，渲染效率的快慢与组件大小成正相关：组件越大， 渲染效率越慢。并且，对于一些静态节点，又无数据更新，这些遍历都是性能浪费。Vue.js 3.0 做到了通过编译阶段对静态模板的分析，编译生成了\nBlock tree。 Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个 区块内部的节点结构是固定的，每个区块只需要追踪自身包含的动态节点。所以，在 3.0\n里，渲染效率不再与模板大小成正相关，而是与模板中动态节点的数量成正相关。\n\n2. slot 编译优化\n\nVue.js 2.x 中，如果有一个组件传入了 slot，那么每次父组件更新的时候，会强制使子组件 update，造成性能的浪费。\n\nVue.js 3.0 优化了 slot 的生成，使得非动态 slot 中属性的更新只会触发子组件的更\n\n新。动态 slot 指的是在 slot 上面使用 v-if，v-for，动态 slot 名字等会导致 slot 产\n\n生运行时动态变化但是又无法被子组件 track 的操作。c. diff 算法优化\n\n- Vue3.0 新特性 —— Composition API 与 React.js 中 Hooks 的异同点\n\n参考回答：\n\n1. React.js 中的 Hooks 基本使用\n\nReact Hooks 允许你 \"勾入\" 诸如组件状态和副作用处理等 React 功能中。Hooks 只能用在函数组件中，并允许我们在不需要创建类的情况下将状态、副作用处理和更多东西带入组件中。\n\nReact 核心团队奉上的采纳策略是不反对类组件，所以你可以升级 React 版本、在新组件中开始尝试 Hooks，并保持既有组件不做任何更改。\n\n案例：\n\n> ![](media/image43.jpeg)\n\nuseState 和 useEffect 是 React Hooks 中的一些例子，使得函数组件中也能增加状态和运行副作用。\n\n我们也可以自定义一个 Hooks，它打开了代码复用性和扩展性的新大门。\n\n2. Vue Composition API 基本使用\n\nVue Composition API 围绕一个新的组件选项 setup 而创建。setup() 为 Vue 组件提供了状态、计算值、watcher 和生命周期钩子。\n\n并没有让原来的 API（Options-based API）消失。允许开发者 结合使用新旧两种 API\n\n（向下兼容）。\n\n> ![](media/image44.jpeg)\n\n3. 原理\n\nReact hook 底层是基于链表实现，调用的条件是每次组件被 render 的时候都会顺序执行所有的 hooks。\n\nVue hook 只会被注册调用一次，Vue 能避开这些麻烦的问题，原因在于它对数据的响\n\n应是基于 proxy 的，对数据直接代理观察。（这种场景下，只要任何一个更改 data 的\n\n地方，相关的 function 或者 template 都会被重新计算，因此避开了 React 可能遇到的性能上的问题）。\n\nReact 中，数据更改的时候，会导致重新 render，重新 render 又会重新把 hooks 重新注册一次，所以 React 复杂程度会高一些。\n\n- ### Vue3.0 是如何变得更快的？（底层，源码）\n\n参考回答：\n\n1. diff 方法优化\n\nVue2.x 中的虚拟 dom 是进行全量的对比。\n\nVue3.0 中新增了静态标记（PatchFlag）：在与上次虚拟结点进行对比的时候，值对比带有 patch flag 的节点，并且可以通过 flag 的信息得知当前节点要对比的具体内容化。\n\n2. hoistStatic 静态提升\n\nVue2.x : 无论元素是否参与更新，每次都会重新创建。\n\nVue3.0 : 对不参与更新的元素，只会被创建一次，之后会在每次渲染时候被不停的复用。\n\n3. cacheHandlers 事件侦听器缓存\n\n默认情况下 onClick 会被视为动态绑定，所以每次都会去追踪它的变化但是因为是同一个函数，所以没有追踪变化，直接缓存起来复用即可。\n\n原作者姓名： 欧阳呀\n\n- ### vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？\n\n参考回答：\n\n按 钮 级 别 的 权 限 ：\n[_https://panjiachen.github.io/vue-element-admin-_](https://panjiachen.github.io/vue-element-admin-site/zh/guide/essentials/permission.html#%E6%8C%87%E4%BB%A4%E6%9D%83%E9%99%90)\n\n[_site/zh/guide/essentials/permission.html#%E6%8C%87%E4%BB%A4%E6%9D%83%E9%99%_](https://panjiachen.github.io/vue-element-admin-site/zh/guide/essentials/permission.html#%E6%8C%87%E4%BB%A4%E6%9D%83%E9%99%90)\n[_90_](https://panjiachen.github.io/vue-element-admin-site/zh/guide/essentials/permission.html#%E6%8C%87%E4%BB%A4%E6%9D%83%E9%99%90)\n\n- ### vue 在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？\n\n参考回答：\n\n看实际情况，一般在 created（或 beforeRouter） 里面就可以，如果涉及到需要页面加载完成之后的话就用 mounted。\n\n在 created 的时候，视图中的 html 并没有渲染出来，所以此时如果直接去操作 html\n\n的 dom 节点，一定找不到相关的元素\n\n而在 mounted 中，由于此时 html 已经渲染出来了，所以可以直接操作 dom 节点，（此时 document.getelementById 即可生效了）。\n\n- ### 说说你对 proxy 的理解\n\n参考回答：\n\nvue 的数据劫持有两个缺点:\n\n1、无法监听通过索引修改数组的值的变化\n\n2、无法监听 object 也就是对象的值的变化所以 vue2.x 中才会有\\$set 属性的存在\n\nproxy 是 es6 中推出的新 api，可以弥补以上两个缺点，所以 vue3.x 版本用 proxy 替换 object.defineproperty。\n\n1. ## | React 框架\n\n- ### angularJs 和 React 区别\n\n参考回答：\n\nReact 对比 Angular 是思想上的转变，它也并不是一个库，是一种开发理念，组件化， 分治的管理，数据与 view 的一体化。它只有一个中心,发出状态，渲染 view，对于虚拟 dom\n它并没有提高渲染页面的性能，它提供更多的是利用 jsx 便捷生成 dom 元素， 利用组件概念进行分治管理页面每个部分(例如 header section footer slider)\n\n- ### redux 中间件\n\n参考回答：\n\n中间件提供第三方插件的模式，自定义拦截 action -> reducer 的过程。变为action -> middlewares -> reducer\n。这种机制可以让我们改变数据流，实现如异步action ，action 过滤，日志输出，异常报告等功能。\n\n常见的中间件： redux-logger：提供日志输出；redux-thunk：处理异步操作；\n\nredux-promise：处理异步操作；actionCreator 的返回值是 promise\n\n- ### redux 有什么缺点\n\n参考回答：\n\n1. 一个组件所需要的数据，必须由父组件传过来，而不能像 flux 中直接从 store 取。\n\n2. 当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新render，可能会有效率影响，或者需要写复杂的 shouldComponentUpdate 进行判断。\n\n- ### React 组件的划分业务组件技术组件？\n\n参考回答：\n\n根据组件的职责通常把组件分为 UI 组件和容器组件。UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。两者通过 React-Redux 提供 connect 方法联系起来。\n\n- ### React 生命周期函数\n\n参考回答：\n\n一、初始化阶段：\n\ngetDefaultProps:获取实例的默认属性\n\ngetInitialState:获取每个实例的初始化状态\n\ncomponentWillMount：组件即将被装载、渲染到页面上\n\nrender:组件在这里生成虚拟的 DOM 节点\n\ncomponentDidMount:组件真正在被装载之后\n\n二、运行中状态：\n\ncomponentWillReceiveProps:组件将要接收到属性的时候调用\n\nshouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）\n\ncomponentWillUpdate:组件即将更新不能修改属性和状态\n\nrender:组件重新描绘\n\ncomponentDidUpdate:组件已经更新\n\n三、销毁阶段：\n\ncomponentWillUnmount:组件即将销毁\n\n- ### React 性能优化是哪个周期函数？\n\n参考回答：\n\nshouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate\n方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。\n\n- ### 为什么虚拟 dom 会提高性能?\n\n参考回答：\n\n虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。\n\n具体实现步骤如下：\n\n1. 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM\n\n树，插到文档当中；\n\n2. 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较， 记录两棵树差异；\n\n把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。\n\n- ### diff 算法?\n\n参考回答：\n\n1. 把树形结构按照层级分解，只比较同级元素。\n\n2. 给列表结构的每个单元添加唯一的 key 属性，方便比较。\n\n3. React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）\n\n4. 合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.\n\n到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.\n\n6. 选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。\n\n- ### React 性能优化方案\n\n参考回答：\n\n1. 重写 shouldComponentUpdate 来避免不必要的 dom 操作。\n\n2. 使用 production 版本的 React.js。\n\n3. 使用 key 来帮助 React 识别列表中所有子组件的最小变化\n\n- ### 简述 flux 思想\n\n参考回答：\n\nFlux 的最大特点，就是数据的\"单向流动\"。\n\n1. 用户访问 View\n\n2. View 发出用户的 Action\n\n3. Dispatcher 收到 Action，要求 Store 进行相应的更新\n\n4. Store 更新后，发出一个\"change\"事件\n\n5. View 收到\"change\"事件后，更新页面\n\n- ### React 项目用过什么脚手架？Mern? Yeoman?\n\n参考回答：\n\nMern：MERN 是脚手架的工具，它可以很容易地使用 Mongo, Express, React and NodeJS 生成同构 JS\n应用。它最大限度地减少安装时间，并得到您使用的成熟技术来加速开发。\n\n- ### 你了解 React 吗？\n\n参考回答：\n\n了解，React 是 facebook 搞出来的一个轻量级的组件库，用于解决前端视图层的一些问题，就是 MVC 中V 层的问题，它内部的 Instagram 网站就是用 React 搭建的。\n\n- ### React 解决了什么问题？\n\n参考回答：\n\n解决了三个问题： 1.组件复用问题， 2.性能问题，3.兼容性问题：\n\n- ### React 的协议？\n\n参考回答：\n\nReact 遵循的协议是“BSD 许可证 + 专利开源协议”，这个协议比较奇葩，如果你的产品跟 facebook 没有竞争关系，你可以自由的使用 React，但是如果有竞争关系，你的 React\n的使用许可将会被取消\n\n- ### 了解 shouldComponentUpdate 吗？\n\n参考回答：\n\nReact 虚拟 dom 技术要求不断的将 dom 和虚拟 dom 进行 diff 比较，如果 dom 树比价大，这种比较操作会比较耗时，因此 React 提供了\nshouldComponentUpdate 这种补丁函数，如果对于一些变化，如果我们不希望某个组件刷新，或者刷新后跟原来其实一样，就可以使用这个函数直接告诉 React，省去 diff\n操作，进一步的提高了效率。\n\n- ### React 的工作原理？\n\n参考回答：\n\nReact 会创建一个虚拟 DOM(virtual DOM)。当一个组件中的状态改变时，React 首先会通过 \"diffing\" 算法来标记虚拟 DOM\n中的改变，第二步是调节(reconciliation)，会用 diff 的结果来更新 DOM。\n\n- ### 使用 React 有何优点？\n\n参考回答：\n\n1. 只需查看 render 函数就会很容易知道一个组件是如何被渲染的\n\n2. JSX 的引入，使得组件的代码更加可读，也更容易看懂组件的布局，或者组件之间是如何互相引用的\n\n3. 支持服务端渲染，这可以改进 SEO 和性能\n\n4. 易于测试\n\n5. React 只关注 View 层，所以可以和其它任何框架(如 Backbone.js, Angular.js)一起使用\n\n- ### 展示组件(Presentational component)和容器组件(Container component)之间有何不同？\n\n参考回答：\n\n1. 展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。\n\n2. 容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 Flux\n   actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源\n\n- ### 类组件(Class component)和函数式组件(Functional component)之间有何不同？\n\n参考回答：\n\n1. 类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态\n\n2. 当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 '无状态组件(stateless\n   component)'，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件\n\n- ### (组件的)状态(state)和属性(props)之间有何不同？\n\n参考回答：\n\n1. State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。\n\n2. Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的\n   props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据--回调函数也可以通过 props 传递。\n\n- ### 应该在 React 组件的何处发起 Ajax 请求？\n\n参考回答：\n\n在 React 组件中，应该在 componentDidMount 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到\nDOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在\ncomponentDidMount 中发起网络请求将保证这有一个组件可以更新了。\n\n- ### 在 React 中，refs 的作用是什么？\n\n参考回答：\n\nRefs 可以用于获取一个 DOM 节点或者 React 组件的引用。何时使用 refs 的好的示例有管理焦点/文本选择，触发命令动画，或者和第三方 DOM 库集成。你应该避免使用 String\n类型的 Refs 和内联的 ref 回调。Refs 回调是 React 所推荐的。\n\n- ### 何为高阶组件(higher order component)？\n\n参考回答：\n\n高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC 最好的方式是共享\nReact 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。\n\n- ### 使用箭头函数(arrow functions)的优点是什么？\n\n参考回答：\n\n1. 作用域安全：在箭头函数之前，每一个新创建的函数都有定义自身的 this 值(在构造函数中是新对象；在严格模式下，函数调用中的 this 是未定义的；如果函数被\n\n称为“对象方法”，则为基础对象等)，但箭头函数不会，它会使用封闭执行上下文的this 值。\n\n2. 简单：箭头函数易于阅读和书写\n\n3. 清晰：当一切都是一个箭头函数，任何常规函数都可以立即用于定义作用域。开发者总是可以查找 next-higher 函数语句，以查看 this 的值\n\n- ### 为什么建议传递给 setState 的参数是一个 callback 而不是一个对象？\n\n参考回答：\n\n因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state。\n\n- ### 除了在构造函数中绑定 this，还有其它方式吗？\n\n参考回答：\n\n可以使用属性初始值设定项(property initializers)来正确绑定回调，create- React-app\n也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。\n\n- ### 怎么阻止组件的渲染？\n\n参考回答：\n\n在组件的 render 方法中返回 null 并不会影响触发组件的生命周期方法\n\n- ### 当渲染一个列表时，何为 key？设置 key 的目的是什么？\n\n参考回答：\n\nKeys 会有助于 React 识别哪些 items 改变了，被添加了或者被移除了。Keys 应该被赋予数组内的元素以赋予(DOM)元素一个稳定的标识，选择一个 key\n的最佳方法是使用一个字符串，该字符串能惟一地标识一个列表项。很多时候你会使用数据中的 IDs 作为 keys，当你没有稳定的 IDs 用于被渲染的 items 时，可以使用项目索引作为渲染项的\nkey，但这种方式并不推荐，如果 items 可以重新排序，就会导致 re- render 变慢\n\n- (在构造函数中)调用 super(props) 的目的是什么？\n\n参考回答：\n\n在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在constructor 中调用 super()。传递 props 给 super()\n的原因则是便于(在子类中) 能在 constructor 访问 this.props。\n\n- ### 何为 JSX ？\n\n参考回答：\n\nJSX 是 JavaScript 语法的一种语法扩展，并拥有 JavaScript 的全部功能。JSX 生产 React \"元素\"，你可以将任何的 JavaScript\n表达式封装在花括号里，然后将其嵌入到 JSX 中。在编译完成之后，JSX 表达式就变成了常规的 JavaScript 对象，这意味着你可以在 if 语句和 for 循环内部使用\nJSX，将它赋值给变量，接受它作为参数，并从函数中返回它。\n","slug":"0-1前端工程师面试题2-md","published":1,"updated":"2022-08-23T02:34:28.755Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl75kqn4p0031yu3lc9ypavik","content":"<h2 id=\"HTTP-HTML-浏览器\"><a href=\"#HTTP-HTML-浏览器\" class=\"headerlink\" title=\"| HTTP/HTML/浏览器\"></a>| HTTP/HTML/浏览器</h2><h3 id=\"说一下-http-和-https\"><a href=\"#说一下-http-和-https\" class=\"headerlink\" title=\"说一下 http 和 https\"></a>说一下 http 和 https</h3><p>参考回答：</p>\n<p>https 的 SSL 加密是在传输层实现的。(1)http 和 https 的基本概念</p>\n<p>http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW<br>服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p>\n<p>https: 是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL</p>\n<p>层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。</p>\n<p>https 协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。</p>\n<ol start=\"2\">\n<li>http 和 https 的区别？</li>\n</ol>\n<p>http 传输的数据都是未加密的，也就是明文的，网景公司设置了 SSL 协议来对 http 协议传输的数据进行加密处理，简单来说 https 协议是由 http 和 ssl<br>协议构建的可进行加密传输和身份认证的网络协议，比 http 协议的安全性更高。</p>\n<p>主要的区别如下：</p>\n<p>Https 协议需要 ca 证书，费用较高。</p>\n<p>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。</p>\n<p>使用不同的链接方式，端口也不同，一般而言，http 协议的端口为 80，https 的端口为 443</p>\n<p>http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。</p>\n<ol start=\"3\">\n<li>https 协议的工作原理</li>\n</ol>\n<p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤，如图所示。客户使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。</p>\n<p>web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。</p>\n<p>客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。</p>\n<p>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</p>\n<p>web 服务器通过自己的私钥解密出会话密钥。</p>\n<p>web 服务器通过会话密钥加密与客户端之间的通信。(4)https 协议的优点</p>\n<p>使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>\n<p>HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比http 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。HTTPS<br>是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p>\n<p>谷歌曾在 2014 年 8 月份调整搜索引擎算法，并称“比起同等 HTTP 网站，采用 HTTPS</p>\n<p>加密的网站在搜索结果中的排名将会更高”。(5)https 协议的缺点</p>\n<p>https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。https 缓存不如 http 高效，会增加数据开销。</p>\n<p>SSL 证书也需要钱，功能越强大的证书费用越高。</p>\n<p>SSL 证书需要绑定 IP，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。</p>\n<h3 id=\"tcp-三次握手，一句话概括\"><a href=\"#tcp-三次握手，一句话概括\" class=\"headerlink\" title=\"tcp 三次握手，一句话概括\"></a>tcp 三次握手，一句话概括</h3><p>参考回答：</p>\n<p>客户端和服务端都需要直到各自可收发，因此需要三次握手。简化三次握手：</p>\n<p><img width=\"487\" alt=\"2018-07-10 3 42 11\"\nsrc=\"[_https://user-_](https://user-images.githubusercontent.com/17233651/42496289-1c6d668a-8458-11e8-98b3-65db50f64d48.png)\n[_images.githubusercontent.com/17233651/42496289-1c6d668a-8458-11e8-98b3-_](https://user-images.githubusercontent.com/17233651/42496289-1c6d668a-8458-11e8-98b3-65db50f64d48.png)\n[_65db50f64d48.png_](https://user-images.githubusercontent.com/17233651/42496289-1c6d668a-8458-11e8-98b3-65db50f64d48.png)\"></p>\n<p>从图片可以得到三次握手可以简化为：C 发起请求连接S 确认，也发起连接C 确认我们再看看每次握手的作用：第一次握手：S 只可以确认 自己可以接受C 发送的报文段第二次握手：C 可以确认 S<br>收到了自己发送的报文段，并且可以确认 自己可以接受S 发送的报文段第三次握手：S 可以确认 C 收到了自己发送的报文段</p>\n<ul>\n<li><h3 id=\"TCP-和-UDP-的区别\"><a href=\"#TCP-和-UDP-的区别\" class=\"headerlink\" title=\"TCP 和 UDP 的区别\"></a>TCP 和 UDP 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>TCP 是面向连接的，udp 是无连接的即发送数据前不需要先建立链接。</p>\n</li>\n<li><p>TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失， 不重复，且按序到达;UDP 尽最大努力交付，即不保证可靠交付。 并且因为 tcp 可靠，<br>面向连接，不会丢失数据因此适合大数据量的交换。</p>\n</li>\n<li><p>TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低</p>\n</li>\n</ol>\n<p>（因此会出现丢包，对实时的应用比如 IP 电话和视频会议等）。</p>\n<ol start=\"4\">\n<li><p>TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多。</p>\n</li>\n<li><p>TCP 的首部较大为 20 字节，而 UDP 只有 8 字节。</p>\n</li>\n<li><p>TCP 是面向连接的可靠性传输，而 UDP 是不可靠的。</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"WebSocket-的实现和应用\"><a href=\"#WebSocket-的实现和应用\" class=\"headerlink\" title=\"WebSocket 的实现和应用\"></a>WebSocket 的实现和应用</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li>什么是 WebSocket?</li>\n</ol>\n<p>WebSocket 是 HTML5 中的协议，支持持久连续，http 协议不支持持久性连接。Http1.0 和 HTTP1.1 都不支持持久性的链接，HTTP1.1 中的 keep-alive，将多个<br>http 请求合并为 1 个</p>\n<ol start=\"2\">\n<li>WebSocket 是什么样的协议，具体有什么优点？</li>\n</ol>\n<p>HTTP 的生命周期通过 Request 来界定，也就是 Request 一个 Response，那么在Http1.0 协议中，这次 Http 请求就结束了。在 Http1.1<br>中进行了改进，是的有一个connection：Keep-alive，也就是说，在一个 Http 连接中，可以发送多个 Request， 接收多个 Response。但是必须记住，在 Http 中一个<br>Request 只能对应有一个Response，而且这个 Response 是被动的，不能主动发起。</p>\n<p>WebSocket 是基于 Http 协议的，或者说借用了 Http 协议来完成一部分握手，在握手阶段与 Http 是相同的。我们来看一个 websocket 握手协议的实现，基本是 2 个属性，<br>upgrade，connection。</p>\n<p>基本请求如下：</p>\n<h3 id=\"GET-chat-HTTP-1-1\"><a href=\"#GET-chat-HTTP-1-1\" class=\"headerlink\" title=\"GET /chat HTTP/1.1\"></a>GET /chat HTTP/1.1</h3><blockquote>\n<p>Host: server.example.com Upgrade: websocket Connection: Upgrade</p>\n</blockquote>\n<blockquote>\n<p>Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== Sec-WebSocket-Protocol: chat, superchat<br>Sec-WebSocket-Version: 13</p>\n</blockquote>\n<blockquote>\n<p><a href=\"http://example.com/\">Origin: http://example.com</a></p>\n</blockquote>\n<p>多了下面 2 个属性：</p>\n<p>告诉服务器发送的是 websocket</p>\n<ul>\n<li><h3 id=\"HTTP-请求的方式，HEAD-方式\"><a href=\"#HTTP-请求的方式，HEAD-方式\" class=\"headerlink\" title=\"HTTP 请求的方式，HEAD 方式\"></a>HTTP 请求的方式，HEAD 方式</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>head：类似于 get 请求，只不过返回的响应中没有具体的内容，用户获取报头options：允许客户端查看服务器的性能，比如说服务器支持的请求方式等等。</p>\n<ul>\n<li><h3 id=\"一个图片-url-访问后直接下载怎样实现？\"><a href=\"#一个图片-url-访问后直接下载怎样实现？\" class=\"headerlink\" title=\"一个图片 url 访问后直接下载怎样实现？\"></a>一个图片 url 访问后直接下载怎样实现？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>请求的返回头里面，用于浏览器解析的重要参数就是 OSS 的 API 文档里面的返回 http</p>\n<p>头，决定用户下载行为的参数。下载的情况下：</p>\n<ol>\n<li><p>x-oss-object-type: Normal</p>\n</li>\n<li><p>x-oss-request-id: 598D5ED34F29D01FE2925F41</p>\n</li>\n<li><p>x-oss-storage-class: Standard</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"说一下-web-Quality（无障碍）\"><a href=\"#说一下-web-Quality（无障碍）\" class=\"headerlink\" title=\"说一下 web Quality（无障碍）\"></a>说一下 web Quality（无障碍）</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>能够被残障人士使用的网站才能称得上一个易用的（易访问的）网站。残障人士指的是那些带有残疾或者身体不健康的用户。</p>\n<p>使用 alt 属性：</p>\n<img src=\"person.jpg\" alt=\"this is a person\"/>\n\n<p>有时候浏览器会无法显示图像。具体的原因有： 用户关闭了图像显示</p>\n<p>浏览器是不支持图形显示的迷你浏览器</p>\n<p>浏览器是语音浏览器（供盲人和弱视人群使用）</p>\n<p>如果您使用了 alt 属性，那么浏览器至少可以显示或读出有关图像的描述。</p>\n<ul>\n<li><h3 id=\"几个很实用的-BOM-属性对象方法\"><a href=\"#几个很实用的-BOM-属性对象方法\" class=\"headerlink\" title=\"几个很实用的 BOM 属性对象方法?\"></a>几个很实用的 BOM 属性对象方法?</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>什么是 Bom? Bom 是浏览器对象。有哪些常用的 Bom 属性呢？ (1)location 对象</p>\n<p>location.href– 返 回 或 设 置 当 前 文 档 的 URL location.search – 返回 URL 中的查询字符串部分。例</p>\n<p>如<br><a href=\"http://www.dreamdu.com/dreamdu.php?id=5&name=dreamdu\"><em>http://www.dreamdu.com/dreamdu.php?id=5&amp;name=dreamdu</em></a><br>返回包括(?)后面的内容?id=5&amp;name=dreamdu</p>\n<p>location.hash – 返回 URL#后面的内容，如果没有#，返回空location.host – 返回 URL 中的域名部分，例如<br><a href=\"http://www.dreamdu.com/\"><em>www.dreamdu.com</em></a> location.hostname – 返回 URL 中的主域名部分，例如 dreamdu.com<br>location.pathname – 返回 URL 的域名后的部分。例</p>\n<p>如 <a href=\"http://www.dreamdu.com/xhtml/\"><em>http://www.dreamdu.com/xhtml/</em></a> 返回/xhtml/ location.port – 返回 URL<br>中的端口部分。例</p>\n<p>如 <em><a href=\"http://www.dreamdu.com:8080/xhtml/\">http://www.dreamdu.com:8080/xhtml/</a></em> 返 回 8080</p>\n<p>location.protocol – 返回 URL 中的协议部分。例</p>\n<p>如 <em><a href=\"http://www.dreamdu.com:8080/xhtml/\">http://www.dreamdu.com:8080/xhtml/</a></em> 返回(//)前面的内容 http: location.assign – 设置当前文档的 URL</p>\n<p>location.replace() – 设置当前文档的 URL，并且在 history 对象的地址列表中移除这个 URL location.replace(url);</p>\n<p>location.reload() – 重载当前页面(2)history 对象</p>\n<p>history.go() – 前进或后退指定的页面数 history.go(num); history.back() – 后退一页</p>\n<p>history.forward() – 前进一页(3)Navigator 对象</p>\n<p>navigator.userAgent – 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)</p>\n<p>navigator.cookieEnabled – 返回浏览器是否支持(启用)cookie</p>\n<ul>\n<li><h3 id=\"说一下-HTML5-drag-api\"><a href=\"#说一下-HTML5-drag-api\" class=\"headerlink\" title=\"说一下 HTML5 drag api\"></a>说一下 HTML5 drag api</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发，。darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。dragend：事件主体是被拖放元素，在整个拖放操作结束时触发</p>\n<ul>\n<li><h3 id=\"说一下-http2-0\"><a href=\"#说一下-http2-0\" class=\"headerlink\" title=\"说一下 http2.0\"></a>说一下 http2.0</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>首先补充一下，http 和 https 的区别，相比于 http,https 是基于 ssl 加密的 http 协议</p>\n<p>简要概括：http2.0 是基于 1999 年发布的 http1.0 之后的首次更新。</p>\n<p>提升访问速度（可以对于，请求资源所需时间更少，访问速度更快，相比 http1.0） 允许多路复用：多路复用允许同时通过单一的 HTTP/2 连接发送多重请求-响应信息。改善了：在 http1.1<br>中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。</p>\n<p>二进制分帧：HTTP2.0 会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码</p>\n<p>首部压缩</p>\n<p>服务器端推送</p>\n<ul>\n<li><h3 id=\"补充-400-和-401、403-状态码\"><a href=\"#补充-400-和-401、403-状态码\" class=\"headerlink\" title=\"补充 400 和 401、403 状态码\"></a>补充 400 和 401、403 状态码</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>(1)400 状态码：请求无效产生原因：</p>\n<p>前端提交数据的字段名称和字段类型与后台的实体没有保持一致</p>\n<p>前端提交到后台的数据应该是 json 字符串类型，但是前端没有将对象 JSON.stringify</p>\n<p>转化成字符串。解决方法：</p>\n<p>对照字段的名称，保持一致性</p>\n<p>将 obj 对象通过 JSON.stringify 实现序列化(2)401 状态码：当前请求需要用户验证</p>\n<ol start=\"3\">\n<li>403 状态码：服务器已经得到请求，但是拒绝执行</li>\n</ol>\n<ul>\n<li><h3 id=\"fetch-发送-2-次请求的原因\"><a href=\"#fetch-发送-2-次请求的原因\" class=\"headerlink\" title=\"fetch 发送 2 次请求的原因\"></a>fetch 发送 2 次请求的原因</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>fetch 发送 post 请求的时候，总是发送 2 次，第一次状态码是 204，第二次才成功？ 原因很简单，因为你用 fetch 的 post 请求的时候，导致 fetch<br>第一次发送了一个Options 请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。</p>\n<ul>\n<li><h3 id=\"Cookie、sessionStorage、localStorage-的区别\"><a href=\"#Cookie、sessionStorage、localStorage-的区别\" class=\"headerlink\" title=\"Cookie、sessionStorage、localStorage 的区别\"></a>Cookie、sessionStorage、localStorage 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>共同点：都是保存在浏览器端，并且是同源的</p>\n<p>Cookie：cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递。而 sessionStorage 和 localStorage<br>不会自动把数据发给服务器，仅在本地保存。cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下,存储的大小很小只有 4K 左右。<br>（key：可以在浏览器和服务器端来回传递，存储容量小，只有大约 4K 左右）</p>\n<p>sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持， localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据； cookie 只在设置的<br>cookie 过期时间之前一直有效，即使窗口或浏览器关闭。（key： 本身就是一个回话过程，关闭浏览器后消失，session 为一个回话，当页面不同即使是同一页面打开两次，也被视为同一次回话）</p>\n<p>localStorage：localStorage 在所有同源窗口中都是共享的；cookie<br>也是在所有同源窗口中都是共享的。（key：同源窗口都会共享，并且不会失效，不管窗口或者浏览器关闭与否都会始终生效）</p>\n<p>补充说明一下 cookie 的作用：</p>\n<p>保存用户登录状态。例如将用户 id 存储于一个 cookie 内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie<br>还可以设置过期时间，当超过时间期限后，cookie 就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。</p>\n<p>跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了 cookie 后就会显得很人性化了，<br>系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后<br>台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便定制页面。如果网站提供了换肤或更换布局的功能， 那么可以使用 cookie<br>来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。</p>\n<ul>\n<li><h3 id=\"说一下-web-worker\"><a href=\"#说一下-web-worker\" class=\"headerlink\" title=\"说一下 web worker\"></a>说一下 web worker</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面你的性能。并且通过<br>postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。</p>\n<p>如何创建 web worker：</p>\n<p>检测浏览器对于 web worker 的支持性</p>\n<p>创建 web worker 文件（js，回传函数等） 创建 web worker 对象</p>\n<ul>\n<li><h3 id=\"对-HTML-语义化标签的理解\"><a href=\"#对-HTML-语义化标签的理解\" class=\"headerlink\" title=\"对 HTML 语义化标签的理解\"></a>对 HTML 语义化标签的理解</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>HTML5 语义化标签是指正确的标签包含了正确的内容，结构良好，便于阅读，比如 nav</p>\n<p>表示导航条，类似的还有 article、header、footer 等等标签。</p>\n<ul>\n<li><h3 id=\"iframe-是什么？有什么缺点？\"><a href=\"#iframe-是什么？有什么缺点？\" class=\"headerlink\" title=\"iframe 是什么？有什么缺点？\"></a>iframe 是什么？有什么缺点？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>定义：iframe 元素会创建包含另一个文档的内联框架</p>\n<p>提示：可以将提示文字放在&lt;iframe&gt;&lt;/iframe&gt;之间，来提示某些不支持 iframe 的浏览器</p>\n<p>缺点：</p>\n<p>会阻塞主页面的 onload 事件</p>\n<p>搜索引擎无法解读这种页面，不利于 SEO</p>\n<p>iframe 和主页面共享连接池，而浏览器对相同区域有限制所以会影响性能。</p>\n<ul>\n<li><h3 id=\"Doctype-作用-严格模式与混杂模式如何区分？它们有何意义\"><a href=\"#Doctype-作用-严格模式与混杂模式如何区分？它们有何意义\" class=\"headerlink\" title=\"Doctype 作用?严格模式与混杂模式如何区分？它们有何意义?\"></a>Doctype 作用?严格模式与混杂模式如何区分？它们有何意义?</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Doctype 声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。</p>\n<p>严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。</p>\n<p>混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。</p>\n<ul>\n<li><h3 id=\"Cookie-如何防范-XSS-攻击\"><a href=\"#Cookie-如何防范-XSS-攻击\" class=\"headerlink\" title=\"Cookie 如何防范 XSS 攻击\"></a>Cookie 如何防范 XSS 攻击</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>XSS（跨站脚本攻击）是指攻击者在返回的 HTML 中嵌入 javascript 脚本，为了减轻这些攻击，需要在 HTTP 头部配上，set-cookie：</p>\n<p>httponly-这个属性可以防止 XSS,它会禁止 javascript 脚本来访问 cookie。secure - 这个属性告诉浏览器仅在请求为 https 的时候发送 cookie。</p>\n<p>结果应该是这样的：Set-Cookie=&lt;cookie-value&gt;.</p>\n<ul>\n<li><h3 id=\"Cookie-和-session-的区别\"><a href=\"#Cookie-和-session-的区别\" class=\"headerlink\" title=\"Cookie 和 session 的区别\"></a>Cookie 和 session 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>HTTP 是一个无状态协议，因此 Cookie 的最大的作用就是存储 sessionId 用来唯一标识用户。</p>\n<ul>\n<li><h3 id=\"一句话概括-RESTFUL\"><a href=\"#一句话概括-RESTFUL\" class=\"headerlink\" title=\"一句话概括 RESTFUL\"></a>一句话概括 RESTFUL</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>就是用 URL 定位资源，用 HTTP 描述操作。</p>\n<ul>\n<li><h3 id=\"讲讲-viewport-和移动端布局\"><a href=\"#讲讲-viewport-和移动端布局\" class=\"headerlink\" title=\"讲讲 viewport 和移动端布局\"></a>讲讲 viewport 和移动端布局</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>可以参考这篇文章：</p>\n<p><a href=\"https://github.com/forthealllight/blog/issues/13\"><em>响应式布局的常用解决方案对比(媒体查询、百分比、rem 和 vw/vh）</em></a></p>\n<ul>\n<li><h3 id=\"click-在-ios-上有-300ms-延迟，原因及如何解决？\"><a href=\"#click-在-ios-上有-300ms-延迟，原因及如何解决？\" class=\"headerlink\" title=\"click 在 ios 上有 300ms 延迟，原因及如何解决？\"></a>click 在 ios 上有 300ms 延迟，原因及如何解决？</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li>粗暴型，禁用缩放</li>\n</ol>\n<meta name=\"viewport\" content=\"width=device-width, user-scalable=no\"> (2)利用 FastClick，其原理是：\n\n<p>检测到 touchend 事件后，立刻出发模拟 click 事件，并且把浏览器 300 毫秒之后真正出发的事件给阻断掉</p>\n<ul>\n<li><h3 id=\"addEventListener-参数\"><a href=\"#addEventListener-参数\" class=\"headerlink\" title=\"addEventListener 参数\"></a>addEventListener 参数</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>addEventListener(event, function, useCapture)</p>\n<p>其中，event 指定事件名；function 指定要事件触发时执行的函数；useCapture 指定事件是否在捕获或冒泡阶段执行。</p>\n<ul>\n<li><h3 id=\"cookie-sessionStorage-localStorage-区别\"><a href=\"#cookie-sessionStorage-localStorage-区别\" class=\"headerlink\" title=\"cookie sessionStorage localStorage 区别\"></a>cookie sessionStorage localStorage 区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>cookie 数据始终在同源的 http 请求中携带(即使不需要)，即 cookie 在浏览器和服务器间来回传递</p>\n<p>cookie 数据还有路径（path）的概念，可以限制。cookie 只属于某个路径下</p>\n<p>存储大小限制也不同，cookie 数据不能超过 4K，同时因为每次 http 请求都会携带</p>\n<p>cookie，所以 cookie 只适合保存很小的数据，如回话标识。</p>\n<p>webStorage 虽然也有存储大小的限制，但是比 cookie 大得多，可以达到 5M 或更大数据的有效期不同 sessionStorage：仅在当前的浏览器窗口关闭有效；<br>localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据； cookie：只在设置的 cookie 过期时间之前一直有效，即使窗口和浏览器关闭</p>\n<p>作用域不同 sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面； localStorage：在所有同源窗口都是共享的；cookie：也是在所有同源窗口中共享的</p>\n<ul>\n<li><h3 id=\"cookie-session-区别\"><a href=\"#cookie-session-区别\" class=\"headerlink\" title=\"cookie session 区别\"></a>cookie session 区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>cookie 数据存放在客户的浏览器上，session 数据放在服务器上。</p>\n</li>\n<li><p>cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗</p>\n</li>\n</ol>\n<p>考虑到安全应当使用 session。</p>\n<ol start=\"3\">\n<li>session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能</li>\n</ol>\n<p>考虑到减轻服务器性能方面，应当使用 COOKIE。</p>\n<ol start=\"4\">\n<li>单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个cookie。</li>\n</ol>\n<ul>\n<li><h3 id=\"介绍知道的-http-返回的状态码\"><a href=\"#介绍知道的-http-返回的状态码\" class=\"headerlink\" title=\"介绍知道的 http 返回的状态码\"></a>介绍知道的 http 返回的状态码</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>100 Continue 继续。客户端应继续其请求</p>\n<p>101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议</p>\n<p>200 OK 请求成功。一般用于 GET 与 POST 请求</p>\n<p>201 Created 已创建。成功请求并创建了新的资源</p>\n<p>202 Accepted 已接受。已经接受请求，但未处理完成</p>\n<p>203 Non-Authoritative Information 非授权信息。请求成功。但返回的 meta 信息不在原始的服务器，而是一个副本</p>\n<p>204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</p>\n<p>205 Reset Content 重置内容。服务器处理成功，用户终端（例如： 浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</p>\n<p>206 Partial Content 部分内容。服务器成功处理了部分 GET 请求</p>\n<p>300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</p>\n<p>301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替</p>\n<p>302 Found 临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有 URI</p>\n<p>303 See Other 查看其它地址。与 301 类似。使用 GET 和 POST 请求查看</p>\n<p>304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</p>\n<p>305 Use Proxy 使用代理。所请求的资源必须通过代理访问</p>\n<p>306 Unused 已经被废弃的 HTTP 状态码</p>\n<p>307 Temporary Redirect 临时重定向。与 302 类似。使用 GET 请求重定向</p>\n<p>400 Bad Request 客户端请求的语法错误，服务器无法理解401 Unauthorized 请求要求用户的身份认证</p>\n<p>402 Payment Required 保留，将来使用</p>\n<p>403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求</p>\n<p>404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</p>\n<p>405 Method Not Allowed 客户端请求中的方法被禁止</p>\n<p>406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求407 Proxy Authentication Required 请求要求代理的身份认证，与401<br>类似，但请求者应当使用代理进行授权</p>\n<p>408 Request Time-out 服务器等待客户端发送的请求时间过长，超时</p>\n<p>409 Conflict 服务器完成客户端的 PUT 请求是可能返回此代码，服务器处理请求时发生了冲突</p>\n<p>410 Gone 客户端请求的资源已经不存在。410 不同于 404，如果资源以前有现在被永久删除了可使用 410 代码，网站设计人员可通过 301 代码指定资源的新位置</p>\n<p>411 Length Required 服务器无法处理客户端发送的不带 Content- Length 的请求信息</p>\n<p>412 Precondition Failed 客户端请求信息的先决条件错误</p>\n<p>413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个<br>Retry-After 的响应信息</p>\n<p>414 Request-URI Too Large 请求的 URI 过长（URI 通常为网址），服务器无法处理</p>\n<p>415 Unsupported Media Type 服务器无法处理请求附带的媒体格式416 Requested range not satisfiable 客户端请求的范围无效417<br>Expectation Failed 服务器无法满足 Expect 的请求头信息 500 Internal Server Error 服务器内部错误，无法完成请求</p>\n<p>501 Not Implemented 服务器不支持请求的功能，无法完成请求</p>\n<p>502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时， 从远程服务器接收到了一个无效的响应</p>\n<p>503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中</p>\n<p>504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求</p>\n<p>505 HTTP Version not supported 服务器不支持请求的 HTTP 协议的版本，无法完成处理</p>\n<ul>\n<li><h3 id=\"http-常用请求头\"><a href=\"#http-常用请求头\" class=\"headerlink\" title=\"http 常用请求头\"></a>http 常用请求头</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>[TABLE]</p>\n<p>[TABLE]</p>\n<p>[TABLE]</p>\n<ul>\n<li><h3 id=\"强，协商缓存\"><a href=\"#强，协商缓存\" class=\"headerlink\" title=\"强，协商缓存\"></a>强，协商缓存</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>缓存分为两种：强缓存和协商缓存，根据响应的 header 内容来决定。</p>\n<p>[TABLE]</p>\n<p>强缓存相关字段有 expires，cache-control。如果 cache-control 与 expires 同时存在的话，cache-control 的优先级高于 expires。</p>\n<p>协商缓存相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match</p>\n<ul>\n<li><h3 id=\"讲讲-304\"><a href=\"#讲讲-304\" class=\"headerlink\" title=\"讲讲 304\"></a>讲讲 304</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个 304 状态</p>\n<p>码。</p>\n<ul>\n<li><h3 id=\"强缓存、协商缓存什么时候用哪个\"><a href=\"#强缓存、协商缓存什么时候用哪个\" class=\"headerlink\" title=\"强缓存、协商缓存什么时候用哪个\"></a>强缓存、协商缓存什么时候用哪个</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>因为服务器上的资源不是一直固定不变的，大多数情况下它会更新，这个时候如果我们还访问本地缓存，那么对用户来说，那就相当于资源没有更新，用户看到的还是旧的资源；所以我们希望服务器上的资源更新了浏览器就请求新的资源，没有更新就使用本地的缓存，以最大程度的减少因网络请求而产生的资源浪费。</p>\n<p><img src=\"media/image1.jpeg\"></p>\n<p>参考 <a href=\"https://segmentfault.com/a/1190000008956069\"><em>https://segmentfault.com/a/1190000008956069</em></a></p>\n<ul>\n<li><h3 id=\"前端优化\"><a href=\"#前端优化\" class=\"headerlink\" title=\"前端优化\"></a>前端优化</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>降低请求量：合并资源，减少 HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。</p>\n<p>加快请求速度：预解析 DNS，减少域名数，并行加载，CDN 分发。</p>\n<p>缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage。</p>\n<p>渲染：JS/CSS 优化，加载顺序，服务端渲染，pipeline。</p>\n<ul>\n<li><h3 id=\"GET-和-POST-的区别\"><a href=\"#GET-和-POST-的区别\" class=\"headerlink\" title=\"GET 和 POST 的区别\"></a>GET 和 POST 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>get 参数通过 url 传递，post 放在 request body 中。</p>\n<p>get 请求在 url 中传递的参数是有长度限制的，而 post 没有。</p>\n<p>get 比 post 更不安全，因为参数直接暴露在 url 中，所以不能用来传递敏感信息。get 请求只能进行 url 编码，而 post 支持多种编码方式</p>\n<p>get 请求会浏览器主动 cache，而 post 支持多种编码方式。</p>\n<p>get 请求参数会被完整保留在浏览历史记录里，而 post 中的参数不会被保留。</p>\n<p>GET 和 POST 本质上就是 TCP 链接，并无差别。但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p>\n<p>GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。</p>\n<ul>\n<li><h3 id=\"301-和-302-的区别\"><a href=\"#301-和-302-的区别\" class=\"headerlink\" title=\"301 和 302 的区别\"></a>301 和 302 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>301 Moved Permanently 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI<br>之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。</p>\n<p>302 Found 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires<br>中进行了指定的情况下，这个响应才是可缓存的。</p>\n<p>字面上的区别就是 301 是永久重定向，而 302 是临时重定向。</p>\n<p>301 比较常用的场景是使用域名跳转。302 用来做临时跳转 比如未登陆的用户访问用户中心重定向到登录页面。</p>\n<ul>\n<li><h3 id=\"HTTP-支持的方法\"><a href=\"#HTTP-支持的方法\" class=\"headerlink\" title=\"HTTP 支持的方法\"></a>HTTP 支持的方法</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"GET-POST-HEAD-OPTIONS-PUT-DELETE-TRACE-CONNECT\"><a href=\"#GET-POST-HEAD-OPTIONS-PUT-DELETE-TRACE-CONNECT\" class=\"headerlink\" title=\"GET, POST, HEAD, OPTIONS, PUT, DELETE, TRACE, CONNECT\"></a>GET, POST, HEAD, OPTIONS, PUT, DELETE, TRACE, CONNECT</h3><ul>\n<li><h3 id=\"如何画一个三角形\"><a href=\"#如何画一个三角形\" class=\"headerlink\" title=\"如何画一个三角形\"></a>如何画一个三角形</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>三角形原理：边框的均分原理</p>\n<h3 id=\"div-width-0px-height-0px\"><a href=\"#div-width-0px-height-0px\" class=\"headerlink\" title=\"div { width:0px; height:0px\"></a>div { width:0px; height:0px</h3><blockquote>\n<p>border-top:10px solid red;</p>\n</blockquote>\n<blockquote>\n<p>border-right:10px solid transparent; border-bottom:10px solid transparent; border-left:10px solid<br>transparent;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"状态码-304-和-200\"><a href=\"#状态码-304-和-200\" class=\"headerlink\" title=\"状态码 304 和 200\"></a>状态码 304 和 200</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>状态码 200：请求已成功，请求所希望的响应头或数据体将随此响应返回。即返回的数据为全量的数据，如果文件不通过 GZIP 压缩的话，文件是多大，则要有多大传输量。状态码<br>304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状<br>态码。即客户端和服务器端只需要传输很少的数据量来做文件的校验，如果文件没有 修改过，则不需要返回全量的数据。</p>\n<ul>\n<li><h3 id=\"说一下浏览器缓存\"><a href=\"#说一下浏览器缓存\" class=\"headerlink\" title=\"说一下浏览器缓存\"></a>说一下浏览器缓存</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>缓存分为两种：强缓存和协商缓存，根据响应的 header 内容来决定。</p>\n<p>强缓存相关字段有 expires，cache-control。如果 cache-control 与 expires 同时存在的话，cache-control 的优先级高于 expires。</p>\n<p>协商缓存相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match</p>\n<ul>\n<li><h3 id=\"HTML5-新增的元素\"><a href=\"#HTML5-新增的元素\" class=\"headerlink\" title=\"HTML5 新增的元素\"></a>HTML5 新增的元素</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>首先 html5 为了更好的实践 web 语义化，增加了 header，footer，nav,aside,section</p>\n<p>等语义化标签，在表单方面，为了增强表单，为 input 增加了 color，</p>\n<p>emial,data ,range 等类型，在存储方面，提供了<br>sessionStorage，localStorage,和离线存储，通过这些存储方式方便数据在客户端的存储和获取，在多媒体方面规定了音频和视频元素 audio 和<br>vedio，另外还有地理定位，canvas 画布，拖放，多线程编程的 web worker 和 websocket 协议。</p>\n<ul>\n<li><h3 id=\"在地址栏里输入一个-URL-到这个页面呈现出来，中间会发生什么？\"><a href=\"#在地址栏里输入一个-URL-到这个页面呈现出来，中间会发生什么？\" class=\"headerlink\" title=\"在地址栏里输入一个 URL,到这个页面呈现出来，中间会发生什么？\"></a>在地址栏里输入一个 URL,到这个页面呈现出来，中间会发生什么？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>这是一个必考的面试问题，</p>\n<p>输入 url 后，首先需要找到这个 url 域名的服务器 ip,为了寻找这个 ip，浏览器首先会寻找缓存，查看缓存中是否有记录，缓存的查找记录为：浏览器缓存-》系统缓存</p>\n<p>-》路由器缓存，缓存中没有则查找系统的 hosts 文件中是否有记录，如果没有则查询DNS 服务器，得到服务器的 ip 地址后，浏览器根据这个 ip 以及相应的端口号，构造一个 http<br>请求，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并将这个 http 请求封装在一个 tcp 包中，这个 tcp<br>包会依次经过传输层，网络层，数据链路层，物理层到达服务器，服务器解析这个请求来作出响应，返回相应的 html 给浏览器，因为 html 是一个树形结构，浏览器根据这个 html 来构建DOM 树，在<br>dom 树的构建过程中如果遇到 JS 脚本和外部 JS 连接，则会停止构建 DOM 树来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐 JS 代码应该放在 html<br>代码的后面，之后根据外部央视，内部央视，内联样式构建一个 CSS 对象模型树 CSSOM 树，构建完成后和 DOM 树合并为渲染树，这里主要做的是排除非视觉节点，比如</p>\n<p>script，meta 标签和排除 display 为 none 的节点，之后进行布局，布局主要是确定各个元素的位置和尺寸，之后是渲染页面，因为 html 文件中会含有图片，视频，音频等资源，在解析<br>DOM 的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是 4-6 个，当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过<br>Cache-Control、Last-Modify、Expires 等首部字段控制。Cache-Control 和 Expires 的区别在于 Cache-Control 使用相对时间，Expires<br>使用的是基于服务器 端的绝对时间，因为存在时差问题，一般采用 Cache-Control，在请求这些有设置了缓存的数据时，会先<br>查看是否过期，如果没有过期则直接使用本地缓存，过期则请求并在服务器校验文件是否修改，如果上一次 响应设置了 ETag 值会在这次请求的时候作为 If-None-Match<br>的值交给服务器校验，如果一致，继续校验Last-Modified，没有设置 ETag 则直接验证 Last-Modified，再决定是否返回 304。</p>\n<ul>\n<li><h3 id=\"cookie-和-session-的区别，localstorage-和-sessionstorage-的区别\"><a href=\"#cookie-和-session-的区别，localstorage-和-sessionstorage-的区别\" class=\"headerlink\" title=\"cookie 和 session 的区别，localstorage 和 sessionstorage 的区别\"></a>cookie 和 session 的区别，localstorage 和 sessionstorage 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Cookie 和 session 都可用来存储用户信息，cookie 存放于客户端，session 存放于服务器端，因为cookie 存放于客户端有可能被窃取，所以 cookie<br>一般用来存放不敏感的信息，比如用户设置的网站主题，敏感的信息用 session 存储，比如用户的登陆信息，session 可以存放于文件，数据库，内存中都可以，cookie<br>可以服务器端响应的时候设置，也可以客户端通过 JS 设置 cookie 会在请求时在 http 首部发送给客户端， cookie 一般在客户端有大小限制，一般为 4K，</p>\n<p>下面从几个方向区分一下 cookie，localstorage，sessionstorage 的区别1、生命周期：</p>\n<p>Cookie：可设置失效时间，否则默认为关闭浏览器后失效Localstorage:除非被手动清除，否则永久保存</p>\n<p>Sessionstorage：仅在当前网页会话下有效，关闭页面或浏览器后就会被清除 2、存放数据：</p>\n<p>Cookie：4k 左右</p>\n<p>Localstorage 和 sessionstorage：可以保存 5M 的信息3、http 请求：</p>\n<p>Cookie：每次都会携带在 http 头中，如果使用 cookie 保存过多数据会带来性能问题其他两个：仅在客户端即浏览器中保存，不参与和服务器的通信</p>\n<p>4、易用性：</p>\n<p>Cookie：需要程序员自己封装，原生的 cookie 接口不友好其他两个：即可采用原生接口，亦可再次封装</p>\n<p>5、应用场景：</p>\n<p>从安全性来说，因为每次 http 请求都回携带 cookie 信息，这样子浪费了带宽，所以cookie 应该尽可能的少用，此外 cookie<br>还需要指定作用域，不可以跨域调用，限制很多，但是用户识别用户登陆来说，cookie 还是比storage 好用，其他情况下可以用storage，localstorage<br>可以用来在页面传递参数，sessionstorage 可以用来保存一些临时的数据，防止用户刷新页面后丢失了一些参数。</p>\n<ul>\n<li><h3 id=\"常见的-HTTP-的头部\"><a href=\"#常见的-HTTP-的头部\" class=\"headerlink\" title=\"常见的 HTTP 的头部\"></a>常见的 HTTP 的头部</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>可以将 http 首部分为通用首部，请求首部，响应首部，实体首部通用首部表示一些通用信息，比如 date 表示报文创建时间，</p>\n<p>请求首部就是请求报文中独有的，如 cookie，和缓存相关的如 if-Modified-Since</p>\n<p>响应首部就是响应报文中独有的，如 set-cookie，和重定向相关的 location，</p>\n<p>实体首部用来描述实体部分，如 allow 用来描述可执行的请求方法，content-type 描述主题类型，content-Encoding 描述主体的编码方式。</p>\n<ul>\n<li><h3 id=\"HTTP2-0-的特性\"><a href=\"#HTTP2-0-的特性\" class=\"headerlink\" title=\"HTTP2.0 的特性\"></a>HTTP2.0 的特性</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>http2.0 的特性如下：</p>\n<p>1、内容安全，应为 http2.0 是基于 https 的，天然具有安全特性，通过 http2.0 的特性可以避免单纯使用 https 的性能下降</p>\n<p>2、二进制格式，http1.X 的解析是基于文本的，http2.0 将所有的传输信息分割为更小的消息和帧，并对他们采用二进制格式编码，基于二进制可以让协议有更多的扩展性，比如引入了帧来传输数据和指令</p>\n<p>3、多路复用，这个功能相当于是长连接的增强，每个 request 请求可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里<br>面，另外多路复用中也支持了流的优先级，允许客户端告诉服务器那些内容是更优先级的资源，可以优先传输。</p>\n<ul>\n<li><h3 id=\"cache-control-的值有哪些\"><a href=\"#cache-control-的值有哪些\" class=\"headerlink\" title=\"cache-control 的值有哪些\"></a>cache-control 的值有哪些</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>cache-control 是一个通用消息头字段被用于 HTTP 请求和响应中，通过指定指令来实现缓存机制，这个缓存指令是单向的，常见的取值有<br>private、no-cache、max-age、must-revalidate 等，默认为 private。</p>\n<ul>\n<li><h3 id=\"浏览器在生成页面的时候，会生成那两颗树？\"><a href=\"#浏览器在生成页面的时候，会生成那两颗树？\" class=\"headerlink\" title=\"浏览器在生成页面的时候，会生成那两颗树？\"></a>浏览器在生成页面的时候，会生成那两颗树？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>构造两棵树，DOM 树和 CSSOM 规则树，</p>\n<p>当浏览器接收到服务器相应来的 HTML 文档后，会遍历文档节点，生成 DOM 树， CSSOM 规则树由浏览器解析 CSS 文件生成。</p>\n<ul>\n<li><h3 id=\"csrf-和-xss-的网络攻击及防范\"><a href=\"#csrf-和-xss-的网络攻击及防范\" class=\"headerlink\" title=\"csrf 和 xss 的网络攻击及防范\"></a>csrf 和 xss 的网络攻击及防范</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>CSRF：跨站请求伪造，可以理解为攻击者盗用了用户的身份，以用户的名义发送了恶意请求，比如用户登录了一个网站后，立刻在另一个ｔａｂ页面访问量攻击者用来制</p>\n<p>造攻击的网站，这个网站要求访问刚刚登陆的网站，并发送了一个恶意请求，这时候CSRF<br>就产生了，比如这个制造攻击的网站使用一张图片，但是这种图片的链接却是可以修改数据库的，这时候攻击者就可以以用户的名义操作这个数据库，防御方式的 话：使用验证码，检查 https 头部的<br>refer，使用 token XSS：跨站脚本攻击，是说攻击者通过注入恶意的脚本，在用户浏览网页的时候进行攻击，比如获取<br>cookie，或者其他用户身份信息，可以分为存储型和反射型，存储型是攻击者输入一些数据并且存储到了数据库中，其他浏览者看到的时候进行攻击，反射型的话不存储在数据库中，往往表现为将攻击代码放在 url<br>地址的请求参数中，防御的话为 cookie 设置 httpOnly 属性，对用户的输入进行检查，进行特殊字符过滤。</p>\n<ul>\n<li><h3 id=\"怎么看网站的性能如何\"><a href=\"#怎么看网站的性能如何\" class=\"headerlink\" title=\"怎么看网站的性能如何\"></a>怎么看网站的性能如何</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>检测页面加载时间一般有两种方式，一种是被动去测：就是在被检测的页面置入脚本或探针，当用户访问网页时，探针自动采集数据并传回数据库进行分析，另一种主动监测的方式，即主动的搭建分布式受控环境，模拟用户发起页面访问请求，主动采集性能数据并分析，在检测的精准度上，专业的第三方工具效果更佳，比如说性能极<br>客。</p>\n<ul>\n<li><h3 id=\"介绍-HTTP-协议-特征\"><a href=\"#介绍-HTTP-协议-特征\" class=\"headerlink\" title=\"介绍 HTTP 协议(特征)\"></a>介绍 HTTP 协议(特征)</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>HTTP 是一个基于 TCP/IP 通信协议来传递数据（HTML 文件, 图片文件, 查询结果等） HTTP 是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于<br>1990 年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在 WWW 中使用的是 HTTP/1.0 的第六版，HTTP/1.1 的规范化工作正在进行之中，而且 HTTP-NG(Next<br>Generation of HTTP)的建议已经提出。HTTP 协议工作于客户端-服务端架构为上。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器发送所有请求。Web<br>服务器根据接收到的请求后，向客户端发送响应信息。</p>\n<ul>\n<li><h3 id=\"输入-URL-到页面加载显示完成发生了什么\"><a href=\"#输入-URL-到页面加载显示完成发生了什么\" class=\"headerlink\" title=\"输入 URL 到页面加载显示完成发生了什么?\"></a>输入 URL 到页面加载显示完成发生了什么?</h3></li>\n</ul>\n<p>参考回答： DNS 解析TCP 连接</p>\n<p>发送 HTTP 请求</p>\n<p>服务器处理请求并返回 HTTP 报文浏览器解析渲染页面</p>\n<p>连接结束</p>\n<ul>\n<li><h3 id=\"说一下对-Cookie-和-Session-的认知，Cookie-有哪些限制？\"><a href=\"#说一下对-Cookie-和-Session-的认知，Cookie-有哪些限制？\" class=\"headerlink\" title=\"说一下对 Cookie 和 Session 的认知，Cookie 有哪些限制？\"></a>说一下对 Cookie 和 Session 的认知，Cookie 有哪些限制？</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>cookie 数据存放在客户的浏览器上，session 数据放在服务器上。</p>\n</li>\n<li><p>cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗</p>\n</li>\n</ol>\n<p>考虑到安全应当使用 session。</p>\n<ol start=\"3\">\n<li>session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能</li>\n</ol>\n<p>考虑到减轻服务器性能方面，应当使用 COOKIE。</p>\n<ol start=\"4\">\n<li>单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个cookie。</li>\n</ol>\n<ul>\n<li><h3 id=\"描述一下-XSS-和-CRSF-攻击？防御方法？\"><a href=\"#描述一下-XSS-和-CRSF-攻击？防御方法？\" class=\"headerlink\" title=\"描述一下 XSS 和 CRSF 攻击？防御方法？\"></a>描述一下 XSS 和 CRSF 攻击？防御方法？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>XSS, 即为（Cross Site Scripting）, 中文名为跨站脚本, 是发生在目标用户的浏览器层面上的，当渲染 DOM 树的过程成发生了不在预期内执行的 JS 代码时，就发生了XSS<br>攻击。大多数 XSS 攻击的主要方式是嵌入一段远程或者第三方域上的 JS 代码。实际上是在目标网站的作用域下执行了这段 JS 代码。</p>\n<p>CSRF（Cross Site Request Forgery，跨站请求伪造），字面理解意思就是在别的站点伪造了一个请求。专业术语来说就是在受害者访问一个网站时，其 Cookie<br>还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。</p>\n<p>XSS 防御的总体思路是：对输入(和 URL 参数)进行过滤，对输出进行编码。也就是对提交的所有内容进行过滤，对 url<br>中的参数进行过滤，过滤掉会导致脚本执行的相关内容；然后对动态输出到页面的内容进行 html 编码，使脚本无法在浏览器中执行。虽然对输入过滤可以被绕过，但是也还是会拦截很大一部分的 XSS 攻击。</p>\n<p>防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token</p>\n<p>并验证；在 HTTP 头中自定义属性并验证。</p>\n<ul>\n<li><h3 id=\"知道-304-吗，什么时候用-304？\"><a href=\"#知道-304-吗，什么时候用-304？\" class=\"headerlink\" title=\"知道 304 吗，什么时候用 304？\"></a>知道 304 吗，什么时候用 304？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个 304 状态</p>\n<p>码。</p>\n<ul>\n<li><h3 id=\"具体有哪些请求头是跟缓存相关的\"><a href=\"#具体有哪些请求头是跟缓存相关的\" class=\"headerlink\" title=\"具体有哪些请求头是跟缓存相关的\"></a>具体有哪些请求头是跟缓存相关的</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>缓存分为两种：强缓存和协商缓存，根据响应的 header 内容来决定。</p>\n<p>强缓存相关字段有 expires，cache-control。如果 cache-control 与 expires 同时存在的话，cache-control 的优先级高于 expires。</p>\n<p>协商缓存相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match</p>\n<ul>\n<li><h3 id=\"cookie-和-session-的区别\"><a href=\"#cookie-和-session-的区别\" class=\"headerlink\" title=\"cookie 和 session 的区别\"></a>cookie 和 session 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>cookie 数据存放在客户的浏览器上，session 数据放在服务器上。</p>\n</li>\n<li><p>cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗</p>\n</li>\n</ol>\n<p>考虑到安全应当使用 session。</p>\n<ol start=\"3\">\n<li>session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能</li>\n</ol>\n<p>考虑到减轻服务器性能方面，应当使用 COOKIE。</p>\n<ol start=\"4\">\n<li>单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个cookie。</li>\n</ol>\n<ul>\n<li><h3 id=\"cookie-有哪些字段可以设置\"><a href=\"#cookie-有哪些字段可以设置\" class=\"headerlink\" title=\"cookie 有哪些字段可以设置\"></a>cookie 有哪些字段可以设置</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>name 字段为一个 cookie 的名称。value 字段为一个 cookie 的值。</p>\n<p>domain 字段为可以访问此 cookie 的域名。</p>\n<p>非顶级域名，如二级域名或者三级域名，设置的 cookie 的 domain 只能为顶级域名或者二级域名或者三级域名本身，不能设置其他二级域名的 cookie，否则 cookie 无法生成。</p>\n<p>顶级域名只能设置 domain 为顶级域名，不能设置为二级域名或者三级域名，否则</p>\n<p>cookie 无法生成。</p>\n<p>二级域名能读取设置了 domain 为顶级域名或者自身的 cookie，不能读取其他二级域名domain 的 cookie。所以要想 cookie 在多个二级域名中共享，需要设置 domain<br>为顶级域名，这样就可以在所有二级域名里面或者到这个 cookie 的值了。</p>\n<p>顶级域名只能获取到 domain 设置为顶级域名的 cookie，其他 domain 设置为二级域名的无法获取。</p>\n<p>path 字段为可以访问此 cookie 的页面路径。 比如 domain 是 abc.com,path 是/test， 那么只有/test 路径下的页面可以读取此 cookie。</p>\n<p>expires/Max-Age 字段为此 cookie 超时时间。若设置其值为一个时间，那么当到达此时间后，此 cookie 失效。不设置的话默认值是 Session，意思是 cookie<br>会和session 一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie 失效。</p>\n<p>Size 字段 此 cookie 大小。</p>\n<p>http 字段 cookie 的 httponly 属性。若此属性为 true，则只有在 http 请求头中会带有此 cookie 的信息，而不能通过 document.cookie 来访问此<br>cookie。</p>\n<p>secure 字段 设置是否只能通过 https 来传递此条 cookie</p>\n<ul>\n<li><h3 id=\"cookie-有哪些编码方式？\"><a href=\"#cookie-有哪些编码方式？\" class=\"headerlink\" title=\"cookie 有哪些编码方式？\"></a>cookie 有哪些编码方式？</h3></li>\n</ul>\n<p>参 考 回 答 ： encodeURI（）</p>\n<ul>\n<li><h3 id=\"除了-cookie，还有什么存储方式。说说-cookie-和-localStorage-的区别\"><a href=\"#除了-cookie，还有什么存储方式。说说-cookie-和-localStorage-的区别\" class=\"headerlink\" title=\"除了 cookie，还有什么存储方式。说说 cookie 和 localStorage 的区别\"></a>除了 cookie，还有什么存储方式。说说 cookie 和 localStorage 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>还有 localStorage，sessionStorage，indexdDB 等cookie 和 localStorage 的区别：</p>\n<p>cookie 数据始终在同源的 http 请求中携带(即使不需要)，即 cookie 在浏览器和服务器间来回传递</p>\n<p>cookie 数据还有路径（path）的概念，可以限制。cookie 只属于某个路径下</p>\n<p>存储大小限制也不同，cookie 数据不能超过 4K，同时因为每次 http 请求都会携带</p>\n<p>cookie，所以 cookie 只适合保存很小的数据，如回话标识。</p>\n<p>localStorage 虽然也有存储大小的限制，但是比cookie 大得多，可以达到 5M 或更大localStorage 始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie<br>只在设置的 cookie 过期时间之前一直有效，即使窗口和浏览器关闭。</p>\n<ul>\n<li><h3 id=\"浏览器输入网址到页面渲染全过程\"><a href=\"#浏览器输入网址到页面渲染全过程\" class=\"headerlink\" title=\"浏览器输入网址到页面渲染全过程\"></a>浏览器输入网址到页面渲染全过程</h3></li>\n</ul>\n<p>参考回答： DNS 解析TCP 连接</p>\n<p>发送 HTTP 请求</p>\n<p>服务器处理请求并返回 HTTP 报文浏览器解析渲染页面</p>\n<p>连接结束</p>\n<ul>\n<li><h3 id=\"HTML5-和-CSS3-用的多吗？你了解它们的新属性吗？有在项目中用过吗？\"><a href=\"#HTML5-和-CSS3-用的多吗？你了解它们的新属性吗？有在项目中用过吗？\" class=\"headerlink\" title=\"HTML5 和 CSS3 用的多吗？你了解它们的新属性吗？有在项目中用过吗？\"></a>HTML5 和 CSS3 用的多吗？你了解它们的新属性吗？有在项目中用过吗？</h3></li>\n</ul>\n<p>参考回答： html5： 1）标签增删</p>\n<p>8 个语义元素 header section footer aside nav main article figure 内容元素 mark 高亮 progress 进度</p>\n<p>新的表单控件 calander date time email url search</p>\n<p>新的 input 类型 color date datetime datetime-local email 移除过时标签 big font frame frameset</p>\n<p>2）canvas 绘图，支持内联 SVG。支持 MathML 3）多媒体 audio video source embed track</p>\n<ol start=\"4\">\n<li><p>本地离线存储，把需要离线存储在本地的文件列在一个 manifest 配置文件</p>\n</li>\n<li><p>web 存储。localStorage、SessionStorage</p>\n</li>\n</ol>\n<p>css3：</p>\n<p>CSS3 边框如 border-radius，box-shadow 等；CSS3 背景如 background-size， background-origin 等；CSS3 2D，3D 转换如<br>transform 等；CSS3 动画如 animation 等。 参考<br><a href=\"https://www.cnblogs.com/xkweb/p/5862612.html\"><em>https://www.cnblogs.com/xkweb/p/5862612.html</em></a></p>\n<ul>\n<li><h3 id=\"http-常见的请求方法\"><a href=\"#http-常见的请求方法\" class=\"headerlink\" title=\"http 常见的请求方法\"></a>http 常见的请求方法</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>get、post，这两个用的是最多的，还有很多比如 patch、delete、put、options 等等</p>\n<ul>\n<li><h3 id=\"get-和-post-的区别\"><a href=\"#get-和-post-的区别\" class=\"headerlink\" title=\"get 和 post 的区别\"></a>get 和 post 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>GET - 从指定的资源请求数据。</p>\n<p>POST - 向指定的资源提交要被处理的数据。</p>\n<p>GET：不同的浏览器和服务器不同，一般限制在 2~8K 之间，更加常见的是 1k 以内。GET 和 POST 的底层也是 TCP/IP，GET/POST 都是 TCP 链接。</p>\n<p>GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。</p>\n<p>对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应</p>\n<p>200（返回数据）；</p>\n<p>而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送data，服务器响应 200 ok（返回数据）。</p>\n<ul>\n<li><h3 id=\"说说-302，301，304-的状态码\"><a href=\"#说说-302，301，304-的状态码\" class=\"headerlink\" title=\"说说 302，301，304 的状态码\"></a>说说 302，301，304 的状态码</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替</p>\n<p>302 Found 临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有 URI</p>\n<p>304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</p>\n<ul>\n<li><h3 id=\"web-性能优化\"><a href=\"#web-性能优化\" class=\"headerlink\" title=\"web 性能优化\"></a>web 性能优化</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>降低请求量：合并资源，减少 HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。</p>\n<p>加快请求速度：预解析 DNS，减少域名数，并行加载，CDN 分发。</p>\n<p>缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage。</p>\n<p>渲染：JS/CSS 优化，加载顺序，服务端渲染，pipeline。</p>\n<ul>\n<li><h3 id=\"浏览器缓存机制\"><a href=\"#浏览器缓存机制\" class=\"headerlink\" title=\"浏览器缓存机制\"></a>浏览器缓存机制</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>缓存分为两种：强缓存和协商缓存，根据响应的 header 内容来决定。</p>\n<p>强缓存相关字段有 expires，cache-control。如果 cache-control 与 expires 同时存在的话，cache-control 的优先级高于 expires。</p>\n<p>协商缓存相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match</p>\n<ul>\n<li><h3 id=\"post-和-get-区别\"><a href=\"#post-和-get-区别\" class=\"headerlink\" title=\"post 和 get 区别\"></a>post 和 get 区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>GET - 从指定的资源请求数据。</p>\n<p>POST - 向指定的资源提交要被处理的数据。</p>\n<p>GET：不同的浏览器和服务器不同，一般限制在 2~8K 之间，更加常见的是 1k 以内。GET 和 POST 的底层也是 TCP/IP，GET/POST 都是 TCP 链接。</p>\n<p>GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。</p>\n<p>对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应</p>\n<p>200（返回数据）；</p>\n<p>而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送data，服务器响应 200 ok（返回数据）。</p>\n<h2 id=\"1-2-CSS\"><a href=\"#1-2-CSS\" class=\"headerlink\" title=\"1.2 | CSS\"></a>1.2 | CSS</h2><ul>\n<li><h3 id=\"说一下-css-盒模型\"><a href=\"#说一下-css-盒模型\" class=\"headerlink\" title=\"说一下 css 盒模型\"></a>说一下 css 盒模型</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>简介：就是用来装页面上的元素的矩形区域。CSS 中的盒子模型包括 IE 盒子模型和标准的 W3C 盒子模型。</p>\n<p>box-sizing(有 3 个值哦)：border-box,padding-box,content-box. 标准盒子模型：</p>\n<p><img src=\"media/image2.jpeg\"></p>\n<p><img src=\"media/image3.jpeg\"> IE 盒子模型：</p>\n<p>区别：从图中我们可以看出，这两种盒子模型最主要的区别就是 width 的包含范围， 在标准的盒子模型中，width 指 content 部分的宽度，在 IE 盒子模型中，width<br>表示content+padding+border 这三个部分的宽度，故这使得在计算整个盒子的宽度时存在着差异：</p>\n<p>标准盒子模型的盒子宽度：左右 border+左右 padding+width IE 盒子模型的盒子宽度：width</p>\n<p>在 CSS3 中引入了 box-sizing 属性，box-sizing:content-box;表示标准的盒子模型，</p>\n<p>box-sizing:border-box 表示的是 IE 盒子模型</p>\n<p>最后，前面我们还提到了，box-sizing:padding-box,这个属性值的宽度包含了左右</p>\n<p>padding+width</p>\n<p>也很好理解性记忆，包含什么，width 就从什么开始算起。</p>\n<ul>\n<li><h3 id=\"画一条-0-5px-的线\"><a href=\"#画一条-0-5px-的线\" class=\"headerlink\" title=\"画一条 0.5px 的线\"></a>画一条 0.5px 的线</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>采用 meta viewport 的方式</p>\n<meta name=\"viewport\" content=\"initial-scale=1.0, maximum-scale=1.0, user- scalable=no\" />\n\n<p>采用 border-image 的方式</p>\n<p>采用 transform: scale()的方式</p>\n<ul>\n<li><h3 id=\"link-标签和-import-标签的区别\"><a href=\"#link-标签和-import-标签的区别\" class=\"headerlink\" title=\"link 标签和 import 标签的区别\"></a>link 标签和 import 标签的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>link 属于 html 标签，而@import 是 css 提供的</p>\n<p>页面被加载时，link 会同时被加载，而@import 引用的 css 会等到页面加载结束后加载。</p>\n<p>link 是 html 标签，因此没有兼容性，而@import 只有 IE5 以上才能识别。link 方式样式的权重高于@import 的。</p>\n<ul>\n<li><h3 id=\"transition-和-animation-的区别\"><a href=\"#transition-和-animation-的区别\" class=\"headerlink\" title=\"transition 和 animation 的区别\"></a>transition 和 animation 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Animation 和 transition 大部分属性是相同的，他们都是随时间改变元素的属性值， 他们的主要区别是 transition 需要触发一个事件才能改变属性，而 animation<br>不需要触发任何事件的情况下才会随时间改变属性值，并且 transition 为 2 帧，从</p>\n<p>from to，而 animation 可以一帧一帧的。</p>\n<ul>\n<li><h3 id=\"Flex-布局\"><a href=\"#Flex-布局\" class=\"headerlink\" title=\"Flex 布局\"></a>Flex 布局</h3></li>\n</ul>\n<p>参考回答： 文章链接：</p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool%EF%BC%88%E8%AF%AD%E6%B3%95%E7%AF%87%EF%BC%89\"><em>http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool</em></a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool%EF%BC%88%E8%AF%AD%E6%B3%95%E7%AF%87%EF%BC%89\"><em>（语法篇）</em></a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-examples.html%EF%BC%88%E5%AE%9E%E4%BE%8B%E7%AF%87%EF%BC%89\"><em>http://www.ruanyifeng.com/blog/2015/07/flex-examples.html（实例篇）</em></a>Flex<br>是</p>\n<p>Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p>\n<p>布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。</p>\n<p>简单的分为容器属性和元素属性容器的属性：</p>\n<p>flex-direction：决定主轴的方向（即子 item 的排列方法）</p>\n<p>.box {</p>\n<p>flex-direction: row | row-reverse | column | column-reverse;</p>\n<p>}</p>\n<p>flex-wrap：决定换行规则</p>\n<p>.box{</p>\n<p>flex-wrap: nowrap | wrap | wrap-reverse;</p>\n<p>}</p>\n<p>flex-flow：</p>\n<p>.box {</p>\n<p>flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</p>\n<p>}</p>\n<p>justify-content：对其方式，水平主轴对齐方式align-items：对齐方式，竖直轴线方向</p>\n<p>项目的属性（元素的属性）：</p>\n<p>order 属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为 0 flex-grow 属性：定义项目的放大比例，即使存在空间，也不会放大</p>\n<p>flex-shrink 属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果定义个 item 的 flow-shrink 为 0，则为不缩小</p>\n<p>flex-basis 属性：定义了在分配多余的空间，项目占据的空间。</p>\n<p>flex：是 flex-grow 和 flex-shrink、flex-basis 的简写，默认值为 0 1 auto。align-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖<br>align-items，默认属性为 auto，表示继承父元素的 align-items</p>\n<p>比如说，用 flex 实现圣杯布局</p>\n<ul>\n<li><h3 id=\"BFC（块级格式化上下文，用于清楚浮动，防止-margin-重叠等）\"><a href=\"#BFC（块级格式化上下文，用于清楚浮动，防止-margin-重叠等）\" class=\"headerlink\" title=\"BFC（块级格式化上下文，用于清楚浮动，防止 margin 重叠等）\"></a>BFC（块级格式化上下文，用于清楚浮动，防止 margin 重叠等）</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>直译成：块级格式化上下文，是一个独立的渲染区域，并且有一定的布局规则。BFC 区域不会与 float box 重叠</p>\n<p>BFC 是页面上的一个独立容器，子元素不会影响到外面计算 BFC 的高度时，浮动元素也会参与计算</p>\n<p>那些元素会生成 BFC：</p>\n<p>根元素</p>\n<p>float 不为 none 的元素</p>\n<p>position 为 fixed 和 absolute 的元素</p>\n<p>display 为 inline-block、table-cell、table-caption，flex，inline-flex 的元素overflow 不为 visible 的元素</p>\n<ul>\n<li><h3 id=\"垂直居中的方法\"><a href=\"#垂直居中的方法\" class=\"headerlink\" title=\"垂直居中的方法\"></a>垂直居中的方法</h3></li>\n</ul>\n<p>参 考 回 答 ： (1)margin:auto 法css:</p>\n<h3 id=\"div\"><a href=\"#div\" class=\"headerlink\" title=\"div{\"></a>div{</h3><blockquote>\n<p>width: 400px; height: 400px; position: relative;</p>\n</blockquote>\n<blockquote>\n<p>border: 1px solid #465468;</p>\n</blockquote>\n<blockquote>\n<p>} img{</p>\n</blockquote>\n<blockquote>\n<p>position: absolute; margin: auto;</p>\n</blockquote>\n<blockquote>\n<p>top: 0; left: 0; right: 0; bottom: 0;</p>\n</blockquote>\n<blockquote>\n<p>} html:</p>\n</blockquote>\n<blockquote>\n<div>\n</blockquote>\n<blockquote>\n<img src=\"mm.jpg\">\n</blockquote>\n<blockquote>\n</div>\n</blockquote>\n<p>定位为上下左右为 0，margin：0 可以实现脱离文档流的居中. (2)margin 负值法</p>\n<h3 id=\"container-width-500px-height-400px\"><a href=\"#container-width-500px-height-400px\" class=\"headerlink\" title=\".container{ width: 500px; height: 400px\"></a>.container{ width: 500px; height: 400px</h3><blockquote>\n<p>border: 2px solid #379; position: relative;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.inner{ width: 480px;</p>\n</blockquote>\n<blockquote>\n<p>height: 380px; background-color: #746; position: absolute; top: 50%;</p>\n</blockquote>\n<blockquote>\n<p>left: 50%;</p>\n</blockquote>\n<p>margin-top: -190px; /*height 的一半*/ margin-left: -240px; /*width 的一半*/</p>\n<p>}</p>\n<p>补充：其实这里也可以将 marin-top 和 margin-left 负值替换成， transform：translateX(-50%) 和 transform：translateY(-50%)<br>(3)table-cell（未脱离文档流的）</p>\n<p>设置父元素的 display:table-cell,并且 vertical-align:middle，这样子元素可以实现垂直居中。</p>\n<h3 id=\"css-div\"><a href=\"#css-div\" class=\"headerlink\" title=\"css: div{\"></a>css: div{</h3><blockquote>\n<p>width: 300px; height: 300px;</p>\n</blockquote>\n<blockquote>\n<p>border: 3px solid #555; display: table-cell; vertical-align: middle; text-align: center;</p>\n</blockquote>\n<blockquote>\n<p>} img{</p>\n</blockquote>\n<blockquote>\n<p>vertical-align: middle;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ol start=\"4\">\n<li>利用 flex</li>\n</ol>\n<p>将父元素设置为 display:flex，并且设置 align-items:center;justify- content:center;</p>\n<ul>\n<li><h3 id=\"关于-JS-动画和-css3-动画的差异性\"><a href=\"#关于-JS-动画和-css3-动画的差异性\" class=\"headerlink\" title=\"关于 JS 动画和 css3 动画的差异性\"></a>关于 JS 动画和 css3 动画的差异性</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>渲染线程分为 main thread 和 compositor thread，如果 css 动画只改变 transform 和opacity，这时整个 CSS 动画得以在 compositor<br>trhead 完成（而 JS 动画则会在 main thread 执行，然后出发 compositor thread 进行下一步操作），特别注意的是如果改变 transform 和 opacity<br>是不会 layout 或者 paint 的。</p>\n<p>区别：</p>\n<p>功能涵盖面，JS 比 CSS 大</p>\n<p>实现/重构难度不一，CSS3 比 JS 更加简单，性能跳优方向固定对帧速表现不好的低版本浏览器，css3 可以做到自然降级</p>\n<p>css 动画有天然事件支持css3 有兼容性问题</p>\n<ul>\n<li><h3 id=\"说一下块元素和行元素\"><a href=\"#说一下块元素和行元素\" class=\"headerlink\" title=\"说一下块元素和行元素\"></a>说一下块元素和行元素</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>块元素：独占一行，并且有自动填满父元素，可以设置 margin 和 pading 以及高度和宽度</p>\n<p>行元素：不会独占一行，width 和 height 会失效，并且在垂直方向的 padding 和</p>\n<p>margin 会失效。</p>\n<ul>\n<li><h3 id=\"多行元素的文本省略号\"><a href=\"#多行元素的文本省略号\" class=\"headerlink\" title=\"多行元素的文本省略号\"></a>多行元素的文本省略号</h3></li>\n</ul>\n<p>参考回答：</p>\n<ul>\n<li><h3 id=\"visibility-hidden-opacity-0，display-none\"><a href=\"#visibility-hidden-opacity-0，display-none\" class=\"headerlink\" title=\"visibility=hidden, opacity=0，display:none\"></a>visibility=hidden, opacity=0，display:none</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>opacity=0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如 click 事件，那么点击该区域，也能触发点击事件的 visibility=hidden，<br>该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件display=none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样。</p>\n<ul>\n<li><h3 id=\"双边距重叠问题（外边距折叠）\"><a href=\"#双边距重叠问题（外边距折叠）\" class=\"headerlink\" title=\"双边距重叠问题（外边距折叠）\"></a>双边距重叠问题（外边距折叠）</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>多个相邻（兄弟或者父子关系）普通流的块元素垂直方向 marigin 会重叠折叠的结果为：</p>\n<p>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。</p>\n<ul>\n<li><h3 id=\"position-属性-比较\"><a href=\"#position-属性-比较\" class=\"headerlink\" title=\"position 属性 比较\"></a>position 属性 比较</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>固定定位 fixed：</p>\n<p>元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重</p>\n<p>叠。</p>\n<p>相对定位 relative：</p>\n<p>如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。<br>在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 绝对定位 absolute：</p>\n<p>绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素， 那么它的位置相对于&lt;html&gt;。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute<br>定位的元素和其他元素重叠。</p>\n<p>粘性定位 sticky：</p>\n<p>元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和containing<br>block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。</p>\n<p>默认定位 Static：</p>\n<p>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者z-index 声明）。</p>\n<p>inherit:</p>\n<p>规定应该从父元素继承 position 属性的值。</p>\n<ul>\n<li><h3 id=\"浮动清除\"><a href=\"#浮动清除\" class=\"headerlink\" title=\"浮动清除\"></a>浮动清除</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>方法一：使用带 clear 属性的空元素</p>\n<p>在浮动元素后使用一个空元素如&lt;div class=”clear”&gt;&lt;/div&gt;，并在 CSS 中赋</p>\n<p>予.clear{clear:both;}属性即可清理浮动。亦可使用&lt;br class=”clear” /&gt;或&lt;hr class=”clear” /&gt;来进行清理。</p>\n<p>方法二：使用 CSS 的 overflow 属性</p>\n<p>给浮动元素的容器添加 overflow:hidden;或 overflow:auto;可以清除浮动，另外在IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。</p>\n<p>在添加 overflow 属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。</p>\n<p>方法三：给浮动的元素的容器添加浮动</p>\n<p>给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动， 影响布局，不推荐使用。</p>\n<p>方法四：使用邻接元素处理</p>\n<p>什么都不做，给浮动元素后面的元素添加 clear 属性。方法五：使用 CSS 的:after 伪元素</p>\n<p>结合:after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素） 和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发hasLayout。</p>\n<p>给浮动元素的容器添加一个 clearfix 的 class，然后给这个 class 添加一个:after 伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。</p>\n<p>参考<br><a href=\"https://www.cnblogs.com/ForEvErNoME/p/3383539.html\"><em>https://www.cnblogs.com/ForEvErNoME/p/3383539.html</em></a></p>\n<ul>\n<li><h3 id=\"css3-新特性\"><a href=\"#css3-新特性\" class=\"headerlink\" title=\"css3 新特性\"></a>css3 新特性</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>开放题。CSS3 边框如 border-radius，box-shadow 等；CSS3 背景如 background- size，background-origin 等；CSS3 2D，3D 转换如<br>transform 等；CSS3 动画如animation 等。</p>\n<p>参考 <a href=\"https://www.cnblogs.com/xkweb/p/5862612.html\"><em>https://www.cnblogs.com/xkweb/p/5862612.html</em></a></p>\n<ul>\n<li><h3 id=\"CSS-选择器有哪些，优先级呢\"><a href=\"#CSS-选择器有哪些，优先级呢\" class=\"headerlink\" title=\"CSS 选择器有哪些，优先级呢\"></a>CSS 选择器有哪些，优先级呢</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>id 选择器，class 选择器，标签选择器，伪元素选择器，伪类选择器等</p>\n<p>同一元素引用了多个样式时，排在后面的样式属性的优先级高；</p>\n<p>样式选择器的类型不同时，优先级顺序为：id 选择器 &gt; class 选择器 &gt; 标签选择器；</p>\n<p>标签之间存在层级包含关系时，后代元素会继承祖先元素的样式。如果后代元素定义了与祖先元素相同的样式，则祖先元素的相同的样式属性会被覆盖。继承的样式的优先级比较低，至少比标签选择器的优先级低；</p>\n<p>带有!important 标记的样式属性的优先级最高；</p>\n<p>样式表的来源不同时，优先级顺序为：内联样式&gt; 内部样式 &gt; 外部样式 &gt; 浏览器用户自定义样式 &gt; 浏览器默认样式</p>\n<ul>\n<li><h3 id=\"清除浮动的方法，能讲讲吗\"><a href=\"#清除浮动的方法，能讲讲吗\" class=\"headerlink\" title=\"清除浮动的方法，能讲讲吗\"></a>清除浮动的方法，能讲讲吗</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>方法一：使用带 clear 属性的空元素</p>\n<p>在浮动元素后使用一个空元素如&lt;div class=”clear”&gt;&lt;/div&gt;，并在 CSS 中赋</p>\n<p>予.clear{clear:both;}属性即可清理浮动。亦可使用&lt;br class=”clear” /&gt;或&lt;hr class=”clear” /&gt;来进行清理。</p>\n<p>方法二：使用 CSS 的 overflow 属性</p>\n<p>给浮动元素的容器添加 overflow:hidden;或 overflow:auto;可以清除浮动，另外在IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。</p>\n<p>在添加 overflow 属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。</p>\n<p>方法三：给浮动的元素的容器添加浮动</p>\n<p>给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动， 影响布局，不推荐使用。</p>\n<p>方法四：使用邻接元素处理</p>\n<p>什么都不做，给浮动元素后面的元素添加 clear 属性。方法五：使用 CSS 的:after 伪元素</p>\n<p>结合:after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素） 和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发hasLayout。</p>\n<p>给浮动元素的容器添加一个 clearfix 的 class，然后给这个 class 添加一个:after 伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。</p>\n<p>参考<br><a href=\"https://www.cnblogs.com/ForEvErNoME/p/3383539.html\"><em>https://www.cnblogs.com/ForEvErNoME/p/3383539.html</em></a></p>\n<ul>\n<li><h3 id=\"怎么样让一个元素消失，讲讲\"><a href=\"#怎么样让一个元素消失，讲讲\" class=\"headerlink\" title=\"怎么样让一个元素消失，讲讲\"></a>怎么样让一个元素消失，讲讲</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>display:none; visibility:hidden; opacity: 0; 等等</p>\n<ul>\n<li><h3 id=\"介绍一下盒模型\"><a href=\"#介绍一下盒模型\" class=\"headerlink\" title=\"介绍一下盒模型\"></a>介绍一下盒模型</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>CSS 盒模型本质上是一个盒子，封装周围的 HTML 元素，它包括：边距，边框，填充， 和实际内容。</p>\n<p>标准盒模型：一个块的总宽度=width+margin(左右)+padding(左右)+border(左右) 怪异盒模型：一个块的总宽度=width+margin（左右）（既 width 已经包含了<br>padding 和 border 值）</p>\n<p>设置盒模型：box-sizing:border-box</p>\n<ul>\n<li><h3 id=\"position-相关属性\"><a href=\"#position-相关属性\" class=\"headerlink\" title=\"position 相关属性\"></a>position 相关属性</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>固定定位 fixed：</p>\n<p>元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重</p>\n<p>叠。</p>\n<p>相对定位 relative：</p>\n<p>如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。<br>在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 绝对定位 absolute：</p>\n<p>绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素， 那么它的位置相对于&lt;html&gt;。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute<br>定位的元素和其他元素重叠。</p>\n<p>粘性定位 sticky：</p>\n<p>元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和containing<br>block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。</p>\n<p>默认定位 Static：</p>\n<p>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者z-index 声明）。</p>\n<p>inherit:</p>\n<p>规定应该从父元素继承 position 属性的值。</p>\n<ul>\n<li><h3 id=\"css-动画如何实现\"><a href=\"#css-动画如何实现\" class=\"headerlink\" title=\"css 动画如何实现\"></a>css 动画如何实现</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>创建动画序列，需要使用 animation 属性或其子属性，该属性允许配置动画时间、时长以及其他动画细节，但该属性不能配置动画的实际表现，动画的实际表现是</p>\n<p>由 @keyframes 规则实现，具体情况参见使用 keyframes 定义动画序列小节部分。transition 也可实现动画。transition<br>强调过渡，是元素的一个或多个属性发生变化时产生的过渡效果，同一个元素通过两个不同的途径获取样式，而第二个途径当某种改变发生（例如 hover）时才能获取样式，这样就会产生过渡动画。</p>\n<ul>\n<li><h3 id=\"如何实现图片在某个容器中居中的？\"><a href=\"#如何实现图片在某个容器中居中的？\" class=\"headerlink\" title=\"如何实现图片在某个容器中居中的？\"></a>如何实现图片在某个容器中居中的？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>父元素固定宽高，利用定位及设置子元素 margin 值为自身的一半。</p>\n<p>父元素固定宽高，子元素设置 position: absolute，margin：auto 平均分配 margin css3 属 性 transform 。 子 元 素 设 置 position:<br>absolute; left: 50%; top: 50%;transform: translate(-50%,-50%);即可。</p>\n<p>将父元素设置成 display: table, 子元素设置为单元格 display: table-cell。</p>\n<p>弹性布局 display: flex。设置 align-items: center; justify-content: center</p>\n<ul>\n<li><h3 id=\"如何实现元素的垂直居中\"><a href=\"#如何实现元素的垂直居中\" class=\"headerlink\" title=\"如何实现元素的垂直居中\"></a>如何实现元素的垂直居中</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>法一：父元素 display:flex,align-items:center;</p>\n<p>法二：元素绝对定位，top:50%，margin-top：-（高度/2）</p>\n<p>法三：高度不确定用 transform：translateY（-50%）</p>\n<p>法四：父元素 table 布局，子元素设置 vertical-align:center;</p>\n<ul>\n<li><h3 id=\"CSS3-中对溢出的处理\"><a href=\"#CSS3-中对溢出的处理\" class=\"headerlink\" title=\"CSS3 中对溢出的处理\"></a>CSS3 中对溢出的处理</h3></li>\n</ul>\n<p>参考回答： cnkOhu</p>\n<p>text-overflow 属性，值为 clip 是修剪文本；ellipsis 为显示省略符号来表被修剪的文本；string 为使用给定的字符串来代表被修剪的文本。</p>\n<ul>\n<li><h3 id=\"float-的元素，display-是什么\"><a href=\"#float-的元素，display-是什么\" class=\"headerlink\" title=\"float 的元素，display 是什么\"></a>float 的元素，display 是什么</h3></li>\n</ul>\n<p>参 考 回 答 ： display 为 block</p>\n<ul>\n<li><h3 id=\"隐藏页面中某个元素的方法\"><a href=\"#隐藏页面中某个元素的方法\" class=\"headerlink\" title=\"隐藏页面中某个元素的方法\"></a>隐藏页面中某个元素的方法</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>display:none; visibility:hidden; opacity: 0; position 移到外部，z-index 涂层遮盖等等</p>\n<ul>\n<li><h3 id=\"三栏布局的实现方式，尽可能多写，浮动布局时，三个-div-的生成顺序有没有影响\"><a href=\"#三栏布局的实现方式，尽可能多写，浮动布局时，三个-div-的生成顺序有没有影响\" class=\"headerlink\" title=\"三栏布局的实现方式，尽可能多写，浮动布局时，三个 div 的生成顺序有没有影响\"></a>三栏布局的实现方式，尽可能多写，浮动布局时，三个 div 的生成顺序有没有影响</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>三列布局又分为两种，两列定宽一列自适应，以及两侧定宽中间自适应两列定宽一列自适应：</p>\n<p>1、使用 float+margin：</p>\n<p>给 div 设置 float：left，left 的 div 添加属性 margin-right：left 和 center 的间隔 px,right 的 div 添加属性<br>margin-left：left 和 center 的宽度之和加上间隔</p>\n<p>2、使用 float+overflow：</p>\n<p>给 div 设置 float：left，再给 right 的 div 设置 overflow:hidden。这样子两个盒子浮动，另一个盒子触发 bfc 达到自适应</p>\n<p>3、使用 position：</p>\n<p>父级 div 设置 position：relative，三个子级 div 设置 position：absolute，这个要计算好盒子的宽度和间隔去设置位置，兼容性比较好，</p>\n<p>4、使用 table 实现：</p>\n<p>父级 div 设置 display：table，设置 border-spacing：10px//设置间距，取值随意, 子级 div 设置<br>display:table-cell，这种方法兼容性好，适用于高度宽度未知的情况，但是 margin 失效，设计间隔比较麻烦，</p>\n<p>5、flex 实现：</p>\n<p>parent 的 div 设置 display：flex；left 和 center 的 div 设置 margin-right；然后right 的 div 设置 flex：1；这样子 right<br>自适应，但是 flex 的兼容性不好</p>\n<p>6、grid 实现：</p>\n<p>parent 的 div 设置 display：grid，设置 grid-template-columns 属性，固定第一列第二列宽度，第三列 auto，</p>\n<p>对于两侧定宽中间自适应的布局，对于这种布局需要把 center 放在前面，可以采用双飞翼布局：圣杯布局，来实现，也可以使用上述方法中的 grid，table，flex， position 实现</p>\n<ul>\n<li><h3 id=\"什么是-BFC\"><a href=\"#什么是-BFC\" class=\"headerlink\" title=\"什么是 BFC\"></a>什么是 BFC</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>BFC 也就是常说的块格式化上下文，这是一个独立的渲染区域，规定了内部如何布局， 并且这个区域的子元素不会影响到外面的元素，其中比较重要的布局规则有内部 box 垂直放置，计算 BFC<br>的高度的时候，浮动元素也参与计算，触发 BFC 的规则有根元</p>\n<p>素，浮动元素，position 为 absolute 或 fixed 的元素，display 为 inline-block，<br>table-cell，table-caption，flex，inline-flex，overflow 不为 visible 的元素</p>\n<ul>\n<li><h3 id=\"calc-属性\"><a href=\"#calc-属性\" class=\"headerlink\" title=\"calc 属性\"></a>calc 属性</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Calc 用户动态计算长度值，任何长度值都可以使用 calc()函数计算，需要注意的是， 运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；</p>\n<ul>\n<li><h3 id=\"有一个-width300，height300，怎么实现在屏幕上垂直水平居中\"><a href=\"#有一个-width300，height300，怎么实现在屏幕上垂直水平居中\" class=\"headerlink\" title=\"有一个 width300，height300，怎么实现在屏幕上垂直水平居中\"></a>有一个 width300，height300，怎么实现在屏幕上垂直水平居中</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>对于行内块级元素，</p>\n<p>1、父级元素设置 text-alig：center，然后设置 line-height 和 vertical-align 使其垂直居中，最后设置 font-size：0 消除近似居中的 bug</p>\n<p>2、父级元素设置 display：table-cell，vertical-align：middle 达到水平垂直居中3、采用绝对定位，原理是子绝父相，父元素设置<br>position：relative，子元素设置position：absolute，然后通过 transform 或 margin 组合使用达到垂直居中效果，设置<br>top：50%，left：50%，transform：translate（-50%，-50%）</p>\n<p>4、绝对居中，原理是当 top,bottom 为 0 时，margin-top&amp;bottom 设置 auto 的话会无限延伸沾满空间并平分，当 left，right 为 0<br>时,margin-left&amp;right 设置 auto 会无限延伸占满空间并平分，</p>\n<p>5、采用 flex，父元素设置 display：flex，子元素设置 margin：auto</p>\n<p>6、视窗居中，vh 为视口单位，50vh 即是视口高度的 50/100，设置 margin：50vh auto 0，transform：translate(-50%)</p>\n<ul>\n<li><h3 id=\"display：table-和本身的-table-有什么区别\"><a href=\"#display：table-和本身的-table-有什么区别\" class=\"headerlink\" title=\"display：table 和本身的 table 有什么区别\"></a>display：table 和本身的 table 有什么区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Display:table 和本身 table 是相对应的，区别在于，display：table 的 css 声明能够让一个 html 元素和它的子节点像 table 元素一样，使用基于表格的 css<br>布局，是我们能够轻松定义一个单元格的边界，背景等样式，而不会产生因为使用了 table 那样的制表标签导致的语义化问题。</p>\n<p>之所以现在逐渐淘汰了 table 系表格元素，是因为用 div+css 编写出来的文件比用table 边写出来的文件小，而且 table 必须在页面完全加载后才显示，div 则是逐行显示，table<br>的嵌套性太多，没有 div 简洁</p>\n<ul>\n<li><h3 id=\"position-属性的值有哪些及其区别\"><a href=\"#position-属性的值有哪些及其区别\" class=\"headerlink\" title=\"position 属性的值有哪些及其区别\"></a>position 属性的值有哪些及其区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Position 属性把元素放置在一个静态的，相对的，绝对的，固定的位置中， Static：位置设置为 static 的元素，他始终处于页面流给予的位置，static 元素会忽略任何<br>top,buttom,left,right 声明</p>\n<p>Relative：位置设置为 relative 的元素，可将其移至相对于其正常位置的地方，因此</p>\n<p>left：20 会将元素移至元素正常位置左边 20 个像素的位置</p>\n<p>Absolute：此元素可定位于相对包含他的元素的指定坐标，此元素可通过 left，top</p>\n<p>等属性规定</p>\n<p>Fixed：位置被设为 fiexd 的元素，可定为与相对浏览器窗口的指定坐标，可以通过</p>\n<p>left，top，right 属性来定位</p>\n<ul>\n<li><h3 id=\"z-index-的定位方法\"><a href=\"#z-index-的定位方法\" class=\"headerlink\" title=\"z-index 的定位方法\"></a>z-index 的定位方法</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol start=\"26\">\n<li>index 属性设置元素的堆叠顺序，拥有更好堆叠顺序的元素会处于较低顺序元素之前，z-index 可以为负，且z-index 只能在定位元素上奏效，该属性设置一个定位元素沿z<br>轴的位置，如果为正数，离用户越近，为负数，离用户越远，它的属性值有auto，默认，堆叠顺序与父元素相等，number，inherit，从父元素继承 z-index 属性的值</li>\n</ol>\n<ul>\n<li><h3 id=\"如果想要改变一个-DOM-元素的字体颜色，不在它本身上进行操作？\"><a href=\"#如果想要改变一个-DOM-元素的字体颜色，不在它本身上进行操作？\" class=\"headerlink\" title=\"如果想要改变一个 DOM 元素的字体颜色，不在它本身上进行操作？\"></a>如果想要改变一个 DOM 元素的字体颜色，不在它本身上进行操作？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>可以更改父元素的 color</p>\n<ul>\n<li><h3 id=\"对-CSS-的新属性有了解过的吗？\"><a href=\"#对-CSS-的新属性有了解过的吗？\" class=\"headerlink\" title=\"对 CSS 的新属性有了解过的吗？\"></a>对 CSS 的新属性有了解过的吗？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>CSS3 的新特性中，在布局方面新增了 flex 布局，在选择器方面新增了例如 first-of- type,nth-child 等选择器，在盒模型方面添加了box-sizing<br>来改变盒模型，在动画方面增加了 animation，2d 变换，3d 变换等，在颜色方面添加透明，rbga 等，在字体方面允许嵌入字体和设置字体阴影，最后还有媒体查讯等</p>\n<ul>\n<li><h3 id=\"用的最多的-css-属性是啥？\"><a href=\"#用的最多的-css-属性是啥？\" class=\"headerlink\" title=\"用的最多的 css 属性是啥？\"></a>用的最多的 css 属性是啥？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>用的目前来说最多的是 flex 属性，灵活但是兼容性方面不强。</p>\n<ul>\n<li><h3 id=\"line-height-和-height-的区别\"><a href=\"#line-height-和-height-的区别\" class=\"headerlink\" title=\"line-height 和 height 的区别\"></a>line-height 和 height 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>line-height 一般是指布局里面一段文字上下行之间的高度，是针对字体来设置的，</p>\n<p>height 一般是指容器的整体高度。</p>\n<ul>\n<li><h3 id=\"设置一个元素的背景颜色，背景颜色会填充哪些区域？\"><a href=\"#设置一个元素的背景颜色，背景颜色会填充哪些区域？\" class=\"headerlink\" title=\"设置一个元素的背景颜色，背景颜色会填充哪些区域？\"></a>设置一个元素的背景颜色，背景颜色会填充哪些区域？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>background-color 设置的背景颜色会填充元素的content、padding、border 区域。</p>\n<ul>\n<li><h3 id=\"知道属性选择器和伪类选择器的优先级吗\"><a href=\"#知道属性选择器和伪类选择器的优先级吗\" class=\"headerlink\" title=\"知道属性选择器和伪类选择器的优先级吗\"></a>知道属性选择器和伪类选择器的优先级吗</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>属性选择器和伪类选择器优先级相同</p>\n<ul>\n<li><h3 id=\"inline-block、inline-和-block-的区别；为什么-img-是-inline-还可以设置宽高\"><a href=\"#inline-block、inline-和-block-的区别；为什么-img-是-inline-还可以设置宽高\" class=\"headerlink\" title=\"inline-block、inline 和 block 的区别；为什么 img 是 inline 还可以设置宽高\"></a>inline-block、inline 和 block 的区别；为什么 img 是 inline 还可以设置宽高</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Block 是块级元素，其前后都会有换行符，能设置宽度，高度，margin/padding 水平垂直方向都有效。</p>\n<p>Inline：设置 width 和 height 无效，margin 在竖直方向上无效，padding 在水平方向垂直方向都有效，前后无换行符</p>\n<p>Inline-block：能设置宽度高度，margin/padding 水平垂直方向 都有效，前后无换行符</p>\n<ul>\n<li><h3 id=\"用-css-实现一个硬币旋转的效果\"><a href=\"#用-css-实现一个硬币旋转的效果\" class=\"headerlink\" title=\"用 css 实现一个硬币旋转的效果\"></a>用 css 实现一个硬币旋转的效果</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>虽然不认为很多人能在面试中写出来</p>\n<h3 id=\"euro-width-150px\"><a href=\"#euro-width-150px\" class=\"headerlink\" title=\"#euro { width: 150px\"></a>#euro { width: 150px</h3><blockquote>\n<p>height: 150px; margin-left: -75px; margin-top: -75px; position: absolute; top: 50%;</p>\n</blockquote>\n<blockquote>\n<p>left: 50%;</p>\n</blockquote>\n<blockquote>\n<p>transform-style: preserve-3d; animation: spin 2.5s linear infinite;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.back {</p>\n</blockquote>\n<blockquote>\n<p>background-image: url(“/uploads/160101/backeuro.png”); width: 150px;</p>\n</blockquote>\n<blockquote>\n<p>height: 150px;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.middle {</p>\n</blockquote>\n<blockquote>\n<p>background-image: url(“/uploads/160101/faceeuro.png”); width: 150px;</p>\n</blockquote>\n<blockquote>\n<p>height: 150px;</p>\n</blockquote>\n<blockquote>\n<p>transform: translateZ(1px); position: absolute;</p>\n</blockquote>\n<blockquote>\n<p>top: 0;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.front {</p>\n</blockquote>\n<blockquote>\n<p>background-image: url(“/uploads/160101/faceeuro.png”); height: 150px;</p>\n</blockquote>\n<blockquote>\n<p>position: absolute; top: 0;</p>\n</blockquote>\n<blockquote>\n<p>transform: translateZ(10px); width: 150px;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>@keyframes spin { 0% {</p>\n</blockquote>\n<blockquote>\n<p>transform: rotateY(0deg);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>100% {</p>\n</blockquote>\n<blockquote>\n<p>transform: rotateY(360deg);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"了解重绘和重排吗，知道怎么去减少重绘和重排吗，让文档脱离文档流有哪些方法\"><a href=\"#了解重绘和重排吗，知道怎么去减少重绘和重排吗，让文档脱离文档流有哪些方法\" class=\"headerlink\" title=\"了解重绘和重排吗，知道怎么去减少重绘和重排吗，让文档脱离文档流有哪些方法\"></a>了解重绘和重排吗，知道怎么去减少重绘和重排吗，让文档脱离文档流有哪些方法</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>DOM 的变化影响到了预算内宿的几何属性比如宽高，浏览器重新计算元素的几何属性， 其他元素的几何属性也会受到影响，浏览器需要重新构造渲染书，这个过程称之为重排，浏览器将受到影响的部分重新绘制在屏幕上<br>的过程称为重绘，引起重排重绘的原因有：</p>\n<p>添加或者删除可见的 DOM 元素， 元素尺寸位置的改变</p>\n<p>浏览器页面初始化，</p>\n<p>浏览器窗口大小发生改变，重排一定导致重绘，重绘不一定导致重排， 减少重绘重排的方法有：</p>\n<p>不在布局信息改变时做 DOM 查询，</p>\n<p>使用 csstext,className 一次性改变属性使用 fragment</p>\n<p>对于多次重排的元素，比如说动画。使用绝对定位脱离文档流，使其不影响其他元素</p>\n<ul>\n<li><h3 id=\"CSS-画正方体，三角形\"><a href=\"#CSS-画正方体，三角形\" class=\"headerlink\" title=\"CSS 画正方体，三角形\"></a>CSS 画正方体，三角形</h3></li>\n</ul>\n<p>参考回答： 画三角形</p>\n<h3 id=\"triangle02-width-0-height-0\"><a href=\"#triangle02-width-0-height-0\" class=\"headerlink\" title=\"#triangle02{ width: 0; height: 0\"></a>#triangle02{ width: 0; height: 0</h3><blockquote>\n<p>border-top: 50px solid blue; border-right: 50px solid red; border-bottom: 50px solid green;<br>border-left: 50px solid yellow;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<p>画正方体：</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><!DOCTYPE html></h3><blockquote>\n<html lang=\"en\">\n</blockquote>\n<blockquote>\n<head>\n</blockquote>\n<blockquote>\n<meta charset=\"UTF-8\">\n</blockquote>\n<blockquote>\n<title>perspective\\</title>\n</blockquote>\n<blockquote>\n<style>\n</blockquote>\n<blockquote>\n<p>.wrapper{ width: 50%; float: left;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.cube{</p>\n</blockquote>\n<blockquote>\n<p>font-size: 4em; width: 2em;</p>\n</blockquote>\n<blockquote>\n<p>margin: 1.5em auto; transform-style:preserve-3d;</p>\n</blockquote>\n<blockquote>\n<p>transform:rotateX(-35deg) rotateY(30deg);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.side{</p>\n</blockquote>\n<blockquote>\n<p>position: absolute; width: 2em;</p>\n</blockquote>\n<blockquote>\n<p>height: 2em;</p>\n</blockquote>\n<blockquote>\n<p>background: rgba(255,99,71,0.6); border: 1px solid rgba(0,0,0,0.5); color: white;</p>\n</blockquote>\n<blockquote>\n<p>text-align: center; line-height: 2em;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.front{ transform:translateZ(1em);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.bottom{</p>\n</blockquote>\n<blockquote>\n<p>transform:rotateX(-90deg) translateZ(1em);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.top{</p>\n</blockquote>\n<blockquote>\n<p>transform:rotateX(90deg) translateZ(1em);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.left{</p>\n</blockquote>\n<blockquote>\n<p>transform:rotateY(-90deg) translateZ(1em);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.right{</p>\n</blockquote>\n<blockquote>\n<p>transform:rotateY(90deg) translateZ(1em);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.back{ transform:translateZ(-1em);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p></style></p>\n</blockquote>\n<blockquote>\n</head>\n</blockquote>\n<blockquote>\n<body>\n</blockquote>\n<blockquote>\n<div class=\"wrapper w1\">\n</blockquote>\n<blockquote>\n<div class=\"cube\">\n</blockquote>\n<blockquote>\n<div class=\"side front\">1\\</div>\n</blockquote>\n<blockquote>\n<div class=\"side back\">6\\</div>\n</blockquote>\n<blockquote>\n<div class=\"side right\">4\\</div>\n</blockquote>\n<blockquote>\n<div class=\"side left\">3\\</div>\n</blockquote>\n<blockquote>\n<div class=\"side top\">5\\</div>\n</blockquote>\n<blockquote>\n<div class=\"side bottom\">2\\</div>\n</blockquote>\n<blockquote>\n</div>\n</blockquote>\n<blockquote>\n</div>\n</blockquote>\n<blockquote>\n<div class=\"wrapper w2\">\n</blockquote>\n<blockquote>\n<div class=\"cube\">\n</blockquote>\n<blockquote>\n<div class=\"side front\">1\\</div>\n</blockquote>\n<blockquote>\n<div class=\"side back\">6\\</div>\n</blockquote>\n<blockquote>\n<div class=\"side right\">4\\</div>\n</blockquote>\n<blockquote>\n<div class=\"side left\">3\\</div>\n</blockquote>\n<blockquote>\n<div class=\"side top\">5\\</div>\n</blockquote>\n<blockquote>\n<div class=\"side bottom\">2\\</div>\n</blockquote>\n<blockquote>\n</div>\n</blockquote>\n<blockquote>\n</div>\n</blockquote>\n<blockquote>\n</body>\n</blockquote>\n<blockquote>\n</html>\n</blockquote>\n<ul>\n<li><h3 id=\"overflow-的原理\"><a href=\"#overflow-的原理\" class=\"headerlink\" title=\"overflow 的原理\"></a>overflow 的原理</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>要讲清楚这个解决方案的原理，首先需要了解块格式化上下文，A block formatting context is a part of a visual CSS rendering of a Web<br>page. It is the region in which the layout of block boxes occurs and in which floats interact with<br>each other.翻译过来就是块格式化上下文是 CSS 可视化渲染的一部分，它是一块区域，规定了内部块盒 的渲染方式，以及浮动相互之间的影响关系</p>\n<p>当元素设置了 overflow 样式且值部位 visible 时，该元素就构建了一个 BFC，BFC 在计算高度时，内部浮动元素的高度也要计算在内，也就是说技术 BFC 区域内只有一个浮动元素，BFC<br>的高度也不会发生塌缩，所以达到了清除浮动的目的。</p>\n<ul>\n<li><h3 id=\"清除浮动的方法\"><a href=\"#清除浮动的方法\" class=\"headerlink\" title=\"清除浮动的方法\"></a>清除浮动的方法</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>给要清除浮动的元素添加样式 clear，\\</p>\n<p>父元素结束标签钱插入清除浮动的块级元素，给该元素添加样式 clear</p>\n<p>添加伪元素，在父级元素的最后，添加一个伪元素，通过清除伪元素的浮动，注意该伪元素的 display 为 block，</p>\n<p>父元素添加样式 overflow 清除浮动，overflow 设置除 visible 以外的任何位置</p>\n<ul>\n<li><h3 id=\"box-sizing-的语法和基本用处\"><a href=\"#box-sizing-的语法和基本用处\" class=\"headerlink\" title=\"box-sizing 的语法和基本用处\"></a>box-sizing 的语法和基本用处</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>box-sizing 规定两个并排的带边框的框，语法为box-sizing：content-box/border- box/inherit</p>\n<p>content-box：宽度和高度分别应用到元素的内容框，在宽度和高度之外绘制元素的内边距和边框</p>\n<p>border-box：为元素设定的宽度和高度决定了元素的边框盒， inherit：继承父元素的 box-sizing</p>\n<ul>\n<li><h3 id=\"使元素消失的方法有哪些？\"><a href=\"#使元素消失的方法有哪些？\" class=\"headerlink\" title=\"使元素消失的方法有哪些？\"></a>使元素消失的方法有哪些？</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>opacity：0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如 click 事件，那么点击该区域，也能触发点击事件的</p>\n</li>\n<li><p>visibility：hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件</p>\n</li>\n<li><p>display：none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉。</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"两个嵌套的-div，position-都是-absolute，子-div-设置-top-属性，那么这个-top-是相对于父元素的哪个位置定位的\"><a href=\"#两个嵌套的-div，position-都是-absolute，子-div-设置-top-属性，那么这个-top-是相对于父元素的哪个位置定位的\" class=\"headerlink\" title=\"两个嵌套的 div，position 都是 absolute，子 div 设置 top 属性，那么这个 top 是相对于父元素的哪个位置定位的\"></a>两个嵌套的 div，position 都是 absolute，子 div 设置 top 属性，那么这个 top 是相对于父元素的哪个位置定位的</h3></li>\n</ul>\n<p>参 考 回 答 ： margin 的外边缘</p>\n<ul>\n<li><h3 id=\"说说盒子模型\"><a href=\"#说说盒子模型\" class=\"headerlink\" title=\"说说盒子模型\"></a>说说盒子模型</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>CSS 盒模型本质上是一个盒子，封装周围的 HTML 元素，它包括：边距，边框，填充， 和实际内容。</p>\n<p>标准盒模型：一个块的总宽度=width+margin(左右)+padding(左右)+border(左右) 怪异盒模型：一个块的总宽度=width+margin（左右）（既 width 已经包含了<br>padding 和 border 值）</p>\n<p>如何设置：box-sizing:border-box</p>\n<ul>\n<li><h3 id=\"display\"><a href=\"#display\" class=\"headerlink\" title=\"display\"></a>display</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>主要取值有 none,block,inline-block,inline,flex 等。具体可参考</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/display\"><em>https://developer.mozilla.org/zh-CN/docs/Web/CSS/display</em></a></p>\n<ul>\n<li><h3 id=\"怎么隐藏一个元素\"><a href=\"#怎么隐藏一个元素\" class=\"headerlink\" title=\"怎么隐藏一个元素\"></a>怎么隐藏一个元素</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>opacity：0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如 click 事件，那么点击该区域，也能触发点击事件的</p>\n</li>\n<li><p>visibility：hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件</p>\n</li>\n<li><p>display：none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉。</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"display-none-和-visibilty-hidden-的区别\"><a href=\"#display-none-和-visibilty-hidden-的区别\" class=\"headerlink\" title=\"display:none 和 visibilty:hidden 的区别\"></a>display:none 和 visibilty:hidden 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>visibility：hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件</p>\n</li>\n<li><p>display：none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉。</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"相对布局和绝对布局，position-relative-和-obsolute\"><a href=\"#相对布局和绝对布局，position-relative-和-obsolute\" class=\"headerlink\" title=\"相对布局和绝对布局，position:relative 和 obsolute\"></a>相对布局和绝对布局，position:relative 和 obsolute</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>相对定位 relative：</p>\n<p>如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。<br>在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 绝对定位 absolute：</p>\n<p>绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素， 那么它的位置相对于&lt;html&gt;。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute<br>定位的元素和其他元素重叠。</p>\n<ul>\n<li><h3 id=\"flex-布局\"><a href=\"#flex-布局\" class=\"headerlink\" title=\"flex 布局\"></a>flex 布局</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>flex 是 Flexible Box 的缩写，意为”弹性布局”。指定容器 display: flex<br>即可。容器有以下属性：flex-direction，flex-wrap，flex-flow，justify-content， align-items，align-content。</p>\n<p>flex-direction 属性决定主轴的方向；</p>\n<p>flex-wrap 属性定义，如果一条轴线排不下，如何换行；</p>\n<p>flex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap；</p>\n<p>justify-content 属性定义了项目在主轴上的对齐方式。align-items 属性定义项目在交叉轴上如何对齐。</p>\n<p>align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>\n<p>项目（子元素）也有一些属性：order，flex-grow，flex-shrink，flex-basis，</p>\n<p>flex，align-self。</p>\n<p>order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。</p>\n<p>flex-grow 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。</p>\n<p>flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为<br>0 1 auto。后两个属性可选。</p>\n<p>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于<br>stretch。</p>\n<p>参考<br><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\"><em>http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</em></a></p>\n<ul>\n<li><h3 id=\"block、inline、inline-block-的区别\"><a href=\"#block、inline、inline-block-的区别\" class=\"headerlink\" title=\"block、inline、inline-block 的区别\"></a>block、inline、inline-block 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>block 元素会独占一行，多个 block 元素会各自新起一行。默认情况下，block 元素宽度自动填满其父元素宽度。</p>\n<p>block 元素可以设置 width,height 属性。块级元素即使设置了宽度,仍然是独占一行。block 元素可以设置 margin 和 padding 属性。</p>\n<p>inline 元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。</p>\n<p>inline 元素设置 width,height 属性无效。</p>\n<p>inline 元素的 margin 和 padding 属性，水平方向的 padding-left, padding-right, margin-left, margin-right<br>都产生边距效果；但竖直方向的 padding-top, padding- bottom, margin-top, margin-bottom 不会产生边距效果。</p>\n<p>inline-block：简单来说就是将对象呈现为 inline 对象，但是对象的内容作为 block</p>\n<p>对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个 link（a 元</p>\n<p>素）inline-block 属性值，使其既具有 block 的宽度高度特性又具有 inline 的同行特性。</p>\n<ul>\n<li><h3 id=\"css-的常用选择器\"><a href=\"#css-的常用选择器\" class=\"headerlink\" title=\"css 的常用选择器\"></a>css 的常用选择器</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>id 选择器，类选择器，伪类选择器等</p>\n<ul>\n<li><h3 id=\"css-布局\"><a href=\"#css-布局\" class=\"headerlink\" title=\"css 布局\"></a>css 布局</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>六种布局方式总结：圣杯布局、双飞翼布局、Flex 布局、绝对定位布局、表格布局、网格布局。</p>\n<p>圣杯布局是指布局从上到下分为 header、container、footer，然后 container 部分定为三栏布局。这种布局方式同样分为<br>header、container、footer。圣杯布局的缺陷在于 center 是在 container 的 padding 中的，因此宽度小的时候会出现混乱。</p>\n<p>双飞翼布局给 center 部分包裹了一个 main 通过设置 margin 主动地把页面撑开。Flex 布局是由 CSS3 提供的一种方便的布局方式。</p>\n<p>绝对定位布局是给 container 设置 position: relative 和 overflow: hidden，因为绝对定位的元素的参照物为第一个 postion 不为 static<br>的祖先元素。 left 向左浮动，right 向右浮动。center 使用绝对定位，通过设置 left 和 right 并把两边撑开。 center 设置 top: 0 和 bottom: 0<br>使其高度撑开。</p>\n<p>表格布局的好处是能使三栏的高度统一。</p>\n<p>网格布局可能是最强大的布局方式了，使用起来极其方便，但目前而言，兼容性并不好。网格布局，可以将页面分割成多个区域，或者用来定义内部元素的大小，位置， 图层关系。</p>\n<ul>\n<li><h3 id=\"css-定位\"><a href=\"#css-定位\" class=\"headerlink\" title=\"css 定位\"></a>css 定位</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>固定定位 fixed：</p>\n<p>元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重</p>\n<p>叠。</p>\n<p>相对定位 relative：</p>\n<p>如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。<br>在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 绝对定位 absolute：</p>\n<p>绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素， 那么它的位置相对于&lt;html&gt;。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute<br>定位的元素和其他元素重叠。</p>\n<p>粘性定位 sticky：</p>\n<p>元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和containing<br>block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。</p>\n<p>默认定位 Static：</p>\n<p>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者z-index 声明）。</p>\n<p>inherit:</p>\n<p>规定应该从父元素继承 position 属性的值。</p>\n<ul>\n<li><h3 id=\"relative-定位规则\"><a href=\"#relative-定位规则\" class=\"headerlink\" title=\"relative 定位规则\"></a>relative 定位规则</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。<br>在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。</p>\n<ul>\n<li><h3 id=\"垂直居中\"><a href=\"#垂直居中\" class=\"headerlink\" title=\"垂直居中\"></a>垂直居中</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>父元素固定宽高，利用定位及设置子元素 margin 值为自身的一半。</p>\n<p>父元素固定宽高，子元素设置 position: absolute，margin：auto 平均分配 margin css3 属 性 transform 。 子 元 素 设 置 position:<br>absolute; left: 50%; top: 50%;transform: translate(-50%,-50%);即可。</p>\n<p>将父元素设置成 display: table, 子元素设置为单元格 display: table-cell。</p>\n<p>弹性布局 display: flex。设置 align-items: center; justify-content: center;</p>\n<ul>\n<li><h3 id=\"css-预处理器有什么\"><a href=\"#css-预处理器有什么\" class=\"headerlink\" title=\"css 预处理器有什么\"></a>css 预处理器有什么</h3></li>\n</ul>\n<p>参考回答： less，sass 等</p>\n<ol start=\"3\">\n<li><h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"| JavaScript\"></a>| JavaScript</h2></li>\n</ol>\n<ul>\n<li><h3 id=\"get-请求传参长度的误区\"><a href=\"#get-请求传参长度的误区\" class=\"headerlink\" title=\"get 请求传参长度的误区\"></a>get 请求传参长度的误区</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。</p>\n<p>实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或 web 服务器，浏览器或 web 服务器限制了 url<br>的长度。为了明确这个概念，我们必须再次强调下面几点:</p>\n<p>HTTP 协议 未规定 GET 和 POST 的长度限制</p>\n<p>GET 的最大长度显示是因为 浏览器和 web 服务器限制了 URI 的长度不同的浏览器和 WEB 服务器，限制的最大长度不一样</p>\n<p>要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte</p>\n<ul>\n<li><h3 id=\"补充-get-和-post-请求在缓存方面的区别\"><a href=\"#补充-get-和-post-请求在缓存方面的区别\" class=\"headerlink\" title=\"补充 get 和 post 请求在缓存方面的区别\"></a>补充 get 和 post 请求在缓存方面的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>post/get 的请求区别，具体不再赘述。</p>\n<p>补充补充一个 get 和 post 在缓存方面的区别：</p>\n<p>get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</p>\n<p>post 不同，post 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此 get 请求适合于请求缓存。</p>\n<ul>\n<li><h3 id=\"说一下闭包\"><a href=\"#说一下闭包\" class=\"headerlink\" title=\"说一下闭包\"></a>说一下闭包</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>一句话可以概括：闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放。</p>\n<ul>\n<li><h3 id=\"说一下类的创建和继承\"><a href=\"#说一下类的创建和继承\" class=\"headerlink\" title=\"说一下类的创建和继承\"></a>说一下类的创建和继承</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li>类的创建（es5）：new 一个 function，在这个 function 的 prototype 里面增加属性和方法。</li>\n</ol>\n<p>下面来创建一个 Animal 类：</p>\n<p>// 定义一个动物类function Animal (name) {</p>\n<p>// 属性</p>\n<p>this.name = name || ‘Animal’;</p>\n<p>// 实例方法</p>\n<p>this.sleep = function(){ console.log(this.name + ‘正在睡觉！’);</p>\n<p>}</p>\n<p>}</p>\n<p>// 原型方法</p>\n<p>Animal.prototype.eat = function(food) { console.log(this.name + ‘正在吃：’ + food);</p>\n<p>};</p>\n<p>这样就生成了一个 Animal 类，实力化生成对象后，有方法和属性。</p>\n<ol start=\"2\">\n<li>类的继承——原型链继承</li>\n</ol>\n<p>–原型链继承</p>\n<h3 id=\"function-Cat-Cat-prototype-new-Animal-Cat-prototype-name-‘cat’\"><a href=\"#function-Cat-Cat-prototype-new-Animal-Cat-prototype-name-‘cat’\" class=\"headerlink\" title=\"function Cat(){ } Cat.prototype = new Animal(); Cat.prototype.name = ‘cat’\"></a>function Cat(){ } Cat.prototype = new Animal(); Cat.prototype.name = ‘cat’</h3><blockquote>\n<p>// Test Code</p>\n</blockquote>\n<blockquote>\n<p>var cat = new Cat(); console.log(cat.name); console.log(cat.eat(‘fish’));<br>console.log(cat.sleep());</p>\n</blockquote>\n<blockquote>\n<p>console.log(cat instanceof Animal); //true console.log(cat instanceof Cat); //true</p>\n</blockquote>\n<p>介绍：在这里我们可以看到 new 了一个空对象,这个空对象指向 Animal 并且</p>\n<p>Cat.prototype 指向了这个空对象，这种就是基于原型链的继承。特点：基于原型链，既是父类的实例，也是子类的实例</p>\n<p>缺点：无法实现多继承</p>\n<ol start=\"3\">\n<li>构造继承：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</li>\n</ol>\n<h3 id=\"function-Cat-name-Animal-call-this-this-name-name-‘Tom’\"><a href=\"#function-Cat-name-Animal-call-this-this-name-name-‘Tom’\" class=\"headerlink\" title=\"function Cat(name){ Animal.call(this); this.name = name || ‘Tom’\"></a>function Cat(name){ Animal.call(this); this.name = name || ‘Tom’</h3><blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>// Test Code</p>\n</blockquote>\n<blockquote>\n<p>var cat = new Cat(); console.log(cat.name); console.log(cat.sleep());</p>\n</blockquote>\n<blockquote>\n<p>console.log(cat instanceof Animal); // false console.log(cat instanceof Cat); // true</p>\n</blockquote>\n<p>特点：可以实现多继承</p>\n<p>缺点：只能继承父类实例的属性和方法，不能继承原型上的属性和方法。</p>\n<ol start=\"4\">\n<li>实例继承和拷贝继承</li>\n</ol>\n<p>实例继承：为父类实例添加新特性，作为子类实例返回拷贝继承：拷贝父类元素上的属性和方法</p>\n<p>上述两个实用性不强，不一一举例。</p>\n<ol start=\"5\">\n<li>组合继承：相当于构造继承和原型链继承的组合体。通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用function Cat(name){</li>\n</ol>\n<h3 id=\"Animal-call-this-this-name-name-‘Tom’\"><a href=\"#Animal-call-this-this-name-name-‘Tom’\" class=\"headerlink\" title=\"Animal.call(this); this.name = name || ‘Tom’\"></a>Animal.call(this); this.name = name || ‘Tom’</h3><blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>Cat.prototype = new Animal(); Cat.prototype.constructor = Cat;</p>\n</blockquote>\n<blockquote>\n<p>// Test Code</p>\n</blockquote>\n<blockquote>\n<p>var cat = new Cat(); console.log(cat.name); console.log(cat.sleep());</p>\n</blockquote>\n<blockquote>\n<p>console.log(cat instanceof Animal); // true console.log(cat instanceof Cat); // true</p>\n</blockquote>\n<p>特点：可以继承实例属性/方法，也可以继承原型属性/方法缺点：调用了两次父类构造函数，生成了两份实例</p>\n<ol start=\"6\">\n<li>寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性</li>\n</ol>\n<h3 id=\"function-Cat-name-Animal-call-this-this-name-name-‘Tom’-1\"><a href=\"#function-Cat-name-Animal-call-this-this-name-name-‘Tom’-1\" class=\"headerlink\" title=\"function Cat(name){ Animal.call(this); this.name = name || ‘Tom’\"></a>function Cat(name){ Animal.call(this); this.name = name || ‘Tom’</h3><blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>(function(){</p>\n</blockquote>\n<p>// 创建一个没有实例方法的类</p>\n<h3 id=\"var-Super-function-Super-prototype-Animal-prototype\"><a href=\"#var-Super-function-Super-prototype-Animal-prototype\" class=\"headerlink\" title=\"var Super = function(){}; Super.prototype = Animal.prototype\"></a>var Super = function(){}; Super.prototype = Animal.prototype</h3><p>//将实例作为子类的原型</p>\n<h3 id=\"Cat-prototype-new-Super\"><a href=\"#Cat-prototype-new-Super\" class=\"headerlink\" title=\"Cat.prototype = new Super()\"></a>Cat.prototype = new Super()</h3><blockquote>\n<p>})();</p>\n</blockquote>\n<blockquote>\n<p>// Test Code</p>\n</blockquote>\n<blockquote>\n<p>var cat = new Cat(); console.log(cat.name); console.log(cat.sleep());</p>\n</blockquote>\n<blockquote>\n<p>console.log(cat instanceof Animal); // true console.log(cat instanceof Cat); //true</p>\n</blockquote>\n<p>较为推荐</p>\n<ul>\n<li><h3 id=\"如何解决异步回调地狱\"><a href=\"#如何解决异步回调地狱\" class=\"headerlink\" title=\"如何解决异步回调地狱\"></a>如何解决异步回调地狱</h3></li>\n</ul>\n<p>参考回答：</p>\n<ul>\n<li><h3 id=\"说说前端中的事件流\"><a href=\"#说说前端中的事件流\" class=\"headerlink\" title=\"说说前端中的事件流\"></a>说说前端中的事件流</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>HTML 中与 javascript 交互是通过事件驱动来实现的，例如鼠标点击事件 onclick、页面的滚动事件 onscroll<br>等等，可以向文档或者文档中的元素添加事件侦听器来预订事件。想要知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概</p>\n<p>念。</p>\n<p>什么是事件流：事件流描述的是从页面中接收事件的顺序,DOM2 级事件流包括下面几个阶段。</p>\n<p>事件捕获阶段处于目标阶段事件冒泡阶段</p>\n<p>addEventListener：addEventListener 是 DOM2 级事件新增的指定事件处理程序的操作，这个方法接收 3<br>个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。</p>\n<p>IE 只支持事件冒泡。</p>\n<ul>\n<li><h3 id=\"如何让事件先冒泡后捕获\"><a href=\"#如何让事件先冒泡后捕获\" class=\"headerlink\" title=\"如何让事件先冒泡后捕获\"></a>如何让事件先冒泡后捕获</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>在 DOM 标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间。</p>\n<ul>\n<li><h3 id=\"说一下事件委托\"><a href=\"#说一下事件委托\" class=\"headerlink\" title=\"说一下事件委托\"></a>说一下事件委托</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>简介：事件委托指的是，不在事件的发生地（直接 dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素 DOM<br>的类型，来做出不同的响应。</p>\n<p>举例：最经典的就是 ul 和 li 标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在 li 标签上直接添加，而是在 ul 父元素上添加。</p>\n<p>好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。</p>\n<ul>\n<li><h3 id=\"说一下图片的懒加载和预加载\"><a href=\"#说一下图片的懒加载和预加载\" class=\"headerlink\" title=\"说一下图片的懒加载和预加载\"></a>说一下图片的懒加载和预加载</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。</p>\n<p>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。</p>\n<p>两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p>\n<ul>\n<li><h3 id=\"mouseover-和-mouseenter-的区别\"><a href=\"#mouseover-和-mouseenter-的区别\" class=\"headerlink\" title=\"mouseover 和 mouseenter 的区别\"></a>mouseover 和 mouseenter 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是 mouseout</p>\n<p>mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是 mouseleave</p>\n<ul>\n<li><h3 id=\"JS-的-new-操作符做了哪些事情\"><a href=\"#JS-的-new-操作符做了哪些事情\" class=\"headerlink\" title=\"JS 的 new 操作符做了哪些事情\"></a>JS 的 new 操作符做了哪些事情</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>new 操作符新建了一个空对象，这个对象原型指向构造函数的 prototype，执行构造函数后返回这个对象。</p>\n<ul>\n<li><h3 id=\"改变函数内部-this-指针的指向函数（bind，apply，call-的区别）\"><a href=\"#改变函数内部-this-指针的指向函数（bind，apply，call-的区别）\" class=\"headerlink\" title=\"改变函数内部 this 指针的指向函数（bind，apply，call 的区别）\"></a>改变函数内部 this 指针的指向函数（bind，apply，call 的区别）</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>通过 apply 和 call 改变函数的 this 指向，他们两个函数的第一个参数都是一样的表示要改变指向的那个对象，第二个参数，apply 是数组，而 call 则是<br>arg1,arg2…这种形式。通过 bind 改变 this 作用域会返回一个新的函数，这个函数不会马上执行。</p>\n<ul>\n<li><h3 id=\"JS-的各种位置，比如-clientHeight-scrollHeight-offsetHeight-以及-scrollTop-offsetTop-clientTop-的区别？\"><a href=\"#JS-的各种位置，比如-clientHeight-scrollHeight-offsetHeight-以及-scrollTop-offsetTop-clientTop-的区别？\" class=\"headerlink\" title=\"JS 的各种位置，比如 clientHeight,scrollHeight,offsetHeight ,以及 scrollTop, offsetTop,clientTop 的区别？\"></a>JS 的各种位置，比如 clientHeight,scrollHeight,offsetHeight ,以及 scrollTop, offsetTop,clientTop 的区别？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>clientHeight：表示的是可视区域的高度，不包含 border 和滚动条offsetHeight：表示可视区域的高度，包含了 border<br>和滚动条scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分。clientTop：表示边框 border 的厚度，在未指定的情况下一般为 0</p>\n<p>scrollTop：滚动后被隐藏的高度，获取对象相对于由 offsetParent 属性指定的父坐标(css 定位的元素或 body 元素)距离顶端的高度。</p>\n<ul>\n<li><h3 id=\"JS-拖拽功能的实现\"><a href=\"#JS-拖拽功能的实现\" class=\"headerlink\" title=\"JS 拖拽功能的实现\"></a>JS 拖拽功能的实现</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>首先是三个事件，分别是 mousedown，mousemove，mouseup</p>\n<p>当鼠标点击按下的时候，需要一个 tag 标识此时已经按下，可以执行 mousemove 里面的具体方法。</p>\n<p>clientX，clientY 标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用</p>\n<p>offsetX 和 offsetY 来表示元素的元素的初始坐标，移动的举例应该是：</p>\n<p>鼠标移动时候的坐标-鼠标按下去时候的坐标。</p>\n<p>也就是说定位信息为：</p>\n<p>鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的 offetLeft.</p>\n<p>还有一点也是原理性的东西，也就是拖拽的同时是绝对定位，我们改变的是绝对定位条件下的 left</p>\n<p>以及 top 等等值。</p>\n<p>补充：也可以通过 html5 的拖放（Drag 和 drop）来实现</p>\n<ul>\n<li><h3 id=\"异步加载-JS-的方法\"><a href=\"#异步加载-JS-的方法\" class=\"headerlink\" title=\"异步加载 JS 的方法\"></a>异步加载 JS 的方法</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>defer：只支持 IE 如果您的脚本不会改变文档的内容，可将 defer 属性加入到</p>\n<script>标签中，以便加快处理文档的速度。因为浏览器知道它将能够安全地读取文档的剩余部分而不用执行脚本，它将推迟对脚本的解释，直到文档已经显示给用户为止。\n\nasync，HTML5 属性仅适用于外部脚本，并且如果在 IE 中，同时存在 defer 和 async， 那么 defer 的优先级比较高，脚本将在页面完成时执行。\n\n创建 script 标签，插入到 DOM 中\n\n- ### Ajax 解决浏览器缓存问题\n\n参考回答：\n\n在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(\"If-Modified- Since\",\"0\")。\n\n在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(\"Cache-Control\",\"no- cache\")。\n\n在 URL 后面加上一个随机数： \"fresh=\" + Math.random()。\n\n在 URL 后面加上时间搓：\"nowtime=\" + new Date().getTime()。\n\n如果是使用 jQuery，直接这样就可以了 \\$.ajaxSetup({cache:false})。这样页面的所有 ajax 都会执行这条语句就是不需要保存缓存记录。\n\n- ### JS 的节流和防抖\n\n参 考 回 答 ：\n[_http://www.cnblogs.com/coco1s/p/5499469.html_](http://www.cnblogs.com/coco1s/p/5499469.html)\n\n- ### JS 中的垃圾回收机制\n\n参考回答：\n\n必要性：由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript\n程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript\n的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。\n\n这段话解释了为什么需要系统需要垃圾回收，JS 不像 C/C++，他有自己的一套垃圾回收机制（Garbage Collection）。JavaScript\n的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。例如：\n\n### var a=\"hello world\"; var b=\"world\"\n\n> var a=b;\n\n//这时，会释放掉\"hello world\"，释放内存以便再引用\n\n垃圾回收的方法：标记清除、计数引用。标记清除\n\n这是最常见的垃圾回收方式，当变量进入环境时，就标记这个变量为”进入环境“,从逻辑上讲，永远不能释放进入环境的变量所占的内存，永远不能释放进入环境变量所占用的内存，只要执行流程进入相应的环境，就可能用到他们。当离开环境时，就标记为离开环境。\n\n垃圾回收器在运行的时候会给存储在内存中的变量都加上标记（所有都加），然后去掉环境变量中的变量，以及被环境变量中的变量所引用的变量（条件性去除标记），\n删除所有被标记的变量，删除的变量无法在环境变量中被访问所以会被删除，最后垃圾回收器，完成了内存的清除工作，并回收他们所占用的内存。\n\n引用计数法\n\n另一种不太常见的方法就是引用计数法，引用计数法的意思就是每个值没引用的次 数，当声明了一个变量，并用一个引用类型的值赋值给改变量，则这个值的引用次数为\n1,；相反的，如果包含了对这个值引用的变量又取得了另外一个值，则原先的引用\n\n值引用次数就减 1，当这个值的引用次数为 0 的时候，说明没有办法再访问这个值了， 因此就把所占的内存给回收进来，这样垃圾收集器再次运行的时候，就会释放引用次数为 0 的这些值。\n\n用引用计数法会存在内存泄露，下面来看原因：\n\n### function problem() {\n\n> var objA = new Object(); var objB = new Object();\n\n> objA.someOtherObject = objB; objB.anotherObject = objA;\n\n> }\n\n在这个例子里面，objA 和 objB 通过各自的属性相互引用，这样的话，两个对象的引用次数都为 2，在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，因为计数不为\n0，这样的相互引用如果大量存在就会导致内存泄露。\n\n特别是在 DOM 对象中，也容易存在这种问题：\n\n### var element=document.getElementById（’‘）； var myObj=new Object(); myObj.element=element; element.someObject=myObj\n\n这样就不会有垃圾回收的过程。\n\n- ### eval 是做什么的\n\n参考回答：\n\n它的功能是将对应的字符串解析成 JS 并执行，应该避免使用 JS，因为非常消耗性能\n\n（2 次，一次解析成 JS，一次执行）\n\n- ### 如何理解前端模块化\n\n参考回答：\n\n前端模块化就是复杂的文件编程一个一个独立的模块，比如 JS 文件等等，分成独立的模块有利于重用（复用性）和维护（版本迭代），这样会引来模块之间相互依赖的问题，所以有了 commonJS\n规范，AMD，CMD 规范等等，以及用于 JS 打包（编译等处理） 的工具webpack\n\n- ### 说一下 CommonJS、AMD 和 CMD\n\n参考回答：\n\n一个模块是能实现特定功能的文件，有了模块就可以方便的使用别人的代码，想要什么功能就能加载什么模块。\n\nCommonJS：开始于服务器端的模块化，同步定义的模块化，每个模块都是一个单独的作用域，模块输出，modules.exports，模块加载 require()引入模块。\nAMD：中文名异步模块定义的意思。\n\nrequireJS 实现了 AMD 规范，主要用于解决下述两个问题。\n\n1. 多个文件有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器\n\n2. 加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应的时间越长。语法：requireJS 定义了一个函数 define，它是全局变量，用来定义模块。requireJS 的例子：\n\n//定义模块\n\n### define(\\['dependency'\\], function(){ var name = 'Byron'\n\n> function printName(){ console.log(name);\n\n> }\n\n> return {\n\n> printName: printName\n\n> };\n\n> });\n\n//加载模块\n\n### require(\\['myModule'\\], function (my){ my.printName()\n\n> }\n\nRequireJS 定义了一个函数 define,它是全局变量，用来定义模块：\n\ndefine(id?dependencies?,factory) 在页面上使用模块加载函数： require(\\[dependencies\\],factory)；\n\n总结 AMD 规范：require（）函数在加载依赖函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块加载成功，才会去执行。\n\n因为网页在加载 JS 的时候会停止渲染，因此我们可以通过异步的方式去加载 JS,而如果需要依赖某些，也是异步去依赖，依赖后再执行某些方法。\n\n- ### 对象深度克隆的简单实现\n\n参考回答：\n\n### function deepClone(obj){\n\n> var newObj= obj instanceof Array ? \\[\\]:{}; for(var item in obj){\n\n> var temple= typeof obj\\[item\\] == 'object' ? deepClone(obj\\[item\\]):obj\\[item\\]; newObj\\[item\\] =\n> temple;\n\n> }\n\n> return newObj;\n\n> }\n\nES5 的常用的对象克隆的一种方式。注意数组是对象，但是跟对象又有一定区别，所以我们一开始判断了一些类型，决定 newObj 是对象还是数组。\n\n- ### 实现一个 once 函数，传入函数参数只执行一次\n\n参考回答：\n\n### function ones(func){ var tag=true\n\n> return function(){ if(tag==true){ func.apply(null,arguments); tag=false;\n\n> }\n\n> return undefined\n\n> }\n\n> }\n\n- ### 将原生的 ajax 封装成 promise\n\n参考回答：\n\n### var myNewAjax=function(url){\n\n> return new Promise(function(resolve,reject){\n\n> var xhr = new XMLHttpRequest(); xhr.open('get',url); xhr.send(data);\n> xhr.onreadystatechange=function(){ if(xhr.status==200&&readyState==4){\n\n> var json=JSON.parse(xhr.responseText); resolve(json)\n\n> }else if(xhr.readyState==4&&xhr.status!=200){ reject('error');\n\n> }\n\n> }\n\n> })\n\n> }\n\n- ### JS 监听对象属性的改变\n\n参考回答：\n\n我们假设这里有一个 user 对象,\n\n1. 在 ES5 中可以通过 Object.defineProperty 来实现已有属性的监听Object.defineProperty(user,'name',{\n   set：function(key,value){\n\n### }\n\n> })\n\n缺点：如果 id 不在 user 对象中，则不能监听 id 的变化(2)在 ES6 中可以通过 Proxy 来实现\n\n### var user = new Proxy({}，{ set：function(target,key,value,receiver){\n\n> }\n\n> })\n\n这样即使有属性在 user 中不存在，通过 user.id 来定义也同样可以这样监听这个属性的变化哦。\n\n- ### 如何实现一个私有变量，用 getName 方法可以访问，不能直接访问\n\n参考回答：\n\n1. 通过 defineProperty 来实现\n\n### obj={ name:yuxiaoliang, getName:function(){ return this.name\n\n> }\n\n> } object.defineProperty(obj,\"name\",{\n\n//不可枚举不可配置\n\n});\n\n2. 通过函数的创建形式\n\n### function product(){\n\n> var name='yuxiaoliang'; this.getName=function(){ return name;\n\n> }\n\n> }\n\n> var obj=new product();\n\n### • ==和===、以及 Object.is 的区别\n\n参考回答： (1) ==\n\n主要存在：强制转换成 number,null==undefined \" \"==0 //true\n\n\"0\"==0 //true \" \" !=\"0\" //true\n\n123==\"123\" //true null==undefined //true (2)Object.js\n\n主要的区别就是+0！=-0 而 NaN==NaN (相对比===和==的改进)\n\n- ### setTimeout、setInterval 和 requestAnimationFrame 之间的区别\n\n参考回答：\n\n这里有一篇文章讲的是 requestAnimationFrame：\n[_http://www.cnblogs.com/xiaohuochai/p/5777186.html_](http://www.cnblogs.com/xiaohuochai/p/5777186.html)\n\n与 setTimeout 和 setInterval 不同，requestAnimationFrame 不需要设置时间间隔， 大多数电脑显示器的刷新频率是 60Hz，大概相当于每秒钟重绘 60\n次。大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。因此，最平滑动画的最佳循环间隔是 1000ms/60，约等于 16.6ms。RAF\n采用的是系统时间间隔，不会因为前面的任务，不会影响 RAF，但是如果前面的任务多的话，\n\n会响应 setTimeout 和 setInterval 真正运行时的时间间隔。特点：\n\n1. requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。\n\n2. 在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量\n\n3. requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销。\n\n- ### 实现一个两列等高布局，讲讲思路\n\n参考回答：\n\n为了实现两列等高，可以给每列加上 padding-bottom:9999px; margin-bottom:-9999px;同时父元素设置 overflow:hidden;\n\n- ### 自己实现一个 bind 函数\n\n参考回答：\n\n原理：通过 apply 或者 call 方法来实现。(1)初始版本\n\n### Function.prototype.bind=function(obj,arg){\n\n> var arg=Array.prototype.slice.call(arguments,1); var context=this;\n\n> return function(newArg){ arg=arg.concat(Array.prototype.slice.call(newArg)); return\n> context.apply(obj,arg);\n\n> }\n\n> }\n\n2. 考虑到原型链\n\n为什么要考虑？因为在 new 一个 bind 过生成的新函数的时候，必须的条件是要继承原函数的原型\n\n### Function.prototype.bind=function(obj,arg){\n\n> var arg=Array.prototype.slice.call(arguments,1); var context=this;\n\n> var bound=function(newArg){ arg=arg.concat(Array.prototype.slice.call(newArg)); return\n> context.apply(obj,arg);\n\n> }\n\n> var F=function(){}\n\n> //这里需要一个寄生组合继承F.prototype=context.prototype; bound.prototype=new F(); return bound;\n\n> }\n\n- ### 用 setTimeout 来实现 setInterval\n\n参考回答：\n\n1. 用 setTimeout()方法来模拟 setInterval()与 setInterval()之间的什么区别？ 首先来看 setInterval 的缺陷，使用\n   setInterval()创建的定时器确保了定时器代码规则地插入队列中。这个问题在于：如果定时器代码在代码再次添加到队列之前还没完成执行，结果就会导致定时器代码连续运行好几次。而之间没有间隔。不过幸运的\n\n是：javascript 引擎足够聪明，能够避免这个问题。当且仅当没有该定时器的如何代码实例时，才会将定时器代码添加到队列中。这确保了定时器代码加入队列中最小的时间间隔为指定时间。\n\n这种重复定时器的规则有两个问题：1.某些间隔会被跳过 2.多个定时器的代码执行时间可能会比预期小。\n\n下面举例子说明：\n\n假设，某个 onclick 事件处理程序使用啦 setInterval()来设置了一个 200ms 的重复定时器。如果事件处理程序花了 300ms 多一点的时间完成。\n\n<img width=\"626\" alt=\"2018-07-10 11 36 43\"\nsrc=\"[_https://user-_](https://user-images.githubusercontent.com/17233651/42487876-92656f2c-8435-11e8-8a5f-0a97918039da.png)\n[_images.githubusercontent.com/17233651/42487876-92656f2c-8435-11e8-8a5f-_](https://user-images.githubusercontent.com/17233651/42487876-92656f2c-8435-11e8-8a5f-0a97918039da.png)\n[_0a97918039da.png_](https://user-images.githubusercontent.com/17233651/42487876-92656f2c-8435-11e8-8a5f-0a97918039da.png)\">\n\n这个例子中的第一个定时器是在 205ms 处添加到队列中，但是要过 300ms 才能执行。在 405ms 又添加了一个副本。在一个间隔，605ms 处，第一个定时器代码还在执行中，\n而且队列中已经有了一个定时器实例，结果是 605ms 的定时器代码不会添加到队列\n\n中。结果是在 5ms 处添加的定时器代码执行结束后，405 处的代码立即执行。\n\n### function say(){\n\n> //something setTimeout(say,200);\n\n> } setTimeout(say,200) 或者\n\n> setTimeout(function(){\n\n> //do something setTimeout(arguments.callee,200);\n\n> },200);\n\n- ### JS 怎么控制一次加载一张图片，加载完后再加载下一张\n\n参考回答： (1)方法 1\n\n### <script type=\"text/javascript\"> var obj=new Image()\n\n> [obj.src=\"http://www.phpernote.com/uploadfiles/editor/2011072405022011](http://www.phpernote.com/uploadfiles/editor/2011072405022011)\n> 79.jpg\";\n\n> obj.onload=function(){\n\nalert('图片的宽度为：'+obj.width+'；图片的高度为：'+obj.height);\n\n### document.getElementById(\"mypic\").innnerHTML=\"\\<img src='\"+this.src+\"'\n\n> />\";\n\n> }\n\n> </script>\n\n<blockquote>\n<div id=\"mypic\">onloading……\\</div>\n</blockquote>\n<ol start=\"2\">\n<li>方法 2</li>\n</ol>\n<h3 id=\"var-obj-new-Image\"><a href=\"#var-obj-new-Image\" class=\"headerlink\" title=\" var obj=new Image()\"></a><script type=\"text/javascript\"> var obj=new Image()</h3><blockquote>\n<p><a href=\"http://www.phpernote.com/uploadfiles/editor/2011072405022011\">obj.src=”http://www.phpernote.com/uploadfiles/editor/2011072405022011</a><br>79.jpg”;</p>\n</blockquote>\n<blockquote>\n<p>obj.onreadystatechange=function(){ if(this.readyState==”complete”){</p>\n</blockquote>\n<p>alert(‘图片的宽度为：’+obj.width+’；图片的高度为：’+obj.height);</p>\n<h3 id=\"document-getElementById-“mypic”-innnerHTML-”-lt-img-src-’”-this-src-”‘\"><a href=\"#document-getElementById-“mypic”-innnerHTML-”-lt-img-src-’”-this-src-”‘\" class=\"headerlink\" title=\"document.getElementById(“mypic”).innnerHTML=”&lt;img src=’”+this.src+”‘\"></a>document.getElementById(“mypic”).innnerHTML=”&lt;img src=’”+this.src+”‘</h3><blockquote>\n<p>/&gt;”;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p></script></p>\n</blockquote>\n<blockquote>\n<div id=\"mypic\">onloading……\\</div>\n</blockquote>\n<ul>\n<li><h3 id=\"代码的执行顺序\"><a href=\"#代码的执行顺序\" class=\"headerlink\" title=\"代码的执行顺序\"></a>代码的执行顺序</h3></li>\n</ul>\n<blockquote>\n<p>参 考 回 答 ： setTimeout(function(){console.log(1)},0); new Promise(function(resolve,reject){<br>console.log(2);</p>\n</blockquote>\n<blockquote>\n<p>resolve();</p>\n</blockquote>\n<blockquote>\n<p>}).then(function(){console.log(3)</p>\n</blockquote>\n<blockquote>\n<p>}).then(function(){console.log(4)}); process.nextTick(function(){console.log(5)}); console.log(6);</p>\n</blockquote>\n<p>//输出 2,6,5,3,4,1</p>\n<p>为什么呢？具体请参考这篇文章：</p>\n<p><a href=\"https://github.com/forthealllight/blog/issues/5\"><em>从 promise、process.nextTick、setTimeout 出发，谈谈 Event Loop 中的 Job<br>queue</em></a></p>\n<ul>\n<li><h3 id=\"如何实现-sleep-的效果（es5-或者-es6）\"><a href=\"#如何实现-sleep-的效果（es5-或者-es6）\" class=\"headerlink\" title=\"如何实现 sleep 的效果（es5 或者 es6）\"></a>如何实现 sleep 的效果（es5 或者 es6）</h3></li>\n</ul>\n<p>参 考 回 答 ： (1)while 循环的方式</p>\n<h3 id=\"function-sleep-ms\"><a href=\"#function-sleep-ms\" class=\"headerlink\" title=\"function sleep(ms){\"></a>function sleep(ms){</h3><blockquote>\n<p>var start=Date.now(),expire=start+ms; while(Date.now()&lt;expire); console.log(‘1111’);</p>\n</blockquote>\n<blockquote>\n<p>return;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<p>执行 sleep(1000)之后，休眠了 1000ms 之后输出了 1111。上述循环的方式缺点很明显，容易造成死循环。</p>\n<ol start=\"2\">\n<li>通过 promise 来实现</li>\n</ol>\n<h3 id=\"function-sleep-ms-1\"><a href=\"#function-sleep-ms-1\" class=\"headerlink\" title=\"function sleep(ms){\"></a>function sleep(ms){</h3><blockquote>\n<p>var temple=new Promise( (resolve)=&gt;{</p>\n</blockquote>\n<blockquote>\n<p>console.log(111);setTimeout(resolve,ms)</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>return temple</p>\n</blockquote>\n<blockquote>\n<p>} sleep(500).then(function(){</p>\n</blockquote>\n<blockquote>\n<p>//console.log(222)</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<p>//先输出了 111，延迟 500ms 后输出 222 (3)通过 async 封装</p>\n<h3 id=\"function-sleep-ms-2\"><a href=\"#function-sleep-ms-2\" class=\"headerlink\" title=\"function sleep(ms){\"></a>function sleep(ms){</h3><blockquote>\n<p>return new Promise((resolve)=&gt;setTimeout(resolve,ms));</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>async function test(){</p>\n</blockquote>\n<blockquote>\n<p>var temple=await sleep(1000); console.log(1111)</p>\n</blockquote>\n<blockquote>\n<p>return temple</p>\n</blockquote>\n<blockquote>\n<p>} test();</p>\n</blockquote>\n<blockquote>\n<p>//延迟 1000ms 输出了 1111 (4).通过 generate 来实现function* sleep(ms){</p>\n</blockquote>\n<h3 id=\"yield-new-Promise-function-resolve-reject-console-log-111\"><a href=\"#yield-new-Promise-function-resolve-reject-console-log-111\" class=\"headerlink\" title=\"yield new Promise(function(resolve,reject){ console.log(111)\"></a>yield new Promise(function(resolve,reject){ console.log(111)</h3><blockquote>\n<p>setTimeout(resolve,ms);</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<blockquote>\n<p>} sleep(500).next().value.then(function(){console.log(2222)})</p>\n</blockquote>\n<ul>\n<li><h3 id=\"简单的实现一个-promise\"><a href=\"#简单的实现一个-promise\" class=\"headerlink\" title=\"简单的实现一个 promise\"></a>简单的实现一个 promise</h3></li>\n</ul>\n<p>参考回答：</p>\n<p><a href=\"https://promisesaplus.com/\"><em>首先明确什么是 promiseA+规范，参考规范的地址：primise</em></a> A+规范</p>\n<p>如何实现一个 promise，参考这篇文章：</p>\n<p><a href=\"https://github.com/forthealllight/blog/issues/4\"><em>实现一个完美符合 Promise/A+规范的 Promise</em></a></p>\n<p>一般不会问的很详细，只要能写出上述文章中的 v1.0 版本的简单 promise 即可。</p>\n<ul>\n<li><h3 id=\"Function-proto-getPrototypeOf-是什么？\"><a href=\"#Function-proto-getPrototypeOf-是什么？\" class=\"headerlink\" title=\"Function._proto_(getPrototypeOf)是什么？\"></a>Function._proto_(getPrototypeOf)是什么？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>获取一个对象的原型，在 chrome 中可以通过_proto_的形式，或者在 ES6 中可以通过</p>\n<p>Object.getPrototypeOf 的形式。</p>\n<p>那么 Function.proto 是什么么？也就是说 Function 由什么对象继承而来，我们来做如下判别。</p>\n<p>Function. proto ==Object.prototype //false Function. proto ==Function.prototype//true 我们发现 Function<br>的原型也是 Function。</p>\n<p>我们用图可以来明确这个关系：</p>\n<p><img width=\"646\" alt=\"2018-07-10 2 38 27\"\nsrc=\"[_https://user-_](https://user-images.githubusercontent.com/17233651/42493275-f55d0860-844e-11e8-983f-e04189a4f3d8.png)\n[_images.githubusercontent.com/17233651/42493275-f55d0860-844e-11e8-983f-_](https://user-images.githubusercontent.com/17233651/42493275-f55d0860-844e-11e8-983f-e04189a4f3d8.png)\n[_e04189a4f3d8.png_](https://user-images.githubusercontent.com/17233651/42493275-f55d0860-844e-11e8-983f-e04189a4f3d8.png)\"></p>\n<ul>\n<li><h3 id=\"实现-JS-中所有对象的深度克隆（包装对象，Date-对象，正则对象）\"><a href=\"#实现-JS-中所有对象的深度克隆（包装对象，Date-对象，正则对象）\" class=\"headerlink\" title=\"实现 JS 中所有对象的深度克隆（包装对象，Date 对象，正则对象）\"></a>实现 JS 中所有对象的深度克隆（包装对象，Date 对象，正则对象）</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>通过递归可以简单实现对象的深度克隆，但是这种方法不管是 ES6 还是 ES5 实现，都有同样的缺陷，就是只能实现特定的 object 的深度复制（比如数组和函数），不能实现包装对象<br>Number，String ， Boolean，以及 Date 对象，RegExp 对象的复制。(1)前文的方法</p>\n<h3 id=\"function-deepClone-obj\"><a href=\"#function-deepClone-obj\" class=\"headerlink\" title=\"function deepClone(obj){\"></a>function deepClone(obj){</h3><blockquote>\n<p>var newObj= obj instanceof Array?[]:{}; for(var i in obj){</p>\n</blockquote>\n<blockquote>\n<p>newObj[i]=typeof obj[i]==’object’? deepClone(obj[i]):obj[i];</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>return newObj;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<p>这种方法可以实现一般对象和数组对象的克隆，比如：</p>\n<h3 id=\"var-arr-1-2-3\"><a href=\"#var-arr-1-2-3\" class=\"headerlink\" title=\"var arr=[1,2,3]\"></a>var arr=[1,2,3]</h3><blockquote>\n<p>var newArr=deepClone(arr);</p>\n</blockquote>\n<blockquote>\n<p>// newArr-&gt;[1,2,3] var obj={</p>\n</blockquote>\n<blockquote>\n<p>x:1, y:2</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>var newObj=deepClone(obj);</p>\n</blockquote>\n<blockquote>\n<p>// newObj={x:1,y:2}</p>\n</blockquote>\n<p>但是不能实现例如包装对象 Number,String,Boolean,以及正则对象 RegExp 和 Date 对象的克隆，比如：</p>\n<p>//Number 包装对象</p>\n<h3 id=\"var-num-new-Number-1\"><a href=\"#var-num-new-Number-1\" class=\"headerlink\" title=\"var num=new Number(1)\"></a>var num=new Number(1)</h3><blockquote>\n<p>typeof num // “object”</p>\n</blockquote>\n<blockquote>\n<p>var newNum=deepClone(num);</p>\n</blockquote>\n<p>//newNum -&gt; {} 空 对 象</p>\n<p>//String 包装对象</p>\n<h3 id=\"var-str-new-String-“hello”-typeof-str-“object”\"><a href=\"#var-str-new-String-“hello”-typeof-str-“object”\" class=\"headerlink\" title=\"var str=new String(“hello”); typeof str //“object”\"></a>var str=new String(“hello”); typeof str //“object”</h3><blockquote>\n<p>var newStr=deepClone(str);</p>\n</blockquote>\n<blockquote>\n<p>//newStr-&gt; {0:’h’,1:’e’,2:’l’,3:’l’,4:’o’};</p>\n</blockquote>\n<p>//Boolean 包装对象</p>\n<h3 id=\"var-bol-new-Boolean-true-typeof-bol-“object”\"><a href=\"#var-bol-new-Boolean-true-typeof-bol-“object”\" class=\"headerlink\" title=\"var bol=new Boolean(true); typeof bol //“object”\"></a>var bol=new Boolean(true); typeof bol //“object”</h3><blockquote>\n<p>var newBol=deepClone(bol);</p>\n</blockquote>\n<p>// newBol -&gt;{} 空对象</p>\n<p>….</p>\n<ol start=\"2\">\n<li>valueof()函数</li>\n</ol>\n<p>所有对象都有 valueOf 方法，valueOf 方法对于：如果存在任意原始值，它就默认将对象转换为表示它的原始值。对象是复合值，而且大多数对象无法真正表示为一个原始值，因此默认的<br>valueOf()方法简单地返回对象本身，而不是返回一个原始值。数组、函数和正则表达式简单地继承了这个默认方法，调用这些类型的实例的 valueOf()方法只是简单返回这个对象本身。</p>\n<h3 id=\"对于原始值或者包装类：-function-baseClone-base-return-base-valueOf\"><a href=\"#对于原始值或者包装类：-function-baseClone-base-return-base-valueOf\" class=\"headerlink\" title=\"对于原始值或者包装类： function baseClone(base){ return base.valueOf()\"></a>对于原始值或者包装类： function baseClone(base){ return base.valueOf()</h3><blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>//Number</p>\n</blockquote>\n<blockquote>\n<p>var num=new Number(1);</p>\n</blockquote>\n<blockquote>\n<p>var newNum=baseClone(num);</p>\n</blockquote>\n<blockquote>\n<p>//newNum-&gt;1</p>\n</blockquote>\n<blockquote>\n<p>//String</p>\n</blockquote>\n<blockquote>\n<p>var str=new String(‘hello’); var newStr=baseClone(str);</p>\n</blockquote>\n<blockquote>\n<p>// newStr-&gt;”hello”</p>\n</blockquote>\n<blockquote>\n<p>//Boolean</p>\n</blockquote>\n<blockquote>\n<p>var bol=new Boolean(true); var newBol=baseClone(bol);</p>\n</blockquote>\n<blockquote>\n<p>//newBol-&gt; true</p>\n</blockquote>\n<p>其实对于包装类，完全可以用=号来进行克隆，其实没有深度克隆一说， 这里用 valueOf 实现，语法上比较符合规范。</p>\n<p>对于 Date 类型：</p>\n<p>因为 valueOf 方法，日期类定义的 valueOf()方法会返回它的一个内部表示：1970 年 1</p>\n<p>月 1 日以来的毫秒数.因此我们可以在 Date 的原型上定义克隆的方法：</p>\n<h3 id=\"Date-prototype-clone-function-return-new-Date-this-valueOf\"><a href=\"#Date-prototype-clone-function-return-new-Date-this-valueOf\" class=\"headerlink\" title=\"Date.prototype.clone=function(){ return new Date(this.valueOf())\"></a>Date.prototype.clone=function(){ return new Date(this.valueOf())</h3><blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>var date=new Date(‘2010’); var newDate=date.clone();</p>\n</blockquote>\n<blockquote>\n<p>// newDate-&gt; Fri Jan 01 2010 08:00:00 GMT+0800</p>\n</blockquote>\n<blockquote>\n<p>对 于 正 则 对 象 RegExp： RegExp.prototype.clone = function() { var pattern = this.valueOf();</p>\n</blockquote>\n<h3 id=\"var-flags-‘’\"><a href=\"#var-flags-‘’\" class=\"headerlink\" title=\"var flags = ‘’\"></a>var flags = ‘’</h3><blockquote>\n<p>flags += pattern.global ? ‘g’ : ‘’; flags += pattern.ignoreCase ? ‘i’ : ‘’; flags +=<br>pattern.multiline ? ‘m’ : ‘’;</p>\n</blockquote>\n<blockquote>\n<p>return new RegExp(pattern.source, flags);</p>\n</blockquote>\n<blockquote>\n<p>};</p>\n</blockquote>\n<blockquote>\n<p>var reg=new RegExp(‘/111/‘); var newReg=reg.clone();</p>\n</blockquote>\n<blockquote>\n<p>//newReg-&gt; /\\/111\\//</p>\n</blockquote>\n<ul>\n<li><h3 id=\"简单实现-Node-的-Events-模块\"><a href=\"#简单实现-Node-的-Events-模块\" class=\"headerlink\" title=\"简单实现 Node 的 Events 模块\"></a>简单实现 Node 的 Events 模块</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>简介：观察者模式或者说订阅模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。</p>\n<p>node 中的 Events 模块就是通过观察者模式来实现的：</p>\n<h3 id=\"var-events-require-‘events’\"><a href=\"#var-events-require-‘events’\" class=\"headerlink\" title=\"var events=require(‘events’)\"></a>var events=require(‘events’)</h3><blockquote>\n<p>var eventEmitter=new events.EventEmitter(); eventEmitter.on(‘say’,function(name){<br>console.log(‘Hello’,name);</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<blockquote>\n<p>eventEmitter.emit(‘say’,’Jony yu’);</p>\n</blockquote>\n<p>这样，eventEmitter 发出 say 事件，通过 On 接收，并且输出结果，这就是一个订阅模式的实现，下面我们来简单的实现一个 Events 模块的 EventEmitter。</p>\n<ol>\n<li>实现简单的 Event 模块的 emit 和 on 方法function Events(){ this.on=function(eventName,callBack){<br>if(!this.handles){</li>\n</ol>\n<h3 id=\"this-handles\"><a href=\"#this-handles\" class=\"headerlink\" title=\"this.handles={}\"></a>this.handles={}</h3><blockquote>\n<p>} if(!this.handles[eventName]){ this.handles[eventName]=[];</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>this.handles[eventName].push(callBack);</p>\n</blockquote>\n<blockquote>\n<p>} this.emit=function(eventName,obj){ if(this.handles[eventName]){</p>\n</blockquote>\n<blockquote>\n<p>for(var i=0;o&lt;this.handles[eventName].length;i++){ this.handles[eventName][i](obj);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>return this;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>这样我们就定义了 Events，现在我们可以开始来调用： var events=new Events(); events.on(‘say’,function(name){<br>console.log(‘Hello’,nama)</p>\n</blockquote>\n<h3 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"})\"></a>})</h3><blockquote>\n<p>events.emit(‘say’,’Jony yu’);</p>\n</blockquote>\n<p>//结果就是通过 emit 调用之后，输出了 Jony yu (2)每个对象是独立的</p>\n<p>因为是通过 new 的方式，每次生成的对象都是不相同的，因此：</p>\n<h3 id=\"var-event1-new-Events-var-event2-new-Events-event1-on-‘say’-function-console-log-‘Jony-event1’\"><a href=\"#var-event1-new-Events-var-event2-new-Events-event1-on-‘say’-function-console-log-‘Jony-event1’\" class=\"headerlink\" title=\"var event1=new Events(); var event2=new Events(); event1.on(‘say’,function(){ console.log(‘Jony event1’)\"></a>var event1=new Events(); var event2=new Events(); event1.on(‘say’,function(){ console.log(‘Jony event1’)</h3><blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>event2.on(‘say’,function(){ console.log(‘Jony event2’);</p>\n</blockquote>\n<blockquote>\n<p>}) event1.emit(‘say’); event2.emit(‘say’);</p>\n</blockquote>\n<p>//event1、event2 之间的事件监听互相不影响</p>\n<p>//输出结果为’Jony event1’ ‘Jony event2’</p>\n<ul>\n<li><h3 id=\"箭头函数中-this-指向举例\"><a href=\"#箭头函数中-this-指向举例\" class=\"headerlink\" title=\"箭头函数中 this 指向举例\"></a>箭头函数中 this 指向举例</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"var-a-11-function-test2-this-a-22\"><a href=\"#var-a-11-function-test2-this-a-22\" class=\"headerlink\" title=\"var a=11; function test2(){ this.a=22\"></a>var a=11; function test2(){ this.a=22</h3><blockquote>\n<p>let b=()=&gt;{console.log(this.a)} b();</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>var x=new test2();</p>\n</blockquote>\n<p>//输出 22</p>\n<p>定义时绑定。</p>\n<ul>\n<li><h3 id=\"JS-判断类型\"><a href=\"#JS-判断类型\" class=\"headerlink\" title=\"JS 判断类型\"></a>JS 判断类型</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>判断方法：typeof()，instanceof，Object.prototype.toString.call()等</p>\n<ul>\n<li><h3 id=\"数组常用方法\"><a href=\"#数组常用方法\" class=\"headerlink\" title=\"数组常用方法\"></a>数组常用方法</h3></li>\n</ul>\n<p>参 考 回 答 ： push()，pop()，shift()，unshift()，splice()，sort()，reverse()，map()等</p>\n<ul>\n<li><h3 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>法一：indexOf 循环去重</p>\n<p>法二：ES6 Set 去重；Array.from(new Set(array))</p>\n<p>法三：Object 键值对去重；把数组的值存成 Object 的 key 值，比如Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，<br>就说明该值是重复的。</p>\n<ul>\n<li><h3 id=\"闭包-有什么用\"><a href=\"#闭包-有什么用\" class=\"headerlink\" title=\"闭包 有什么用\"></a>闭包 有什么用</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li>什么是闭包：</li>\n</ol>\n<p>闭包是指有权访问另外一个函数作用域中的变量的函数。</p>\n<p>闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。当在一个函数内定义另外一个函数就会产生闭包。</p>\n<ol start=\"2\">\n<li>为什么要用：</li>\n</ol>\n<p>匿名自执行函数：我们知道所有的变量，如果不加上 var<br>关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用<br>var 关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，可以用闭包。 结果缓存：我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对<br>象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。</p>\n<p>封装：实现类和继承等。</p>\n<ul>\n<li><h3 id=\"事件代理在捕获阶段的实际应用\"><a href=\"#事件代理在捕获阶段的实际应用\" class=\"headerlink\" title=\"事件代理在捕获阶段的实际应用\"></a>事件代理在捕获阶段的实际应用</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>可以在父元素层面阻止事件向子元素传播，也可代替子元素执行某些操作。</p>\n<ul>\n<li><h3 id=\"去除字符串首尾空格\"><a href=\"#去除字符串首尾空格\" class=\"headerlink\" title=\"去除字符串首尾空格\"></a>去除字符串首尾空格</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>使用正则(^\\s*)|(\\s*$)即可</p>\n<ul>\n<li><h3 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h3></li>\n</ul>\n<p>参考回答： 减少 HTTP 请求</p>\n<p>使用内容发布网络（CDN） 添加本地缓存</p>\n<p>压缩资源文件</p>\n<p>将 CSS 样式表放在顶部，把 javascript 放在底部（浏览器的运行机制决定） 避免使用 CSS 表达式</p>\n<p>减少 DNS 查询</p>\n<p>使用外部 javascript 和 CSS</p>\n<p>避免重定向 图片 lazyLoad</p>\n<ul>\n<li><h3 id=\"来讲讲-JS-的闭包吧\"><a href=\"#来讲讲-JS-的闭包吧\" class=\"headerlink\" title=\"来讲讲 JS 的闭包吧\"></a>来讲讲 JS 的闭包吧</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>闭包是指有权访问另外一个函数作用域中的变量的函数。</p>\n<p>闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。当在一个函数内定义另外一个函数就会产生闭包。</p>\n<ol start=\"2\">\n<li>为什么要用：</li>\n</ol>\n<p>匿名自执行函数：我们知道所有的变量，如果不加上 var<br>关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用<br>var 关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，可以用闭包。 结果缓存：我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对<br>象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用</p>\n<p>这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。</p>\n<ul>\n<li><h3 id=\"能来讲讲-JS-的语言特性吗\"><a href=\"#能来讲讲-JS-的语言特性吗\" class=\"headerlink\" title=\"能来讲讲 JS 的语言特性吗\"></a>能来讲讲 JS 的语言特性吗</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>运行在客户端浏览器上；</p>\n<p>不用预编译，直接解析执行代码； 是弱类型语言，较为灵活；</p>\n<p>与操作系统无关，跨平台的语言； 脚本语言、解释性语言</p>\n<ul>\n<li><h3 id=\"如何判断一个数组-讲到-typeof-差点掉坑里\"><a href=\"#如何判断一个数组-讲到-typeof-差点掉坑里\" class=\"headerlink\" title=\"如何判断一个数组(讲到 typeof 差点掉坑里)\"></a>如何判断一个数组(讲到 typeof 差点掉坑里)</h3></li>\n</ul>\n<blockquote>\n<p>参 考 回 答 ： Object.prototype.call.toString() instanceof</p>\n</blockquote>\n<ul>\n<li><h3 id=\"你说到-typeof，能不能加一个限制条件达到判断条件\"><a href=\"#你说到-typeof，能不能加一个限制条件达到判断条件\" class=\"headerlink\" title=\"你说到 typeof，能不能加一个限制条件达到判断条件\"></a>你说到 typeof，能不能加一个限制条件达到判断条件</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>typeof 只能判断是 object,可以判断一下是否拥有数组的方法</p>\n<ul>\n<li><h3 id=\"JS-实现跨域\"><a href=\"#JS-实现跨域\" class=\"headerlink\" title=\"JS 实现跨域\"></a>JS 实现跨域</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>JSONP：通过动态创建 script，再请求一个带参网址实现跨域通信。document.domain</p>\n<ul>\n<li>iframe 跨域：两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域。</li>\n</ul>\n<p>location.hash + iframe 跨域：a 欲与b 跨域相互通信，通过中间页c 来实现。 三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 js<br>访问来通信。</p>\n<p>window.name + iframe 跨域：通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。</p>\n<p>postMessage 跨域：可以跨域操作的 window 属性之一。</p>\n<p>CORS：服务端设置 Access-Control-Allow-Origin 即可，前端无须设置，若要带</p>\n<p>cookie 请求，前后端都需要设置。</p>\n<p>代理跨域：启一个代理服务器，实现数据的转发</p>\n<p>参考 <a href=\"https://segmentfault.com/a/1190000011145364\"><em>https://segmentfault.com/a/1190000011145364</em></a></p>\n<ul>\n<li><h3 id=\"JS-基本数据类型\"><a href=\"#JS-基本数据类型\" class=\"headerlink\" title=\"JS 基本数据类型\"></a>JS 基本数据类型</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>基本数据类型：undefined、null、number、boolean、string、symbol</p>\n<ul>\n<li><h3 id=\"JS-深度拷贝一个元素的具体实现\"><a href=\"#JS-深度拷贝一个元素的具体实现\" class=\"headerlink\" title=\"JS 深度拷贝一个元素的具体实现\"></a>JS 深度拷贝一个元素的具体实现</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"var-deepCopy-function-obj\"><a href=\"#var-deepCopy-function-obj\" class=\"headerlink\" title=\"var deepCopy = function(obj) {\"></a>var deepCopy = function(obj) {</h3><blockquote>\n<p>if (typeof obj !== ‘object’) return;</p>\n</blockquote>\n<blockquote>\n<p>var newObj = obj instanceof Array ? [] : {}; for (var key in obj) {</p>\n</blockquote>\n<blockquote>\n<p>if (obj.hasOwnProperty(key)) {</p>\n</blockquote>\n<blockquote>\n<p>newObj[key] = typeof obj[key] === ‘object’ ? deepCopy(obj[key]) : obj[key];</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>return newObj;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"之前说了-ES6set-可以数组去重，是否还有数组去重的方法\"><a href=\"#之前说了-ES6set-可以数组去重，是否还有数组去重的方法\" class=\"headerlink\" title=\"之前说了 ES6set 可以数组去重，是否还有数组去重的方法\"></a>之前说了 ES6set 可以数组去重，是否还有数组去重的方法</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>法一：indexOf 循环去重</p>\n<p>法二：Object 键值对去重；把数组的值存成 Object 的 key 值，比如Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，<br>就说明该值是重复的。</p>\n<ul>\n<li><h3 id=\"重排和重绘，讲讲看\"><a href=\"#重排和重绘，讲讲看\" class=\"headerlink\" title=\"重排和重绘，讲讲看\"></a>重排和重绘，讲讲看</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>重绘（repaint 或<br>redraw）：当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。</p>\n<p>触发重绘的条件：改变元素外观属性。如：color，background-color 等。</p>\n<p>注意：table 及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值， 比同等元素要多花两倍时间，这就是我们尽量避免使用 table<br>布局页面的原因之一。重排（重构/回流/reflow）：当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建,<br>这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。</p>\n<p>重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。所以，重排必定会引发重绘，但重绘不一定会引发重排。</p>\n<ul>\n<li><h3 id=\"JS-的全排列\"><a href=\"#JS-的全排列\" class=\"headerlink\" title=\"JS 的全排列\"></a>JS 的全排列</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"function-permutate-str-var-result-if-str-length-gt-1\"><a href=\"#function-permutate-str-var-result-if-str-length-gt-1\" class=\"headerlink\" title=\"function permutate(str) { var result = []; if(str.length &gt; 1) {\"></a>function permutate(str) { var result = []; if(str.length &gt; 1) {</h3><blockquote>\n<p>var left = str[0];</p>\n</blockquote>\n<blockquote>\n<p>var rest = str.slice(1, str.length); var preResult = permutate(rest); for(var i=0;<br>i&lt;preResult.length; i++) {</p>\n</blockquote>\n<blockquote>\n<p>for(var j=0; j&lt;preResult[i].length; j++) {</p>\n</blockquote>\n<blockquote>\n<p>var tmp = preResult[i],slice(0, j) + left + preResult[i].slice(j, preResult[i].length);</p>\n</blockquote>\n<blockquote>\n<p>result.push(tmp);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>} else if (str.length == 1) { return [str];</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>return result;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"跨域的原理\"><a href=\"#跨域的原理\" class=\"headerlink\" title=\"跨域的原理\"></a>跨域的原理</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对 JavaScript<br>实施的安全限制，那么只要协议、域名、端口有任何一个不同，都被当作是不同的域。跨域原理，即是通过各种方式，避开浏览器的安全限制。</p>\n<ul>\n<li><h3 id=\"不同数据类型的值的比较，是怎么转换的，有什么规则\"><a href=\"#不同数据类型的值的比较，是怎么转换的，有什么规则\" class=\"headerlink\" title=\"不同数据类型的值的比较，是怎么转换的，有什么规则\"></a>不同数据类型的值的比较，是怎么转换的，有什么规则</h3></li>\n</ul>\n<p>参考回答：</p>\n<p><img src=\"media/image4.jpeg\"></p>\n<ul>\n<li><h3 id=\"null-undefined-为什么\"><a href=\"#null-undefined-为什么\" class=\"headerlink\" title=\"null == undefined 为什么\"></a>null == undefined 为什么</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>要比较相等性之前，不能将 null 和 undefined 转换成其他任何值，但 null == undefined 会返回 true 。ECMAScript 规范中是这样定义的。</p>\n<ul>\n<li><h3 id=\"this-的指向-哪几种\"><a href=\"#this-的指向-哪几种\" class=\"headerlink\" title=\"this 的指向 哪几种\"></a>this 的指向 哪几种</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>默认绑定：全局环境中，this 默认绑定到 window。</p>\n<p>隐式绑定：一般地，被直接对象所包含的函数调用时，也称为方法调用，this 隐式绑定到该直接对象。</p>\n<p>隐式丢失：隐式丢失是指被隐式绑定的函数丢失绑定对象，从而默认绑定到 window。显式绑定：通过 call()、apply()、bind()方法把对象绑定到 this 上，叫做显式绑定。</p>\n<p>new 绑定：如果函数或者方法调用之前带有关键字 new，它就构成构造函数调用。对于this 绑定来说，称为 new 绑定。</p>\n<p>【1】构造函数通常不使用 return 关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。</p>\n<p>【2】如果构造函数使用 return 语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果。</p>\n<p>【3】如果构造函数显式地使用 return 语句返回一个对象，那么调用表达式的值就是这个对象。</p>\n<ul>\n<li><h3 id=\"暂停死区\"><a href=\"#暂停死区\" class=\"headerlink\" title=\"暂停死区\"></a>暂停死区</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>在代码块内，使用 let、const 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”</p>\n<ul>\n<li><h3 id=\"写一个深度拷贝\"><a href=\"#写一个深度拷贝\" class=\"headerlink\" title=\"写一个深度拷贝\"></a>写一个深度拷贝</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"function-clone-obj-var-copy\"><a href=\"#function-clone-obj-var-copy\" class=\"headerlink\" title=\"function clone( obj ) { var copy\"></a>function clone( obj ) { var copy</h3><blockquote>\n<p>switch( typeof obj ) { case “undefined”: break;</p>\n</blockquote>\n<blockquote>\n<p>case “number”: copy = obj - 0; break;</p>\n</blockquote>\n<blockquote>\n<p>case “string”: copy = obj + “”; break;</p>\n</blockquote>\n<blockquote>\n<p>case “boolean”: copy = obj; break;</p>\n</blockquote>\n<p>case “object”: //object 分为两种情况 对象（Object）和数组（Array）</p>\n<h3 id=\"if-obj-null-copy-null\"><a href=\"#if-obj-null-copy-null\" class=\"headerlink\" title=\"if(obj === null) { copy = null\"></a>if(obj === null) { copy = null</h3><blockquote>\n<p>} else {</p>\n</blockquote>\n<blockquote>\n<p>if( Object.prototype.toString.call(obj).slice(8, -1) === “Array”) { copy = [];</p>\n</blockquote>\n<blockquote>\n<p>for( var i = 0 ; i &lt; obj.length ; i++ ) { copy.push(clone(obj[i]));</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>} else { copy = {};</p>\n</blockquote>\n<blockquote>\n<p>for( var j in obj) { copy[j] = clone(obj[j]);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>} break; default:</p>\n</blockquote>\n<blockquote>\n<p>copy = obj; break;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>return copy;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"简历中提到了-requestAnimationFrame，请问是怎么使用的\"><a href=\"#简历中提到了-requestAnimationFrame，请问是怎么使用的\" class=\"headerlink\" title=\"简历中提到了 requestAnimationFrame，请问是怎么使用的\"></a>简历中提到了 requestAnimationFrame，请问是怎么使用的</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。</p>\n<ul>\n<li><h3 id=\"有一个游戏叫做-Flappy-Bird，就是一只小鸟在飞，前面是无尽的沙漠，上下不断有钢管生成，你要躲避钢管。然后小明在玩这个游戏时候老是卡顿甚至崩溃，说出原因（3-5-个）以及解决办法（3-5-个）\"><a href=\"#有一个游戏叫做-Flappy-Bird，就是一只小鸟在飞，前面是无尽的沙漠，上下不断有钢管生成，你要躲避钢管。然后小明在玩这个游戏时候老是卡顿甚至崩溃，说出原因（3-5-个）以及解决办法（3-5-个）\" class=\"headerlink\" title=\"有一个游戏叫做 Flappy Bird，就是一只小鸟在飞，前面是无尽的沙漠，上下不断有钢管生成，你要躲避钢管。然后小明在玩这个游戏时候老是卡顿甚至崩溃，说出原因（3-5 个）以及解决办法（3-5 个）\"></a>有一个游戏叫做 Flappy Bird，就是一只小鸟在飞，前面是无尽的沙漠，上下不断有钢管生成，你要躲避钢管。然后小明在玩这个游戏时候老是卡顿甚至崩溃，说出原因（3-5 个）以及解决办法（3-5 个）</h3></li>\n</ul>\n<p>参考回答： 原因可能是：</p>\n<ol>\n<li><p>内存溢出问题。</p>\n</li>\n<li><p>资源过大问题。</p>\n</li>\n<li><p>资源加载问题。4.canvas 绘制频率问题解决办法：</p>\n</li>\n<li><p>针对内存溢出问题，我们应该在钢管离开可视区域后，销毁钢管，让垃圾收集器回收钢管，因为不断生成的钢管不及时清理容易导致内存溢出游戏崩溃。</p>\n</li>\n<li><p>针对资源过大问题，我们应该选择图片文件大小更小的图片格式，比如使用 webp、png 格式的图片，因为绘制图片需要较大计算量。</p>\n</li>\n<li><p>针对资源加载问题，我们应该在可视区域之前就预加载好资源，如果在可视区域生成钢管的话，用户的体验就认为钢管是卡顿后才生成的，不流畅。</p>\n</li>\n<li><p>针对 canvas 绘制频率问题，我们应该需要知道大部分显示器刷新频率为 60 次/s,因此游戏的每一帧绘制间隔时间需要小于 1000/60=16.7ms，才能让用户觉得不卡顿。</p>\n</li>\n</ol>\n<p>（注意因为这是单机游戏，所以回答与网络无关）</p>\n<ul>\n<li><h3 id=\"编写代码，满足以下条件：-（1）Hero-“37er”-执行结果为-Hi-This-is-37er-（2）Hero-“37er”-kill-1-recover-30-执行结果为-Hi-This-is-37er-Kill-1-bug-Recover-30-bloods-（3）-Hero-“37er”-sleep-10-kill-2-执行结果为-Hi-This-is-37er-等待-10s-后-Kill-2-bugs-注意为-bugs-（双斜线后的为提示信息，不需要打印）\"><a href=\"#编写代码，满足以下条件：-（1）Hero-“37er”-执行结果为-Hi-This-is-37er-（2）Hero-“37er”-kill-1-recover-30-执行结果为-Hi-This-is-37er-Kill-1-bug-Recover-30-bloods-（3）-Hero-“37er”-sleep-10-kill-2-执行结果为-Hi-This-is-37er-等待-10s-后-Kill-2-bugs-注意为-bugs-（双斜线后的为提示信息，不需要打印）\" class=\"headerlink\" title=\"编写代码，满足以下条件： （1）Hero(“37er”);执行结果为 Hi! This is 37er （2）Hero(“37er”).kill(1).recover(30);执行结果为 Hi! This is 37er Kill 1 bug Recover 30 bloods （3） Hero(“37er”).sleep(10).kill(2)执行结果为 Hi! This is 37er //等待 10s 后 Kill 2 bugs //注意为 bugs （双斜线后的为提示信息，不需要打印）\"></a>编写代码，满足以下条件： （1）Hero(“37er”);执行结果为 Hi! This is 37er （2）Hero(“37er”).kill(1).recover(30);执行结果为 Hi! This is 37er Kill 1 bug Recover 30 bloods （3） Hero(“37er”).sleep(10).kill(2)执行结果为 Hi! This is 37er //等待 10s 后 Kill 2 bugs //注意为 bugs （双斜线后的为提示信息，不需要打印）</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"function-Hero-name-let-o-new-Object-o-name-name-o-time-0\"><a href=\"#function-Hero-name-let-o-new-Object-o-name-name-o-time-0\" class=\"headerlink\" title=\"function Hero(name){ let o=new Object(); o.name=name; o.time=0\"></a>function Hero(name){ let o=new Object(); o.name=name; o.time=0</h3><blockquote>\n<p>console.log(“Hi! This is “+o.name); o.kill=function(bugs) { if(bugs==1){</p>\n</blockquote>\n<blockquote>\n<p>console.log(“Kill “+(bugs)+” bug”);</p>\n</blockquote>\n<blockquote>\n<p>}else { setTimeout(function () {</p>\n</blockquote>\n<blockquote>\n<p>console.log(“Kill “ + (bugs) + “ bugs”);</p>\n</blockquote>\n<blockquote>\n<p>}, 1000 * this.time);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>return o;</p>\n</blockquote>\n<blockquote>\n<p>};</p>\n</blockquote>\n<ol start=\"18\">\n<li>ecover=function (bloods) { console.log(“Recover “+(bloods)+” bloods”); return o;</li>\n</ol>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ol start=\"19\">\n<li>leep=function (sleepTime) { o.time=sleepTime;</li>\n</ol>\n<blockquote>\n<p>return o;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>return o;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"什么是按需加载\"><a href=\"#什么是按需加载\" class=\"headerlink\" title=\"什么是按需加载\"></a>什么是按需加载</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>当用户触发了动作时才加载对应的功能。触发的动作，是要看具体的业务场景而言， 包括但不限于以下几个情况：鼠标点击、输入文字、拉动滚动条，鼠标移动、窗口大小更改等。加载的文件，可以是<br>JS、图片、CSS、HTML 等。</p>\n<ul>\n<li><h3 id=\"说一下什么是-virtual-dom\"><a href=\"#说一下什么是-virtual-dom\" class=\"headerlink\" title=\"说一下什么是 virtual dom\"></a>说一下什么是 virtual dom</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树， 插到文档当中 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异<br>把所记录的差异应用到所构建的真正的 DOM 树上，视图就更新了。Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。</p>\n<ul>\n<li><h3 id=\"webpack-用来干什么的\"><a href=\"#webpack-用来干什么的\" class=\"headerlink\" title=\"webpack 用来干什么的\"></a>webpack 用来干什么的</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency<br>graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p>\n<ul>\n<li><h3 id=\"ant-design-优点和缺点\"><a href=\"#ant-design-优点和缺点\" class=\"headerlink\" title=\"ant-design 优点和缺点\"></a>ant-design 优点和缺点</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>优点：组件非常全面，样式效果也都比较不错。</p>\n<p>缺点：框架自定义程度低，默认 UI 风格修改困难。</p>\n<ul>\n<li><h3 id=\"JS-中继承实现的几种方式\"><a href=\"#JS-中继承实现的几种方式\" class=\"headerlink\" title=\"JS 中继承实现的几种方式\"></a>JS 中继承实现的几种方式</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>1、原型链继承，将父类的实例作为子类的原型，他的特点是实例是子类的实例也是父类的实例，父类新增的原型方法/属性，子类都能够访问，并且原型链继承简单易于实现，缺点是来自原型对象的所有属性被所有实例共享，无法实现多继承，无法向父类构造函数传参。</p>\n<p>2、构造继承，使用父类的构造函数来增强子类实例，即复制父类的实例属性给子类， 构造继承可以向父类传递参数，可以实现多继承，通过 call<br>多个父类对象。但是构造继承只能继承父类的实例属性和方法，不能继承原型属性和方法，无法实现函数服</p>\n<p>用，每个子类都有父类实例函数的副本，影响性能</p>\n<p>3、实例继承，为父类实例添加新特性，作为子类实例返回，实例继承的特点是不限制调用方法，不管是 new 子类（）还是子类（）返回的对象具有相同的效果，缺点是实例是父类的实例，不是子类的实例，不支持多继承</p>\n<p>4、拷贝继承：特点：支持多继承，缺点：效率较低，内存占用高（因为要拷贝父类的属性）无法获取父类不可枚举的方法（不可枚举方法，不能使用 for in 访问到）</p>\n<p>5、组合继承：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<p>6、寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</p>\n<ul>\n<li><h3 id=\"写一个函数，第一秒打印-1，第二秒打印-2\"><a href=\"#写一个函数，第一秒打印-1，第二秒打印-2\" class=\"headerlink\" title=\"写一个函数，第一秒打印 1，第二秒打印 2\"></a>写一个函数，第一秒打印 1，第二秒打印 2</h3></li>\n</ul>\n<p>参考回答：</p>\n<blockquote>\n<p>两个方法，第一个是用 let 块级作用域for(let i=0;i&lt;5;i++){ setTimeout(function(){ console.log(i)</p>\n</blockquote>\n<h3 id=\"1000-i\"><a href=\"#1000-i\" class=\"headerlink\" title=\"},1000*i)\"></a>},1000*i)</h3><blockquote>\n<p>}</p>\n</blockquote>\n<p>第二个方法闭包</p>\n<h3 id=\"for-var-i-0-i-lt-5-i-function-i-setTimeout-function-console-log-i\"><a href=\"#for-var-i-0-i-lt-5-i-function-i-setTimeout-function-console-log-i\" class=\"headerlink\" title=\"for(var i=0;i&lt;5;i++){ (function(i){ setTimeout(function(){ console.log(i)\"></a>for(var i=0;i&lt;5;i++){ (function(i){ setTimeout(function(){ console.log(i)</h3><blockquote>\n<p>},1000*i)</p>\n</blockquote>\n<blockquote>\n<p>})(i)</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"Vue-的生命周期\"><a href=\"#Vue-的生命周期\" class=\"headerlink\" title=\"Vue 的生命周期\"></a>Vue 的生命周期</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是 Vue 的生命周期。通俗说就是 Vue<br>实例从创建到销毁的过程，就是生命周期。</p>\n<p>每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁。</p>\n<p>实例、组件通过 new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行beforeCreate 钩子函数，这个时候，数据还没有挂载呢，只是一个空壳，无法访问到数据和真实的<br>dom，一般不做操作</p>\n<p>挂载数据，绑定事件等等，然后执行 created 函数，这个时候已经可以使用到数据， 也可以更改数据,在这里更改数据不会触发 updated<br>函数，在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取</p>\n<p>接下来开始找实例或者组件对应的模板，编译模板为虚拟 dom 放入到 render 函数中准备渲染，然后执行 beforeMount 钩子函数，在这个函数中虚拟 dom<br>已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发 updated，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取 接下来开始<br>render，渲染出真实 dom，然后执行 mounted 钩子函数，此时，组件已经出现在页面中，数据、真实 dom 都已经处理好了,事件都已经挂载好了，可以在这里操作真实 dom 等事情…</p>\n<p>当组件或实例的数据更改之后，会立即执行 beforeUpdate，然后 Vue 的虚拟 dom 机制会重新构建虚拟 dom 与上一次的虚拟 dom 树利用 diff<br>算法进行对比之后重新渲染，一般不做什么事儿</p>\n<p>当更新完成后，执行 updated，数据已经更改完成，dom 也重新 render 完成，可以操作更新后的虚拟 dom</p>\n<p>当经过某种途径调用$destroy 方法后，立即执行beforeDestroy，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等</p>\n<p>组件的数据绑定、监听…去掉后只剩下 dom 空壳，这个时候，执行 destroyed，在这里做善后工作也可以</p>\n<ul>\n<li><h3 id=\"简单介绍一下-symbol\"><a href=\"#简单介绍一下-symbol\" class=\"headerlink\" title=\"简单介绍一下 symbol\"></a>简单介绍一下 symbol</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Symbol 是 ES6 的新增属性，代表用给定名称作为唯一标识，这种类型的值可以这样创建，let id=symbol(“id”)</p>\n<p>Symbl 确保唯一，即使采用相同的名称，也会产生不同的值，我们创建一个字段，仅为知道对应 symbol 的人能访问，使用 symbol 很有用，symbol 并不是 100%隐藏，有内置方法<br>Object.getOwnPropertySymbols(obj)可以获得所有的 symbol。</p>\n<p>也有一个方法 Reflect.ownKeys(obj)返回对象所有的键，包括 symbol。</p>\n<p>所以并不是真正隐藏。但大多数库内置方法和语法结构遵循通用约定他们是隐藏的。</p>\n<ul>\n<li><h3 id=\"什么是事件监听\"><a href=\"#什么是事件监听\" class=\"headerlink\" title=\"什么是事件监听\"></a>什么是事件监听</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>addEventListener()方法，用于向指定元素添加事件句柄，它可以更简单的控制事件，语法为</p>\n<p>element.addEventListener(event, function, useCapture);</p>\n<p>第一个参数是事件的类型(如 “click” 或 “mousedown”). 第二个参数是事件触发后调用的函数。</p>\n<p>第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。事件传递有两种方式，冒泡和捕获</p>\n<p>事件传递定义了元素事件触发的顺序，如果你将P 元素插入到 div 元素中，用户点击P</p>\n<p>元素，</p>\n<p>在冒泡中，内部元素先被触发，然后再触发外部元素， 捕获中，外部元素先被触发，在触发内部元素。</p>\n<ul>\n<li><h3 id=\"介绍一下-promise，及其底层如何实现\"><a href=\"#介绍一下-promise，及其底层如何实现\" class=\"headerlink\" title=\"介绍一下 promise，及其底层如何实现\"></a>介绍一下 promise，及其底层如何实现</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Promise 是一个对象，保存着未来将要结束的事件，她有两个特征:</p>\n<p>1、对象的状态不受外部影响，Promise 对象代表一个异步操作，有三种状态，pending 进行中，fulfilled 已成功，rejected<br>已失败，只有异步操作的结果，才可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也就是 promise 名字的由来2、一旦状态改变，就不会再变，promise 对象状态改变只有两种可能，从<br>pending 改到 fulfilled 或者从 pending 改到 rejected，只要这两种情况发生，状态就凝固了， 不会再改变，这个时候就称为定型 resolved,</p>\n<p>Promise 的基本用法，</p>\n<h3 id=\"let-promise1-new-Promise-function-resolve-reject-setTimeout-function\"><a href=\"#let-promise1-new-Promise-function-resolve-reject-setTimeout-function\" class=\"headerlink\" title=\"let promise1 = new Promise(function(resolve,reject){ setTimeout(function(){\"></a>let promise1 = new Promise(function(resolve,reject){ setTimeout(function(){</h3><blockquote>\n<p>resolve(‘ok’)</p>\n</blockquote>\n<blockquote>\n<p>},1000)</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<blockquote>\n<p>promise1.then(function success(val){ console.log(val)</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<blockquote>\n<p>最简单代码实现 promise class PromiseM { constructor (process) { this.status = ‘pending’ this.msg = ‘’</p>\n</blockquote>\n<blockquote>\n<p>process(this.resolve.bind(this), this.reject.bind(this)) return this</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>resolve (val) { this.status = ‘fulfilled’ this.msg = val</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>reject (err) { this.status = ‘rejected’ this.msg = err</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>then (fufilled, reject) { if(this.status === ‘fulfilled’) { fufilled(this.msg)</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>if(this.status === ‘rejected’) { reject(this.msg)</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<p>//测试代码</p>\n<h3 id=\"var-mm-new-PromiseM-function-resolve-reject-resolve-‘123’\"><a href=\"#var-mm-new-PromiseM-function-resolve-reject-resolve-‘123’\" class=\"headerlink\" title=\"var mm=new PromiseM(function(resolve,reject){ resolve(‘123’)\"></a>var mm=new PromiseM(function(resolve,reject){ resolve(‘123’)</h3><blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>mm.then(function(success){ console.log(success);</p>\n</blockquote>\n<blockquote>\n<p>},function(){</p>\n</blockquote>\n<blockquote>\n<p>console.log(‘fail!’);</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<ul>\n<li><h3 id=\"说说-C-Java，JavaScript-这三种语言的区别\"><a href=\"#说说-C-Java，JavaScript-这三种语言的区别\" class=\"headerlink\" title=\"说说 C++,Java，JavaScript 这三种语言的区别\"></a>说说 C++,Java，JavaScript 这三种语言的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>从静态类型还是动态类型来看</p>\n<p>静态类型，编译的时候就能够知道每个变量的类型，编程的时候也需要给定类型，如</p>\n<p>Java 中的整型 int，浮点型 float 等。C、C++、Java 都属于静态类型语言。</p>\n<p>动态类型，运行的时候才知道每个变量的类型，编程的时候无需显示指定类型，如JavaScript 中的 var、PHP 中的$。JavaScript、Ruby、Python<br>都属于动态类型语言。静态类型还是动态类型对语言的性能有很大影响。</p>\n<p>对于静态类型，在编译后会大量利用已知类型的优势，如 int 类型，占用 4 个字节， 编译后的代码就可以用内存地址加偏移量的方法存取变量，而地址加偏移量的算法汇编很容易实现。</p>\n<p>对于动态类型，会当做字符串通通存下来，之后存取就用字符串匹配。从编译型还是解释型来看</p>\n<p>编译型语言，像C、C++，需要编译器编译成本地可执行程序后才能运行，由开发人员在编写完成后手动实施。用户只使用这些编译好的本地代码，这些本地代码由系统加载器执行，由操作系统的 CPU<br>直接执行，无需其他额外的虚拟机等。</p>\n<p>源代码=》抽象语法树=》中间表示=》本地代码</p>\n<p>解释性语言，像 JavaScript、Python，开发语言写好后直接将代码交给用户，用户使用脚本解释器将脚本文件解释执行。对于脚本语言，没有开发人员的编译过程，当 然，也不绝对。</p>\n<p>源代码=》抽象语法树=》解释器解释执行。</p>\n<p>对于 JavaScript，随着 Java 虚拟机 JIT 技术的引入，工作方式也发生了改变。可以将抽象语法树转成中间表示（字节码），再转成本地代码，如<br>JavaScriptCore，这样可以大大提高执行效率。也可以从抽象语法树直接转成本地代码，如 V8</p>\n<p>Java 语言，分为两个阶段。首先像 C++语言一样，经过编译器编译。和 C++的不同， C++编译生成本地代码，Java 编译后，生成字节码，字节码与平台无关。第二阶段，由Java 的运行环境也就是<br>Java 虚拟机运行字节码，使用解释器执行这些代码。一般情况下，Java 虚拟机都引入了 JIT 技术，将字节码转换成本地代码来提高执行效率。</p>\n<p>注意，在上述情况中，编译器的编译过程没有时间要求，所以编译器可以做大量的代码优化措施。</p>\n<p>对于 JavaScript 与 Java 它们还有的不同：</p>\n<p>对于 Java，Java 语言将源代码编译成字节码，这个同执行阶段是分开的。也就是从源代码到抽象语法树到字节码这段时间的长短是无所谓的。</p>\n<p>对于 JavaScript，这些都是在网页和 JavaScript 文件下载后同执行阶段一起在网页的加载和渲染过程中实施的，所以对于它们的处理时间有严格要求。</p>\n<ul>\n<li><h3 id=\"JS-原型链，原型链的顶端是什么？Object-的原型是什么？Object-的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法\"><a href=\"#JS-原型链，原型链的顶端是什么？Object-的原型是什么？Object-的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法\" class=\"headerlink\" title=\"JS 原型链，原型链的顶端是什么？Object 的原型是什么？Object 的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法\"></a>JS 原型链，原型链的顶端是什么？Object 的原型是什么？Object 的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>能够把这个讲清楚弄明白是一件很困难的事，</p>\n<p>首先明白原型是什么，在 ES6 之前，JS 没有类和继承的概念，JS 是通过原型来实现继承的，在 JS 中一个构造函数默认带有一个 prototype 属性，这个的属性值是一个对象，同时这个<br>prototype 对象自带有一个 constructor 属性，这个属性指向这个构造函数，同时每一个实例都会有一个_proto_属性指向这个 prototype<br>对象，我们可以把这个叫做隐式原型，我们在使用一个实例的方法的时候，会先检查这个实例中是否有这个方法，没有的话就会检查这个 prototype 对象是否有这个方法，</p>\n<p>基于这个规则，如果让原型对象指向另一个类型的实例，即constructor1.protoytpe=instance2，这时候如果试图引用 constructor1 构造的实例instance1<br>的某个属性 p1,</p>\n<p>首先会在 instance1 内部属性中找一遍，</p>\n<p>接着会在 instance1._proto_（constructor1.prototype）即是 instance2 中寻找 p1</p>\n<p>搜寻轨迹：</p>\n<p>instance1-&gt;instance2-&gt;constructor2.prototype……-&gt;Object.prototype;这即是原型链，原型链顶端是 Object.prototype</p>\n<p>补充学习：</p>\n<p>每个函数都有一个 prototype 属性，这个属性指向了一个对象，这个对象正是调用该函数而创建的实例的原型，那么什么是原型呢，可以这样理解，每一个 JavaScript<br>对象在创建的时候就会预制管理另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型继承属性，如图：</p>\n<p><img src=\"media/image5.jpeg\"></p>\n<p>那么怎么表示实例与实例原型的关系呢，这时候就要用到第二个属性_proto_ 这是每一个 JS 对象都会有的一个属性，指向这个对象的原型，如图：</p>\n<blockquote>\n<p><img src=\"media/image6.jpeg\"></p>\n</blockquote>\n<p>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢，指向实例是没有的，因为一个构造函数可以生成多个实例，但是原型有属性可以直接指向构造函数，通过constructor 即可</p>\n<p>接下来讲解实例和原型的关系：</p>\n<p>当读取实例的属性时，如果找不到，就会查找与对象相关的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层，那么原型的原型是什么呢，首先，原型也是一个对象，既然是对象，我们就可以通过构造函数的方式创建它，所以原型对象就是通过<br>Object 构造函数生成的，如图：</p>\n<p><img src=\"media/image7.jpeg\"></p>\n<p>那么 Object.prototype 的原型呢，我们可以打印</p>\n<p>console.log(Object.prototype. proto === null)，返回 true</p>\n<p>null 表示没有对象，即该处不应有值，所以 Object.prototype 没有原型，如图：</p>\n<p><img src=\"media/image8.jpeg\"></p>\n<p>图中这条蓝色的线即是原型链， 最 后 补 充 三 点 ： constructor：</p>\n<p>function Person(){</p>\n<p>}</p>\n<p>var person = new Person(); console.log(Person === person.constructor);</p>\n<p>原本 person 中没有 constructor 属性，当不能读取到 constructor 属性时，会从</p>\n<p>person 的原型中读取，所以指向构造函数 Person</p>\n<p>proto ：</p>\n<p>绝大部分浏览器支持这个非标准的方法访问原型，然而它并不存在与Person.prototype 中，实际上它来自 Object.prototype，当使用 obj. proto 时， 可以理解为返回来<br>Object.getPrototype(obj)</p>\n<p>继承：</p>\n<p>前面说到，每个对象都会从原型继承属性，但是引用《你不知道的 JS》中的话，继承意味着复制操作，然而 JS 默认不会复制对象的属性，相反，JS<br>只是在两个对象之间创建一个关联，这样子一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，叫委托更合适。</p>\n<ul>\n<li><h3 id=\"什么是-js-的闭包？有什么作用，用闭包写个单例模式\"><a href=\"#什么是-js-的闭包？有什么作用，用闭包写个单例模式\" class=\"headerlink\" title=\"什么是 js 的闭包？有什么作用，用闭包写个单例模式\"></a>什么是 js 的闭包？有什么作用，用闭包写个单例模式</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>MDN 对闭包的定义是：闭包是指那些能够访问自由变量的函数，自由变量是指在函数中使用的，但既不是函数参数又不是函数的局部变量的变量，由此可以看出，闭包=函数</p>\n<p>+函数能够访问的自由变量，所以从技术的角度讲，所有 JS 函数都是闭包，但是这是理论上的闭包，还有一个实践角度上的闭包，从实践角度上来说，只有满足<br>1、即使创建它的上下文已经销毁，它仍然存在，2、在代码中引入了自由变量，才称为闭包</p>\n<p>闭包的应用：</p>\n<p>模仿块级作用域。2、保存外部函数的变量。3、封装私有变量单例模式：</p>\n<h3 id=\"var-Singleton-function-var-instance\"><a href=\"#var-Singleton-function-var-instance\" class=\"headerlink\" title=\"var Singleton = (function(){ var instance\"></a>var Singleton = (function(){ var instance</h3><blockquote>\n<p>var CreateSingleton = function (name) { this.name = name;</p>\n</blockquote>\n<blockquote>\n<p>if(instance) { return instance;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<p>// 打印实例名字</p>\n<h3 id=\"this-getName\"><a href=\"#this-getName\" class=\"headerlink\" title=\"this.getName()\"></a>this.getName()</h3><blockquote>\n<p>// instance = this;</p>\n</blockquote>\n<blockquote>\n<p>// return instance; return instance = this;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>// 获取实例的名字CreateSingleton.prototype.getName = function() { console.log(this.name)</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>return CreateSingleton;</p>\n</blockquote>\n<blockquote>\n<p>})();</p>\n</blockquote>\n<p>// 创建实例对象 1</p>\n<h3 id=\"var-a-new-Singleton-‘a’\"><a href=\"#var-a-new-Singleton-‘a’\" class=\"headerlink\" title=\"var a = new Singleton(‘a’)\"></a>var a = new Singleton(‘a’)</h3><p>// 创建实例对象 2</p>\n<h3 id=\"var-b-new-Singleton-‘b’-console-log-a-b\"><a href=\"#var-b-new-Singleton-‘b’-console-log-a-b\" class=\"headerlink\" title=\"var b = new Singleton(‘b’); console.log(a===b)\"></a>var b = new Singleton(‘b’); console.log(a===b)</h3><ul>\n<li><h3 id=\"promise-Generator-Async-的使用\"><a href=\"#promise-Generator-Async-的使用\" class=\"headerlink\" title=\"promise+Generator+Async 的使用\"></a>promise+Generator+Async 的使用</h3></li>\n</ul>\n<p>参考回答： Promise</p>\n<p>解决的问题:回调地狱Promise 规范:</p>\n<p>promise 有三种状态，等待（pending）、已完成（fulfilled/resolved）、已拒绝</p>\n<p>（rejected）.Promise 的状态只能从“等待”转到“完成”或者“拒绝”，不能逆向转换，同时“完成”和“拒绝”也不能相互转换.</p>\n<p>promise 必须提供一个 then 方法以访问其当前值、终值和据因。promise.then(resolve, reject),resolve 和 reject 都是可选参数。如果 resolve<br>或 reject 不是函数，其必须被忽略.</p>\n<p>then 方法必须返回一个 promise 对象.</p>\n<p>使用:</p>\n<p>实例化 promise 对象需要传入函数(包含两个参数),resolve 和 reject,内部确定状态.resolve 和 reject 函数可以传入参数在回调函数中使用.</p>\n<blockquote>\n<p>resolve 和 reject 都是函数,传入的参数在 then 的回调函数中接收. var promise = new Promise(function(resolve, reject) {<br>setTimeout(function(){</p>\n</blockquote>\n<h3 id=\"resolve-‘好哈哈哈哈’\"><a href=\"#resolve-‘好哈哈哈哈’\" class=\"headerlink\" title=\"resolve(‘好哈哈哈哈’)\"></a>resolve(‘好哈哈哈哈’)</h3><blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>promise.then(function(val){ console.log(val)</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<p>then 接收两个函数,分别对应 resolve 和 reject 状态的回调,函数中接收实例化时传入的参数.</p>\n<h3 id=\"promise-then-val-gt\"><a href=\"#promise-then-val-gt\" class=\"headerlink\" title=\"promise.then(val=&gt;{\"></a>promise.then(val=&gt;{</h3><blockquote>\n<p>//resolved</p>\n</blockquote>\n<blockquote>\n<p>},reason=&gt;{</p>\n</blockquote>\n<blockquote>\n<p>//rejected</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<p>catch 相当于.then(null, rejection)</p>\n<p>当 then 中没有传入 rejection 时,错误会冒泡进入 catch 函数中,若传入了 rejection, 则错误会被 rejection 捕获,而且不会进入 catch.此外,then<br>中的回调函数中发生的错误只会在下一级的 then 中被捕获,不会影响该 promise 的状态.</p>\n<h3 id=\"new-Promise-resolve-reject-gt-throw-new-Error-‘错误’\"><a href=\"#new-Promise-resolve-reject-gt-throw-new-Error-‘错误’\" class=\"headerlink\" title=\"new Promise((resolve,reject)=&gt;{ throw new Error(‘错误’)\"></a>new Promise((resolve,reject)=&gt;{ throw new Error(‘错误’)</h3><blockquote>\n<p>}).then(null,(err)=&gt;{ console.log(err,1);//此处捕获</p>\n</blockquote>\n<blockquote>\n<p>}).catch((err)=&gt;{ console.log(err,2);</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<h3 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"// 对比\"></a>// 对比</h3><blockquote>\n<p>new Promise((resolve,reject)=&gt;{</p>\n</blockquote>\n<blockquote>\n<p>throw new Error(‘错误’)</p>\n</blockquote>\n<blockquote>\n<p>}).then(null,null).catch((err)=&gt;{ console.log(err,2);//此处捕获</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>// 错误示例</p>\n</blockquote>\n<blockquote>\n<p>new Promise((resolve,reject)=&gt;{ resolve(‘正常’);</p>\n</blockquote>\n<blockquote>\n<p>}).then((val)=&gt;{</p>\n</blockquote>\n<blockquote>\n<p>throw new Error(‘回调函数中错误’)</p>\n</blockquote>\n<blockquote>\n<p>},(err)=&gt;{ console.log(err,1);</p>\n</blockquote>\n<blockquote>\n<p>}).then(null,(err)=&gt;{ console.log(err,2);//此处捕获,也可用 catch</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<p>两者不等价的情况:</p>\n<p>此时，catch 捕获的并不是 p1 的错误，而是 p2 的错误，</p>\n<h3 id=\"p1-then-res-gt\"><a href=\"#p1-then-res-gt\" class=\"headerlink\" title=\"p1().then(res=&gt;{\"></a>p1().then(res=&gt;{</h3><blockquote>\n<p>return p2()//p2 返回一个 promise 对象</p>\n</blockquote>\n<blockquote>\n<p>}).catch(err=&gt; console.log(err))</p>\n</blockquote>\n<p>一个错误捕获的错误用例:</p>\n<p>该函数调用中即使发生了错误依然会进入 then 中的 resolve 的回调函数,因为函数 p1 中实例化 promise 对象时已经调用了 catch,若发生错误会进入 catch<br>中,此时会返回一个新的 promise,因此即使发生错误依然会进入 p1 函数的 then 链中的 resolve 回调函数.</p>\n<h3 id=\"function-p1-val\"><a href=\"#function-p1-val\" class=\"headerlink\" title=\"function p1(val){\"></a>function p1(val){</h3><blockquote>\n<p>return new Promise((resolve,reject)=&gt;{ if(val){</p>\n</blockquote>\n<blockquote>\n<p>var len = val.length;//传入 null 会发生错误,进入 catch 捕获错resolve(len);</p>\n</blockquote>\n<blockquote>\n<p>}else{ reject();</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}).catch((err)=&gt;{ console.log(err)</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<blockquote>\n<p>}; p1(null).then((len)=&gt;{</p>\n</blockquote>\n<blockquote>\n<p>console.log(len,’resolved’);</p>\n</blockquote>\n<blockquote>\n<p>},()=&gt;{</p>\n</blockquote>\n<blockquote>\n<p>console.log(‘rejected’);</p>\n</blockquote>\n<blockquote>\n<p>}).catch((err)=&gt;{</p>\n</blockquote>\n<blockquote>\n<p>console.log(err,’catch’);</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<p>Promise 回调链:</p>\n<p>promise 能够在回调函数里面使用 return 和 throw， 所以在 then 中可以 return 出一个 promise 对象或其他值，也可以 throw 出一个错误对象，但如果没有<br>return，将默认返回 undefined，那么后面的 then 中的回调参数接收到的将是 undefined. function p1(val){</p>\n<h3 id=\"return-new-Promise-resolve-reject-gt-val-1-resolve-1-reject\"><a href=\"#return-new-Promise-resolve-reject-gt-val-1-resolve-1-reject\" class=\"headerlink\" title=\"return new Promise((resolve,reject)=&gt;{ val==1?resolve(1):reject()\"></a>return new Promise((resolve,reject)=&gt;{ val==1?resolve(1):reject()</h3><blockquote>\n<p>})</p>\n</blockquote>\n<blockquote>\n<p>};</p>\n</blockquote>\n<blockquote>\n<p>function p2(val){</p>\n</blockquote>\n<blockquote>\n<p>return new Promise((resolve,reject)=&gt;{ val==2?resolve(2):reject();</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<blockquote>\n<p>};</p>\n</blockquote>\n<blockquote>\n<p>let promimse = new Promise(function(resolve,reject){ resolve(1)</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<blockquote>\n<p>.then(function(data1) {</p>\n</blockquote>\n<blockquote>\n<p>return p1(data1)//如果去掉 return,则返回 undefined 而不是 p1 的返回值, 会导致报错</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<blockquote>\n<p>.then(function(data2){ return p2(data2+1)</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<blockquote>\n<p>.then(res=&gt;console.log(res))</p>\n</blockquote>\n<p>Generator 函 数 ： generator 函数使用:</p>\n<p>1、分段执行，可以暂停</p>\n<p>2、可以控制阶段和每个阶段的返回值</p>\n<p>3、可以知道是否执行到结尾</p>\n<h3 id=\"function-g-var-o-1-yield-o-yield-o\"><a href=\"#function-g-var-o-1-yield-o-yield-o\" class=\"headerlink\" title=\"function* g() { var o = 1; yield o++; yield o++\"></a>function* g() { var o = 1; yield o++; yield o++</h3><blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>var gen = g();</p>\n</blockquote>\n<blockquote>\n<p>console.log(gen.next()); // Object {value: 1, done: false} var xxx = g();</p>\n</blockquote>\n<blockquote>\n<p>console.log(gen.next()); // Object {value: 2, done: false} console.log(xxx.next()); // Object<br>{value: 1, done: false} console.log(gen.next()); // Object {value: undefined, done: true}</p>\n</blockquote>\n<p>generator 和异步控制:</p>\n<p>利用 Generator 函数的暂停执行的效果，可以把异步操作写在 yield 语句里面，等到调用 next 方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在<br>yield 语句下面，反正要等到调用 next 方法时再执行。所以， Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。</p>\n<p>async 和异步: 用法:</p>\n<p>async 表示这是一个 async 函数，await 只能用在这个函数里面。await 表示在这里等待异步操作返回结果，再继续执行。</p>\n<p>await 后一般是一个 promise 对象</p>\n<p>示例:async 用于定义一个异步函数，该函数返回一个 Promise。</p>\n<p>如果 async 函数返回的是一个同步的值，这个值将被包装成一个理解 resolve 的</p>\n<p>Promise，等同于 return Promise.resolve(value)。</p>\n<p>await 用于一个异步操作之前，表示要“等待”这个异步操作的返回值。await 也可以用于一个同步的值。</p>\n<h3 id=\"let-timer-async-function-timer-return-new-Promise-resolve-reject-gt-setTimeout-gt\"><a href=\"#let-timer-async-function-timer-return-new-Promise-resolve-reject-gt-setTimeout-gt\" class=\"headerlink\" title=\"let timer = async function timer(){ return new Promise((resolve,reject) =&gt; { setTimeout(() =&gt; {\"></a>let timer = async function timer(){ return new Promise((resolve,reject) =&gt; { setTimeout(() =&gt; {</h3><blockquote>\n<p>resolve(‘500’);</p>\n</blockquote>\n<blockquote>\n<p>},500);</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>timer().then(result =&gt; { console.log(result); //500</p>\n</blockquote>\n<blockquote>\n<p>}).catch(err =&gt; { console.log(err.message);</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>//返回一个同步的值</p>\n</blockquote>\n<blockquote>\n<p>let sayHi = async function sayHi(){ let hi = await ‘hello world’;</p>\n</blockquote>\n<blockquote>\n<p>return hi; //等同于 return Promise.resolve(hi);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>sayHi().then(result =&gt; { console.log(result);</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<ul>\n<li><h3 id=\"事件委托以及冒泡原理\"><a href=\"#事件委托以及冒泡原理\" class=\"headerlink\" title=\"事件委托以及冒泡原理\"></a>事件委托以及冒泡原理</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>事件委托是利用冒泡阶段的运行机制来实现的，就是把一个元素响应事件的函数委托到另一个元素，一般是把一组元素的事件委托到他的父元素上，委托的优点是</p>\n<p>减少内存消耗，节约效率动态绑定事件</p>\n<p>事件冒泡，就是元素自身的事件被触发后，如果父元素有相同的事件，如 onclick 事件，那么元素本身的触发状态就会传递，也就是冒到父元素，父元素的相同事件也会一级一级根据嵌套关系向外触发，直到<br>document/window，冒泡过程结束。</p>\n<ul>\n<li><h3 id=\"写个函数，可以转化下划线命名到驼峰命名\"><a href=\"#写个函数，可以转化下划线命名到驼峰命名\" class=\"headerlink\" title=\"写个函数，可以转化下划线命名到驼峰命名\"></a>写个函数，可以转化下划线命名到驼峰命名</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"public-static-String-UnderlineToHump-String-para-StringBuilder-result-new-StringBuilder\"><a href=\"#public-static-String-UnderlineToHump-String-para-StringBuilder-result-new-StringBuilder\" class=\"headerlink\" title=\"public static String UnderlineToHump(String para){ StringBuilder result=new StringBuilder()\"></a>public static String UnderlineToHump(String para){ StringBuilder result=new StringBuilder()</h3><blockquote>\n<p>String a[]=para.split(“_“); for(String s:a){ if(result.length()==0){<br>result.append(s.toLowerCase());</p>\n</blockquote>\n<blockquote>\n<p>}else{</p>\n</blockquote>\n<blockquote>\n<p>result.append(s.substring(0, 1).toUpperCase()); result.append(s.substring(1).toLowerCase());</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>return result.toString();</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"深浅拷贝的区别和实现\"><a href=\"#深浅拷贝的区别和实现\" class=\"headerlink\" title=\"深浅拷贝的区别和实现\"></a>深浅拷贝的区别和实现</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>数组的浅拷贝：</p>\n<p>如果是数组，我们可以利用数组的一些方法，比如 slice，concat 方法返回一个新数组的特性来实现拷贝，但假如数组嵌套了对象或者数组的话，使用 concat<br>方法克隆并不完整，如果数组元素是基本类型，就会拷贝一份，互不影响，而如果是对象或数<br>组，就会只拷贝对象和数组的引用，这样我们无论在新旧数组进行了修改，两者都会发生变化，我们把这种复制引用的拷贝方法称为浅拷贝，</p>\n<p>深拷贝就是指完全的拷贝一个对象，即使嵌套了对象，两者也互相分离，修改一个对象的属性，不会影响另一个</p>\n<p>如何深拷贝一个数组</p>\n<h3 id=\"1、这里介绍一个技巧，不仅适用于数组还适用于对象！那就是：-var-arr-‘old’-1-true-‘old1’-‘old2’-old-1-var-new-arr-JSON-parse-JSON-stringify-arr-console-log-new-arr\"><a href=\"#1、这里介绍一个技巧，不仅适用于数组还适用于对象！那就是：-var-arr-‘old’-1-true-‘old1’-‘old2’-old-1-var-new-arr-JSON-parse-JSON-stringify-arr-console-log-new-arr\" class=\"headerlink\" title=\"1、这里介绍一个技巧，不仅适用于数组还适用于对象！那就是： var arr = [‘old’, 1, true, [‘old1’, ‘old2’], {old: 1}] var new_arr = JSON.parse( JSON.stringify(arr) ); console.log(new_arr)\"></a>1、这里介绍一个技巧，不仅适用于数组还适用于对象！那就是： var arr = [‘old’, 1, true, [‘old1’, ‘old2’], {old: 1}] var new_arr = JSON.parse( JSON.stringify(arr) ); console.log(new_arr)</h3><p>原理是 JOSN 对象中的 stringify 可以把一个 js 对象序列化为一个 JSON 字符串， parse 可以把 JSON 字符串反序列化为一个 js<br>对象，通过这两个方法，也可以实现对象的深复制。</p>\n<p>但是这个方法不能够拷贝函数浅拷贝的实现：</p>\n<p>以上三个方法 concat,slice ,JSON.stringify<br>都是技巧类，根据实际项目情况选择使用，我们可以思考下如何实现一个对象或数组的浅拷贝，遍历对象，然后把属性和属性值都放在一个新的对象里即可</p>\n<h3 id=\"var-shallowCopy-function-obj\"><a href=\"#var-shallowCopy-function-obj\" class=\"headerlink\" title=\"var shallowCopy = function(obj) {\"></a>var shallowCopy = function(obj) {</h3><blockquote>\n<p>// 只拷贝对象</p>\n</blockquote>\n<blockquote>\n<p>if (typeof obj !== ‘object’) return;</p>\n</blockquote>\n<blockquote>\n<p>// 根据 obj 的类型判断是新建一个数组还是对象var newObj = obj instanceof Array ? [] : {};</p>\n</blockquote>\n<blockquote>\n<p>// 遍历 obj，并且判断是 obj 的属性才拷贝</p>\n</blockquote>\n<blockquote>\n<p>for (var key in obj) {</p>\n</blockquote>\n<blockquote>\n<p>if (obj.hasOwnProperty(key)) { newObj[key] = obj[key];</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>return newObj;</p>\n</blockquote>\n<p>深拷贝的实现</p>\n<p>那如何实现一个深拷贝呢？说起来也好简单，我们在拷贝的时候判断一下属性值的类型，如果是对象，我们递归调用深拷贝函数不就好了~</p>\n<h3 id=\"var-deepCopy-function-obj-1\"><a href=\"#var-deepCopy-function-obj-1\" class=\"headerlink\" title=\"var deepCopy = function(obj) {\"></a>var deepCopy = function(obj) {</h3><blockquote>\n<p>if (typeof obj !== ‘object’) return;</p>\n</blockquote>\n<blockquote>\n<p>var newObj = obj instanceof Array ? [] : {}; for (var key in obj) {</p>\n</blockquote>\n<blockquote>\n<p>if (obj.hasOwnProperty(key)) {</p>\n</blockquote>\n<blockquote>\n<p>newObj[key] = typeof obj[key] === ‘object’ ? deepCopy(obj[key]) : obj[key];</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>return newObj;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"JS-中-string-的-startwith-和-indexof-两种方法的区别\"><a href=\"#JS-中-string-的-startwith-和-indexof-两种方法的区别\" class=\"headerlink\" title=\"JS 中 string 的 startwith 和 indexof 两种方法的区别\"></a>JS 中 string 的 startwith 和 indexof 两种方法的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>JS 中 startwith 函数，其参数有 3 个，stringObj,要搜索的字符串对象，str，搜索的字符串，position，可选，从哪个位置开始搜索，如果以 position<br>开始的字符串以搜索字符串开头，则返回 true，否则返回 false</p>\n<p>Indexof 函数，indexof 函数可返回某个指定字符串在字符串中首次出现的位置。</p>\n<ul>\n<li><h3 id=\"JS-字符串转数字的方法\"><a href=\"#JS-字符串转数字的方法\" class=\"headerlink\" title=\"JS 字符串转数字的方法\"></a>JS 字符串转数字的方法</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>通过函数 parseInt（），可解析一个字符串，并返回一个整数，语法为 parseInt</p>\n<p>（string ,radix） string：被解析的字符串</p>\n<p>radix：表示要解析的数字的基数，默认是十进制，如果 radix&lt;2 或&gt;36,则返回 NaN</p>\n<ul>\n<li><h3 id=\"let-const-var-的区别-，什么是块级作用域，如何用-ES5-的方法实现块级作用域（立即执行函数），ES6-呢\"><a href=\"#let-const-var-的区别-，什么是块级作用域，如何用-ES5-的方法实现块级作用域（立即执行函数），ES6-呢\" class=\"headerlink\" title=\"let const var 的区别 ，什么是块级作用域，如何用 ES5 的方法实现块级作用域（立即执行函数），ES6 呢\"></a>let const var 的区别 ，什么是块级作用域，如何用 ES5 的方法实现块级作用域（立即执行函数），ES6 呢</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>提起这三个最明显的区别是 var 声明的变量是全局或者整个函数块的，而 let,const 声明的变量是块级的变量，var 声明的变量存在变量提升，let,const 不存在，let<br>声明的变量允许重新赋值，const 不允许。</p>\n<ul>\n<li><h3 id=\"ES6-箭头函数的特性\"><a href=\"#ES6-箭头函数的特性\" class=\"headerlink\" title=\"ES6 箭头函数的特性\"></a>ES6 箭头函数的特性</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>ES6 增加了箭头函数，基本语法为let func = value =&gt; value;</p>\n<p>相当于</p>\n<p>let func = function (value) { return value;</p>\n<p>};</p>\n<p>箭头函数与普通函数的区别在于：</p>\n<p>1、箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值，这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this，</p>\n<p>2、箭头函数没有自己的 arguments 对象，但是可以访问外围函数的 arguments 对象3、不能通过 new 关键字调用，同样也没有 new.target 值和原型</p>\n<ul>\n<li><h3 id=\"setTimeout-和-Promise-的执行顺序\"><a href=\"#setTimeout-和-Promise-的执行顺序\" class=\"headerlink\" title=\"setTimeout 和 Promise 的执行顺序\"></a>setTimeout 和 Promise 的执行顺序</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>首先我们来看这样一道题：</p>\n<h3 id=\"setTimeout-function\"><a href=\"#setTimeout-function\" class=\"headerlink\" title=\"setTimeout(function() {\"></a>setTimeout(function() {</h3><blockquote>\n<p>console.log(1)</p>\n</blockquote>\n<blockquote>\n<p>}, 0);</p>\n</blockquote>\n<blockquote>\n<p>new Promise(function(resolve, reject) { console.log(2)</p>\n</blockquote>\n<blockquote>\n<p>for (var i = 0; i &lt; 10000; i++) { if(i === 10) {console.log(10)}</p>\n</blockquote>\n<blockquote>\n<p>i == 9999 &amp;&amp; resolve();</p>\n</blockquote>\n<blockquote>\n<p>} console.log(3)</p>\n</blockquote>\n<blockquote>\n<p>}).then(function() { console.log(4)</p>\n</blockquote>\n<blockquote>\n<p>}) console.log(5);</p>\n</blockquote>\n<p>输出答案为 2 10 3 5 4 1</p>\n<p>要先弄清楚 settimeout（fun,0）何时执行，promise 何时执行，then 何时执行settimeout<br>这种异步操作的回调，只有主线程中没有执行任何同步代码的前提下，才会执行异步回调，而 settimeout（fun,0）表示立刻执行，也就是用来改变任务的执行顺序，要求浏览器尽可能快的进行回调</p>\n<p>promise 何时执行，由上图可知 promise 新建后立即执行，所以 promise 构造函数里代码同步执行的，</p>\n<p>then 方法指向的回调将在当前脚本所有同步任务执行完成后执行，</p>\n<p>那么 then 为什么比 settimeout 执行的早呢，因为 settimeout（fun,0）不是真的立即执行，</p>\n<p>经过测试得出结论：执行顺序为：同步执行的代码-》promise.then-&gt;settimeout</p>\n<ul>\n<li><h3 id=\"有了解过事件模型吗，DOM0-级和-DOM2-级有什么区别，DOM-的分级是什么\"><a href=\"#有了解过事件模型吗，DOM0-级和-DOM2-级有什么区别，DOM-的分级是什么\" class=\"headerlink\" title=\"有了解过事件模型吗，DOM0 级和 DOM2 级有什么区别，DOM 的分级是什么\"></a>有了解过事件模型吗，DOM0 级和 DOM2 级有什么区别，DOM 的分级是什么</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>JSDOM 事件流存在如下三个阶段： 事件捕获阶段</p>\n<p>处于目标阶段事件冒泡阶段</p>\n<p>JSDOM 标准事件流的触发的先后顺序为：先捕获再冒泡，点击 DOM 节点时，事件传播顺序：事件捕获阶段，从上往下传播，然后到达事件目标节点，最后是冒泡阶段，从下往上传播</p>\n<p>DOM 节点添加事件监听方法 addEventListener，中参数 capture 可以指定该监听是添加在事件捕获阶段还是事件冒泡阶段，为 false 是事件冒泡，为 true<br>是事件捕获，并非所有的事件都支持冒泡，比如 focus，blur 等等，我们可以通过 event.bubbles 来判断</p>\n<p>事件模型有三个常用方法：</p>\n<p>event.stopPropagation:阻止捕获和冒泡阶段中，当前事件的进一步传播， event.stopImmediatePropagetion，阻止调用相同事件的其他侦听器，</p>\n<p>event.preventDefault，取消该事件（假如事件是可取消的）而不停止事件的进一步传播，</p>\n<p>event.target：指向触发事件的元素，在事件冒泡过程中这个值不变event.currentTarget = this，时间帮顶的当前元素，只有被点击时目标元素的target 才会等于<br>currentTarget，</p>\n<p>最后，对于执行顺序的问题，如果 DOM<br>节点同时绑定了两个事件监听函数，一个用于捕获，一个用于冒泡，那么两个事件的执行顺序真的是先捕获在冒泡吗，答案是否定的，绑定在被点击元素的事件是按照代码添加顺序执行的，其他函数是先捕获再冒泡</p>\n<ul>\n<li><h3 id=\"平时是怎么调试-JS-的\"><a href=\"#平时是怎么调试-JS-的\" class=\"headerlink\" title=\"平时是怎么调试 JS 的\"></a>平时是怎么调试 JS 的</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>一般用 Chrome 自带的控制台</p>\n<ul>\n<li><h3 id=\"JS-的基本数据类型有哪些，基本数据类型和引用数据类型的区别，NaN-是什么的缩写，JS-的作用域类型，undefined-null-返回的结果是什么，undefined-与-null-的区别在哪，写一个函数判断变量类型\"><a href=\"#JS-的基本数据类型有哪些，基本数据类型和引用数据类型的区别，NaN-是什么的缩写，JS-的作用域类型，undefined-null-返回的结果是什么，undefined-与-null-的区别在哪，写一个函数判断变量类型\" class=\"headerlink\" title=\"JS 的基本数据类型有哪些，基本数据类型和引用数据类型的区别，NaN 是什么的缩写，JS 的作用域类型，undefined==null 返回的结果是什么，undefined 与 null 的区别在哪，写一个函数判断变量类型\"></a>JS 的基本数据类型有哪些，基本数据类型和引用数据类型的区别，NaN 是什么的缩写，JS 的作用域类型，undefined==null 返回的结果是什么，undefined 与 null 的区别在哪，写一个函数判断变量类型</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>JS 的基本数据类型有字符串，数字，布尔，数组，对象，Null，Undefined,基本数据类型是按值访问的，也就是说我们可以操作保存在变量中的实际的值，</p>\n<p>基本数据类型和引用数据类型的区别如下：</p>\n<p>基本数据类型的值是不可变的，任何方法都无法改变一个基本类型的值，当这个变量重新赋值后看起来变量的值是改变了，但是这里变量名只是指向变量的一个指针，所以改变的是指针的指向改变，该变量是不变的，但是引用类型可以改变</p>\n<p>基本数据类型不可以添加属性和方法，但是引用类型可以</p>\n<p>基本数据类型的赋值是简单赋值，如果从一个变量向另一个变量赋值基本类型的值， 会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上，引用数据类型的赋值是对象引用，</p>\n<p>基本数据类型的比较是值的比较，引用类型的比较是引用的比较，比较对象的内存地址是否相同</p>\n<p>基本数据类型是存放在栈区的，引用数据类型同事保存在栈区和堆区</p>\n<p>NaN 是 JS 中的特殊值，表示非数字，NaN 不是数字，但是他的数据类型是数字，它不等于任何值，包括自身，在布尔运算时被当做 false，NaN 与任何数运算得到的结果都是<br>NaN，党员算失败或者运算无法返回正确的数值的就会返回 NaN，一些数学函数的运算结果也会出现 NaN ,</p>\n<p>JS 的作用域类型：</p>\n<p>一般认为的作用域是词法作用域，此外 JS 还提供了一些动态改变作用域的方法，常见的作用域类型有：</p>\n<p>函数作用域，如果在函数内部我们给未定义的一个变量赋值，这个变量会转变成为一个全局变量，</p>\n<p>块作用域：块作用域吧标识符限制在{}中， 改变函数作用域的方法：</p>\n<p>eval（），这个方法接受一个字符串作为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码，</p>\n<p>with 关键字：通常被当做重复引用同一个对象的多个属性的快捷方式</p>\n<p>undefined 与 null：目前 null 和 undefined 基本是同义的，只有一些细微的差别， null 表示没有对象，undefined<br>表示缺少值，就是此处应该有一个值但是还没有定义，因此 undefined==null 返回 false</p>\n<p>此外了解== 和===的区别：</p>\n<p>在做==比较时。不同类型的数据会先转换成一致后在做比较，===中如果类型不一致就直接返回 false，一致的才会比较</p>\n<p>类型判断函数，使用 typeof 即可，首先判断是否为 null，之后用 typeof 哦按段，如果是 object 的话，再用 array.isarray 判断是否为数组，如果是数字的话用<br>isNaN 判断是否是 NaN 即可</p>\n<p>扩展学习：</p>\n<p>JS 采用的是词法作用域，也就是静态作用域，所以函数的作用域在函数定义的时候就决定了，</p>\n<p>看如下例子：</p>\n<h3 id=\"var-value-1-function-foo-console-log-value\"><a href=\"#var-value-1-function-foo-console-log-value\" class=\"headerlink\" title=\"var value = 1; function foo() { console.log(value)\"></a>var value = 1; function foo() { console.log(value)</h3><blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>function bar() { var value = 2; foo();</p>\n</blockquote>\n<blockquote>\n<p>} bar();</p>\n</blockquote>\n<p>假设 JavaScript 采用静态作用域，让我们分析下执行过程：</p>\n<p>执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。</p>\n<p>假设 JavaScript 采用动态作用域，让我们分析下执行过程：</p>\n<p>执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印<br>2。前面我们已经说了，JavaScript 采用的是静态作用域，所以这个例子的结果是 1。</p>\n<ul>\n<li><h3 id=\"setTimeout-fn-100-100-毫秒是如何权衡的\"><a href=\"#setTimeout-fn-100-100-毫秒是如何权衡的\" class=\"headerlink\" title=\"setTimeout(fn,100);100 毫秒是如何权衡的\"></a>setTimeout(fn,100);100 毫秒是如何权衡的</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>setTimeout()函数只是将事件插入了任务列表，必须等到当前代码执行完，主线程才会去执行它指定的回调函数，有可能要等很久，所以没有办法保证回调函数一定会在setTimeout<br>指定的时间内执行，100 毫秒是插入队列的时间+等待的时间</p>\n<ul>\n<li><h3 id=\"JS-的垃圾回收机制\"><a href=\"#JS-的垃圾回收机制\" class=\"headerlink\" title=\"JS 的垃圾回收机制\"></a>JS 的垃圾回收机制</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>GC（garbage collection），GC 执行时，中断代码，停止其他操作，遍历所有对象， 对于不可访问的对象进行回收，在 V8 引擎中使用两种优化方法，</p>\n<p>分代回收，2、增量 GC，目的是通过对象的使用频率，存在时长来区分新生代和老生代对象，多回收新生代区，少回收老生代区，减少每次遍历的时间，从而减少 GC 的耗时回收方法：</p>\n<p>引用计次，当对象被引用的次数为零时进行回收，但是循环引用时，两个对象都至少被引用了一次，因此导致内存泄漏，</p>\n<p>标记清除</p>\n<ul>\n<li><h3 id=\"写一个-newBind-函数，完成-bind-的功能\"><a href=\"#写一个-newBind-函数，完成-bind-的功能\" class=\"headerlink\" title=\"写一个 newBind 函数，完成 bind 的功能\"></a>写一个 newBind 函数，完成 bind 的功能</h3></li>\n</ul>\n<p>参考回答：</p>\n<blockquote>\n<p>bind（）方法，创建一个新函数，当这个新函数被调用时，bind（）的第一个参数将作为它运行时的<br>this，之后的一序列参数将会在传递的实参前传入作为它的参数Function.prototype.bind2 = function (context) {</p>\n</blockquote>\n<h3 id=\"if-typeof-this-“function”\"><a href=\"#if-typeof-this-“function”\" class=\"headerlink\" title=\"if (typeof this !== “function”) {\"></a>if (typeof this !== “function”) {</h3><blockquote>\n<p>throw new Error(“Function.prototype.bind - what is trying to be bound is not callable”);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>var self = this;</p>\n</blockquote>\n<blockquote>\n<p>var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () {};</p>\n</blockquote>\n<blockquote>\n<p>var fbound = function () {</p>\n</blockquote>\n<blockquote>\n<p>self.apply(this instanceof self ? this : context,<br>args.concat(Array.prototype.slice.call(arguments)));</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>fNOP.prototype = this.prototype; fbound.prototype = new fNOP(); return fbound;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"怎么获得对象上的属性：比如说通过-Object-key（）\"><a href=\"#怎么获得对象上的属性：比如说通过-Object-key（）\" class=\"headerlink\" title=\"怎么获得对象上的属性：比如说通过 Object.key（）\"></a>怎么获得对象上的属性：比如说通过 Object.key（）</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>从 ES5 开始，有三种方法可以列出对象的属性</p>\n<p>for（let I in<br>obj）该方法依次访问一个对象及其原型链中所有可枚举的类型object.keys:返回一个数组，包括所有可枚举的属性名称object.getOwnPropertyNames:返回一个数组包含不可枚举的属性</p>\n<ul>\n<li><h3 id=\"简单讲一讲-ES6-的一些新特性\"><a href=\"#简单讲一讲-ES6-的一些新特性\" class=\"headerlink\" title=\"简单讲一讲 ES6 的一些新特性\"></a>简单讲一讲 ES6 的一些新特性</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>ES6 在变量的声明和定义方面增加了 let、const 声明变量，有局部变量的概念，赋值中有比较吸引人的结构赋值，同时 ES6 对字符串、<br>数组、正则、对象、函数等拓展了一些方法，如字符串方面的模板字符串、函数方面的默认参数、对象方面属性的简洁表达方式，ES6 也 引入了新的数据类型 symbol，新的数据结构 set 和<br>map,symbol 可以通过 typeof 检测出来，为解决异步回调问题，引入了 promise 和 generator，还有最为吸引人了实现 Class 和模块，通过 Class<br>可以更好的面向对象编程，使用模块加载方便模块化编程，当然考虑到 浏览器兼容性，我们在实际开发中需要使用 babel 进行编译</p>\n<p>重要的特性：</p>\n<p>块级作用域：ES5 只有全局作用域和函数作用域，块级作用域的好处是不再需要立即执行的函数表达式，循环体中的闭包不再有问题</p>\n<p>rest 参数：用于获取函数的多余参数，这样就不需要使用 arguments 对象了， promise:一种异步编程的解决方案，比传统的解决方案回调函数和事件更合理强大<br>模块化：其模块功能主要有两个命令构成，export 和 import，export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能</p>\n<ul>\n<li><h3 id=\"call-和-apply-是用来做什么？\"><a href=\"#call-和-apply-是用来做什么？\" class=\"headerlink\" title=\"call 和 apply 是用来做什么？\"></a>call 和 apply 是用来做什么？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Call 和 apply 的作用是一模一样的，只是传参的形式有区别而已1、改变 this 的指向</p>\n<p>2、借用别的对象的方法，</p>\n<p>3、调用函数，因为 apply，call 方法会使函数立即执行</p>\n<ul>\n<li><h3 id=\"了解事件代理吗，这样做有什么好处\"><a href=\"#了解事件代理吗，这样做有什么好处\" class=\"headerlink\" title=\"了解事件代理吗，这样做有什么好处\"></a>了解事件代理吗，这样做有什么好处</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>事件代理/事件委托：利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的事件，</p>\n<p>简而言之：事件代理就是说我们将事件添加到本来要添加的事件的父节点，将事件委托给父节点来触发处理函数，这通常会使用在大量的同级元素需要添加同一类事件的时候，比如一个动态的非常多的列表，需要为每个列表项都添加点击事件，这时就可以使用事件代理，通过判断<br>e.target.nodeName 来判断发生的具体元素，这样做的好处是减少事件绑定，同事动态的 DOM 结构任然可以监听，事件代理发生在冒泡阶段</p>\n<ul>\n<li><h3 id=\"如何写一个继承？\"><a href=\"#如何写一个继承？\" class=\"headerlink\" title=\"如何写一个继承？\"></a>如何写一个继承？</h3></li>\n</ul>\n<p>参考回答： 原型链继承</p>\n<p>核心： 将父类的实例作为子类的原型特点：</p>\n<p>非常纯粹的继承关系，实例是子类的实例，也是父类的实例父类新增原型方法/原型属性，子类都能访问到</p>\n<p>简单，易于实现缺点：</p>\n<p>要想为子类新增属性和方法，不能放到构造器中无法实现多继承</p>\n<p>来自原型对象的所有属性被所有实例共享 创建子类实例时，无法向父类构造函数传参</p>\n<p>构造继承</p>\n<p>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p>\n<p>特点：</p>\n<p>解决了子类实例共享父类引用属性的问题创建子类实例时，可以向父类传递参数 可以实现多继承（call 多个父类对象） 缺点：</p>\n<p>实例并不是父类的实例，只是子类的实例</p>\n<p>只能继承父类的实例属性和方法，不能继承原型属性/方法</p>\n<p>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</p>\n<p>实例继承</p>\n<p>核心：为父类实例添加新特性，作为子类实例返回特点：</p>\n<p>不限制调用方式，不管是 new 子类()还是子类(),返回的对象具有相同的效果</p>\n<p>缺点：</p>\n<p>实例是父类的实例，不是子类的实例不支持多继承</p>\n<p>拷贝继承特点：</p>\n<p>支持多继承缺点：</p>\n<p>效率较低，内存占用高（因为要拷贝父类的属性）</p>\n<p>组合继承</p>\n<p>核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<p>特点：</p>\n<p>可以继承实例属性/方法，也可以继承原型属性/方法既是子类的实例，也是父类的实例</p>\n<p>不存在引用属性共享问题可传参</p>\n<p>函数可复用</p>\n<p>寄生组合继承</p>\n<p>核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<p>参考 <a href=\"https://www.cnblogs.com/humin/p/4556820.html\"><em>https://www.cnblogs.com/humin/p/4556820.html</em></a></p>\n<ul>\n<li><h3 id=\"给出以下代码，输出的结果是什么？原因？-for-var-i-0-i-lt-5-i\"><a href=\"#给出以下代码，输出的结果是什么？原因？-for-var-i-0-i-lt-5-i\" class=\"headerlink\" title=\"给出以下代码，输出的结果是什么？原因？ for(var i=0;i&lt;5;i++)\"></a>给出以下代码，输出的结果是什么？原因？ for(var i=0;i&lt;5;i++)</h3></li>\n</ul>\n<blockquote>\n<p>{ setTimeout(function(){ console.log(i); },1000); } console.log(i)</p>\n</blockquote>\n<p>参考回答：</p>\n<p>在一秒后输出 5 个 5</p>\n<p>每次 for 循环的时候 setTimeout 都会执行，但是里面的 function 则不会执行被放入任务队列，因此放了 5 次；for 循环的 5 次执行完之后不到 1000 毫秒；1000<br>毫秒后全部执行任务队列中的函数，所以就是输出 5 个 5。</p>\n<ul>\n<li><h3 id=\"给两个构造函数-A-和-B，如何实现-A-继承-B？\"><a href=\"#给两个构造函数-A-和-B，如何实现-A-继承-B？\" class=\"headerlink\" title=\"给两个构造函数 A 和 B，如何实现 A 继承 B？\"></a>给两个构造函数 A 和 B，如何实现 A 继承 B？</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"function-A-…-A-prototype\"><a href=\"#function-A-…-A-prototype\" class=\"headerlink\" title=\"function A(…) {} A.prototype\"></a>function A(…) {} A.prototype</h3><blockquote>\n<p>function B(…) {} B.prototype… A.prototype = Object.create(B.prototype);</p>\n</blockquote>\n<blockquote>\n<p>// 再在A 的构造函数里 new B(props); for(var i = 0; i &lt; lis.length; i++) {</p>\n</blockquote>\n<blockquote>\n<p>lis[i].addEventListener(‘click’, function(e) { alert(i);</p>\n</blockquote>\n<blockquote>\n<p>}, false)</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"问能不能正常打印索引\"><a href=\"#问能不能正常打印索引\" class=\"headerlink\" title=\"问能不能正常打印索引\"></a>问能不能正常打印索引</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>在 click 的时候，已经变成 length 了</p>\n<ul>\n<li><h3 id=\"如果已经有三个-promise，A、B-和-C，想串行执行，该怎么写？\"><a href=\"#如果已经有三个-promise，A、B-和-C，想串行执行，该怎么写？\" class=\"headerlink\" title=\"如果已经有三个 promise，A、B 和 C，想串行执行，该怎么写？\"></a>如果已经有三个 promise，A、B 和 C，想串行执行，该怎么写？</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"promise-A-then-B-then-C-catch-…\"><a href=\"#promise-A-then-B-then-C-catch-…\" class=\"headerlink\" title=\"// promise A.then(B).then(C).catch(…)\"></a>// promise A.then(B).then(C).catch(…)</h3><blockquote>\n<p>// async/await (async ()=&gt;{ await a(); await b(); await c();</p>\n</blockquote>\n<blockquote>\n<p>})()</p>\n</blockquote>\n<ul>\n<li><h3 id=\"知道-private-和-public-吗\"><a href=\"#知道-private-和-public-吗\" class=\"headerlink\" title=\"知道 private 和 public 吗\"></a>知道 private 和 public 吗</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>public：public 表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用</p>\n<p>private：private 表示私有，私有的意思就是除了 class 自己之外，任何人都不可以直接使用</p>\n<ul>\n<li><h3 id=\"基础的-js\"><a href=\"#基础的-js\" class=\"headerlink\" title=\"基础的 js\"></a>基础的 js</h3></li>\n</ul>\n<p>参 考 回 答 ： Function.prototype.a = 1; Object.prototype.b = 2; function A() {}</p>\n<p>var a = new A();</p>\n<p>console.log(a.a, a.b); // undefined, 2 console.log(A.a, A.b); // 1, 2</p>\n<ul>\n<li><h3 id=\"async-和-await-具体该怎么用？\"><a href=\"#async-和-await-具体该怎么用？\" class=\"headerlink\" title=\"async 和 await 具体该怎么用？\"></a>async 和 await 具体该怎么用？</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"async-gt-await-new-promise\"><a href=\"#async-gt-await-new-promise\" class=\"headerlink\" title=\"(async () = &gt; { await new promise()\"></a>(async () = &gt; { await new promise()</h3><blockquote>\n<p>})()</p>\n</blockquote>\n<ul>\n<li><h3 id=\"知道哪些-ES6，ES7-的语法\"><a href=\"#知道哪些-ES6，ES7-的语法\" class=\"headerlink\" title=\"知道哪些 ES6，ES7 的语法\"></a>知道哪些 ES6，ES7 的语法</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>promise，await/async，let、const、块级作用域、箭头函数</p>\n<ul>\n<li><h3 id=\"promise-和-await-async-的关系\"><a href=\"#promise-和-await-async-的关系\" class=\"headerlink\" title=\"promise 和 await/async 的关系\"></a>promise 和 await/async 的关系</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>都是异步编程的解决方案</p>\n<ul>\n<li><h3 id=\"JS-的数据类型\"><a href=\"#JS-的数据类型\" class=\"headerlink\" title=\"JS 的数据类型\"></a>JS 的数据类型</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>字符串，数字，布尔，数组，null，Undefined，symbol，对象。</p>\n<ul>\n<li><h3 id=\"JS-加载过程阻塞，解决方法\"><a href=\"#JS-加载过程阻塞，解决方法\" class=\"headerlink\" title=\"JS 加载过程阻塞，解决方法\"></a>JS 加载过程阻塞，解决方法</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>指定 script 标签的 async 属性。</p>\n<p>如果 async=”async”，脚本相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本将被执行）</p>\n<p>如果不使用 async 且 defer=”defer”：脚本将在页面完成解析时执行</p>\n<ul>\n<li><h3 id=\"JS-对象类型，基本对象类型以及引用对象类型的区别\"><a href=\"#JS-对象类型，基本对象类型以及引用对象类型的区别\" class=\"headerlink\" title=\"JS 对象类型，基本对象类型以及引用对象类型的区别\"></a>JS 对象类型，基本对象类型以及引用对象类型的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>分为基本对象类型和引用对象类型</p>\n<p>基本数据类型：按值访问，可操作保存在变量中的实际的值。基本类型值指的是简单的数据段。基本数据类型有这六种:undefined、null、string、number、boolean、symbol。</p>\n<p>引用类型：当复制保存着对象的某个变量时，操作的是对象的引用，但在为对象添加属性时，操作的是实际的对象。引用类型值指那些可能为多个值构成的对象。</p>\n<p>引用类型有这几种：Object、Array、RegExp、Date、Function、特殊的基本包装类型</p>\n<p>(String、Number、Boolean)以及单体内置对象(Global、Math)。</p>\n<ul>\n<li><h3 id=\"JavaScript-中的轮播实现原理？假如一个页面上有两个轮播，你会怎么实现？\"><a href=\"#JavaScript-中的轮播实现原理？假如一个页面上有两个轮播，你会怎么实现？\" class=\"headerlink\" title=\"JavaScript 中的轮播实现原理？假如一个页面上有两个轮播，你会怎么实现？\"></a>JavaScript 中的轮播实现原理？假如一个页面上有两个轮播，你会怎么实现？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>图片轮播的原理就是图片排成一行，然后准备一个只有一张图片大小的容器，对这个容器设置超出部分隐藏，在控制定时器来让这些图片整体左移或右移，这样呈现出来的效果就是图片在轮播了。</p>\n<p>如果有两个轮播，可封装一个轮播组件，供两处调用</p>\n<ul>\n<li><h3 id=\"怎么实现一个计算一年中有多少周？\"><a href=\"#怎么实现一个计算一年中有多少周？\" class=\"headerlink\" title=\"怎么实现一个计算一年中有多少周？\"></a>怎么实现一个计算一年中有多少周？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>首先你得知道是不是闰年，也就是一年是 365 还是 366.</p>\n<p>其次你得知道当年 1 月 1 号是周几。假如是周五，一年 365 天把 1 号 2 号 3 号减去， 也就是把第一个不到一周的天数减去等于 362</p>\n<p>还得知道最后一天是周几，加入是周五，需要把周一到周五减去，也就是 362-5=357.</p>\n<p>正常情况 357 这个数计算出来是 7 的倍数。357/7=51 。即为周数。</p>\n<ul>\n<li><h3 id=\"面向对象的继承方式\"><a href=\"#面向对象的继承方式\" class=\"headerlink\" title=\"面向对象的继承方式\"></a>面向对象的继承方式</h3></li>\n</ul>\n<p>参考回答： 原型链继承</p>\n<p>核心： 将父类的实例作为子类的原型特点：</p>\n<p>非常纯粹的继承关系，实例是子类的实例，也是父类的实例父类新增原型方法/原型属性，子类都能访问到</p>\n<p>简单，易于实现缺点：</p>\n<p>要想为子类新增属性和方法，不能放到构造器中无法实现多继承</p>\n<p>来自原型对象的所有属性被所有实例共享 创建子类实例时，无法向父类构造函数传参</p>\n<p>构造继承</p>\n<p>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p>\n<p>特点：</p>\n<p>解决了子类实例共享父类引用属性的问题创建子类实例时，可以向父类传递参数 可以实现多继承（call 多个父类对象） 缺点：</p>\n<p>实例并不是父类的实例，只是子类的实例</p>\n<p>只能继承父类的实例属性和方法，不能继承原型属性/方法</p>\n<p>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</p>\n<p>实例继承</p>\n<p>核心：为父类实例添加新特性，作为子类实例返回特点：</p>\n<p>不限制调用方式，不管是 new 子类()还是子类(),返回的对象具有相同的效果</p>\n<p>缺点：</p>\n<p>实例是父类的实例，不是子类的实例不支持多继承</p>\n<p>拷贝继承特点：</p>\n<p>支持多继承</p>\n<p>缺点：</p>\n<p>效率较低，内存占用高（因为要拷贝父类的属性）</p>\n<p>组合继承</p>\n<p>核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<p>特点：</p>\n<p>可以继承实例属性/方法，也可以继承原型属性/方法既是子类的实例，也是父类的实例</p>\n<p>不存在引用属性共享问题可传参</p>\n<p>函数可复用</p>\n<p>寄生组合继承</p>\n<p>核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<p>参考 <a href=\"https://www.cnblogs.com/humin/p/4556820.html\"><em>https://www.cnblogs.com/humin/p/4556820.html</em></a></p>\n<ul>\n<li><h3 id=\"JS-的数据类型-1\"><a href=\"#JS-的数据类型-1\" class=\"headerlink\" title=\"JS 的数据类型\"></a>JS 的数据类型</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>字符串，数字，布尔，数组，null，Undefined，symbol，对象。</p>\n<ul>\n<li><h3 id=\"引用类型常见的对象\"><a href=\"#引用类型常见的对象\" class=\"headerlink\" title=\"引用类型常见的对象\"></a>引用类型常见的对象</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Object、Array、RegExp、Date、Function、特殊的基本包装类型(String、Number、Boolean)以及单体内置对象(Global、Math)等</p>\n<ul>\n<li><h3 id=\"es6-的常用\"><a href=\"#es6-的常用\" class=\"headerlink\" title=\"es6 的常用\"></a>es6 的常用</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>promise，await/async，let、const、块级作用域、箭头函数</p>\n<ul>\n<li><h3 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过 class 关键字，可以定义类。</p>\n<ul>\n<li><h3 id=\"口述数组去重\"><a href=\"#口述数组去重\" class=\"headerlink\" title=\"口述数组去重\"></a>口述数组去重</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>法一：indexOf 循环去重</p>\n<p>法二：ES6 Set 去重；Array.from(new Set(array))</p>\n<p>法三：Object 键值对去重；把数组的值存成 Object 的 key 值，比如Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，<br>就说明该值是重复的。</p>\n<ul>\n<li><h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3></li>\n</ul>\n<p>参考回答： 原型链继承</p>\n<p>核心： 将父类的实例作为子类的原型特点：</p>\n<p>非常纯粹的继承关系，实例是子类的实例，也是父类的实例父类新增原型方法/原型属性，子类都能访问到</p>\n<p>简单，易于实现缺点：</p>\n<p>要想为子类新增属性和方法，不能放到构造器中无法实现多继承</p>\n<p>来自原型对象的所有属性被所有实例共享 创建子类实例时，无法向父类构造函数传参</p>\n<p>构造继承</p>\n<p>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p>\n<p>特点：</p>\n<p>解决了子类实例共享父类引用属性的问题创建子类实例时，可以向父类传递参数 可以实现多继承（call 多个父类对象） 缺点：</p>\n<p>实例并不是父类的实例，只是子类的实例</p>\n<p>只能继承父类的实例属性和方法，不能继承原型属性/方法</p>\n<p>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</p>\n<p>实例继承</p>\n<p>核心：为父类实例添加新特性，作为子类实例返回特点：</p>\n<p>不限制调用方式，不管是 new 子类()还是子类(),返回的对象具有相同的效果</p>\n<p>缺点：</p>\n<p>实例是父类的实例，不是子类的实例不支持多继承</p>\n<p>拷贝继承特点：</p>\n<p>支持多继承缺点：</p>\n<p>效率较低，内存占用高（因为要拷贝父类的属性）</p>\n<p>组合继承</p>\n<p>核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<p>特点：</p>\n<p>可以继承实例属性/方法，也可以继承原型属性/方法既是子类的实例，也是父类的实例</p>\n<p>不存在引用属性共享问题可传参</p>\n<p>函数可复用</p>\n<p>寄生组合继承</p>\n<p>核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<p>参考 <a href=\"https://www.cnblogs.com/humin/p/4556820.html\"><em>https://www.cnblogs.com/humin/p/4556820.html</em></a></p>\n<ul>\n<li><h3 id=\"call-和-apply-的区别\"><a href=\"#call-和-apply-的区别\" class=\"headerlink\" title=\"call 和 apply 的区别\"></a>call 和 apply 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即 A 对象应用B 对象的方法。</p>\n<p>call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即 A 对象调用B 对象的方法。</p>\n<ul>\n<li><h3 id=\"es6-的常用特性\"><a href=\"#es6-的常用特性\" class=\"headerlink\" title=\"es6 的常用特性\"></a>es6 的常用特性</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>promise，await/async，let、const、块级作用域、箭头函数</p>\n<ul>\n<li><h3 id=\"箭头函数和-function-有什么区别\"><a href=\"#箭头函数和-function-有什么区别\" class=\"headerlink\" title=\"箭头函数和 function 有什么区别\"></a>箭头函数和 function 有什么区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>箭头函数根本就没有绑定自己的 this，在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用</p>\n<ul>\n<li><h3 id=\"new-操作符原理\"><a href=\"#new-操作符原理\" class=\"headerlink\" title=\"new 操作符原理\"></a>new 操作符原理</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>创建一个类的实例：创建一个空对象 obj，然后把这个空对象的 proto 设置为构造函数的 prototype。</p>\n</li>\n<li><p>初始化实例：构造函数被传入参数并调用，关键字 this 被设定指向该实例 obj。</p>\n</li>\n<li><p>返回实例 obj。</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"bind-apply-call\"><a href=\"#bind-apply-call\" class=\"headerlink\" title=\"bind,apply,call\"></a>bind,apply,call</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即 A 对象应用B 对象的方法。</p>\n<p>call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即 A 对象调用B 对象的方法。</p>\n<p>bind 除了返回是函数以外，它的参数和 call 一样。</p>\n<ul>\n<li><h3 id=\"bind-和-apply-的区别\"><a href=\"#bind-和-apply-的区别\" class=\"headerlink\" title=\"bind 和 apply 的区别\"></a>bind 和 apply 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>返回不同：bind 返回是函数</p>\n<p>参数不同：apply(A, arguments)，bind(A, args1,args2)</p>\n<ul>\n<li><h3 id=\"数组的去重\"><a href=\"#数组的去重\" class=\"headerlink\" title=\"数组的去重\"></a>数组的去重</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>法一：indexOf 循环去重</p>\n<p>法二：ES6 Set 去重；Array.from(new Set(array))</p>\n<p>法三：Object 键值对去重；把数组的值存成 Object 的 key 值，比如Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，<br>就说明该值是重复的。</p>\n<ul>\n<li><h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li>什么是闭包：</li>\n</ol>\n<p>闭包是指有权访问另外一个函数作用域中的变量的函数。</p>\n<p>闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。当在一个函数内定义另外一个函数就会产生闭包。</p>\n<ol start=\"2\">\n<li>为什么要用：</li>\n</ol>\n<p>匿名自执行函数：我们知道所有的变量，如果不加上 var 关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可</p>\n<p>能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用 var<br>关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，可以用闭包。 结果缓存：我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对<br>象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。</p>\n<ul>\n<li><h3 id=\"promise-实现\"><a href=\"#promise-实现\" class=\"headerlink\" title=\"promise 实现\"></a>promise 实现</h3></li>\n</ul>\n<p>参 考 回 答 ： Promise 实现如下</p>\n<h3 id=\"function-Promise-fn-var-state-‘pending’-value-null-callbacks\"><a href=\"#function-Promise-fn-var-state-‘pending’-value-null-callbacks\" class=\"headerlink\" title=\"function Promise(fn) { var state = ‘pending’, value = null, callbacks = []\"></a>function Promise(fn) { var state = ‘pending’, value = null, callbacks = []</h3><blockquote>\n<p>this.then = function (onFulfilled, onRejected) { return new Promise(function (resolve, reject) {<br>handle({</p>\n</blockquote>\n<blockquote>\n<p>onFulfilled: onFulfilled || null, onRejected: onRejected || null, resolve: resolve,</p>\n</blockquote>\n<blockquote>\n<p>reject: reject</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>};</p>\n</blockquote>\n<blockquote>\n<p>function handle(callback) { if (state === ‘pending’) { callbacks.push(callback); return;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>var cb = state === ‘fulfilled’ ? callback.onFulfilled : callback.onRejected,</p>\n</blockquote>\n<blockquote>\n<p>ret;</p>\n</blockquote>\n<blockquote>\n<p>if (cb === null) {</p>\n</blockquote>\n<blockquote>\n<p>cb = state === ‘fulfilled’ ? callback.resolve : callback.reject; cb(value);</p>\n</blockquote>\n<blockquote>\n<p>return;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>ret = cb(value); callback.resolve(ret);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>function resolve(newValue) {</p>\n</blockquote>\n<blockquote>\n<p>if (newValue &amp;&amp; (typeof newValue === ‘object’ || typeof newValue === ‘function’)) {</p>\n</blockquote>\n<blockquote>\n<p>var then = newValue.then;</p>\n</blockquote>\n<blockquote>\n<p>if (typeof then === ‘function’) { then.call(newValue, resolve, reject); return;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>state = ‘fulfilled’; value = newValue; execute();</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>function reject(reason) { state = ‘rejected’;</p>\n</blockquote>\n<blockquote>\n<p>value = reason; execute();</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>function execute() { setTimeout(function () { callbacks.forEach(function (callback) {<br>handle(callback);</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>}, 0);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>fn(resolve, reject);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"assign-的深拷贝\"><a href=\"#assign-的深拷贝\" class=\"headerlink\" title=\"assign 的深拷贝\"></a>assign 的深拷贝</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"function-clone-obj-var-copy-1\"><a href=\"#function-clone-obj-var-copy-1\" class=\"headerlink\" title=\"function clone( obj ) { var copy\"></a>function clone( obj ) { var copy</h3><blockquote>\n<p>switch( typeof obj ) { case “undefined”: break;</p>\n</blockquote>\n<blockquote>\n<p>case “number”: copy = obj - 0; break;</p>\n</blockquote>\n<blockquote>\n<p>case “string”: copy = obj + “”; break;</p>\n</blockquote>\n<blockquote>\n<p>case “boolean”:</p>\n</blockquote>\n<blockquote>\n<p>copy = obj; break;</p>\n</blockquote>\n<p>case “object”: //object 分为两种情况 对象（Object）和数组（Array）</p>\n<ul>\n<li><h3 id=\"说-promise，没有-promise-怎么办\"><a href=\"#说-promise，没有-promise-怎么办\" class=\"headerlink\" title=\"说 promise，没有 promise 怎么办\"></a>说 promise，没有 promise 怎么办</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>没有 promise，可以用回调函数代替</p>\n<ul>\n<li><h3 id=\"事件委托\"><a href=\"#事件委托\" class=\"headerlink\" title=\"事件委托\"></a>事件委托</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>把一个元素响应事件（click、keydown. ）的函数委托到另一个元素；</p>\n<p>优点：减少内存消耗、动态绑定事件。</p>\n<ul>\n<li><h3 id=\"箭头函数和-function-的区别\"><a href=\"#箭头函数和-function-的区别\" class=\"headerlink\" title=\"箭头函数和 function 的区别\"></a>箭头函数和 function 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>箭头函数根本就没有绑定自己的 this，在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用</p>\n<ul>\n<li><h3 id=\"arguments\"><a href=\"#arguments\" class=\"headerlink\" title=\"arguments\"></a>arguments</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>arguments 是类数组对象，有 length 属性，不能调用数组方法可用 Array.from()转换</p>\n<ul>\n<li><h3 id=\"箭头函数获取-arguments\"><a href=\"#箭头函数获取-arguments\" class=\"headerlink\" title=\"箭头函数获取 arguments\"></a>箭头函数获取 arguments</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>可用…rest 参数获取</p>\n<ul>\n<li><h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Promise 对象是 CommonJS 工作组提出的一种规范，目的是为异步编程提供统一接口。每一个异步任务返回一个 Promise 对象，该对象有一个 then 方法，允许指定回调函数。</p>\n<p>f1().then(f2);</p>\n<p>一个 promise 可能有三种状态：等待（pending）、已完成（resolved，又称</p>\n<p>fulfilled）、已拒绝（rejected）。</p>\n<p>promise 必须实现 then 方法（可以说，then 就是 promise 的核心），而且 then 必须返回一个 promise，同一个 promise 的 then<br>可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致。</p>\n<p>then 方法接受两个参数，第一个参数是成功时的回调，在 promise 由“等待”态转换到“完成”态时调用，另一个是失败时的回调，在 promise<br>由“等待”态转换到“拒绝”态时调用。同时，then 可以接受另一个 promise 传入，也接受一个“类then”的对象或方法，即 thenable 对象。</p>\n<ul>\n<li><h3 id=\"事件代理\"><a href=\"#事件代理\" class=\"headerlink\" title=\"事件代理\"></a>事件代理</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>事件代理是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a; 比如给最里面的a 加一个 click<br>点击事件，那么这个事件就会一层一层的往外执行， 执行顺序 a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的 div 加点击事件，那么里面的 ul，li，a<br>做点击事件的时候，都会冒泡到最外层的 div 上，所以都会触发， 这就是事件代理，代理它们父级代为执行事件。</p>\n<ul>\n<li><h3 id=\"Eventloop\"><a href=\"#Eventloop\" class=\"headerlink\" title=\"Eventloop\"></a>Eventloop</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>任务队列中，在每一次事件循环中，macrotask 只会提取一个执行，而 microtask 会一直提取，直到 microsoft 队列为空为止。</p>\n<p>也就是说如果某个 microtask 任务被推入到执行中，那么当主线程任务执行完成后， 会循环调用该队列任务中的下一个任务来执行，直到该任务队列到最后一个任务为 止。而事件循环每次只会入栈一个<br>macrotask,主线程执行完成该任务后又会检查microtasks 队列并完成里面的所有任务后再执行macrotask 的任务。</p>\n<p>macrotasks: setTimeout, setInterval, setImmediate, I/O, UI rendering microtasks: process.nextTick,<br>Promise, MutationObserver</p>\n<h1 id=\"2-前端核心\"><a href=\"#2-前端核心\" class=\"headerlink\" title=\"2 | 前端核心\"></a>2 | 前端核心</h1><ol>\n<li><h2 id=\"服务端编程\"><a href=\"#服务端编程\" class=\"headerlink\" title=\"| 服务端编程\"></a>| 服务端编程</h2></li>\n</ol>\n<ul>\n<li><h3 id=\"JSONP-的缺点\"><a href=\"#JSONP-的缺点\" class=\"headerlink\" title=\"JSONP 的缺点\"></a>JSONP 的缺点</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。</p>\n<ul>\n<li><h3 id=\"跨域（jsonp，ajax）\"><a href=\"#跨域（jsonp，ajax）\" class=\"headerlink\" title=\"跨域（jsonp，ajax）\"></a>跨域（jsonp，ajax）</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>JSONP：ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数</p>\n<p>据，而是返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。</p>\n<ul>\n<li><h3 id=\"如何实现跨域\"><a href=\"#如何实现跨域\" class=\"headerlink\" title=\"如何实现跨域\"></a>如何实现跨域</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>JSONP：通过动态创建 script，再请求一个带参网址实现跨域通信。document.domain</p>\n<ul>\n<li>iframe 跨域：两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域。</li>\n</ul>\n<p>location.hash + iframe 跨域：a 欲与b 跨域相互通信，通过中间页c 来实现。 三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 js<br>访问来通信。</p>\n<p>window.name + iframe 跨域：通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。</p>\n<p>postMessage 跨域：可以跨域操作的 window 属性之一。</p>\n<p>CORS：服务端设置 Access-Control-Allow-Origin 即可，前端无须设置，若要带</p>\n<p>cookie 请求，前后端都需要设置。</p>\n<p>代理跨域：起一个代理服务器，实现数据的转发</p>\n<ul>\n<li><h3 id=\"dom-是什么，你的理解？\"><a href=\"#dom-是什么，你的理解？\" class=\"headerlink\" title=\"dom 是什么，你的理解？\"></a>dom 是什么，你的理解？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>文档对象模型（Document Object Model，简称 DOM），是 W3C<br>组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为 DOM。</p>\n<ul>\n<li><h3 id=\"关于-dom-的-api-有什么\"><a href=\"#关于-dom-的-api-有什么\" class=\"headerlink\" title=\"关于 dom 的 api 有什么\"></a>关于 dom 的 api 有什么</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>节点创建型 api，页面修改型 API，节点查询型 API，节点关系型 api，元素属性型api，元素样式型 api 等</p>\n<ol start=\"2\">\n<li><h2 id=\"Ajax\"><a href=\"#Ajax\" class=\"headerlink\" title=\"| Ajax\"></a>| Ajax</h2></li>\n</ol>\n<ul>\n<li><h3 id=\"ajax-返回的状态\"><a href=\"#ajax-返回的状态\" class=\"headerlink\" title=\"ajax 返回的状态\"></a>ajax 返回的状态</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>0 － （未初始化）还没有调用 send()方法</p>\n<p>1 － （载入）已调用 send()方法，正在发送请求</p>\n<p>2 － （载入完成）send()方法执行完成，已经接收到全部响应内容</p>\n<p>3 － （交互）正在解析响应内容</p>\n<p>4 － （完成）响应内容解析完成，可以在客户端调用了</p>\n<ul>\n<li><h3 id=\"实现一个-Ajax\"><a href=\"#实现一个-Ajax\" class=\"headerlink\" title=\"实现一个 Ajax\"></a>实现一个 Ajax</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>AJAX 创建异步对象 XMLHttpRequest</p>\n<p>操作 XMLHttpRequest 对象</p>\n<ol>\n<li><p>设置请求参数（请求方式，请求页面的相对路径，是否异步）</p>\n</li>\n<li><p>设置回调函数，一个处理服务器响应的函数，使用 onreadystatechange ，类似函数指针</p>\n</li>\n<li><p>获取异步对象的 readyState 属性：该属性存有服务器响应的状态信息。每当readyState 改变时，onreadystatechange 函数就会被执行。</p>\n</li>\n<li><p>判断响应报文的状态，若为 200 说明服务器正常运行并返回响应数据。</p>\n</li>\n<li><p>读取响应数据，可以通过 responseText 属性来取回由服务器返回的数据。</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"如何实现-ajax-请求，假如我有多个请求，我需要让这些-ajax-请求按照某种顺序一次执行，有什么办法呢？如何处理-ajax-跨域\"><a href=\"#如何实现-ajax-请求，假如我有多个请求，我需要让这些-ajax-请求按照某种顺序一次执行，有什么办法呢？如何处理-ajax-跨域\" class=\"headerlink\" title=\"如何实现 ajax 请求，假如我有多个请求，我需要让这些 ajax 请求按照某种顺序一次执行，有什么办法呢？如何处理 ajax 跨域\"></a>如何实现 ajax 请求，假如我有多个请求，我需要让这些 ajax 请求按照某种顺序一次执行，有什么办法呢？如何处理 ajax 跨域</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>通过实例化一个 XMLHttpRequest 对象得到一个实例，调用实例的 open 方法为这次ajax 请求设定相应的 http 方法，相应的地址和是否异步，以异步为例，调用 send<br>方法，这个方法可以设定需要发送的报文主体，然后通过监听 readystatechange 事件， 通过这个实例 的 readyState 属性来判断这个 ajax 请求状态，其中分为 0，1，2，3，<br>4 这四种状态（0 未初始化，1 载入/正在发送请求 2 载入完成/数据接收，3 交互/解析数据，4 接收数据完成），当状态为 4 的时候也就是接受数据完成的时候，这时候可以通过实例的 status<br>属性判断这个请求是否成功</p>\n<h3 id=\"var-xhr-new-XMLHttpRequest-xhr-open-‘get’-‘aabb-php’-true-xhr-send-null-xhr-onreadystatechange-function-if-xhr-readyState-4-if-xhr-status-200-console-log-xhr-responseText\"><a href=\"#var-xhr-new-XMLHttpRequest-xhr-open-‘get’-‘aabb-php’-true-xhr-send-null-xhr-onreadystatechange-function-if-xhr-readyState-4-if-xhr-status-200-console-log-xhr-responseText\" class=\"headerlink\" title=\"var xhr = new XMLHttpRequest(); xhr.open(‘get’, ‘aabb.php’, true); xhr.send(null); xhr.onreadystatechange = function() { if(xhr.readyState==4) { if(xhr.status==200) { console.log(xhr.responseText)\"></a>var xhr = new XMLHttpRequest(); xhr.open(‘get’, ‘aabb.php’, true); xhr.send(null); xhr.onreadystatechange = function() { if(xhr.readyState==4) { if(xhr.status==200) { console.log(xhr.responseText)</h3><blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<p>使 ajax 请求按照队列顺序执行，通过调用递归函数：</p>\n<p>//按顺序执行多个 ajax 命令，因为数量不定，所以采用递归</p>\n<h3 id=\"function-send-action-arg2\"><a href=\"#function-send-action-arg2\" class=\"headerlink\" title=\"function send(action, arg2) {\"></a>function send(action, arg2) {</h3><blockquote>\n<p>//将多个命令按顺序封装成数组对象，递归执行</p>\n</blockquote>\n<blockquote>\n<p>//利用了 deferred 对象控制回调函数的特点</p>\n</blockquote>\n<blockquote>\n<p>$.when(send_action(action[0], arg2))</p>\n</blockquote>\n<blockquote>\n<p>.done(function () {</p>\n</blockquote>\n<blockquote>\n<p>//前一个 ajax 回调函数完毕之后判断队列长度</p>\n</blockquote>\n<blockquote>\n<p>if (action.length &gt; 1) {</p>\n</blockquote>\n<blockquote>\n<p>//队列长度大于 1，则弹出第一个，继续递归执行该队列</p>\n</blockquote>\n<blockquote>\n<p>action.shift();</p>\n</blockquote>\n<blockquote>\n<p>send(action, arg2);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}).fail(function (){</p>\n</blockquote>\n<blockquote>\n<p>//队列中元素请求失败后的逻辑</p>\n</blockquote>\n<blockquote>\n<p>//</p>\n</blockquote>\n<blockquote>\n<p>//重试发送</p>\n</blockquote>\n<blockquote>\n<p>//send(action, arg2);</p>\n</blockquote>\n<blockquote>\n<p>//</p>\n</blockquote>\n<blockquote>\n<p>//忽略错误进行下个</p>\n</blockquote>\n<blockquote>\n<p>//if (action.length &gt; 1) {</p>\n</blockquote>\n<blockquote>\n<p>//队列长度大于 1，则弹出第一个，继续递归执行该队列</p>\n</blockquote>\n<blockquote>\n<p>// action.shift();</p>\n</blockquote>\n<blockquote>\n<p>// send(action, arg2);</p>\n</blockquote>\n<blockquote>\n<p>//}</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>//处理每个命令的 ajax 请求以及回调函数function send_action(command, arg2) {</p>\n</blockquote>\n<blockquote>\n<p>var dtd = $.Deferred();//定义 deferred 对象</p>\n</blockquote>\n<blockquote>\n<p>$.post( “url”,</p>\n</blockquote>\n<blockquote>\n<p>{</p>\n</blockquote>\n<blockquote>\n<p>command: command, arg2: arg2</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>).done(function (json) { json = $.parseJSON(json);</p>\n</blockquote>\n<blockquote>\n<p>//每次请求回调函数的处理逻辑</p>\n</blockquote>\n<blockquote>\n<p>//</p>\n</blockquote>\n<blockquote>\n<p>//</p>\n</blockquote>\n<blockquote>\n<p>//</p>\n</blockquote>\n<blockquote>\n<p>//逻辑结束</p>\n</blockquote>\n<blockquote>\n<p>dtd.resolve();</p>\n</blockquote>\n<blockquote>\n<p>}).fail(function (){</p>\n</blockquote>\n<blockquote>\n<p>//ajax 请求失败的逻辑dtd.reject();</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>return dtd.promise();//返回 Deferred 对象的 promise，防止在外部</p>\n</blockquote>\n<ul>\n<li><h3 id=\"写出原生-Ajax\"><a href=\"#写出原生-Ajax\" class=\"headerlink\" title=\"写出原生 Ajax\"></a>写出原生 Ajax</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Ajax 能够在不重新加载整个页面的情况下与服务器交换数据并更新部分网页内容，实现局部刷新，大大降低了资源的浪费，是一门用于快速创建动态网页的技术，ajax 的使用分为四部分：</p>\n<p>1、创建 XMLHttpRequest 对象 var xhr = new XMLHttpRequest();</p>\n<p>2、向服务器发送请求，使用 xmlHttpRequest 对象的 open 和 send 方法， 3、监听状态变化，执行相应回调函数</p>\n<h3 id=\"var-xhr-new-XMLHttpRequest-xhr-open-‘get’-‘aabb-php’-true-xhr-send-null-xhr-onreadystatechange-function-if-xhr-readyState-4-if-xhr-status-200-console-log-xhr-responseText-1\"><a href=\"#var-xhr-new-XMLHttpRequest-xhr-open-‘get’-‘aabb-php’-true-xhr-send-null-xhr-onreadystatechange-function-if-xhr-readyState-4-if-xhr-status-200-console-log-xhr-responseText-1\" class=\"headerlink\" title=\"var xhr = new XMLHttpRequest(); xhr.open(‘get’, ‘aabb.php’, true); xhr.send(null); xhr.onreadystatechange = function() { if(xhr.readyState==4) { if(xhr.status==200) { console.log(xhr.responseText)\"></a>var xhr = new XMLHttpRequest(); xhr.open(‘get’, ‘aabb.php’, true); xhr.send(null); xhr.onreadystatechange = function() { if(xhr.readyState==4) { if(xhr.status==200) { console.log(xhr.responseText)</h3><blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"如何实现一个-ajax-请求？如果我想发出两个有顺序的-ajax-需要怎么做？\"><a href=\"#如何实现一个-ajax-请求？如果我想发出两个有顺序的-ajax-需要怎么做？\" class=\"headerlink\" title=\"如何实现一个 ajax 请求？如果我想发出两个有顺序的 ajax 需要怎么做？\"></a>如何实现一个 ajax 请求？如果我想发出两个有顺序的 ajax 需要怎么做？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>AJAX 创建异步对象 XMLHttpRequest</p>\n<p>操作 XMLHttpRequest 对象</p>\n<ol>\n<li><p>设置请求参数（请求方式，请求页面的相对路径，是否异步）</p>\n</li>\n<li><p>设置回调函数，一个处理服务器响应的函数，使用 onreadystatechange ，类似函数指针</p>\n</li>\n<li><p>获取异步对象的 readyState 属性：该属性存有服务器响应的状态信息。每当readyState 改变时，onreadystatechange 函数就会被执行。</p>\n</li>\n<li><p>判断响应报文的状态，若为 200 说明服务器正常运行并返回响应数据。</p>\n</li>\n<li><p>读取响应数据，可以通过 responseText 属性来取回由服务器返回的数据。</p>\n</li>\n</ol>\n<p>发出两个有顺序的 ajax，可以用回调函数，也可以使用 Promise.then 或者 async 等。</p>\n<ul>\n<li><h3 id=\"Fetch-和-Ajax-比有什么优缺点？\"><a href=\"#Fetch-和-Ajax-比有什么优缺点？\" class=\"headerlink\" title=\"Fetch 和 Ajax 比有什么优缺点？\"></a>Fetch 和 Ajax 比有什么优缺点？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>promise 方便异步，在不想用 jQuery 的情况下，相比原生的 ajax，也比较好写。</p>\n<ul>\n<li><h3 id=\"原生-JS-的-ajax\"><a href=\"#原生-JS-的-ajax\" class=\"headerlink\" title=\"原生 JS 的 ajax\"></a>原生 JS 的 ajax</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>AJAX 创建异步对象 XMLHttpRequest</p>\n<p>操作 XMLHttpRequest 对象</p>\n<ol>\n<li><p>设置请求参数（请求方式，请求页面的相对路径，是否异步）</p>\n</li>\n<li><p>设置回调函数，一个处理服务器响应的函数，使用 onreadystatechange ，类似函数指针</p>\n</li>\n<li><p>获取异步对象的 readyState 属性：该属性存有服务器响应的状态信息。每当readyState 改变时，onreadystatechange 函数就会被执行。</p>\n</li>\n<li><p>判断响应报文的状态，若为 200 说明服务器正常运行并返回响应数据。</p>\n</li>\n<li><p>读取响应数据，可以通过 responseText 属性来取回由服务器返回的数据。</p>\n</li>\n<li><h2 id=\"移动-web-开发\"><a href=\"#移动-web-开发\" class=\"headerlink\" title=\"| 移动 web 开发\"></a>| 移动 web 开发</h2></li>\n</ol>\n<ul>\n<li><h3 id=\"知道-PWA-吗\"><a href=\"#知道-PWA-吗\" class=\"headerlink\" title=\"知道 PWA 吗\"></a>知道 PWA 吗</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>PWA 全称 Progressive Web App，即渐进式 WEB 应用。一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和<br>Service Worker 来实现 PWA 的安装和离线等功能</p>\n<ul>\n<li><h3 id=\"移动布局方案\"><a href=\"#移动布局方案\" class=\"headerlink\" title=\"移动布局方案\"></a>移动布局方案</h3></li>\n</ul>\n<p>参 考 回 答 ：<br><a href=\"https://links.jianshu.com/go?to=https://juejin.im/post/599970f4518825243a78b9d5%23heading-22\"><em>https://juejin.im/post/599970f4518825243a78b9d5#heading-22</em></a></p>\n<blockquote>\n<p><img src=\"media/image9.jpeg\"></p>\n</blockquote>\n<ul>\n<li><h3 id=\"Rem-Em\"><a href=\"#Rem-Em\" class=\"headerlink\" title=\"Rem, Em\"></a>Rem, Em</h3></li>\n</ul>\n<p>参 考 回 答 ：<br><a href=\"https://links.jianshu.com/go?to=https://blog.csdn.net/romantic_love/article/details/80875462\"><em>https://blog.csdn.net/romantic_love/article/details/80875462</em></a><br>一、rem 单位如何转换为像素值</p>\n<ol>\n<li>当使用 rem 单位的时候，页面转换为像素大小取决于叶根元素的字体大小，即 HTML 元素的字体大小。根元素字体大小乘 rem 的值。例如，根元素的字体大小为 16px，那么 10rem<br>就等同于 10*16=160px。</li>\n</ol>\n<p>二、em 是如何转换成 px 的</p>\n<p>当使用 em 单位的时候，像素值是将 em 值乘以使用 em 单位的元素的字体大小。例如一个 div 的字体为 18px，设置它的宽高为 10em，那么此时宽高就是 18px*10em=180px。</p>\n<h3 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\".test{\"></a>.test{</h3><blockquote>\n<p>width: 10em;</p>\n</blockquote>\n<blockquote>\n<p>height: 10em;</p>\n</blockquote>\n<blockquote>\n<p>background-color: #ff7d42;</p>\n</blockquote>\n<blockquote>\n<p>font-size: 18px;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<p>一定要记住的是，em 是根据使用它的元素的 font-size 的大小来变化的，而不是根据父元素字体大小。有些元素大小是父元素的多少倍那是因为继承了父元素中 font-size<br>的设定，所以才起到的作用。</p>\n<ol start=\"2\">\n<li>em 单位的继承效果。</li>\n</ol>\n<p>使用 em 单位存在继承的时候，每个元素将自动继承其父元素的字体大小，继承的效果只能被明确的字体单位覆盖，比如 px 和 vw。只要父级元素上面一直有 fontsize 为 em<br>单位，则会一直继承，但假如自己设置了 font-size 的单位为 px 的时候，则会直接使用自己的 px 单位的值。</p>\n<p>三、根 html 的元素将会继承浏览器中设置的字体大小</p>\n<p>除非显式的设置固定值去覆盖。所以 html 元素的字体大小虽然是直接确定 rem 的值， 但这个字体大小首先是来源于浏览器的设置。（所以一定要设置 html<br>的值的大小，因为有可能用户的浏览器字体大小是不一致的。）</p>\n<p>四、当 em 单位设置在 html 元素上时</p>\n<p>它将转换为 em 值乘以浏览器字体大小的设置。例如：</p>\n<h3 id=\"html\"><a href=\"#html\" class=\"headerlink\" title=\"html{\"></a>html{</h3><blockquote>\n<p>font-size: 1.5em;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<p>可以看到，因为浏览器默认字体大小为 16px，所以当设置 HTML 的 fontsize 的值为</p>\n<ol start=\"5\">\n<li>em 的售后，其对应的 px 的值为 16*1.5=24px</li>\n</ol>\n<p>所以此时，再设置其他元素的 rem 的值的时候，其对应的像素值为 n*24px。</p>\n<p>例如，test 的 rem 的值为 10，</p>\n<h3 id=\"test-1\"><a href=\"#test-1\" class=\"headerlink\" title=\".test{\"></a>.test{</h3><blockquote>\n<p>width: 10rem;</p>\n</blockquote>\n<blockquote>\n<p>height: 10rem;</p>\n</blockquote>\n<blockquote>\n<p>background-color: #ff7d42;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<p><img src=\"media/image10.jpeg\"></p>\n<p>可以看到 test 的 font-size 继承了 html 的值 24px，而此时宽高为 24*10=240px</p>\n<p>总结</p>\n<ol>\n<li><p>rem 单位翻译为像素值的时候是由 html 元素的字体大小决定的。此字体大小会被浏览器中字体大小的设置影响，除非显式的在 html 为 font-size 重写一个单位。</p>\n</li>\n<li><p>em 单位转换为像素值的时候，取决于使用它们的元素的 font-size 的大小，但是有因为有继承关系，所以比较复杂。</p>\n</li>\n</ol>\n<p>优缺点</p>\n<p>em 可以让我们的页面更灵活，更健壮，比起到处写死的 px 值，em 似乎更有张力，改动父元素的字体大小，子元素会等比例变化，这一变化似乎预示了无限可能,</p>\n<p>em 做弹性布局的缺点还在于牵一发而动全身，一旦某个节点的字体大小发生变化，那么其后代元素都得重新计算</p>\n<ul>\n<li><h3 id=\"flex-布局及优缺点\"><a href=\"#flex-布局及优缺点\" class=\"headerlink\" title=\"flex 布局及优缺点\"></a>flex 布局及优缺点</h3></li>\n</ul>\n<p>参 考 回 答 ：<br><a href=\"https://links.jianshu.com/go?to=https://juejin.im/post/599970f4518825243a78b9d5%23heading-22\"><em>https://juejin.im/post/599970f4518825243a78b9d5#heading-22</em></a></p>\n<p>css3 引入的，flex 布局；优点在于其容易上手，根据 flex 规则很容易达到某个布局效果，然而缺点是：浏览器兼容性比较差，只能兼容到 ie9 及以上；</p>\n<p><img src=\"media/image11.jpeg\"></p>\n<p><img src=\"media/image12.jpeg\"></p>\n<ul>\n<li><h3 id=\"Rem-布局及其优缺点\"><a href=\"#Rem-布局及其优缺点\" class=\"headerlink\" title=\"Rem 布局及其优缺点\"></a>Rem 布局及其优缺点</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>首先 Rem 相对于根(html)的 font-size 大小来计算。简单的说它就是一个相对单例如:font-size:10px;,那么（1rem = 10px）了解计算原理后</p>\n<p>首先解决怎么在不同设备上设置 html 的 font-size 大小。其实 rem 布局的本质是等比缩放，一般是基于宽度。</p>\n<p>优点</p>\n<p>可以快速适用移动端布局 字体图片 高度缺点</p>\n<p>①目前 ie 不支持，对 pc 页面来讲使用次数不多；</p>\n<p>②数据量大：所有的图片，盒子都需要我们去给一个准确的值；才能保证不同机型的适配；</p>\n<p>③在响应式布局中，必须通过 js 来动态控制根元素 font-size 的大小。</p>\n<p>也就是说 css 样式和 js 代码有一定的耦合性。且必须将改变 font-size 的代码放在</p>\n<p>css 样式之前。</p>\n<ul>\n<li><h3 id=\"百分比布局\"><a href=\"#百分比布局\" class=\"headerlink\" title=\"百分比布局\"></a>百分比布局</h3></li>\n</ul>\n<p>参考回答： 1、具体分析</p>\n<p>除了用 px 结合媒体查询实现响应式布局外，我们也可以通过百分比单位 “ % “<br>来实现响应式的效果。比如当浏览器的宽度或者高度发生变化时，通过百分比单位，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。为了了解百分比布局，首先要了解的问题是：css<br>中的子元素中的百分比</p>\n<p>（%）到底是谁的百分比？</p>\n<p>直观的理解，我们可能会认为子元素的百分比完全相对于直接父元素，height 百分比相对于 height，width 百分比相对于 width。当然这种理解是正确的，但是根据 css 的盒式模型，除了<br>height、width 属性外，还具有 padding、border、margin 等等属</p>\n<p>性。那么这些属性设置成百分比，是根据父元素的那些属性呢？此外还有 border- radius 和 translate 等属性中的百分比，又是相对于什么呢？下面来具体分析。</p>\n<p>padding、border、margin 等等属不论是垂直方向还是水平方向，都相对于直接父元素的 width。</p>\n<p>除了 border-radius 外，还有比如 translate、background-size 等都是相对于自身的。</p>\n<p>2、百分比单位布局应用</p>\n<p>比如我们要实现一个固定长宽比的长方形，比如要实现一个长宽比为 4:3 的长方形,我们可以根据 padding 属性来实现，因为 padding<br>不管是垂直方向还是水平方向，百分比单位都相对于父元素的宽度，因此我们可以设置 padding-top 为百分比来实现，长宽自适应的长方形：</p>\n<h3 id=\"trangle\"><a href=\"#trangle\" class=\"headerlink\" title=\".trangle{\"></a>.trangle{</h3><blockquote>\n<p>height:0;</p>\n</blockquote>\n<blockquote>\n<p>width:100%;</p>\n</blockquote>\n<blockquote>\n<p>padding-top:75%;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<p>3、百分比单位缺点</p>\n<p>从上述对于百分比单位的介绍我们很容易看出如果全部使用百分比单位来实现响应式的布局，有明显的以下两个缺点：</p>\n<ol>\n<li><p>计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。</p>\n</li>\n<li><p>从小节 1 可以看出，各个属性中如果使用百分比，相对父元素的属性并不是唯一的。比如 width 和 height 相对于父元素的 width 和 height，而 margin、padding<br>不管垂直还是水平方向都相对比父元素的宽度、border-radius 则是相对于元素自身等等， 造成我们使用百分比单位容易使布局问题变得复杂。</p>\n</li>\n</ol>\n<p><img src=\"media/image13.jpeg\"> <img src=\"media/image14.jpeg\"></p>\n<ul>\n<li><h3 id=\"移动端适配-1px-的问题\"><a href=\"#移动端适配-1px-的问题\" class=\"headerlink\" title=\"移动端适配 1px 的问题\"></a>移动端适配 1px 的问题</h3></li>\n</ul>\n<p>参 考 回 答 ：<br><a href=\"https://links.jianshu.com/go?to=https://blog.csdn.net/weixin_43675871/article/details/84023447\"><em>https://blog.csdn.net/weixin_43675871/article/details/84023447</em></a><br>首先，我们了解 devicePixelRatio（DPR）这个东西</p>\n<h3 id=\"在-window-对象中有一个-devicePixelRatio-属性，他可以反应-css-中的像素与设备的像素比。然而-1px-在不同的移动设备上都等于这个移动设备的-1px，这是因为不同的移动设备有不同的像素密度。有关这个属性，它的官方的定义-为：设备物理像素和设备独立像素的比例，也就是-devicePixelRatio-物理像素-独立像素-1px-变粗的原因：viewport-的设置和屏幕物理分辨率是按比例而不是相同的-移动端-window-对象有个-devicePixelRatio-属性-它表示设备\"><a href=\"#在-window-对象中有一个-devicePixelRatio-属性，他可以反应-css-中的像素与设备的像素比。然而-1px-在不同的移动设备上都等于这个移动设备的-1px，这是因为不同的移动设备有不同的像素密度。有关这个属性，它的官方的定义-为：设备物理像素和设备独立像素的比例，也就是-devicePixelRatio-物理像素-独立像素-1px-变粗的原因：viewport-的设置和屏幕物理分辨率是按比例而不是相同的-移动端-window-对象有个-devicePixelRatio-属性-它表示设备\" class=\"headerlink\" title=\"在 window 对象中有一个 devicePixelRatio 属性，他可以反应 css 中的像素与设备的像素比。然而 1px 在不同的移动设备上都等于这个移动设备的 1px，这是因为不同的移动设备有不同的像素密度。有关这个属性，它的官方的定义 为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素 1px 变粗的原因：viewport 的设置和屏幕物理分辨率是按比例而不是相同的. 移动端 window 对象有个 devicePixelRatio 属性,它表示设备\"></a>在 window 对象中有一个 devicePixelRatio 属性，他可以反应 css 中的像素与设备的像素比。然而 1px 在不同的移动设备上都等于这个移动设备的 1px，这是因为不同的移动设备有不同的像素密度。有关这个属性，它的官方的定义 为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素 1px 变粗的原因：viewport 的设置和屏幕物理分辨率是按比例而不是相同的. 移动端 window 对象有个 devicePixelRatio 属性,它表示设备</h3><blockquote>\n<p>物理像素和 css 像素的比例, 在 retina 屏的iphone 手机上, 这个值为 2 或</p>\n</blockquote>\n<blockquote>\n<p>3,css 里写的 1px 长度映射到物理像素上就有 2px 或 3px 那么长</p>\n</blockquote>\n<ol>\n<li>用小数来写 px 值 （不推荐）</li>\n</ol>\n<p>IOS8 下已经支持带小数的 px 值, media query 对应 devicePixelRatio 有个查询值 - webkit-min-device-pixel-ratio, css<br>可以写成这样</p>\n<p>通过-webkit-min-device-pixel-ratio 设置。</p>\n<h3 id=\"border-border-1px-solid-999\"><a href=\"#border-border-1px-solid-999\" class=\"headerlink\" title=\".border { border: 1px solid #999 }\"></a>.border { border: 1px solid #999 }</h3><blockquote>\n<p>@media screen and (-webkit-min-device-pixel-ratio: 2) {</p>\n</blockquote>\n<blockquote>\n<p>.border { border: 0.5px solid #999 }</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>@media screen and (-webkit-min-device-pixel-ratio: 3) {</p>\n</blockquote>\n<blockquote>\n<p>.border { border: 0.333333px solid #999 }</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<p>如果使用 less/sass 的话只是加了 1 句 mixin</p>\n<p>缺点: 安卓与低版本 IOS 不适用, 这个或许是未来的标准写法, 现在不做指望 2、flexible.js</p>\n<p>这是淘宝移动端采取的方案, github<br>的地址:<a href=\"https://links.jianshu.com/go?to=https://github.com/amfe/lib-flexible\"><em>https://github.com/amfe/lib-</em></a><br><a href=\"https://links.jianshu.com/go?to=https://github.com/amfe/lib-flexible\"><em>flexible</em></a>. 前面已经说过<br>1px 变粗的原因就在于一刀切的设置 viewport 宽度, 如果能把 viewport 宽度设置为实际的设备物理宽度, css 里的 1px 不就等于实际 1px 长了么. flexible.js<br>就是这样干的.</p>\n<meta name=”viewport”>里面的 scale 值指的是对 ideal viewport 的缩放, flexible.js 检测到 IOS 机型, 会算出 scale =\n1/devicePixelRatio, 然后设置viewport\n\n<p>3、伪类+transform 实现</p>\n<p>对于解决 1px 边框问题，我个人觉得最完美的解决办法还是伪类+transform 比较好。原理：是把原先元素的 border 去掉，然后利用 :before 或者 :after 重做</p>\n<p>border ，并 transform 的 scale 缩小一半，原先的元素相对定位，新做的 border</p>\n<p>绝对定位。media query</p>\n<p>通过媒体查询，可以通过给不同分辨率的设备编写不同的样式来实现响应式的布局， 比如我们为不同分辨率的屏幕，设置不同的背景图片。比如给小屏幕手机设置@2x 图， 为大屏幕手机设置@3x<br>图，通过媒体查询就能很方便的实现。</p>\n<p>但是媒体查询的缺点也很明显，如果在浏览器大小改变时，需要改变的样式太多，那么多套样式代码会很繁琐。</p>\n<h3 id=\"media-screen-and-min-width-320px\"><a href=\"#media-screen-and-min-width-320px\" class=\"headerlink\" title=\"@media screen and (min-width: 320px) {\"></a>@media screen and (min-width: 320px) {</h3><blockquote>\n<p>html {</p>\n</blockquote>\n<blockquote>\n<p>font-size: 50px;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<p>@media</p>\n<p>方便应用广泛 适用于 pc 端 手机页面，通常做自适应布局时 我们比较常用。缺点：相对于代码要重复很多，得知道设备的宽度，手机的分辨率很多所以麻烦了点，不过性能方面肯定最高； 可能存在闪屏的问题</p>\n<p>@media 处理手机和 pc 端界面兼容的问题，在 IE 上的访问出现问题，百度方法，找找两 种 ， 一 种 是 respond.js， 另 一 种 是<br><a href=\"https://links.jianshu.com/go?to=css3-mediaquerieshttp://blog.csdn.net/small_tu/article/details/47317453\"><em>css3-</em></a><br><a href=\"https://links.jianshu.com/go?to=css3-mediaquerieshttp://blog.csdn.net/small_tu/article/details/47317453\"><em>mediaquerieshttp://blog.csdn.net/small_tu/article/details/47317453</em></a></p>\n<ul>\n<li><h3 id=\"移动端性能优化相关经验\"><a href=\"#移动端性能优化相关经验\" class=\"headerlink\" title=\"移动端性能优化相关经验\"></a>移动端性能优化相关经验</h3></li>\n</ul>\n<p>参 考 回 答 ：<br><a href=\"https://links.jianshu.com/go?to=https://blog.csdn.net/tangxiujiang/article/details/79791545\"><em>https://blog.csdn.net/tangxiujiang/article/details/79791545</em></a></p>\n<ul>\n<li><h3 id=\"toB-和-toC-项目的区别\"><a href=\"#toB-和-toC-项目的区别\" class=\"headerlink\" title=\"toB 和 toC 项目的区别\"></a>toB 和 toC 项目的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>to B（business）即面向企业，to C（ customer）即面向普通用户</p>\n<p>简单的事情重复去做，重复的事情用心去做，长期坚持，自然功成，无论是 B 端还是C</p>\n<p>端都同样适用。Tob 与 Toc 的区别</p>\n<p>作者 猪八戒网 • 10-11 10:18:49 阅读 419 oB 产品价值何来？</p>\n<p>最近团队在 toB 产品研究的过程中，得出结论，相对于 toC 产品与服务，toC 产品更注重产品用户的共性而淡化角色关系，而 toB 产品则更强调面向用户、客户的角色关</p>\n<p>系，而淡化共性提取。实际上，这是由服务对象所引起的，C 端产品的服务对象，由终端所限，是一个面向个体的服务。而B 端服务使用最终是面向一个系统体系组织，在干系人间配合使用中发挥产品价值。</p>\n<p>一个好的产品 toB 可以让组织的系统变得更好，最终反哺于系统中的各个单位。需求动力之不同 toC<br>的产品方法论，用户体验是几乎最为重要的需求来源，腾讯此前，也以”以用户体验为归依”来驱动企业产品打造。</p>\n<p>但B 端产品则不同，B 端在一个商业的背景之下，B 端的决策思路是，”以企业获益为归依”，系统是否有利于企业的生产力，竞争力等，单纯的用户体验，仅能让员工得到片刻的享受，<br>但无法说服企业，企业并不会为一个不能”赚钱”的东西买单。</p>\n<p>需求动力的不同，引发的这是购买使用决策体系的变化。</p>\n<p>toB 产品应更考虑 获益与系统性价值，部分情况还有可能会牺牲掉局部个体的利益， 对于使用者而言应该是自律或他律的，toC<br>产品则更考虑的是个体用户的偏好，并长时间内，基于技术效率的提升，产品的服务中心更多地围绕着更高效地帮助用户的”欲望”释放进行设计，对于使用者而言是一个释放自我的存在。</p>\n<ul>\n<li><h3 id=\"移动端兼容性\"><a href=\"#移动端兼容性\" class=\"headerlink\" title=\"移动端兼容性\"></a>移动端兼容性</h3></li>\n</ul>\n<p>参 考 回 答 ：<br><a href=\"https://links.jianshu.com/go?to=https://zhuanlan.zhihu.com/p/28206065\"><em>https://zhuanlan.zhihu.com/p/28206065</em></a><br>1.IOS 移动端 click 事件 300ms 的延迟相应</p>\n<ol start=\"3\">\n<li>h5 底部输入框被键盘遮挡问题</li>\n</ol>\n<p>10.CSS 动画页面闪白,动画卡顿</p>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><ol>\n<li>尽可能地使用合成属性 transform 和 opacity 来设计 CSS3 动画，不使用</li>\n</ol>\n<blockquote>\n<p>position 的 left 和 top 来定位</p>\n</blockquote>\n<ol start=\"2\">\n<li><p>开启硬件加速</p>\n</li>\n<li><p>上下拉动滚动条时卡顿、慢</p>\n</li>\n</ol>\n<h3 id=\"body-webkit-overflow-scrolling-touch-overflow-scrolling-touch\"><a href=\"#body-webkit-overflow-scrolling-touch-overflow-scrolling-touch\" class=\"headerlink\" title=\"body {-webkit-overflow-scrolling: touch;overflow-scrolling: touch;}\"></a>body {-webkit-overflow-scrolling: touch;overflow-scrolling: touch;}</h3><blockquote>\n<p>Android3+和 iOS5+支持 CSS3 的新属性为 overflow-scrolling</p>\n</blockquote>\n<ul>\n<li>小程序</li>\n</ul>\n<p>参考回答： 移动端手势</p>\n<blockquote>\n<p><img src=\"media/image15.jpeg\"></p>\n</blockquote>\n<p><img src=\"media/image16.jpeg\"></p>\n<ul>\n<li><h3 id=\"2X-图-3X-图适配\"><a href=\"#2X-图-3X-图适配\" class=\"headerlink\" title=\"2X 图 3X 图适配\"></a>2X 图 3X 图适配</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>实际程序开发当中，我们代码中用的值是指逻辑分辨率 pt，而不是像素分辨率 px，比如我们定义一个按钮的高度为 45，这个 45 指的是 45pt 而不是 45px。在非 Retina 屏下 1pt =<br>1px，4 和 4.7 寸 Retina 屏下 1pt = 2px，5.5 和x 下 1pt = 3px.我们制作不同尺寸的图片，比如@1x 为 22px，则@2x 为 44px，@3x 为<br>66px，命名分别为image.png，在项目的 Assets.xcassets 中新建 New Image Set，修改名字为 image， 并把相应尺寸的图片拖放至相应位置。</p>\n<p>/* 根据 dpr 显示 2x 图/3x 图 */</p>\n<h3 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a></h3><blockquote>\n<p>.bg-image(@url){</p>\n</blockquote>\n<blockquote>\n<p>background-image:~“url(‘@{url}@2x.png’)”;</p>\n</blockquote>\n<blockquote>\n<p>@media (-webkit-min-device-pixel-ratio: 3),(min-device-pixel- ratio: 3){</p>\n</blockquote>\n<blockquote>\n<p>background-image:~“url(‘@{url}@3x.png’)”;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.bg-color(@color) {</p>\n</blockquote>\n<blockquote>\n<p>background-color: @color;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li>图片在安卓上，有些设备模糊问题</li>\n</ul>\n<p><img src=\"media/image17.jpeg\"> 参考回答：</p>\n<ul>\n<li><h3 id=\"固定定位布局键盘挡住输入框内容\"><a href=\"#固定定位布局键盘挡住输入框内容\" class=\"headerlink\" title=\"固定定位布局键盘挡住输入框内容\"></a>固定定位布局键盘挡住输入框内容</h3></li>\n</ul>\n<p>参考回答：</p>\n<p><img src=\"media/image18.jpeg\"> <img src=\"media/image19.jpeg\"></p>\n<ul>\n<li><h3 id=\"click-的-300ms-延迟问题和点击穿透问题\"><a href=\"#click-的-300ms-延迟问题和点击穿透问题\" class=\"headerlink\" title=\"click 的 300ms 延迟问题和点击穿透问题\"></a>click 的 300ms 延迟问题和点击穿透问题</h3></li>\n</ul>\n<p><img src=\"media/image20.jpeg\"> 参 考 回 答 ：<br><a href=\"https://www.jianshu.com/p/6e2b68a93c88\"><em>https://www.jianshu.com/p/6e2b68a93c88</em></a></p>\n<p>方案二：FastClick</p>\n<p><img src=\"media/image21.jpeg\"><br><a href=\"https://links.jianshu.com/go?to=https://github.com/ftlabs/fastclick\"><em>FastClick</em></a> 是<br><a href=\"https://links.jianshu.com/go?to=http://labs.ft.com/\"><em>FT Labs</em></a> 专门为解决移动端浏览器 300<br>毫秒点击延迟问题所开发的一个轻量级的库。FastClick 的实现原理是在检测到 touchend 事件的时候，会通过 DOM 自定义事件立即出发模拟一个 click 事件，并把浏览器在 300ms<br>之后的 click 事件阻止掉。</p>\n<ul>\n<li><h3 id=\"phone-及-ipad-下输入框默认内阴影\"><a href=\"#phone-及-ipad-下输入框默认内阴影\" class=\"headerlink\" title=\"phone 及 ipad 下输入框默认内阴影\"></a>phone 及 ipad 下输入框默认内阴影</h3></li>\n</ul>\n<p><img src=\"media/image22.jpeg\"> 参考回答：</p>\n<ul>\n<li><h3 id=\"防止手机中页面放大和缩小\"><a href=\"#防止手机中页面放大和缩小\" class=\"headerlink\" title=\"防止手机中页面放大和缩小\"></a>防止手机中页面放大和缩小</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a><meta name=\"viewport\" content=\"user-scalable=no\"></h3><blockquote>\n<meta name=\"viewport\" content=\"initial-scale=1,maximum-scale=1\">\n</blockquote>\n<ul>\n<li>px、em、rem、%、vw、vh、vm 这些单位的区别</li>\n</ul>\n<p>参 考 回 答 ： <a href=\"https://www.jianshu.com/p/ba26509bc5b3\"><em>https://www.jianshu.com/p/ba26509bc5b3</em></a></p>\n<ul>\n<li><h3 id=\"移动端适配-dpr-浅析\"><a href=\"#移动端适配-dpr-浅析\" class=\"headerlink\" title=\"移动端适配- dpr 浅析\"></a>移动端适配- dpr 浅析</h3></li>\n</ul>\n<p>参 考 回 答 ： <a href=\"https://www.jianshu.com/p/cf600c2930cb\"><em>https://www.jianshu.com/p/cf600c2930cb</em></a> dpr =<br>物理像素 / css 像素</p>\n<p>在 dpr = 2； 1px 的 css 像素在设备中是 2px 的物理像素，这会导致在设备上看上去</p>\n<p>1px 的边框是 2px</p>\n<p>解决方法：</p>\n<h3 id=\"用-transfrom：-scale（）缩小-dpr-倍数在-meta-标签中设定-scale-缩小两倍\"><a href=\"#用-transfrom：-scale（）缩小-dpr-倍数在-meta-标签中设定-scale-缩小两倍\" class=\"headerlink\" title=\"用 transfrom： scale（）缩小 dpr 倍数在 meta 标签中设定 scale 缩小两倍\"></a>用 transfrom： scale（）缩小 dpr 倍数在 meta 标签中设定 scale 缩小两倍</h3><ul>\n<li>移动端扩展点击区域</li>\n</ul>\n<p>参考回答： 父级代理事件</p>\n<p>将a 标签设置成块级元素</p>\n<ul>\n<li><h3 id=\"上下拉动滚动条时卡顿、慢\"><a href=\"#上下拉动滚动条时卡顿、慢\" class=\"headerlink\" title=\"上下拉动滚动条时卡顿、慢\"></a>上下拉动滚动条时卡顿、慢</h3></li>\n</ul>\n<p>参考回答：</p>\n<blockquote>\n<p><img src=\"media/image23.jpeg\"></p>\n</blockquote>\n<ul>\n<li><h3 id=\"长时间按住页面出现闪退\"><a href=\"#长时间按住页面出现闪退\" class=\"headerlink\" title=\"长时间按住页面出现闪退\"></a>长时间按住页面出现闪退</h3></li>\n</ul>\n<p>参考回答：</p>\n<p><img src=\"media/image24.jpeg\"></p>\n<ul>\n<li><h3 id=\"ios-和-android-下触摸元素时出现半透明灰色遮罩\"><a href=\"#ios-和-android-下触摸元素时出现半透明灰色遮罩\" class=\"headerlink\" title=\"ios 和 android 下触摸元素时出现半透明灰色遮罩\"></a>ios 和 android 下触摸元素时出现半透明灰色遮罩</h3></li>\n</ul>\n<p><img src=\"media/image25.jpeg\"> 参考回答：</p>\n<ul>\n<li><h3 id=\"active-兼容处理-即-伪类：active-失效\"><a href=\"#active-兼容处理-即-伪类：active-失效\" class=\"headerlink\" title=\"active 兼容处理 即 伪类：active 失效\"></a>active 兼容处理 即 伪类：active 失效</h3></li>\n</ul>\n<p>参 考 回 答 ：<br><a href=\"https://links.jianshu.com/go?to=https://blog.csdn.net/diaobuwei1238/article/details/101716814\"><em>https://blog.csdn.net/diaobuwei1238/article/details/101716814</em></a></p>\n<p>将 :visited 放到最后，则会导致以下结果：若链接已经被访问过，a:visited 会覆盖:active 和:hover<br>的样式声明，链接将总是呈现为紫色，无论鼠标悬停还是按下激活，链接都将保持为紫色。</p>\n<p>基于此原因，上述代码必须按照顺序定义，一般称为 LVHA-order: :link — :visited</p>\n<p>— :hover — :active，为方便记忆，可记为“LOVE HATE”</p>\n<p><img src=\"media/image26.jpeg\"></p>\n<ul>\n<li><h3 id=\"webkit-mask-兼容处理\"><a href=\"#webkit-mask-兼容处理\" class=\"headerlink\" title=\"webkit mask 兼容处理\"></a>webkit mask 兼容处理</h3></li>\n</ul>\n<p>参 考 回 答 ：<br><a href=\"https://links.jianshu.com/go?to=https://segmentfault.com/a/1190000011838367\"><em>https://segmentfault.com/a/1190000011838367</em></a></p>\n<blockquote>\n<p><img src=\"media/image27.jpeg\"></p>\n</blockquote>\n<p><img src=\"media/image28.jpeg\"></p>\n<ul>\n<li><h3 id=\"transiton-闪屏\"><a href=\"#transiton-闪屏\" class=\"headerlink\" title=\"transiton 闪屏\"></a>transiton 闪屏</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"设置内联的元素在-3D-空间如何呈现：保留-3D-webkit-transform-style-preserve-3D\"><a href=\"#设置内联的元素在-3D-空间如何呈现：保留-3D-webkit-transform-style-preserve-3D\" class=\"headerlink\" title=\"//设置内联的元素在 3D 空间如何呈现：保留 3D-webkit-transform- style:preserve-3D\"></a>//设置内联的元素在 3D 空间如何呈现：保留 3D-webkit-transform- style:preserve-3D</h3><blockquote>\n<p>//设置进行转换的元素的背面在面对用户时是否可见：隐藏-webkit-backface- visibility:hidden;</p>\n</blockquote>\n<ul>\n<li>圆角 bug</li>\n</ul>\n<p><img src=\"media/image29.jpeg\"> 参考回答：</p>\n<h3 id=\"作者：Aniugel\"><a href=\"#作者：Aniugel\" class=\"headerlink\" title=\"作者：Aniugel\"></a>作者：Aniugel</h3><blockquote>\n<p>链接：<a href=\"https://www.jianshu.com/p/610123c6ed45\"><em>https://www.jianshu.com/p/610123c6ed45</em></a> 来源：简书</p>\n</blockquote>\n<h1 id=\"3-前端进阶\"><a href=\"#3-前端进阶\" class=\"headerlink\" title=\"3 | 前端进阶\"></a>3 | 前端进阶</h1><ol>\n<li><h2 id=\"前端工程化\"><a href=\"#前端工程化\" class=\"headerlink\" title=\"| 前端工程化\"></a>| 前端工程化</h2></li>\n</ol>\n<ul>\n<li><h3 id=\"Babel-的原理是什么\"><a href=\"#Babel-的原理是什么\" class=\"headerlink\" title=\"Babel 的原理是什么?\"></a>Babel 的原理是什么?</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>babel 的转译过程也分为三个阶段，这三步具体是：</p>\n<ul>\n<li><p>解析 Parse: 将代码解析生成抽象语法树( 即 AST )，即词法分析与语法分析的过程</p>\n</li>\n<li><p>转换 Transform: 对于 AST 进行变换一系列的操作，babel 接受得到AST 并通过 babel-traverse 对其进行遍历，在此过程中进行添加、更新及移除等操作</p>\n</li>\n<li><p>生成 Generate: 将变换后的 AST 再转换为 JS 代码, 使用到的模块是babel-generator</p>\n</li>\n</ul>\n<p><img src=\"media/image30.jpeg\"></p>\n<ul>\n<li><h3 id=\"如何写一个-babel-插件\"><a href=\"#如何写一个-babel-插件\" class=\"headerlink\" title=\"如何写一个 babel 插件?\"></a>如何写一个 babel 插件?</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Babel 解析成 AST，然后插件更改 AST，最后由 Babel 输出代码</p>\n<p>那么 Babel 的插件模块需要你暴露一个 function，function 内返回 visitor</p>\n<h3 id=\"module-export-function-babel\"><a href=\"#module-export-function-babel\" class=\"headerlink\" title=\"module.export = function(babel){\"></a>module.export = function(babel){</h3><blockquote>\n<p>return {</p>\n</blockquote>\n<blockquote>\n<p>visitor:{</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>visitor 是对各类型的 AST 节点做处理的地方，那么我们怎么知道 Babel 生成了的 AST 有哪些节点呢？</p>\n</blockquote>\n<blockquote>\n<p>很简单，你可以把 Babel 转换的结果打印出来，或者这里有传送门:<a href=\"https://astexplorer.net/\"><em>AST</em></a><br><a href=\"https://astexplorer.net/\"><em>explorer</em></a></p>\n</blockquote>\n<p><img src=\"media/image31.jpeg\"></p>\n<blockquote>\n<p>这里我们看到 const result = 1 + 2 中的 1 + 1 是一个 BinaryExpression 节点， 那么在 visitor 中，我们就处理这个节点</p>\n</blockquote>\n<h3 id=\"var-babel-require-‘babel-core’-var-t-require-‘babel-types’-const-visitor\"><a href=\"#var-babel-require-‘babel-core’-var-t-require-‘babel-types’-const-visitor\" class=\"headerlink\" title=\"var babel = require(‘babel-core’); var t = require(‘babel-types’); const visitor = {\"></a>var babel = require(‘babel-core’); var t = require(‘babel-types’); const visitor = {</h3><blockquote>\n<p>BinaryExpression(path) {</p>\n</blockquote>\n<blockquote>\n<p>const node = path.node;</p>\n</blockquote>\n<blockquote>\n<p>let result;</p>\n</blockquote>\n<blockquote>\n<p>// 判断表达式两边，是否都是数字</p>\n</blockquote>\n<blockquote>\n<p>if (t.isNumericLiteral(node.left) &amp;&amp; t.isNumericLiteral(node.right)) {</p>\n</blockquote>\n<blockquote>\n<p>// 根据不同的操作符作运算</p>\n</blockquote>\n<blockquote>\n<p>switch (node.operator) {</p>\n</blockquote>\n<blockquote>\n<p>case “+”:</p>\n</blockquote>\n<blockquote>\n<p>result = node.left.value + node.right.value;</p>\n</blockquote>\n<blockquote>\n<p>break</p>\n</blockquote>\n<blockquote>\n<p>case “-“:</p>\n</blockquote>\n<blockquote>\n<p>result = node.left.value - node.right.value;</p>\n</blockquote>\n<blockquote>\n<p>break;</p>\n</blockquote>\n<blockquote>\n<p>case “*“:</p>\n</blockquote>\n<blockquote>\n<p>result = node.left.value * node.right.value;</p>\n</blockquote>\n<blockquote>\n<p>break;</p>\n</blockquote>\n<blockquote>\n<p>case “/“:</p>\n</blockquote>\n<blockquote>\n<p>result = node.left.value / node.right.value;</p>\n</blockquote>\n<blockquote>\n<p>break;</p>\n</blockquote>\n<blockquote>\n<p>case “**“:</p>\n</blockquote>\n<blockquote>\n<p>let i = node.right.value;</p>\n</blockquote>\n<blockquote>\n<p>while (–i) {</p>\n</blockquote>\n<blockquote>\n<p>result = result || node.left.value;</p>\n</blockquote>\n<blockquote>\n<p>result = result * node.left.value;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>break;</p>\n</blockquote>\n<blockquote>\n<p>default:</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>// 如果上面的运算有结果的话</p>\n</blockquote>\n<blockquote>\n<p>if (result !== undefined) {</p>\n</blockquote>\n<blockquote>\n<p>// 把表达式节点替换成 number 字面量</p>\n</blockquote>\n<blockquote>\n<p>path.replaceWith(t.numericLiteral(result));</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>};</p>\n</blockquote>\n<blockquote>\n<p>module.exports = function (babel) {</p>\n</blockquote>\n<blockquote>\n<p>return {</p>\n</blockquote>\n<blockquote>\n<p>visitor</p>\n</blockquote>\n<blockquote>\n<p>};</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>插件写好了，我们运行下插件试试</p>\n</blockquote>\n<blockquote>\n<p>const babel = require(“babel-core”);</p>\n</blockquote>\n<blockquote>\n<p>const result = babel.transform(“const result = 1 + 2;”,{</p>\n</blockquote>\n<blockquote>\n<p>plugins:[</p>\n</blockquote>\n<blockquote>\n<p>require(“./index”)</p>\n</blockquote>\n<blockquote>\n<p>]</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>console.log(result.code); // const result = 3;</p>\n</blockquote>\n<blockquote>\n<p>与预期一致，那么转换 const result = 1 + 2 + 3 + 4 + 5;呢?</p>\n</blockquote>\n<h3 id=\"结果是-const-result-3-3-4-5\"><a href=\"#结果是-const-result-3-3-4-5\" class=\"headerlink\" title=\"结果是: const result = 3 + 3 + 4 + 5\"></a>结果是: const result = 3 + 3 + 4 + 5</h3><p>这就奇怪了，为什么只计算了 1 + 2 之后，就没有继续往下运算了? 我们看一下这个表达式的 AST 树</p>\n<p><img src=\"media/image32.jpeg\"></p>\n<p>你会发现 Babel 解析成表达式里面再嵌套表达式。</p>\n<h3 id=\"表达式-表达式-表达式-表达式-1-2-3-4-5-而我们的判断条件并不符合所有的，只符合-1-2\"><a href=\"#表达式-表达式-表达式-表达式-1-2-3-4-5-而我们的判断条件并不符合所有的，只符合-1-2\" class=\"headerlink\" title=\"表达式( 表达式( 表达式( 表达式(1 + 2) + 3) + 4) + 5) 而我们的判断条件并不符合所有的，只符合 1 + 2\"></a>表达式( 表达式( 表达式( 表达式(1 + 2) + 3) + 4) + 5) 而我们的判断条件并不符合所有的，只符合 1 + 2</h3><blockquote>\n<p>// 判断表达式两边，是否都是数字</p>\n</blockquote>\n<blockquote>\n<p>if (t.isNumericLiteral(node.left) &amp;&amp; t.isNumericLiteral(node.right)) {}</p>\n</blockquote>\n<p>那么我们得改一改</p>\n<blockquote>\n<p>第一次计算 1 + 2 之后，我们会得到这样的表达式</p>\n</blockquote>\n<h3 id=\"表达式-表达式-表达式-3-3-4-5\"><a href=\"#表达式-表达式-表达式-3-3-4-5\" class=\"headerlink\" title=\"表达式( 表达式( 表达式(3 + 3) + 4) + 5)\"></a>表达式( 表达式( 表达式(3 + 3) + 4) + 5)</h3><p>其中 3 + 3 又符合了我们的条件， 我们通过向上递归的方式遍历父级节点又转换成这样:</p>\n<h3 id=\"表达式-表达式-6-4-5-表达式-10-5\"><a href=\"#表达式-表达式-6-4-5-表达式-10-5\" class=\"headerlink\" title=\"表达式( 表达式(6 + 4) + 5) 表达式(10 + 5)\"></a>表达式( 表达式(6 + 4) + 5) 表达式(10 + 5)</h3><blockquote>\n<p>15</p>\n</blockquote>\n<h3 id=\"如果上面的运算有结果的话\"><a href=\"#如果上面的运算有结果的话\" class=\"headerlink\" title=\"// 如果上面的运算有结果的话\"></a>// 如果上面的运算有结果的话</h3><blockquote>\n<p>if (result !== undefined) {</p>\n</blockquote>\n<blockquote>\n<p>// 把表达式节点替换成 number 字面量</p>\n</blockquote>\n<blockquote>\n<p>path.replaceWith(t.numericLiteral(result));</p>\n</blockquote>\n<blockquote>\n<p>let parentPath = path.parentPath;</p>\n</blockquote>\n<blockquote>\n<p>// 向上遍历父级节点</p>\n</blockquote>\n<blockquote>\n<p>parentPath &amp;&amp; visitor.BinaryExpression.call(this, parentPath);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>到这里，我们就得出了结果 const result = 15;</p>\n</blockquote>\n<h3 id=\"那么其他运算呢\"><a href=\"#那么其他运算呢\" class=\"headerlink\" title=\"那么其他运算呢\"></a>那么其他运算呢</h3><blockquote>\n<p>const result = 100 + 10 - 50&gt;&gt;&gt;const result = 60; const result = (100 / 2) + 50&gt;&gt;&gt;const result<br>= 100;</p>\n</blockquote>\n<blockquote>\n<p>const result = (((100 / 2) + 50 * 2) / 50) ** 2&gt;&gt;&gt;const result = 9;</p>\n</blockquote>\n<ul>\n<li><h3 id=\"你的-git-工作流是怎样的\"><a href=\"#你的-git-工作流是怎样的\" class=\"headerlink\" title=\"你的 git 工作流是怎样的?\"></a>你的 git 工作流是怎样的?</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>GitFlow 是由 Vincent Driessen 提出的一个 git 操作流程标准。包含如下几个关键分支：</p>\n<p>master 主分支 develop 主开发分支，包含确定即将发布的代码</p>\n<p>feature 新功能分支，一般一个新功能对应一个分支，对于功能的拆分需要比较合理， 以避免一些后面不必要的代码冲突</p>\n<p>release 发布分支，发布时候用的分支，一般测试时候发现的</p>\n<p>bug 在这个分支进行修复 hotfixhotfix 分支，紧急修 bug 的时候用GitFlow 的优势有如下几点：</p>\n<ul>\n<li>并行开发：GitFlow 可以很方便的实现并行开发：每个新功能都会建立一个新的 feature 分支，从而和已经完成的功能隔离开来，而且只有在新功能完成开发的情况下，其对应的 feature<br>分支才会合并到主开发分支上（也就是我们经常说的 develop 分支）。另外，如果你正在开发某个功能，同时又有一个新的功能需要开发，你只需要提交当前 feature 的代码，然后创建另外一个<br>feature 分支并完成新功能开发。然后再切回之前</li>\n</ul>\n<blockquote>\n<p>的 feature 分支即可继续完成之前功能的开发。</p>\n</blockquote>\n<ul>\n<li><p>协作开发：GitFlow 还支持多人协同开发，因为每个 feature 分支上改动的代码都只是为了让某个新的 feature 可以独立运行。同时我们也很容易知道每个人都在干啥。</p>\n</li>\n<li><p>发布阶段：当一个新 feature 开发完成的时候，它会被合并</p>\n</li>\n</ul>\n<blockquote>\n<p>到 develop 分支，这个分支主要用来暂时保存那些还没有发布的内容，所以如果需要再开发新的 feature，我们只需要从 develop 分支创建新分支，即可包含所有已经完成的 feature<br>。</p>\n</blockquote>\n<ul>\n<li>支持紧急修复：GitFlow 还包含了 hotfix 分支。这种类型的分支是从某个已经发布的 tag 上创建出来并做一个紧急的修复，而且这个紧急修复只影响这个已经发布的<br>tag，而不会影响到你正在开发的新 feature。</li>\n</ul>\n<p>然后就是 GitFlow 最经典的几张流程图，一定要理解：</p>\n<p><img src=\"media/image33.jpeg\"></p>\n<blockquote>\n<p>feature 分支都是从 develop 分支创建，完成后再合并到 develop 分支上， 等待发布。</p>\n</blockquote>\n<p><img src=\"media/image34.jpeg\"></p>\n<blockquote>\n<p>当需要发布时，我们从 develop 分支创建一个 release 分支</p>\n</blockquote>\n<p><img src=\"media/image35.jpeg\"></p>\n<p>然后这个 release 分支会发布到测试环境进行测试，如果发现问题就在这个分支直接进行修复。在所有问题修复之前，我们会不停的重复发布-&gt;测试-&gt;修复-&gt;重新发布-&gt;重新测试这个流程。</p>\n<blockquote>\n<p>发布结束后，这个 release 分支会合并到 develop 和 master 分支，从而保证不会有代码丢失。</p>\n</blockquote>\n<p><img src=\"media/image36.jpeg\"></p>\n<blockquote>\n<p>master 分支只跟踪已经发布的代码，合并到 master 上的 commit 只能来自 release 分支和 hotfix 分支。</p>\n</blockquote>\n<blockquote>\n<p>hotfix 分支的作用是紧急修复一些 Bug。</p>\n</blockquote>\n<blockquote>\n<p>它们都是从 master 分支上的某个 tag 建立，修复结束后再合并到 develop 和 master 分 支 上 。</p>\n</blockquote>\n<ul>\n<li><h3 id=\"rebase-与-merge-的区别\"><a href=\"#rebase-与-merge-的区别\" class=\"headerlink\" title=\"rebase 与 merge 的区别?\"></a>rebase 与 merge 的区别?</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>git rebase 和 git merge 一样都是用于从一个分支获取并且合并到当前分支. 假设一个场景,就是我们开发的[feature/todo]分支要合并到 master<br>主分支,那么用rebase 或者 merge 有什么不同呢?</p>\n<p><img src=\"media/image37.jpeg\"></p>\n<ul>\n<li><p>marge 特点：自动创建一个新的 commit 如果合并的时候遇到冲突，仅需要修改后重新 commit</p>\n</li>\n<li><p>优点：记录了真实的 commit 情况，包括每个分支的详情</p>\n</li>\n<li><p>缺点：因为每次 merge 会自动产生一个 merge commit，所以在使用一些 git 的 GUI tools，特别是 commit 比较频繁时，看到分支很杂乱。</p>\n</li>\n</ul>\n<blockquote>\n<p><img src=\"media/image38.jpeg\"></p>\n</blockquote>\n<ul>\n<li><p>rebase 特点：会合并之前的 commit 历史</p>\n</li>\n<li><p>优点：得到更简洁的项目历史，去掉了 merge commit</p>\n</li>\n<li><p>缺点：如果合并出现代码问题不容易定位，因为 re-write 了 history</p>\n</li>\n</ul>\n<p>因此,当需要保留详细的合并信息的时候建议使用 git merge，特别是需要将分支合并</p>\n<p>进入 master 分支时；当发现自己修改某个功能时，频繁进行了 git commit 提交时， 发现其实过多的提交信息没有必要时，可以尝试 git rebase.</p>\n<ul>\n<li><h3 id=\"git-reset、git-revert-和-git-checkout-有什么区别\"><a href=\"#git-reset、git-revert-和-git-checkout-有什么区别\" class=\"headerlink\" title=\"git reset、git revert 和 git checkout 有什么区别\"></a>git reset、git revert 和 git checkout 有什么区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>这个问题同样也需要先了解 git 仓库的三个组成部分：工作区（Working Directory）、暂存区（Stage）和历史记录区（History）。</p>\n<ul>\n<li><p>工作区：在 git 管理下的正常目录都算是工作区，我们平时的编辑工作都是在工作区完成</p>\n</li>\n<li><p>暂存区：临时区域。里面存放将要提交文件的快照</p>\n</li>\n<li><p>历史记录区：git commit 后的记录区三个区的转换关系以及转换所使用的命令：</p>\n</li>\n</ul>\n<blockquote>\n<p><img src=\"media/image39.jpeg\"></p>\n</blockquote>\n<p>git reset、git revert 和 git checkout 的共同点：用来撤销代码仓库中的某些更改。</p>\n<p>然后是不同点：</p>\n<p>首先，从 commit 层面来说：</p>\n<ul>\n<li><p>git reset 可以将一个分支的末端指向之前的一个 commit。然后再下次 git 执行垃圾回收的时候，会把这个 commit 之后的 commit 都扔掉。git reset<br>还支持三种标记，用来标记 reset 指令影响的范围：</p>\n<ul>\n<li><p>–mixed：会影响到暂存区和历史记录区。也是默认选项</p>\n</li>\n<li><p>–soft：只影响历史记录区</p>\n</li>\n<li><p>–hard：影响工作区、暂存区和历史记录区</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"注意：因为-git-reset-是直接删除-commit-记录，从而会影响到其他开发人员的分支，所以不要在公共分支（比如-develop）做这个操作\"><a href=\"#注意：因为-git-reset-是直接删除-commit-记录，从而会影响到其他开发人员的分支，所以不要在公共分支（比如-develop）做这个操作\" class=\"headerlink\" title=\"注意：因为 git reset 是直接删除 commit 记录，从而会影响到其他开发人员的分支，所以不要在公共分支（比如 develop）做这个操作\"></a>注意：因为 git reset 是直接删除 commit 记录，从而会影响到其他开发人员的分支，所以不要在公共分支（比如 develop）做这个操作</h3><ul>\n<li><p>git checkout 可以将 HEAD 移到一个新的分支，并更新工作目录。因为可能会覆盖本地的修改，所以执行这个指令之前，你需要 stash 或者 commit 暂存区和工作区的更改。</p>\n</li>\n<li><p>git revert 和 git reset 的目的是一样的，但是做法不同，它会以创建新的 commit 的方式来撤销 commit，这样能保留之前的 commit<br>历史，比较安全。另外，同样因为可能会覆盖本地的修改，所以执行这个指令之前，你需要 stash 或者 commit 暂存区和工作区的更改。</p>\n</li>\n</ul>\n<blockquote>\n<p>然后，从文件层面来说：</p>\n</blockquote>\n<ul>\n<li><p>git reset 只是把文件从历史记录区拿到暂存区，不影响工作区的内容，而且不支持 –mixed、–soft 和 –hard。</p>\n</li>\n<li><p>git checkout 则是把文件从历史记录拿到工作区，不影响暂存区的内容。</p>\n</li>\n<li><p>git revert 不支持文件层面的操作。</p>\n</li>\n</ul>\n<h3 id=\"版权声明：本文为取经猿作者的原创文章，转载请附上原文出处链接及本声明\"><a href=\"#版权声明：本文为取经猿作者的原创文章，转载请附上原文出处链接及本声明\" class=\"headerlink\" title=\"版权声明：本文为取经猿作者的原创文章，转载请附上原文出处链接及本声明\"></a>版权声明：本文为取经猿作者的原创文章，转载请附上原文出处链接及本声明</h3><blockquote>\n<p>原文链接：<a href=\"https://www.teaspect.com/detail/5623?pn=21\"><em>https://www.teaspect.com/detail/5623?pn=21</em></a></p>\n</blockquote>\n<ul>\n<li><h3 id=\"webpack-和-gulp-区别（模块化与流的区别）\"><a href=\"#webpack-和-gulp-区别（模块化与流的区别）\" class=\"headerlink\" title=\"webpack 和 gulp 区别（模块化与流的区别）\"></a>webpack 和 gulp 区别（模块化与流的区别）</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>gulp 强调的是前端开发的工作流程，我们可以通过配置一系列的 task，定义 task 处理的事务（例如文件压缩合并、雪碧图、启动 server、版本控制等），然后定义执行顺序，来让 gulp<br>执行这些 task，从而构建项目的整个前端开发流程。</p>\n<p>webpack 是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js 文件、css 文件等）都看成模块，通过 loader（加载器）和 plugins（插件）<br>对资源进行处理，打包成符合生产环境部署的前端资源。</p>\n<ol>\n<li><h2 id=\"Vue-框架\"><a href=\"#Vue-框架\" class=\"headerlink\" title=\"| Vue 框架\"></a>| Vue 框架</h2></li>\n</ol>\n<ul>\n<li><h3 id=\"有使用过-Vue-吗？说说你对-Vue-的理解\"><a href=\"#有使用过-Vue-吗？说说你对-Vue-的理解\" class=\"headerlink\" title=\"有使用过 Vue 吗？说说你对 Vue 的理解\"></a>有使用过 Vue 吗？说说你对 Vue 的理解</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Vue 是一个构建数据驱动的渐进性框架，它的目标是通过 API 实现响应数据绑定和视图更新。</p>\n<ul>\n<li><h3 id=\"说说-Vue-的优缺点\"><a href=\"#说说-Vue-的优缺点\" class=\"headerlink\" title=\"说说 Vue 的优缺点\"></a>说说 Vue 的优缺点</h3></li>\n</ul>\n<p>参考回答：</p>\n<blockquote>\n<p>优点：</p>\n</blockquote>\n<h3 id=\"1、数据驱动视图，对真实-dom-进行抽象出-virtual-dom（本质就是一个-js-对象），并配合-diff-算法、响应式和观察者、异步队列等手段以最小代价更新dom，渲染页面\"><a href=\"#1、数据驱动视图，对真实-dom-进行抽象出-virtual-dom（本质就是一个-js-对象），并配合-diff-算法、响应式和观察者、异步队列等手段以最小代价更新dom，渲染页面\" class=\"headerlink\" title=\"1、数据驱动视图，对真实 dom 进行抽象出 virtual dom（本质就是一个 js 对象），并配合 diff 算法、响应式和观察者、异步队列等手段以最小代价更新dom，渲染页面\"></a>1、数据驱动视图，对真实 dom 进行抽象出 virtual dom（本质就是一个 js 对象），并配合 diff 算法、响应式和观察者、异步队列等手段以最小代价更新dom，渲染页面</h3><blockquote>\n<p>2、组件化，组件用单文件的形式进行代码的组织编写，使得我们可以在一个文件里编写 html\\css（scoped 属性配置 css 隔离）\\js 并且配合 Vue-loader<br>之后，支持更强大的预处理器等功能</p>\n</blockquote>\n<blockquote>\n<p>3、强大且丰富的 API 提供一系列的 api 能满足业务开发中各类需求</p>\n</blockquote>\n<blockquote>\n<p>4、由于采用虚拟 dom，让 Vue ssr 先天就足</p>\n</blockquote>\n<blockquote>\n<p>5、生命周期钩子函数，选项式的代码组织方式，写熟了还是蛮顺畅的，但仍然有优化空间（Vue3 composition-api）</p>\n</blockquote>\n<blockquote>\n<p>6、生态好，社区活跃</p>\n</blockquote>\n<blockquote>\n<p>缺点：</p>\n</blockquote>\n<h3 id=\"1、由于底层基于-Object-defineProperty-实现响应式，而这个-api-本身不支持\"><a href=\"#1、由于底层基于-Object-defineProperty-实现响应式，而这个-api-本身不支持\" class=\"headerlink\" title=\"1、由于底层基于 Object.defineProperty 实现响应式，而这个 api 本身不支持\"></a>1、由于底层基于 Object.defineProperty 实现响应式，而这个 api 本身不支持</h3><blockquote>\n<p>IE8 及以下浏览器</p>\n</blockquote>\n<blockquote>\n<p>2、csr 的先天不足，首屏性能问题（白屏）</p>\n</blockquote>\n<blockquote>\n<p>3、由于百度等搜索引擎爬虫无法爬取 js 中的内容，故 spa 先天就对 seo 优化心有余力不足（谷歌的 puppeteer 就挺牛逼的，实现预渲染底层也是用到了这个工具）</p>\n</blockquote>\n<ul>\n<li><h3 id=\"Vue-和-React-有什么不同？使用场景分别是什么？\"><a href=\"#Vue-和-React-有什么不同？使用场景分别是什么？\" class=\"headerlink\" title=\"Vue 和 React 有什么不同？使用场景分别是什么？\"></a>Vue 和 React 有什么不同？使用场景分别是什么？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>1、Vue 是完整一套由官方维护的框架，核心库主要有由尤雨溪大神独自维护，而 React 是不要脸的书维护（很多库由社区维护），曾经一段时间很多人质疑 Vue 的后续维护性，似乎这并不是问题。</p>\n<p>2、Vue 上手简单，进阶式框架，白话说你可以学一点，就可以在你项目中去用一点， 你不一定需要一次性学习整个 Vue 才能去使用它，而 React，恐怕如果你这样会面对项目束手无策。</p>\n<p>3、语法上 Vue 并不限制你必须 es6+完全 js 形式编写页面，可以视图和 js 逻辑尽可能分离，减少很多人看不惯 React-jsx 的恶心嵌套，毕竟都是作为前端开发者，还是更习惯于 html<br>干净。</p>\n<p>4、很多人说 React 适合大型项目，适合什么什么，Vue 轻量级，适合移动端中小型项目，其实我想说，说这话的人是心里根本没点逼数，Vue 完全可以应对复杂的大型应用，甚至于说如果你 React<br>学的不是很好，写出来的东西或根本不如 Vue 写的，毕竟Vue 跟着官方文档撸就行，自有人帮你规范，而 React 比较懒散自由，可以自由发挥5、Vue 在国内人气明显胜过<br>React，这很大程度上得益于它的很多语法包括编程思维更符合国人思想。</p>\n<ul>\n<li><h3 id=\"什么是虚拟-DOM？\"><a href=\"#什么是虚拟-DOM？\" class=\"headerlink\" title=\"什么是虚拟 DOM？\"></a>什么是虚拟 DOM？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>虚拟 dom 是相对于浏览器所渲染出来的真实 dom 的，在 react，vue 等技术出现之</p>\n<p>前，我们要改变页面展示的内容只能通过遍历查询 dom 树的方式找到需要修改的 dom 然后修改样式行为或者结构，来达到更新 ui 的目的。</p>\n<p>这种方式相当消耗计算资源，因为每次查询 dom 几乎都需要遍历整颗 dom 树，如果建立一个与 dom 树对应的虚拟 dom 对象（ js 对象），以对象嵌套的方式来表示dom 树，那么每次 dom<br>的更改就变成了 js 对象的属性的更改，这样一来就能查找js 对象的属性变化要比查询 dom 树的性能开销小。</p>\n<ul>\n<li><h3 id=\"请描述下-vue-的生命周期是什么？\"><a href=\"#请描述下-vue-的生命周期是什么？\" class=\"headerlink\" title=\"请描述下 vue 的生命周期是什么？\"></a>请描述下 vue 的生命周期是什么？</h3></li>\n</ul>\n<p>参考回答：</p>\n<ul>\n<li>生命周期就是 vue 从开始创建到销毁的过程，分为四大步（创建，挂载，更新，销毁），每一步又分为两小步，如 beforeCreate， created。beforeCreate 前，也就是 new<br>Vue 的时候会初始化事件和生命周期；beforeCreate 和 created 之间会挂载 Data，绑定事件；接下来会根据 el 挂载页面元素，如果没有设置 el<br>则生命周期结束，直到手动挂载；el 挂载结束后，根据 templete/outerHTML(el)渲染页面；在beforeMount 前虚拟 DOM 已经创建完成；之后在 mounted 前，将<br>vm.$el 替换掉页面元素 el;mounted 将虚拟 dom 挂载到真实页面（此时页面已经全部渲染完成）；之后发生数据变化时触发 beforeUpdate 和updated<br>进行一些操作；最后主动调用销毁函数或者组件自动销毁时</li>\n</ul>\n<blockquote>\n<p>beforeDestroy，手动撤销监听事件，计时器等；destroyed 时仅存在Dom 节点，其他所有东西已自动销毁。这就是我所理解的 vue 的一个完整的生命周期。</p>\n</blockquote>\n<p>-</p>\n<p><img src=\"media/image40.jpeg\"></p>\n<ul>\n<li><h3 id=\"vue-如何监听键盘事件？\"><a href=\"#vue-如何监听键盘事件？\" class=\"headerlink\" title=\"vue 如何监听键盘事件？\"></a>vue 如何监听键盘事件？</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li>@keyup. 方 法</li>\n</ol>\n<h3 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"\"></a><template></h3><blockquote>\n<p>&lt;input ref=”myInput” type=”text” value=”hello world” autofocus @keyup.enter=”handleKey”&gt;</p>\n</blockquote>\n<blockquote>\n</template>\n</blockquote>\n<blockquote>\n<script>\n</blockquote>\n<blockquote>\n<p>export default {</p>\n</blockquote>\n<blockquote>\n<p>methods: {</p>\n</blockquote>\n<blockquote>\n<p>handleKey(e) {</p>\n</blockquote>\n<blockquote>\n<p>console.log(e)</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p></script></p>\n</blockquote>\n<ol start=\"2\">\n<li>addEventListener</li>\n</ol>\n<h3 id=\"-5\"><a href=\"#-5\" class=\"headerlink\" title=\"\"></a><script></h3><blockquote>\n<p>export default {</p>\n</blockquote>\n<blockquote>\n<p>mounted() {</p>\n</blockquote>\n<blockquote>\n<p>document.addEventListener(‘keyup’, this.handleKey)</p>\n</blockquote>\n<blockquote>\n<p>},</p>\n</blockquote>\n<blockquote>\n<p>beforeDestroy() {</p>\n</blockquote>\n<blockquote>\n<p>document.removeEventListener(‘keyup’, this.handleKey)</p>\n</blockquote>\n<blockquote>\n<p>},</p>\n</blockquote>\n<blockquote>\n<p>methods: {</p>\n</blockquote>\n<blockquote>\n<p>handleKey(e) {</p>\n</blockquote>\n<blockquote>\n<p>console.log(e)</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p></script><script></p>\n</blockquote>\n<blockquote>\n<p>export default {</p>\n</blockquote>\n<blockquote>\n<p>mounted() {</p>\n</blockquote>\n<blockquote>\n<p>document.addEventListener(‘keyup’, this.handleKey)</p>\n</blockquote>\n<blockquote>\n<p>},</p>\n</blockquote>\n<blockquote>\n<p>beforeDestroy() {</p>\n</blockquote>\n<blockquote>\n<p>document.removeEventListener(‘keyup’, this.handleKey)</p>\n</blockquote>\n<blockquote>\n<p>},</p>\n</blockquote>\n<blockquote>\n<p>methods: {</p>\n</blockquote>\n<blockquote>\n<p>handleKey(e) {</p>\n</blockquote>\n<blockquote>\n<p>console.log(e)</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p></script></p>\n</blockquote>\n<ul>\n<li><h3 id=\"watch-怎么深度监听对象变化\"><a href=\"#watch-怎么深度监听对象变化\" class=\"headerlink\" title=\"watch 怎么深度监听对象变化\"></a>watch 怎么深度监听对象变化</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>deep 设置为 true 就可以监听到对象的变化</p>\n<h3 id=\"let-vm-new-Vue\"><a href=\"#let-vm-new-Vue\" class=\"headerlink\" title=\"let vm=new Vue({\"></a>let vm=new Vue({</h3><blockquote>\n<p>el:”#first”,</p>\n</blockquote>\n<blockquote>\n<p>data:{msg:{name:’北京’}},</p>\n</blockquote>\n<blockquote>\n<p>watch:{</p>\n</blockquote>\n<blockquote>\n<p>msg:{</p>\n</blockquote>\n<blockquote>\n<p>handler (newMsg,oldMsg){</p>\n</blockquote>\n<blockquote>\n<p>console.log(newMsg);</p>\n</blockquote>\n<blockquote>\n<p>},</p>\n</blockquote>\n<blockquote>\n<p>immediate:true,</p>\n</blockquote>\n<blockquote>\n<p>deep:true</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<ul>\n<li><h3 id=\"删除数组用-delete-和-Vue-delete-有什么区别？\"><a href=\"#删除数组用-delete-和-Vue-delete-有什么区别？\" class=\"headerlink\" title=\"删除数组用 delete 和 Vue.delete 有什么区别？\"></a>删除数组用 delete 和 Vue.delete 有什么区别？</h3></li>\n</ul>\n<p>参考回答：</p>\n<ul>\n<li><p>delete：只是被删除数组成员变为 empty / undefined，其他元素键值不变</p>\n</li>\n<li><p>Vue.delete：直接删了数组成员，并改变了数组的键值（对象是响应式的，确保删除能触发更新视图，这个方法主要用于避开 Vue 不能检测到属性被删除的限制）</p>\n</li>\n<li><h3 id=\"watch-和计算属性有什么区别？\"><a href=\"#watch-和计算属性有什么区别？\" class=\"headerlink\" title=\"watch 和计算属性有什么区别？\"></a>watch 和计算属性有什么区别？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>通俗来讲，既能用 computed 实现又可以用 watch 监听来实现的功能，推荐用computed，重点在于 computed 的缓存功能</p>\n<p>computed 计算属性是用来声明式的描述一个值依赖了其它的值，当所依赖的值或者变量改变时，计算属性也会跟着改变；</p>\n<p>watch 监听的是已经在 data 中定义的变量，当该变量变化时，会触发 watch 中的方法。</p>\n<ul>\n<li><h3 id=\"Vue-双向绑定原理\"><a href=\"#Vue-双向绑定原理\" class=\"headerlink\" title=\"Vue 双向绑定原理\"></a>Vue 双向绑定原理</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Vue 数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。利用了Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)。</p>\n<ul>\n<li><h3 id=\"v-model-是什么？有什么用呢？\"><a href=\"#v-model-是什么？有什么用呢？\" class=\"headerlink\" title=\"v-model 是什么？有什么用呢？\"></a>v-model 是什么？有什么用呢？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>一则语法糖，相当于v-bind:value=”xxx” 和 @input，意思是绑定了一个 value 属性的值，子组件可对 value 属性监听，通过$emit(‘input’,<br>xxx)的方式给父组件通讯。自己实现v-model 方式的组件也是这样的思路。</p>\n<ul>\n<li><h3 id=\"axios-是什么？怎样使用它？怎么解决跨域的问题？\"><a href=\"#axios-是什么？怎样使用它？怎么解决跨域的问题？\" class=\"headerlink\" title=\"axios 是什么？怎样使用它？怎么解决跨域的问题？\"></a>axios 是什么？怎样使用它？怎么解决跨域的问题？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>axios 的是一种异步请求，用法和 ajax 类似，安装 npm install axios –save 即可使用，请求中包括 get,post,put, patch ,delete<br>等五种请求方式，解决跨域可以在请求头中添加 Access-Control-Allow-Origin，也可以在 index.js 文件中更改proxyTable 配置等解决跨域问题。</p>\n<ul>\n<li><h3 id=\"在-vue-项目中如何引入第三方库（比如-jQuery）？有哪些方法可以做到？\"><a href=\"#在-vue-项目中如何引入第三方库（比如-jQuery）？有哪些方法可以做到？\" class=\"headerlink\" title=\"在 vue 项目中如何引入第三方库（比如 jQuery）？有哪些方法可以做到？\"></a>在 vue 项目中如何引入第三方库（比如 jQuery）？有哪些方法可以做到？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>1、绝对路径直接引入</p>\n<p>在 index.html 中用 script 引入</p>\n<h3 id=\"-6\"><a href=\"#-6\" class=\"headerlink\" title=\"\"></a><script src=\"./static/jquery-1.12.4.js\"></script></h3><blockquote>\n<p>然 后 在 webpack 中 配 置 external externals: { ‘jquery’: ‘jQuery’ } 在组件中使用时 import</p>\n</blockquote>\n<blockquote>\n<p>import $ from ‘jquery’ 2 、在 webpack 中配置 alias</p>\n</blockquote>\n<h3 id=\"resolve-extensions-‘-js’-‘-vue’-‘-json’-alias-‘-’-resolve-‘src’-‘jquery’-resolve-‘static-jquery-1-12-4-js’-然后在组件中-import\"><a href=\"#resolve-extensions-‘-js’-‘-vue’-‘-json’-alias-‘-’-resolve-‘src’-‘jquery’-resolve-‘static-jquery-1-12-4-js’-然后在组件中-import\" class=\"headerlink\" title=\"resolve: { extensions: [‘.js’, ‘.vue’, ‘.json’], alias: { ‘@’: resolve(‘src’), ‘jquery’: resolve(‘static/jquery-1.12.4.js’) } } 然后在组件中 import\"></a>resolve: { extensions: [‘.js’, ‘.vue’, ‘.json’], alias: { ‘@’: resolve(‘src’), ‘jquery’: resolve(‘static/jquery-1.12.4.js’) } } 然后在组件中 import</h3><p>3、在 webpack 中配置 plugins</p>\n<h3 id=\"plugins-new-webpack-ProvidePlugin-‘jquery’\"><a href=\"#plugins-new-webpack-ProvidePlugin-‘jquery’\" class=\"headerlink\" title=\"plugins: [ new webpack.ProvidePlugin({ $: ‘jquery’ }) ]\"></a>plugins: [ new webpack.ProvidePlugin({ $: ‘jquery’ }) ]</h3><p>全局使用，但在使用 eslint 情况下会报错，需要在使用了 $ 的代码前添加 /* eslint-disable*/ 来去掉 ESLint 的检查。</p>\n<ul>\n<li><h3 id=\"说说-Vue-React-angularjs-jquery-的区别\"><a href=\"#说说-Vue-React-angularjs-jquery-的区别\" class=\"headerlink\" title=\"说说 Vue React angularjs jquery 的区别\"></a>说说 Vue React angularjs jquery 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>JQuery 与另外几者最大的区别是，JQuery 是事件驱动，其他两者是数据驱动。JQuery 业务逻辑和 UI 更改该混在一起， UI 里面还参杂这交互逻辑，让本来混乱的逻辑更加混乱。</p>\n<p>Angular，Vue 是双向绑定，而 React 不是其他还有设计理念上的区别等</p>\n<ul>\n<li>Vue3.0 里为什么要用 Proxy API 替代 defineProperty API？</li>\n</ul>\n<p>参考回答： 响应式优化。</p>\n<ol>\n<li>defineProperty API 的局限性最大原因是它只能针对单例属性做监听。</li>\n</ol>\n<p>Vue2.x 中的响应式实现正是基于 defineProperty 中的 descriptor，对 data 中的属性做了遍历 + 递归，为每个属性设置了 getter、setter。</p>\n<p>这也就是为什么 Vue 只能对 data 中预定义过的属性做出响应的原因，在 Vue 中使用下标的方式直接修改属性的值或者添加一个预先不存在的对象属性是无法做到 setter 监听的，这是<br>defineProperty 的局限性。</p>\n<ol start=\"2\">\n<li>Proxy API 的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，</li>\n</ol>\n<p>这就完全可以代理所有属性，将会带来很大的性能提升和更优的代码。</p>\n<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>\n<ol start=\"3\">\n<li>响应式是惰性的</li>\n</ol>\n<p>在 Vue.js 2.x 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的变化，就需要递归遍历这个对象，执行 Object.defineProperty<br>把每一层对象数据都变成响应式的，这无疑会有很大的性能消耗。</p>\n<p>在 Vue.js 3.0 中，使用 Proxy API 并不能监听到对象内部深层次的属性变化，因此它的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部属性才会</p>\n<p>变成响应式，简单的可以说是按需实现响应式，减少性能消耗。基础用法：</p>\n<p><img src=\"media/image41.jpeg\"></p>\n<ul>\n<li>Vue3.0 编译做了哪些优化？</li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li>生成 Block tree</li>\n</ol>\n<p><img src=\"media/image42.jpeg\"> Vue.js 2.x 的数据更新并触发重新渲染的粒度是组件级的，单个组件内部 需要遍历该组件的整个 vnode 树。在 2.0<br>里，渲染效率的快慢与组件大小成正相关：组件越大， 渲染效率越慢。并且，对于一些静态节点，又无数据更新，这些遍历都是性能浪费。Vue.js 3.0 做到了通过编译阶段对静态模板的分析，编译生成了<br>Block tree。 Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个 区块内部的节点结构是固定的，每个区块只需要追踪自身包含的动态节点。所以，在 3.0<br>里，渲染效率不再与模板大小成正相关，而是与模板中动态节点的数量成正相关。</p>\n<ol start=\"2\">\n<li>slot 编译优化</li>\n</ol>\n<p>Vue.js 2.x 中，如果有一个组件传入了 slot，那么每次父组件更新的时候，会强制使子组件 update，造成性能的浪费。</p>\n<p>Vue.js 3.0 优化了 slot 的生成，使得非动态 slot 中属性的更新只会触发子组件的更</p>\n<p>新。动态 slot 指的是在 slot 上面使用 v-if，v-for，动态 slot 名字等会导致 slot 产</p>\n<p>生运行时动态变化但是又无法被子组件 track 的操作。c. diff 算法优化</p>\n<ul>\n<li>Vue3.0 新特性 —— Composition API 与 React.js 中 Hooks 的异同点</li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li>React.js 中的 Hooks 基本使用</li>\n</ol>\n<p>React Hooks 允许你 “勾入” 诸如组件状态和副作用处理等 React 功能中。Hooks 只能用在函数组件中，并允许我们在不需要创建类的情况下将状态、副作用处理和更多东西带入组件中。</p>\n<p>React 核心团队奉上的采纳策略是不反对类组件，所以你可以升级 React 版本、在新组件中开始尝试 Hooks，并保持既有组件不做任何更改。</p>\n<p>案例：</p>\n<blockquote>\n<p><img src=\"media/image43.jpeg\"></p>\n</blockquote>\n<p>useState 和 useEffect 是 React Hooks 中的一些例子，使得函数组件中也能增加状态和运行副作用。</p>\n<p>我们也可以自定义一个 Hooks，它打开了代码复用性和扩展性的新大门。</p>\n<ol start=\"2\">\n<li>Vue Composition API 基本使用</li>\n</ol>\n<p>Vue Composition API 围绕一个新的组件选项 setup 而创建。setup() 为 Vue 组件提供了状态、计算值、watcher 和生命周期钩子。</p>\n<p>并没有让原来的 API（Options-based API）消失。允许开发者 结合使用新旧两种 API</p>\n<p>（向下兼容）。</p>\n<blockquote>\n<p><img src=\"media/image44.jpeg\"></p>\n</blockquote>\n<ol start=\"3\">\n<li>原理</li>\n</ol>\n<p>React hook 底层是基于链表实现，调用的条件是每次组件被 render 的时候都会顺序执行所有的 hooks。</p>\n<p>Vue hook 只会被注册调用一次，Vue 能避开这些麻烦的问题，原因在于它对数据的响</p>\n<p>应是基于 proxy 的，对数据直接代理观察。（这种场景下，只要任何一个更改 data 的</p>\n<p>地方，相关的 function 或者 template 都会被重新计算，因此避开了 React 可能遇到的性能上的问题）。</p>\n<p>React 中，数据更改的时候，会导致重新 render，重新 render 又会重新把 hooks 重新注册一次，所以 React 复杂程度会高一些。</p>\n<ul>\n<li><h3 id=\"Vue3-0-是如何变得更快的？（底层，源码）\"><a href=\"#Vue3-0-是如何变得更快的？（底层，源码）\" class=\"headerlink\" title=\"Vue3.0 是如何变得更快的？（底层，源码）\"></a>Vue3.0 是如何变得更快的？（底层，源码）</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li>diff 方法优化</li>\n</ol>\n<p>Vue2.x 中的虚拟 dom 是进行全量的对比。</p>\n<p>Vue3.0 中新增了静态标记（PatchFlag）：在与上次虚拟结点进行对比的时候，值对比带有 patch flag 的节点，并且可以通过 flag 的信息得知当前节点要对比的具体内容化。</p>\n<ol start=\"2\">\n<li>hoistStatic 静态提升</li>\n</ol>\n<p>Vue2.x : 无论元素是否参与更新，每次都会重新创建。</p>\n<p>Vue3.0 : 对不参与更新的元素，只会被创建一次，之后会在每次渲染时候被不停的复用。</p>\n<ol start=\"3\">\n<li>cacheHandlers 事件侦听器缓存</li>\n</ol>\n<p>默认情况下 onClick 会被视为动态绑定，所以每次都会去追踪它的变化但是因为是同一个函数，所以没有追踪变化，直接缓存起来复用即可。</p>\n<p>原作者姓名： 欧阳呀</p>\n<ul>\n<li><h3 id=\"vue-要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？\"><a href=\"#vue-要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？\" class=\"headerlink\" title=\"vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？\"></a>vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>按 钮 级 别 的 权 限 ：<br><a href=\"https://panjiachen.github.io/vue-element-admin-site/zh/guide/essentials/permission.html#%E6%8C%87%E4%BB%A4%E6%9D%83%E9%99%90\"><em>https://panjiachen.github.io/vue-element-admin-</em></a></p>\n<p><a href=\"https://panjiachen.github.io/vue-element-admin-site/zh/guide/essentials/permission.html#%E6%8C%87%E4%BB%A4%E6%9D%83%E9%99%90\"><em>site/zh/guide/essentials/permission.html#%E6%8C%87%E4%BB%A4%E6%9D%83%E9%99%</em></a><br><a href=\"https://panjiachen.github.io/vue-element-admin-site/zh/guide/essentials/permission.html#%E6%8C%87%E4%BB%A4%E6%9D%83%E9%99%90\"><em>90</em></a></p>\n<ul>\n<li><h3 id=\"vue-在-created-和-mounted-这两个生命周期中请求数据有什么区别呢？\"><a href=\"#vue-在-created-和-mounted-这两个生命周期中请求数据有什么区别呢？\" class=\"headerlink\" title=\"vue 在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？\"></a>vue 在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>看实际情况，一般在 created（或 beforeRouter） 里面就可以，如果涉及到需要页面加载完成之后的话就用 mounted。</p>\n<p>在 created 的时候，视图中的 html 并没有渲染出来，所以此时如果直接去操作 html</p>\n<p>的 dom 节点，一定找不到相关的元素</p>\n<p>而在 mounted 中，由于此时 html 已经渲染出来了，所以可以直接操作 dom 节点，（此时 document.getelementById 即可生效了）。</p>\n<ul>\n<li><h3 id=\"说说你对-proxy-的理解\"><a href=\"#说说你对-proxy-的理解\" class=\"headerlink\" title=\"说说你对 proxy 的理解\"></a>说说你对 proxy 的理解</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>vue 的数据劫持有两个缺点:</p>\n<p>1、无法监听通过索引修改数组的值的变化</p>\n<p>2、无法监听 object 也就是对象的值的变化所以 vue2.x 中才会有$set 属性的存在</p>\n<p>proxy 是 es6 中推出的新 api，可以弥补以上两个缺点，所以 vue3.x 版本用 proxy 替换 object.defineproperty。</p>\n<ol>\n<li><h2 id=\"React-框架\"><a href=\"#React-框架\" class=\"headerlink\" title=\"| React 框架\"></a>| React 框架</h2></li>\n</ol>\n<ul>\n<li><h3 id=\"angularJs-和-React-区别\"><a href=\"#angularJs-和-React-区别\" class=\"headerlink\" title=\"angularJs 和 React 区别\"></a>angularJs 和 React 区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>React 对比 Angular 是思想上的转变，它也并不是一个库，是一种开发理念，组件化， 分治的管理，数据与 view 的一体化。它只有一个中心,发出状态，渲染 view，对于虚拟 dom<br>它并没有提高渲染页面的性能，它提供更多的是利用 jsx 便捷生成 dom 元素， 利用组件概念进行分治管理页面每个部分(例如 header section footer slider)</p>\n<ul>\n<li><h3 id=\"redux-中间件\"><a href=\"#redux-中间件\" class=\"headerlink\" title=\"redux 中间件\"></a>redux 中间件</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>中间件提供第三方插件的模式，自定义拦截 action -&gt; reducer 的过程。变为action -&gt; middlewares -&gt; reducer<br>。这种机制可以让我们改变数据流，实现如异步action ，action 过滤，日志输出，异常报告等功能。</p>\n<p>常见的中间件： redux-logger：提供日志输出；redux-thunk：处理异步操作；</p>\n<p>redux-promise：处理异步操作；actionCreator 的返回值是 promise</p>\n<ul>\n<li><h3 id=\"redux-有什么缺点\"><a href=\"#redux-有什么缺点\" class=\"headerlink\" title=\"redux 有什么缺点\"></a>redux 有什么缺点</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>一个组件所需要的数据，必须由父组件传过来，而不能像 flux 中直接从 store 取。</p>\n</li>\n<li><p>当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新render，可能会有效率影响，或者需要写复杂的 shouldComponentUpdate 进行判断。</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"React-组件的划分业务组件技术组件？\"><a href=\"#React-组件的划分业务组件技术组件？\" class=\"headerlink\" title=\"React 组件的划分业务组件技术组件？\"></a>React 组件的划分业务组件技术组件？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>根据组件的职责通常把组件分为 UI 组件和容器组件。UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。两者通过 React-Redux 提供 connect 方法联系起来。</p>\n<ul>\n<li><h3 id=\"React-生命周期函数\"><a href=\"#React-生命周期函数\" class=\"headerlink\" title=\"React 生命周期函数\"></a>React 生命周期函数</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>一、初始化阶段：</p>\n<p>getDefaultProps:获取实例的默认属性</p>\n<p>getInitialState:获取每个实例的初始化状态</p>\n<p>componentWillMount：组件即将被装载、渲染到页面上</p>\n<p>render:组件在这里生成虚拟的 DOM 节点</p>\n<p>componentDidMount:组件真正在被装载之后</p>\n<p>二、运行中状态：</p>\n<p>componentWillReceiveProps:组件将要接收到属性的时候调用</p>\n<p>shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）</p>\n<p>componentWillUpdate:组件即将更新不能修改属性和状态</p>\n<p>render:组件重新描绘</p>\n<p>componentDidUpdate:组件已经更新</p>\n<p>三、销毁阶段：</p>\n<p>componentWillUnmount:组件即将销毁</p>\n<ul>\n<li><h3 id=\"React-性能优化是哪个周期函数？\"><a href=\"#React-性能优化是哪个周期函数？\" class=\"headerlink\" title=\"React 性能优化是哪个周期函数？\"></a>React 性能优化是哪个周期函数？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate<br>方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。</p>\n<ul>\n<li><h3 id=\"为什么虚拟-dom-会提高性能\"><a href=\"#为什么虚拟-dom-会提高性能\" class=\"headerlink\" title=\"为什么虚拟 dom 会提高性能?\"></a>为什么虚拟 dom 会提高性能?</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。</p>\n<p>具体实现步骤如下：</p>\n<ol>\n<li>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM</li>\n</ol>\n<p>树，插到文档当中；</p>\n<ol start=\"2\">\n<li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较， 记录两棵树差异；</li>\n</ol>\n<p>把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。</p>\n<ul>\n<li><h3 id=\"diff-算法\"><a href=\"#diff-算法\" class=\"headerlink\" title=\"diff 算法?\"></a>diff 算法?</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>把树形结构按照层级分解，只比较同级元素。</p>\n</li>\n<li><p>给列表结构的每个单元添加唯一的 key 属性，方便比较。</p>\n</li>\n<li><p>React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）</p>\n</li>\n<li><p>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.</p>\n</li>\n</ol>\n<p>到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.</p>\n<ol start=\"6\">\n<li>选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。</li>\n</ol>\n<ul>\n<li><h3 id=\"React-性能优化方案\"><a href=\"#React-性能优化方案\" class=\"headerlink\" title=\"React 性能优化方案\"></a>React 性能优化方案</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>重写 shouldComponentUpdate 来避免不必要的 dom 操作。</p>\n</li>\n<li><p>使用 production 版本的 React.js。</p>\n</li>\n<li><p>使用 key 来帮助 React 识别列表中所有子组件的最小变化</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"简述-flux-思想\"><a href=\"#简述-flux-思想\" class=\"headerlink\" title=\"简述 flux 思想\"></a>简述 flux 思想</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Flux 的最大特点，就是数据的”单向流动”。</p>\n<ol>\n<li><p>用户访问 View</p>\n</li>\n<li><p>View 发出用户的 Action</p>\n</li>\n<li><p>Dispatcher 收到 Action，要求 Store 进行相应的更新</p>\n</li>\n<li><p>Store 更新后，发出一个”change”事件</p>\n</li>\n<li><p>View 收到”change”事件后，更新页面</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"React-项目用过什么脚手架？Mern-Yeoman\"><a href=\"#React-项目用过什么脚手架？Mern-Yeoman\" class=\"headerlink\" title=\"React 项目用过什么脚手架？Mern? Yeoman?\"></a>React 项目用过什么脚手架？Mern? Yeoman?</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Mern：MERN 是脚手架的工具，它可以很容易地使用 Mongo, Express, React and NodeJS 生成同构 JS<br>应用。它最大限度地减少安装时间，并得到您使用的成熟技术来加速开发。</p>\n<ul>\n<li><h3 id=\"你了解-React-吗？\"><a href=\"#你了解-React-吗？\" class=\"headerlink\" title=\"你了解 React 吗？\"></a>你了解 React 吗？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>了解，React 是 facebook 搞出来的一个轻量级的组件库，用于解决前端视图层的一些问题，就是 MVC 中V 层的问题，它内部的 Instagram 网站就是用 React 搭建的。</p>\n<ul>\n<li><h3 id=\"React-解决了什么问题？\"><a href=\"#React-解决了什么问题？\" class=\"headerlink\" title=\"React 解决了什么问题？\"></a>React 解决了什么问题？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>解决了三个问题： 1.组件复用问题， 2.性能问题，3.兼容性问题：</p>\n<ul>\n<li><h3 id=\"React-的协议？\"><a href=\"#React-的协议？\" class=\"headerlink\" title=\"React 的协议？\"></a>React 的协议？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>React 遵循的协议是“BSD 许可证 + 专利开源协议”，这个协议比较奇葩，如果你的产品跟 facebook 没有竞争关系，你可以自由的使用 React，但是如果有竞争关系，你的 React<br>的使用许可将会被取消</p>\n<ul>\n<li><h3 id=\"了解-shouldComponentUpdate-吗？\"><a href=\"#了解-shouldComponentUpdate-吗？\" class=\"headerlink\" title=\"了解 shouldComponentUpdate 吗？\"></a>了解 shouldComponentUpdate 吗？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>React 虚拟 dom 技术要求不断的将 dom 和虚拟 dom 进行 diff 比较，如果 dom 树比价大，这种比较操作会比较耗时，因此 React 提供了<br>shouldComponentUpdate 这种补丁函数，如果对于一些变化，如果我们不希望某个组件刷新，或者刷新后跟原来其实一样，就可以使用这个函数直接告诉 React，省去 diff<br>操作，进一步的提高了效率。</p>\n<ul>\n<li><h3 id=\"React-的工作原理？\"><a href=\"#React-的工作原理？\" class=\"headerlink\" title=\"React 的工作原理？\"></a>React 的工作原理？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>React 会创建一个虚拟 DOM(virtual DOM)。当一个组件中的状态改变时，React 首先会通过 “diffing” 算法来标记虚拟 DOM<br>中的改变，第二步是调节(reconciliation)，会用 diff 的结果来更新 DOM。</p>\n<ul>\n<li><h3 id=\"使用-React-有何优点？\"><a href=\"#使用-React-有何优点？\" class=\"headerlink\" title=\"使用 React 有何优点？\"></a>使用 React 有何优点？</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>只需查看 render 函数就会很容易知道一个组件是如何被渲染的</p>\n</li>\n<li><p>JSX 的引入，使得组件的代码更加可读，也更容易看懂组件的布局，或者组件之间是如何互相引用的</p>\n</li>\n<li><p>支持服务端渲染，这可以改进 SEO 和性能</p>\n</li>\n<li><p>易于测试</p>\n</li>\n<li><p>React 只关注 View 层，所以可以和其它任何框架(如 Backbone.js, Angular.js)一起使用</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"展示组件-Presentational-component-和容器组件-Container-component-之间有何不同？\"><a href=\"#展示组件-Presentational-component-和容器组件-Container-component-之间有何不同？\" class=\"headerlink\" title=\"展示组件(Presentational component)和容器组件(Container component)之间有何不同？\"></a>展示组件(Presentational component)和容器组件(Container component)之间有何不同？</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。</p>\n</li>\n<li><p>容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 Flux<br>actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"类组件-Class-component-和函数式组件-Functional-component-之间有何不同？\"><a href=\"#类组件-Class-component-和函数式组件-Functional-component-之间有何不同？\" class=\"headerlink\" title=\"类组件(Class component)和函数式组件(Functional component)之间有何不同？\"></a>类组件(Class component)和函数式组件(Functional component)之间有何不同？</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态</p>\n</li>\n<li><p>当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 ‘无状态组件(stateless<br>component)’，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"组件的-状态-state-和属性-props-之间有何不同？\"><a href=\"#组件的-状态-state-和属性-props-之间有何不同？\" class=\"headerlink\" title=\"(组件的)状态(state)和属性(props)之间有何不同？\"></a>(组件的)状态(state)和属性(props)之间有何不同？</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。</p>\n</li>\n<li><p>Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的<br>props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据–回调函数也可以通过 props 传递。</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"应该在-React-组件的何处发起-Ajax-请求？\"><a href=\"#应该在-React-组件的何处发起-Ajax-请求？\" class=\"headerlink\" title=\"应该在 React 组件的何处发起 Ajax 请求？\"></a>应该在 React 组件的何处发起 Ajax 请求？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>在 React 组件中，应该在 componentDidMount 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到<br>DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在<br>componentDidMount 中发起网络请求将保证这有一个组件可以更新了。</p>\n<ul>\n<li><h3 id=\"在-React-中，refs-的作用是什么？\"><a href=\"#在-React-中，refs-的作用是什么？\" class=\"headerlink\" title=\"在 React 中，refs 的作用是什么？\"></a>在 React 中，refs 的作用是什么？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Refs 可以用于获取一个 DOM 节点或者 React 组件的引用。何时使用 refs 的好的示例有管理焦点/文本选择，触发命令动画，或者和第三方 DOM 库集成。你应该避免使用 String<br>类型的 Refs 和内联的 ref 回调。Refs 回调是 React 所推荐的。</p>\n<ul>\n<li><h3 id=\"何为高阶组件-higher-order-component-？\"><a href=\"#何为高阶组件-higher-order-component-？\" class=\"headerlink\" title=\"何为高阶组件(higher order component)？\"></a>何为高阶组件(higher order component)？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC 最好的方式是共享<br>React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。</p>\n<ul>\n<li><h3 id=\"使用箭头函数-arrow-functions-的优点是什么？\"><a href=\"#使用箭头函数-arrow-functions-的优点是什么？\" class=\"headerlink\" title=\"使用箭头函数(arrow functions)的优点是什么？\"></a>使用箭头函数(arrow functions)的优点是什么？</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li>作用域安全：在箭头函数之前，每一个新创建的函数都有定义自身的 this 值(在构造函数中是新对象；在严格模式下，函数调用中的 this 是未定义的；如果函数被</li>\n</ol>\n<p>称为“对象方法”，则为基础对象等)，但箭头函数不会，它会使用封闭执行上下文的this 值。</p>\n<ol start=\"2\">\n<li><p>简单：箭头函数易于阅读和书写</p>\n</li>\n<li><p>清晰：当一切都是一个箭头函数，任何常规函数都可以立即用于定义作用域。开发者总是可以查找 next-higher 函数语句，以查看 this 的值</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"为什么建议传递给-setState-的参数是一个-callback-而不是一个对象？\"><a href=\"#为什么建议传递给-setState-的参数是一个-callback-而不是一个对象？\" class=\"headerlink\" title=\"为什么建议传递给 setState 的参数是一个 callback 而不是一个对象？\"></a>为什么建议传递给 setState 的参数是一个 callback 而不是一个对象？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state。</p>\n<ul>\n<li><h3 id=\"除了在构造函数中绑定-this，还有其它方式吗？\"><a href=\"#除了在构造函数中绑定-this，还有其它方式吗？\" class=\"headerlink\" title=\"除了在构造函数中绑定 this，还有其它方式吗？\"></a>除了在构造函数中绑定 this，还有其它方式吗？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>可以使用属性初始值设定项(property initializers)来正确绑定回调，create- React-app<br>也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。</p>\n<ul>\n<li><h3 id=\"怎么阻止组件的渲染？\"><a href=\"#怎么阻止组件的渲染？\" class=\"headerlink\" title=\"怎么阻止组件的渲染？\"></a>怎么阻止组件的渲染？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>在组件的 render 方法中返回 null 并不会影响触发组件的生命周期方法</p>\n<ul>\n<li><h3 id=\"当渲染一个列表时，何为-key？设置-key-的目的是什么？\"><a href=\"#当渲染一个列表时，何为-key？设置-key-的目的是什么？\" class=\"headerlink\" title=\"当渲染一个列表时，何为 key？设置 key 的目的是什么？\"></a>当渲染一个列表时，何为 key？设置 key 的目的是什么？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Keys 会有助于 React 识别哪些 items 改变了，被添加了或者被移除了。Keys 应该被赋予数组内的元素以赋予(DOM)元素一个稳定的标识，选择一个 key<br>的最佳方法是使用一个字符串，该字符串能惟一地标识一个列表项。很多时候你会使用数据中的 IDs 作为 keys，当你没有稳定的 IDs 用于被渲染的 items 时，可以使用项目索引作为渲染项的<br>key，但这种方式并不推荐，如果 items 可以重新排序，就会导致 re- render 变慢</p>\n<ul>\n<li>(在构造函数中)调用 super(props) 的目的是什么？</li>\n</ul>\n<p>参考回答：</p>\n<p>在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在constructor 中调用 super()。传递 props 给 super()<br>的原因则是便于(在子类中) 能在 constructor 访问 this.props。</p>\n<ul>\n<li><h3 id=\"何为-JSX-？\"><a href=\"#何为-JSX-？\" class=\"headerlink\" title=\"何为 JSX ？\"></a>何为 JSX ？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>JSX 是 JavaScript 语法的一种语法扩展，并拥有 JavaScript 的全部功能。JSX 生产 React “元素”，你可以将任何的 JavaScript<br>表达式封装在花括号里，然后将其嵌入到 JSX 中。在编译完成之后，JSX 表达式就变成了常规的 JavaScript 对象，这意味着你可以在 if 语句和 for 循环内部使用<br>JSX，将它赋值给变量，接受它作为参数，并从函数中返回它。</p>\n","site":{"data":{}},"wordcount":113543,"excerpt":"","more":"<h2 id=\"HTTP-HTML-浏览器\"><a href=\"#HTTP-HTML-浏览器\" class=\"headerlink\" title=\"| HTTP/HTML/浏览器\"></a>| HTTP/HTML/浏览器</h2><h3 id=\"说一下-http-和-https\"><a href=\"#说一下-http-和-https\" class=\"headerlink\" title=\"说一下 http 和 https\"></a>说一下 http 和 https</h3><p>参考回答：</p>\n<p>https 的 SSL 加密是在传输层实现的。(1)http 和 https 的基本概念</p>\n<p>http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW<br>服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p>\n<p>https: 是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL</p>\n<p>层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。</p>\n<p>https 协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。</p>\n<ol start=\"2\">\n<li>http 和 https 的区别？</li>\n</ol>\n<p>http 传输的数据都是未加密的，也就是明文的，网景公司设置了 SSL 协议来对 http 协议传输的数据进行加密处理，简单来说 https 协议是由 http 和 ssl<br>协议构建的可进行加密传输和身份认证的网络协议，比 http 协议的安全性更高。</p>\n<p>主要的区别如下：</p>\n<p>Https 协议需要 ca 证书，费用较高。</p>\n<p>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。</p>\n<p>使用不同的链接方式，端口也不同，一般而言，http 协议的端口为 80，https 的端口为 443</p>\n<p>http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。</p>\n<ol start=\"3\">\n<li>https 协议的工作原理</li>\n</ol>\n<p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤，如图所示。客户使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。</p>\n<p>web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。</p>\n<p>客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。</p>\n<p>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</p>\n<p>web 服务器通过自己的私钥解密出会话密钥。</p>\n<p>web 服务器通过会话密钥加密与客户端之间的通信。(4)https 协议的优点</p>\n<p>使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>\n<p>HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比http 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。HTTPS<br>是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p>\n<p>谷歌曾在 2014 年 8 月份调整搜索引擎算法，并称“比起同等 HTTP 网站，采用 HTTPS</p>\n<p>加密的网站在搜索结果中的排名将会更高”。(5)https 协议的缺点</p>\n<p>https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。https 缓存不如 http 高效，会增加数据开销。</p>\n<p>SSL 证书也需要钱，功能越强大的证书费用越高。</p>\n<p>SSL 证书需要绑定 IP，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。</p>\n<h3 id=\"tcp-三次握手，一句话概括\"><a href=\"#tcp-三次握手，一句话概括\" class=\"headerlink\" title=\"tcp 三次握手，一句话概括\"></a>tcp 三次握手，一句话概括</h3><p>参考回答：</p>\n<p>客户端和服务端都需要直到各自可收发，因此需要三次握手。简化三次握手：</p>\n<p><img width=\"487\" alt=\"2018-07-10 3 42 11\"\nsrc=\"[_https://user-_](https://user-images.githubusercontent.com/17233651/42496289-1c6d668a-8458-11e8-98b3-65db50f64d48.png)\n[_images.githubusercontent.com/17233651/42496289-1c6d668a-8458-11e8-98b3-_](https://user-images.githubusercontent.com/17233651/42496289-1c6d668a-8458-11e8-98b3-65db50f64d48.png)\n[_65db50f64d48.png_](https://user-images.githubusercontent.com/17233651/42496289-1c6d668a-8458-11e8-98b3-65db50f64d48.png)\"></p>\n<p>从图片可以得到三次握手可以简化为：C 发起请求连接S 确认，也发起连接C 确认我们再看看每次握手的作用：第一次握手：S 只可以确认 自己可以接受C 发送的报文段第二次握手：C 可以确认 S<br>收到了自己发送的报文段，并且可以确认 自己可以接受S 发送的报文段第三次握手：S 可以确认 C 收到了自己发送的报文段</p>\n<ul>\n<li><h3 id=\"TCP-和-UDP-的区别\"><a href=\"#TCP-和-UDP-的区别\" class=\"headerlink\" title=\"TCP 和 UDP 的区别\"></a>TCP 和 UDP 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>TCP 是面向连接的，udp 是无连接的即发送数据前不需要先建立链接。</p>\n</li>\n<li><p>TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失， 不重复，且按序到达;UDP 尽最大努力交付，即不保证可靠交付。 并且因为 tcp 可靠，<br>面向连接，不会丢失数据因此适合大数据量的交换。</p>\n</li>\n<li><p>TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低</p>\n</li>\n</ol>\n<p>（因此会出现丢包，对实时的应用比如 IP 电话和视频会议等）。</p>\n<ol start=\"4\">\n<li><p>TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多。</p>\n</li>\n<li><p>TCP 的首部较大为 20 字节，而 UDP 只有 8 字节。</p>\n</li>\n<li><p>TCP 是面向连接的可靠性传输，而 UDP 是不可靠的。</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"WebSocket-的实现和应用\"><a href=\"#WebSocket-的实现和应用\" class=\"headerlink\" title=\"WebSocket 的实现和应用\"></a>WebSocket 的实现和应用</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li>什么是 WebSocket?</li>\n</ol>\n<p>WebSocket 是 HTML5 中的协议，支持持久连续，http 协议不支持持久性连接。Http1.0 和 HTTP1.1 都不支持持久性的链接，HTTP1.1 中的 keep-alive，将多个<br>http 请求合并为 1 个</p>\n<ol start=\"2\">\n<li>WebSocket 是什么样的协议，具体有什么优点？</li>\n</ol>\n<p>HTTP 的生命周期通过 Request 来界定，也就是 Request 一个 Response，那么在Http1.0 协议中，这次 Http 请求就结束了。在 Http1.1<br>中进行了改进，是的有一个connection：Keep-alive，也就是说，在一个 Http 连接中，可以发送多个 Request， 接收多个 Response。但是必须记住，在 Http 中一个<br>Request 只能对应有一个Response，而且这个 Response 是被动的，不能主动发起。</p>\n<p>WebSocket 是基于 Http 协议的，或者说借用了 Http 协议来完成一部分握手，在握手阶段与 Http 是相同的。我们来看一个 websocket 握手协议的实现，基本是 2 个属性，<br>upgrade，connection。</p>\n<p>基本请求如下：</p>\n<h3 id=\"GET-chat-HTTP-1-1\"><a href=\"#GET-chat-HTTP-1-1\" class=\"headerlink\" title=\"GET /chat HTTP/1.1\"></a>GET /chat HTTP/1.1</h3><blockquote>\n<p>Host: server.example.com Upgrade: websocket Connection: Upgrade</p>\n</blockquote>\n<blockquote>\n<p>Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== Sec-WebSocket-Protocol: chat, superchat<br>Sec-WebSocket-Version: 13</p>\n</blockquote>\n<blockquote>\n<p><a href=\"http://example.com/\">Origin: http://example.com</a></p>\n</blockquote>\n<p>多了下面 2 个属性：</p>\n<p>告诉服务器发送的是 websocket</p>\n<ul>\n<li><h3 id=\"HTTP-请求的方式，HEAD-方式\"><a href=\"#HTTP-请求的方式，HEAD-方式\" class=\"headerlink\" title=\"HTTP 请求的方式，HEAD 方式\"></a>HTTP 请求的方式，HEAD 方式</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>head：类似于 get 请求，只不过返回的响应中没有具体的内容，用户获取报头options：允许客户端查看服务器的性能，比如说服务器支持的请求方式等等。</p>\n<ul>\n<li><h3 id=\"一个图片-url-访问后直接下载怎样实现？\"><a href=\"#一个图片-url-访问后直接下载怎样实现？\" class=\"headerlink\" title=\"一个图片 url 访问后直接下载怎样实现？\"></a>一个图片 url 访问后直接下载怎样实现？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>请求的返回头里面，用于浏览器解析的重要参数就是 OSS 的 API 文档里面的返回 http</p>\n<p>头，决定用户下载行为的参数。下载的情况下：</p>\n<ol>\n<li><p>x-oss-object-type: Normal</p>\n</li>\n<li><p>x-oss-request-id: 598D5ED34F29D01FE2925F41</p>\n</li>\n<li><p>x-oss-storage-class: Standard</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"说一下-web-Quality（无障碍）\"><a href=\"#说一下-web-Quality（无障碍）\" class=\"headerlink\" title=\"说一下 web Quality（无障碍）\"></a>说一下 web Quality（无障碍）</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>能够被残障人士使用的网站才能称得上一个易用的（易访问的）网站。残障人士指的是那些带有残疾或者身体不健康的用户。</p>\n<p>使用 alt 属性：</p>\n<img src=\"person.jpg\" alt=\"this is a person\"/>\n\n<p>有时候浏览器会无法显示图像。具体的原因有： 用户关闭了图像显示</p>\n<p>浏览器是不支持图形显示的迷你浏览器</p>\n<p>浏览器是语音浏览器（供盲人和弱视人群使用）</p>\n<p>如果您使用了 alt 属性，那么浏览器至少可以显示或读出有关图像的描述。</p>\n<ul>\n<li><h3 id=\"几个很实用的-BOM-属性对象方法\"><a href=\"#几个很实用的-BOM-属性对象方法\" class=\"headerlink\" title=\"几个很实用的 BOM 属性对象方法?\"></a>几个很实用的 BOM 属性对象方法?</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>什么是 Bom? Bom 是浏览器对象。有哪些常用的 Bom 属性呢？ (1)location 对象</p>\n<p>location.href– 返 回 或 设 置 当 前 文 档 的 URL location.search – 返回 URL 中的查询字符串部分。例</p>\n<p>如<br><a href=\"http://www.dreamdu.com/dreamdu.php?id=5&name=dreamdu\"><em>http://www.dreamdu.com/dreamdu.php?id=5&amp;name=dreamdu</em></a><br>返回包括(?)后面的内容?id=5&amp;name=dreamdu</p>\n<p>location.hash – 返回 URL#后面的内容，如果没有#，返回空location.host – 返回 URL 中的域名部分，例如<br><a href=\"http://www.dreamdu.com/\"><em>www.dreamdu.com</em></a> location.hostname – 返回 URL 中的主域名部分，例如 dreamdu.com<br>location.pathname – 返回 URL 的域名后的部分。例</p>\n<p>如 <a href=\"http://www.dreamdu.com/xhtml/\"><em>http://www.dreamdu.com/xhtml/</em></a> 返回/xhtml/ location.port – 返回 URL<br>中的端口部分。例</p>\n<p>如 <em><a href=\"http://www.dreamdu.com:8080/xhtml/\">http://www.dreamdu.com:8080/xhtml/</a></em> 返 回 8080</p>\n<p>location.protocol – 返回 URL 中的协议部分。例</p>\n<p>如 <em><a href=\"http://www.dreamdu.com:8080/xhtml/\">http://www.dreamdu.com:8080/xhtml/</a></em> 返回(//)前面的内容 http: location.assign – 设置当前文档的 URL</p>\n<p>location.replace() – 设置当前文档的 URL，并且在 history 对象的地址列表中移除这个 URL location.replace(url);</p>\n<p>location.reload() – 重载当前页面(2)history 对象</p>\n<p>history.go() – 前进或后退指定的页面数 history.go(num); history.back() – 后退一页</p>\n<p>history.forward() – 前进一页(3)Navigator 对象</p>\n<p>navigator.userAgent – 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)</p>\n<p>navigator.cookieEnabled – 返回浏览器是否支持(启用)cookie</p>\n<ul>\n<li><h3 id=\"说一下-HTML5-drag-api\"><a href=\"#说一下-HTML5-drag-api\" class=\"headerlink\" title=\"说一下 HTML5 drag api\"></a>说一下 HTML5 drag api</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发，。darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。dragend：事件主体是被拖放元素，在整个拖放操作结束时触发</p>\n<ul>\n<li><h3 id=\"说一下-http2-0\"><a href=\"#说一下-http2-0\" class=\"headerlink\" title=\"说一下 http2.0\"></a>说一下 http2.0</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>首先补充一下，http 和 https 的区别，相比于 http,https 是基于 ssl 加密的 http 协议</p>\n<p>简要概括：http2.0 是基于 1999 年发布的 http1.0 之后的首次更新。</p>\n<p>提升访问速度（可以对于，请求资源所需时间更少，访问速度更快，相比 http1.0） 允许多路复用：多路复用允许同时通过单一的 HTTP/2 连接发送多重请求-响应信息。改善了：在 http1.1<br>中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。</p>\n<p>二进制分帧：HTTP2.0 会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码</p>\n<p>首部压缩</p>\n<p>服务器端推送</p>\n<ul>\n<li><h3 id=\"补充-400-和-401、403-状态码\"><a href=\"#补充-400-和-401、403-状态码\" class=\"headerlink\" title=\"补充 400 和 401、403 状态码\"></a>补充 400 和 401、403 状态码</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>(1)400 状态码：请求无效产生原因：</p>\n<p>前端提交数据的字段名称和字段类型与后台的实体没有保持一致</p>\n<p>前端提交到后台的数据应该是 json 字符串类型，但是前端没有将对象 JSON.stringify</p>\n<p>转化成字符串。解决方法：</p>\n<p>对照字段的名称，保持一致性</p>\n<p>将 obj 对象通过 JSON.stringify 实现序列化(2)401 状态码：当前请求需要用户验证</p>\n<ol start=\"3\">\n<li>403 状态码：服务器已经得到请求，但是拒绝执行</li>\n</ol>\n<ul>\n<li><h3 id=\"fetch-发送-2-次请求的原因\"><a href=\"#fetch-发送-2-次请求的原因\" class=\"headerlink\" title=\"fetch 发送 2 次请求的原因\"></a>fetch 发送 2 次请求的原因</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>fetch 发送 post 请求的时候，总是发送 2 次，第一次状态码是 204，第二次才成功？ 原因很简单，因为你用 fetch 的 post 请求的时候，导致 fetch<br>第一次发送了一个Options 请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。</p>\n<ul>\n<li><h3 id=\"Cookie、sessionStorage、localStorage-的区别\"><a href=\"#Cookie、sessionStorage、localStorage-的区别\" class=\"headerlink\" title=\"Cookie、sessionStorage、localStorage 的区别\"></a>Cookie、sessionStorage、localStorage 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>共同点：都是保存在浏览器端，并且是同源的</p>\n<p>Cookie：cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递。而 sessionStorage 和 localStorage<br>不会自动把数据发给服务器，仅在本地保存。cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下,存储的大小很小只有 4K 左右。<br>（key：可以在浏览器和服务器端来回传递，存储容量小，只有大约 4K 左右）</p>\n<p>sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持， localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据； cookie 只在设置的<br>cookie 过期时间之前一直有效，即使窗口或浏览器关闭。（key： 本身就是一个回话过程，关闭浏览器后消失，session 为一个回话，当页面不同即使是同一页面打开两次，也被视为同一次回话）</p>\n<p>localStorage：localStorage 在所有同源窗口中都是共享的；cookie<br>也是在所有同源窗口中都是共享的。（key：同源窗口都会共享，并且不会失效，不管窗口或者浏览器关闭与否都会始终生效）</p>\n<p>补充说明一下 cookie 的作用：</p>\n<p>保存用户登录状态。例如将用户 id 存储于一个 cookie 内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie<br>还可以设置过期时间，当超过时间期限后，cookie 就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。</p>\n<p>跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了 cookie 后就会显得很人性化了，<br>系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后<br>台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便定制页面。如果网站提供了换肤或更换布局的功能， 那么可以使用 cookie<br>来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。</p>\n<ul>\n<li><h3 id=\"说一下-web-worker\"><a href=\"#说一下-web-worker\" class=\"headerlink\" title=\"说一下 web worker\"></a>说一下 web worker</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面你的性能。并且通过<br>postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。</p>\n<p>如何创建 web worker：</p>\n<p>检测浏览器对于 web worker 的支持性</p>\n<p>创建 web worker 文件（js，回传函数等） 创建 web worker 对象</p>\n<ul>\n<li><h3 id=\"对-HTML-语义化标签的理解\"><a href=\"#对-HTML-语义化标签的理解\" class=\"headerlink\" title=\"对 HTML 语义化标签的理解\"></a>对 HTML 语义化标签的理解</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>HTML5 语义化标签是指正确的标签包含了正确的内容，结构良好，便于阅读，比如 nav</p>\n<p>表示导航条，类似的还有 article、header、footer 等等标签。</p>\n<ul>\n<li><h3 id=\"iframe-是什么？有什么缺点？\"><a href=\"#iframe-是什么？有什么缺点？\" class=\"headerlink\" title=\"iframe 是什么？有什么缺点？\"></a>iframe 是什么？有什么缺点？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>定义：iframe 元素会创建包含另一个文档的内联框架</p>\n<p>提示：可以将提示文字放在&lt;iframe&gt;&lt;/iframe&gt;之间，来提示某些不支持 iframe 的浏览器</p>\n<p>缺点：</p>\n<p>会阻塞主页面的 onload 事件</p>\n<p>搜索引擎无法解读这种页面，不利于 SEO</p>\n<p>iframe 和主页面共享连接池，而浏览器对相同区域有限制所以会影响性能。</p>\n<ul>\n<li><h3 id=\"Doctype-作用-严格模式与混杂模式如何区分？它们有何意义\"><a href=\"#Doctype-作用-严格模式与混杂模式如何区分？它们有何意义\" class=\"headerlink\" title=\"Doctype 作用?严格模式与混杂模式如何区分？它们有何意义?\"></a>Doctype 作用?严格模式与混杂模式如何区分？它们有何意义?</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Doctype 声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。</p>\n<p>严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。</p>\n<p>混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。</p>\n<ul>\n<li><h3 id=\"Cookie-如何防范-XSS-攻击\"><a href=\"#Cookie-如何防范-XSS-攻击\" class=\"headerlink\" title=\"Cookie 如何防范 XSS 攻击\"></a>Cookie 如何防范 XSS 攻击</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>XSS（跨站脚本攻击）是指攻击者在返回的 HTML 中嵌入 javascript 脚本，为了减轻这些攻击，需要在 HTTP 头部配上，set-cookie：</p>\n<p>httponly-这个属性可以防止 XSS,它会禁止 javascript 脚本来访问 cookie。secure - 这个属性告诉浏览器仅在请求为 https 的时候发送 cookie。</p>\n<p>结果应该是这样的：Set-Cookie=&lt;cookie-value&gt;.</p>\n<ul>\n<li><h3 id=\"Cookie-和-session-的区别\"><a href=\"#Cookie-和-session-的区别\" class=\"headerlink\" title=\"Cookie 和 session 的区别\"></a>Cookie 和 session 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>HTTP 是一个无状态协议，因此 Cookie 的最大的作用就是存储 sessionId 用来唯一标识用户。</p>\n<ul>\n<li><h3 id=\"一句话概括-RESTFUL\"><a href=\"#一句话概括-RESTFUL\" class=\"headerlink\" title=\"一句话概括 RESTFUL\"></a>一句话概括 RESTFUL</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>就是用 URL 定位资源，用 HTTP 描述操作。</p>\n<ul>\n<li><h3 id=\"讲讲-viewport-和移动端布局\"><a href=\"#讲讲-viewport-和移动端布局\" class=\"headerlink\" title=\"讲讲 viewport 和移动端布局\"></a>讲讲 viewport 和移动端布局</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>可以参考这篇文章：</p>\n<p><a href=\"https://github.com/forthealllight/blog/issues/13\"><em>响应式布局的常用解决方案对比(媒体查询、百分比、rem 和 vw/vh）</em></a></p>\n<ul>\n<li><h3 id=\"click-在-ios-上有-300ms-延迟，原因及如何解决？\"><a href=\"#click-在-ios-上有-300ms-延迟，原因及如何解决？\" class=\"headerlink\" title=\"click 在 ios 上有 300ms 延迟，原因及如何解决？\"></a>click 在 ios 上有 300ms 延迟，原因及如何解决？</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li>粗暴型，禁用缩放</li>\n</ol>\n<meta name=\"viewport\" content=\"width=device-width, user-scalable=no\"> (2)利用 FastClick，其原理是：\n\n<p>检测到 touchend 事件后，立刻出发模拟 click 事件，并且把浏览器 300 毫秒之后真正出发的事件给阻断掉</p>\n<ul>\n<li><h3 id=\"addEventListener-参数\"><a href=\"#addEventListener-参数\" class=\"headerlink\" title=\"addEventListener 参数\"></a>addEventListener 参数</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>addEventListener(event, function, useCapture)</p>\n<p>其中，event 指定事件名；function 指定要事件触发时执行的函数；useCapture 指定事件是否在捕获或冒泡阶段执行。</p>\n<ul>\n<li><h3 id=\"cookie-sessionStorage-localStorage-区别\"><a href=\"#cookie-sessionStorage-localStorage-区别\" class=\"headerlink\" title=\"cookie sessionStorage localStorage 区别\"></a>cookie sessionStorage localStorage 区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>cookie 数据始终在同源的 http 请求中携带(即使不需要)，即 cookie 在浏览器和服务器间来回传递</p>\n<p>cookie 数据还有路径（path）的概念，可以限制。cookie 只属于某个路径下</p>\n<p>存储大小限制也不同，cookie 数据不能超过 4K，同时因为每次 http 请求都会携带</p>\n<p>cookie，所以 cookie 只适合保存很小的数据，如回话标识。</p>\n<p>webStorage 虽然也有存储大小的限制，但是比 cookie 大得多，可以达到 5M 或更大数据的有效期不同 sessionStorage：仅在当前的浏览器窗口关闭有效；<br>localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据； cookie：只在设置的 cookie 过期时间之前一直有效，即使窗口和浏览器关闭</p>\n<p>作用域不同 sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面； localStorage：在所有同源窗口都是共享的；cookie：也是在所有同源窗口中共享的</p>\n<ul>\n<li><h3 id=\"cookie-session-区别\"><a href=\"#cookie-session-区别\" class=\"headerlink\" title=\"cookie session 区别\"></a>cookie session 区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>cookie 数据存放在客户的浏览器上，session 数据放在服务器上。</p>\n</li>\n<li><p>cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗</p>\n</li>\n</ol>\n<p>考虑到安全应当使用 session。</p>\n<ol start=\"3\">\n<li>session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能</li>\n</ol>\n<p>考虑到减轻服务器性能方面，应当使用 COOKIE。</p>\n<ol start=\"4\">\n<li>单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个cookie。</li>\n</ol>\n<ul>\n<li><h3 id=\"介绍知道的-http-返回的状态码\"><a href=\"#介绍知道的-http-返回的状态码\" class=\"headerlink\" title=\"介绍知道的 http 返回的状态码\"></a>介绍知道的 http 返回的状态码</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>100 Continue 继续。客户端应继续其请求</p>\n<p>101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议</p>\n<p>200 OK 请求成功。一般用于 GET 与 POST 请求</p>\n<p>201 Created 已创建。成功请求并创建了新的资源</p>\n<p>202 Accepted 已接受。已经接受请求，但未处理完成</p>\n<p>203 Non-Authoritative Information 非授权信息。请求成功。但返回的 meta 信息不在原始的服务器，而是一个副本</p>\n<p>204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</p>\n<p>205 Reset Content 重置内容。服务器处理成功，用户终端（例如： 浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</p>\n<p>206 Partial Content 部分内容。服务器成功处理了部分 GET 请求</p>\n<p>300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</p>\n<p>301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替</p>\n<p>302 Found 临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有 URI</p>\n<p>303 See Other 查看其它地址。与 301 类似。使用 GET 和 POST 请求查看</p>\n<p>304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</p>\n<p>305 Use Proxy 使用代理。所请求的资源必须通过代理访问</p>\n<p>306 Unused 已经被废弃的 HTTP 状态码</p>\n<p>307 Temporary Redirect 临时重定向。与 302 类似。使用 GET 请求重定向</p>\n<p>400 Bad Request 客户端请求的语法错误，服务器无法理解401 Unauthorized 请求要求用户的身份认证</p>\n<p>402 Payment Required 保留，将来使用</p>\n<p>403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求</p>\n<p>404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</p>\n<p>405 Method Not Allowed 客户端请求中的方法被禁止</p>\n<p>406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求407 Proxy Authentication Required 请求要求代理的身份认证，与401<br>类似，但请求者应当使用代理进行授权</p>\n<p>408 Request Time-out 服务器等待客户端发送的请求时间过长，超时</p>\n<p>409 Conflict 服务器完成客户端的 PUT 请求是可能返回此代码，服务器处理请求时发生了冲突</p>\n<p>410 Gone 客户端请求的资源已经不存在。410 不同于 404，如果资源以前有现在被永久删除了可使用 410 代码，网站设计人员可通过 301 代码指定资源的新位置</p>\n<p>411 Length Required 服务器无法处理客户端发送的不带 Content- Length 的请求信息</p>\n<p>412 Precondition Failed 客户端请求信息的先决条件错误</p>\n<p>413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个<br>Retry-After 的响应信息</p>\n<p>414 Request-URI Too Large 请求的 URI 过长（URI 通常为网址），服务器无法处理</p>\n<p>415 Unsupported Media Type 服务器无法处理请求附带的媒体格式416 Requested range not satisfiable 客户端请求的范围无效417<br>Expectation Failed 服务器无法满足 Expect 的请求头信息 500 Internal Server Error 服务器内部错误，无法完成请求</p>\n<p>501 Not Implemented 服务器不支持请求的功能，无法完成请求</p>\n<p>502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时， 从远程服务器接收到了一个无效的响应</p>\n<p>503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中</p>\n<p>504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求</p>\n<p>505 HTTP Version not supported 服务器不支持请求的 HTTP 协议的版本，无法完成处理</p>\n<ul>\n<li><h3 id=\"http-常用请求头\"><a href=\"#http-常用请求头\" class=\"headerlink\" title=\"http 常用请求头\"></a>http 常用请求头</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>[TABLE]</p>\n<p>[TABLE]</p>\n<p>[TABLE]</p>\n<ul>\n<li><h3 id=\"强，协商缓存\"><a href=\"#强，协商缓存\" class=\"headerlink\" title=\"强，协商缓存\"></a>强，协商缓存</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>缓存分为两种：强缓存和协商缓存，根据响应的 header 内容来决定。</p>\n<p>[TABLE]</p>\n<p>强缓存相关字段有 expires，cache-control。如果 cache-control 与 expires 同时存在的话，cache-control 的优先级高于 expires。</p>\n<p>协商缓存相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match</p>\n<ul>\n<li><h3 id=\"讲讲-304\"><a href=\"#讲讲-304\" class=\"headerlink\" title=\"讲讲 304\"></a>讲讲 304</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个 304 状态</p>\n<p>码。</p>\n<ul>\n<li><h3 id=\"强缓存、协商缓存什么时候用哪个\"><a href=\"#强缓存、协商缓存什么时候用哪个\" class=\"headerlink\" title=\"强缓存、协商缓存什么时候用哪个\"></a>强缓存、协商缓存什么时候用哪个</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>因为服务器上的资源不是一直固定不变的，大多数情况下它会更新，这个时候如果我们还访问本地缓存，那么对用户来说，那就相当于资源没有更新，用户看到的还是旧的资源；所以我们希望服务器上的资源更新了浏览器就请求新的资源，没有更新就使用本地的缓存，以最大程度的减少因网络请求而产生的资源浪费。</p>\n<p><img src=\"media/image1.jpeg\"></p>\n<p>参考 <a href=\"https://segmentfault.com/a/1190000008956069\"><em>https://segmentfault.com/a/1190000008956069</em></a></p>\n<ul>\n<li><h3 id=\"前端优化\"><a href=\"#前端优化\" class=\"headerlink\" title=\"前端优化\"></a>前端优化</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>降低请求量：合并资源，减少 HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。</p>\n<p>加快请求速度：预解析 DNS，减少域名数，并行加载，CDN 分发。</p>\n<p>缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage。</p>\n<p>渲染：JS/CSS 优化，加载顺序，服务端渲染，pipeline。</p>\n<ul>\n<li><h3 id=\"GET-和-POST-的区别\"><a href=\"#GET-和-POST-的区别\" class=\"headerlink\" title=\"GET 和 POST 的区别\"></a>GET 和 POST 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>get 参数通过 url 传递，post 放在 request body 中。</p>\n<p>get 请求在 url 中传递的参数是有长度限制的，而 post 没有。</p>\n<p>get 比 post 更不安全，因为参数直接暴露在 url 中，所以不能用来传递敏感信息。get 请求只能进行 url 编码，而 post 支持多种编码方式</p>\n<p>get 请求会浏览器主动 cache，而 post 支持多种编码方式。</p>\n<p>get 请求参数会被完整保留在浏览历史记录里，而 post 中的参数不会被保留。</p>\n<p>GET 和 POST 本质上就是 TCP 链接，并无差别。但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p>\n<p>GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。</p>\n<ul>\n<li><h3 id=\"301-和-302-的区别\"><a href=\"#301-和-302-的区别\" class=\"headerlink\" title=\"301 和 302 的区别\"></a>301 和 302 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>301 Moved Permanently 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI<br>之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。</p>\n<p>302 Found 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires<br>中进行了指定的情况下，这个响应才是可缓存的。</p>\n<p>字面上的区别就是 301 是永久重定向，而 302 是临时重定向。</p>\n<p>301 比较常用的场景是使用域名跳转。302 用来做临时跳转 比如未登陆的用户访问用户中心重定向到登录页面。</p>\n<ul>\n<li><h3 id=\"HTTP-支持的方法\"><a href=\"#HTTP-支持的方法\" class=\"headerlink\" title=\"HTTP 支持的方法\"></a>HTTP 支持的方法</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"GET-POST-HEAD-OPTIONS-PUT-DELETE-TRACE-CONNECT\"><a href=\"#GET-POST-HEAD-OPTIONS-PUT-DELETE-TRACE-CONNECT\" class=\"headerlink\" title=\"GET, POST, HEAD, OPTIONS, PUT, DELETE, TRACE, CONNECT\"></a>GET, POST, HEAD, OPTIONS, PUT, DELETE, TRACE, CONNECT</h3><ul>\n<li><h3 id=\"如何画一个三角形\"><a href=\"#如何画一个三角形\" class=\"headerlink\" title=\"如何画一个三角形\"></a>如何画一个三角形</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>三角形原理：边框的均分原理</p>\n<h3 id=\"div-width-0px-height-0px\"><a href=\"#div-width-0px-height-0px\" class=\"headerlink\" title=\"div { width:0px; height:0px\"></a>div { width:0px; height:0px</h3><blockquote>\n<p>border-top:10px solid red;</p>\n</blockquote>\n<blockquote>\n<p>border-right:10px solid transparent; border-bottom:10px solid transparent; border-left:10px solid<br>transparent;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"状态码-304-和-200\"><a href=\"#状态码-304-和-200\" class=\"headerlink\" title=\"状态码 304 和 200\"></a>状态码 304 和 200</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>状态码 200：请求已成功，请求所希望的响应头或数据体将随此响应返回。即返回的数据为全量的数据，如果文件不通过 GZIP 压缩的话，文件是多大，则要有多大传输量。状态码<br>304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状<br>态码。即客户端和服务器端只需要传输很少的数据量来做文件的校验，如果文件没有 修改过，则不需要返回全量的数据。</p>\n<ul>\n<li><h3 id=\"说一下浏览器缓存\"><a href=\"#说一下浏览器缓存\" class=\"headerlink\" title=\"说一下浏览器缓存\"></a>说一下浏览器缓存</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>缓存分为两种：强缓存和协商缓存，根据响应的 header 内容来决定。</p>\n<p>强缓存相关字段有 expires，cache-control。如果 cache-control 与 expires 同时存在的话，cache-control 的优先级高于 expires。</p>\n<p>协商缓存相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match</p>\n<ul>\n<li><h3 id=\"HTML5-新增的元素\"><a href=\"#HTML5-新增的元素\" class=\"headerlink\" title=\"HTML5 新增的元素\"></a>HTML5 新增的元素</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>首先 html5 为了更好的实践 web 语义化，增加了 header，footer，nav,aside,section</p>\n<p>等语义化标签，在表单方面，为了增强表单，为 input 增加了 color，</p>\n<p>emial,data ,range 等类型，在存储方面，提供了<br>sessionStorage，localStorage,和离线存储，通过这些存储方式方便数据在客户端的存储和获取，在多媒体方面规定了音频和视频元素 audio 和<br>vedio，另外还有地理定位，canvas 画布，拖放，多线程编程的 web worker 和 websocket 协议。</p>\n<ul>\n<li><h3 id=\"在地址栏里输入一个-URL-到这个页面呈现出来，中间会发生什么？\"><a href=\"#在地址栏里输入一个-URL-到这个页面呈现出来，中间会发生什么？\" class=\"headerlink\" title=\"在地址栏里输入一个 URL,到这个页面呈现出来，中间会发生什么？\"></a>在地址栏里输入一个 URL,到这个页面呈现出来，中间会发生什么？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>这是一个必考的面试问题，</p>\n<p>输入 url 后，首先需要找到这个 url 域名的服务器 ip,为了寻找这个 ip，浏览器首先会寻找缓存，查看缓存中是否有记录，缓存的查找记录为：浏览器缓存-》系统缓存</p>\n<p>-》路由器缓存，缓存中没有则查找系统的 hosts 文件中是否有记录，如果没有则查询DNS 服务器，得到服务器的 ip 地址后，浏览器根据这个 ip 以及相应的端口号，构造一个 http<br>请求，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并将这个 http 请求封装在一个 tcp 包中，这个 tcp<br>包会依次经过传输层，网络层，数据链路层，物理层到达服务器，服务器解析这个请求来作出响应，返回相应的 html 给浏览器，因为 html 是一个树形结构，浏览器根据这个 html 来构建DOM 树，在<br>dom 树的构建过程中如果遇到 JS 脚本和外部 JS 连接，则会停止构建 DOM 树来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐 JS 代码应该放在 html<br>代码的后面，之后根据外部央视，内部央视，内联样式构建一个 CSS 对象模型树 CSSOM 树，构建完成后和 DOM 树合并为渲染树，这里主要做的是排除非视觉节点，比如</p>\n<p>script，meta 标签和排除 display 为 none 的节点，之后进行布局，布局主要是确定各个元素的位置和尺寸，之后是渲染页面，因为 html 文件中会含有图片，视频，音频等资源，在解析<br>DOM 的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是 4-6 个，当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过<br>Cache-Control、Last-Modify、Expires 等首部字段控制。Cache-Control 和 Expires 的区别在于 Cache-Control 使用相对时间，Expires<br>使用的是基于服务器 端的绝对时间，因为存在时差问题，一般采用 Cache-Control，在请求这些有设置了缓存的数据时，会先<br>查看是否过期，如果没有过期则直接使用本地缓存，过期则请求并在服务器校验文件是否修改，如果上一次 响应设置了 ETag 值会在这次请求的时候作为 If-None-Match<br>的值交给服务器校验，如果一致，继续校验Last-Modified，没有设置 ETag 则直接验证 Last-Modified，再决定是否返回 304。</p>\n<ul>\n<li><h3 id=\"cookie-和-session-的区别，localstorage-和-sessionstorage-的区别\"><a href=\"#cookie-和-session-的区别，localstorage-和-sessionstorage-的区别\" class=\"headerlink\" title=\"cookie 和 session 的区别，localstorage 和 sessionstorage 的区别\"></a>cookie 和 session 的区别，localstorage 和 sessionstorage 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Cookie 和 session 都可用来存储用户信息，cookie 存放于客户端，session 存放于服务器端，因为cookie 存放于客户端有可能被窃取，所以 cookie<br>一般用来存放不敏感的信息，比如用户设置的网站主题，敏感的信息用 session 存储，比如用户的登陆信息，session 可以存放于文件，数据库，内存中都可以，cookie<br>可以服务器端响应的时候设置，也可以客户端通过 JS 设置 cookie 会在请求时在 http 首部发送给客户端， cookie 一般在客户端有大小限制，一般为 4K，</p>\n<p>下面从几个方向区分一下 cookie，localstorage，sessionstorage 的区别1、生命周期：</p>\n<p>Cookie：可设置失效时间，否则默认为关闭浏览器后失效Localstorage:除非被手动清除，否则永久保存</p>\n<p>Sessionstorage：仅在当前网页会话下有效，关闭页面或浏览器后就会被清除 2、存放数据：</p>\n<p>Cookie：4k 左右</p>\n<p>Localstorage 和 sessionstorage：可以保存 5M 的信息3、http 请求：</p>\n<p>Cookie：每次都会携带在 http 头中，如果使用 cookie 保存过多数据会带来性能问题其他两个：仅在客户端即浏览器中保存，不参与和服务器的通信</p>\n<p>4、易用性：</p>\n<p>Cookie：需要程序员自己封装，原生的 cookie 接口不友好其他两个：即可采用原生接口，亦可再次封装</p>\n<p>5、应用场景：</p>\n<p>从安全性来说，因为每次 http 请求都回携带 cookie 信息，这样子浪费了带宽，所以cookie 应该尽可能的少用，此外 cookie<br>还需要指定作用域，不可以跨域调用，限制很多，但是用户识别用户登陆来说，cookie 还是比storage 好用，其他情况下可以用storage，localstorage<br>可以用来在页面传递参数，sessionstorage 可以用来保存一些临时的数据，防止用户刷新页面后丢失了一些参数。</p>\n<ul>\n<li><h3 id=\"常见的-HTTP-的头部\"><a href=\"#常见的-HTTP-的头部\" class=\"headerlink\" title=\"常见的 HTTP 的头部\"></a>常见的 HTTP 的头部</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>可以将 http 首部分为通用首部，请求首部，响应首部，实体首部通用首部表示一些通用信息，比如 date 表示报文创建时间，</p>\n<p>请求首部就是请求报文中独有的，如 cookie，和缓存相关的如 if-Modified-Since</p>\n<p>响应首部就是响应报文中独有的，如 set-cookie，和重定向相关的 location，</p>\n<p>实体首部用来描述实体部分，如 allow 用来描述可执行的请求方法，content-type 描述主题类型，content-Encoding 描述主体的编码方式。</p>\n<ul>\n<li><h3 id=\"HTTP2-0-的特性\"><a href=\"#HTTP2-0-的特性\" class=\"headerlink\" title=\"HTTP2.0 的特性\"></a>HTTP2.0 的特性</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>http2.0 的特性如下：</p>\n<p>1、内容安全，应为 http2.0 是基于 https 的，天然具有安全特性，通过 http2.0 的特性可以避免单纯使用 https 的性能下降</p>\n<p>2、二进制格式，http1.X 的解析是基于文本的，http2.0 将所有的传输信息分割为更小的消息和帧，并对他们采用二进制格式编码，基于二进制可以让协议有更多的扩展性，比如引入了帧来传输数据和指令</p>\n<p>3、多路复用，这个功能相当于是长连接的增强，每个 request 请求可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里<br>面，另外多路复用中也支持了流的优先级，允许客户端告诉服务器那些内容是更优先级的资源，可以优先传输。</p>\n<ul>\n<li><h3 id=\"cache-control-的值有哪些\"><a href=\"#cache-control-的值有哪些\" class=\"headerlink\" title=\"cache-control 的值有哪些\"></a>cache-control 的值有哪些</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>cache-control 是一个通用消息头字段被用于 HTTP 请求和响应中，通过指定指令来实现缓存机制，这个缓存指令是单向的，常见的取值有<br>private、no-cache、max-age、must-revalidate 等，默认为 private。</p>\n<ul>\n<li><h3 id=\"浏览器在生成页面的时候，会生成那两颗树？\"><a href=\"#浏览器在生成页面的时候，会生成那两颗树？\" class=\"headerlink\" title=\"浏览器在生成页面的时候，会生成那两颗树？\"></a>浏览器在生成页面的时候，会生成那两颗树？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>构造两棵树，DOM 树和 CSSOM 规则树，</p>\n<p>当浏览器接收到服务器相应来的 HTML 文档后，会遍历文档节点，生成 DOM 树， CSSOM 规则树由浏览器解析 CSS 文件生成。</p>\n<ul>\n<li><h3 id=\"csrf-和-xss-的网络攻击及防范\"><a href=\"#csrf-和-xss-的网络攻击及防范\" class=\"headerlink\" title=\"csrf 和 xss 的网络攻击及防范\"></a>csrf 和 xss 的网络攻击及防范</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>CSRF：跨站请求伪造，可以理解为攻击者盗用了用户的身份，以用户的名义发送了恶意请求，比如用户登录了一个网站后，立刻在另一个ｔａｂ页面访问量攻击者用来制</p>\n<p>造攻击的网站，这个网站要求访问刚刚登陆的网站，并发送了一个恶意请求，这时候CSRF<br>就产生了，比如这个制造攻击的网站使用一张图片，但是这种图片的链接却是可以修改数据库的，这时候攻击者就可以以用户的名义操作这个数据库，防御方式的 话：使用验证码，检查 https 头部的<br>refer，使用 token XSS：跨站脚本攻击，是说攻击者通过注入恶意的脚本，在用户浏览网页的时候进行攻击，比如获取<br>cookie，或者其他用户身份信息，可以分为存储型和反射型，存储型是攻击者输入一些数据并且存储到了数据库中，其他浏览者看到的时候进行攻击，反射型的话不存储在数据库中，往往表现为将攻击代码放在 url<br>地址的请求参数中，防御的话为 cookie 设置 httpOnly 属性，对用户的输入进行检查，进行特殊字符过滤。</p>\n<ul>\n<li><h3 id=\"怎么看网站的性能如何\"><a href=\"#怎么看网站的性能如何\" class=\"headerlink\" title=\"怎么看网站的性能如何\"></a>怎么看网站的性能如何</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>检测页面加载时间一般有两种方式，一种是被动去测：就是在被检测的页面置入脚本或探针，当用户访问网页时，探针自动采集数据并传回数据库进行分析，另一种主动监测的方式，即主动的搭建分布式受控环境，模拟用户发起页面访问请求，主动采集性能数据并分析，在检测的精准度上，专业的第三方工具效果更佳，比如说性能极<br>客。</p>\n<ul>\n<li><h3 id=\"介绍-HTTP-协议-特征\"><a href=\"#介绍-HTTP-协议-特征\" class=\"headerlink\" title=\"介绍 HTTP 协议(特征)\"></a>介绍 HTTP 协议(特征)</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>HTTP 是一个基于 TCP/IP 通信协议来传递数据（HTML 文件, 图片文件, 查询结果等） HTTP 是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于<br>1990 年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在 WWW 中使用的是 HTTP/1.0 的第六版，HTTP/1.1 的规范化工作正在进行之中，而且 HTTP-NG(Next<br>Generation of HTTP)的建议已经提出。HTTP 协议工作于客户端-服务端架构为上。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器发送所有请求。Web<br>服务器根据接收到的请求后，向客户端发送响应信息。</p>\n<ul>\n<li><h3 id=\"输入-URL-到页面加载显示完成发生了什么\"><a href=\"#输入-URL-到页面加载显示完成发生了什么\" class=\"headerlink\" title=\"输入 URL 到页面加载显示完成发生了什么?\"></a>输入 URL 到页面加载显示完成发生了什么?</h3></li>\n</ul>\n<p>参考回答： DNS 解析TCP 连接</p>\n<p>发送 HTTP 请求</p>\n<p>服务器处理请求并返回 HTTP 报文浏览器解析渲染页面</p>\n<p>连接结束</p>\n<ul>\n<li><h3 id=\"说一下对-Cookie-和-Session-的认知，Cookie-有哪些限制？\"><a href=\"#说一下对-Cookie-和-Session-的认知，Cookie-有哪些限制？\" class=\"headerlink\" title=\"说一下对 Cookie 和 Session 的认知，Cookie 有哪些限制？\"></a>说一下对 Cookie 和 Session 的认知，Cookie 有哪些限制？</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>cookie 数据存放在客户的浏览器上，session 数据放在服务器上。</p>\n</li>\n<li><p>cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗</p>\n</li>\n</ol>\n<p>考虑到安全应当使用 session。</p>\n<ol start=\"3\">\n<li>session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能</li>\n</ol>\n<p>考虑到减轻服务器性能方面，应当使用 COOKIE。</p>\n<ol start=\"4\">\n<li>单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个cookie。</li>\n</ol>\n<ul>\n<li><h3 id=\"描述一下-XSS-和-CRSF-攻击？防御方法？\"><a href=\"#描述一下-XSS-和-CRSF-攻击？防御方法？\" class=\"headerlink\" title=\"描述一下 XSS 和 CRSF 攻击？防御方法？\"></a>描述一下 XSS 和 CRSF 攻击？防御方法？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>XSS, 即为（Cross Site Scripting）, 中文名为跨站脚本, 是发生在目标用户的浏览器层面上的，当渲染 DOM 树的过程成发生了不在预期内执行的 JS 代码时，就发生了XSS<br>攻击。大多数 XSS 攻击的主要方式是嵌入一段远程或者第三方域上的 JS 代码。实际上是在目标网站的作用域下执行了这段 JS 代码。</p>\n<p>CSRF（Cross Site Request Forgery，跨站请求伪造），字面理解意思就是在别的站点伪造了一个请求。专业术语来说就是在受害者访问一个网站时，其 Cookie<br>还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。</p>\n<p>XSS 防御的总体思路是：对输入(和 URL 参数)进行过滤，对输出进行编码。也就是对提交的所有内容进行过滤，对 url<br>中的参数进行过滤，过滤掉会导致脚本执行的相关内容；然后对动态输出到页面的内容进行 html 编码，使脚本无法在浏览器中执行。虽然对输入过滤可以被绕过，但是也还是会拦截很大一部分的 XSS 攻击。</p>\n<p>防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token</p>\n<p>并验证；在 HTTP 头中自定义属性并验证。</p>\n<ul>\n<li><h3 id=\"知道-304-吗，什么时候用-304？\"><a href=\"#知道-304-吗，什么时候用-304？\" class=\"headerlink\" title=\"知道 304 吗，什么时候用 304？\"></a>知道 304 吗，什么时候用 304？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个 304 状态</p>\n<p>码。</p>\n<ul>\n<li><h3 id=\"具体有哪些请求头是跟缓存相关的\"><a href=\"#具体有哪些请求头是跟缓存相关的\" class=\"headerlink\" title=\"具体有哪些请求头是跟缓存相关的\"></a>具体有哪些请求头是跟缓存相关的</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>缓存分为两种：强缓存和协商缓存，根据响应的 header 内容来决定。</p>\n<p>强缓存相关字段有 expires，cache-control。如果 cache-control 与 expires 同时存在的话，cache-control 的优先级高于 expires。</p>\n<p>协商缓存相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match</p>\n<ul>\n<li><h3 id=\"cookie-和-session-的区别\"><a href=\"#cookie-和-session-的区别\" class=\"headerlink\" title=\"cookie 和 session 的区别\"></a>cookie 和 session 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>cookie 数据存放在客户的浏览器上，session 数据放在服务器上。</p>\n</li>\n<li><p>cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗</p>\n</li>\n</ol>\n<p>考虑到安全应当使用 session。</p>\n<ol start=\"3\">\n<li>session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能</li>\n</ol>\n<p>考虑到减轻服务器性能方面，应当使用 COOKIE。</p>\n<ol start=\"4\">\n<li>单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个cookie。</li>\n</ol>\n<ul>\n<li><h3 id=\"cookie-有哪些字段可以设置\"><a href=\"#cookie-有哪些字段可以设置\" class=\"headerlink\" title=\"cookie 有哪些字段可以设置\"></a>cookie 有哪些字段可以设置</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>name 字段为一个 cookie 的名称。value 字段为一个 cookie 的值。</p>\n<p>domain 字段为可以访问此 cookie 的域名。</p>\n<p>非顶级域名，如二级域名或者三级域名，设置的 cookie 的 domain 只能为顶级域名或者二级域名或者三级域名本身，不能设置其他二级域名的 cookie，否则 cookie 无法生成。</p>\n<p>顶级域名只能设置 domain 为顶级域名，不能设置为二级域名或者三级域名，否则</p>\n<p>cookie 无法生成。</p>\n<p>二级域名能读取设置了 domain 为顶级域名或者自身的 cookie，不能读取其他二级域名domain 的 cookie。所以要想 cookie 在多个二级域名中共享，需要设置 domain<br>为顶级域名，这样就可以在所有二级域名里面或者到这个 cookie 的值了。</p>\n<p>顶级域名只能获取到 domain 设置为顶级域名的 cookie，其他 domain 设置为二级域名的无法获取。</p>\n<p>path 字段为可以访问此 cookie 的页面路径。 比如 domain 是 abc.com,path 是/test， 那么只有/test 路径下的页面可以读取此 cookie。</p>\n<p>expires/Max-Age 字段为此 cookie 超时时间。若设置其值为一个时间，那么当到达此时间后，此 cookie 失效。不设置的话默认值是 Session，意思是 cookie<br>会和session 一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie 失效。</p>\n<p>Size 字段 此 cookie 大小。</p>\n<p>http 字段 cookie 的 httponly 属性。若此属性为 true，则只有在 http 请求头中会带有此 cookie 的信息，而不能通过 document.cookie 来访问此<br>cookie。</p>\n<p>secure 字段 设置是否只能通过 https 来传递此条 cookie</p>\n<ul>\n<li><h3 id=\"cookie-有哪些编码方式？\"><a href=\"#cookie-有哪些编码方式？\" class=\"headerlink\" title=\"cookie 有哪些编码方式？\"></a>cookie 有哪些编码方式？</h3></li>\n</ul>\n<p>参 考 回 答 ： encodeURI（）</p>\n<ul>\n<li><h3 id=\"除了-cookie，还有什么存储方式。说说-cookie-和-localStorage-的区别\"><a href=\"#除了-cookie，还有什么存储方式。说说-cookie-和-localStorage-的区别\" class=\"headerlink\" title=\"除了 cookie，还有什么存储方式。说说 cookie 和 localStorage 的区别\"></a>除了 cookie，还有什么存储方式。说说 cookie 和 localStorage 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>还有 localStorage，sessionStorage，indexdDB 等cookie 和 localStorage 的区别：</p>\n<p>cookie 数据始终在同源的 http 请求中携带(即使不需要)，即 cookie 在浏览器和服务器间来回传递</p>\n<p>cookie 数据还有路径（path）的概念，可以限制。cookie 只属于某个路径下</p>\n<p>存储大小限制也不同，cookie 数据不能超过 4K，同时因为每次 http 请求都会携带</p>\n<p>cookie，所以 cookie 只适合保存很小的数据，如回话标识。</p>\n<p>localStorage 虽然也有存储大小的限制，但是比cookie 大得多，可以达到 5M 或更大localStorage 始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie<br>只在设置的 cookie 过期时间之前一直有效，即使窗口和浏览器关闭。</p>\n<ul>\n<li><h3 id=\"浏览器输入网址到页面渲染全过程\"><a href=\"#浏览器输入网址到页面渲染全过程\" class=\"headerlink\" title=\"浏览器输入网址到页面渲染全过程\"></a>浏览器输入网址到页面渲染全过程</h3></li>\n</ul>\n<p>参考回答： DNS 解析TCP 连接</p>\n<p>发送 HTTP 请求</p>\n<p>服务器处理请求并返回 HTTP 报文浏览器解析渲染页面</p>\n<p>连接结束</p>\n<ul>\n<li><h3 id=\"HTML5-和-CSS3-用的多吗？你了解它们的新属性吗？有在项目中用过吗？\"><a href=\"#HTML5-和-CSS3-用的多吗？你了解它们的新属性吗？有在项目中用过吗？\" class=\"headerlink\" title=\"HTML5 和 CSS3 用的多吗？你了解它们的新属性吗？有在项目中用过吗？\"></a>HTML5 和 CSS3 用的多吗？你了解它们的新属性吗？有在项目中用过吗？</h3></li>\n</ul>\n<p>参考回答： html5： 1）标签增删</p>\n<p>8 个语义元素 header section footer aside nav main article figure 内容元素 mark 高亮 progress 进度</p>\n<p>新的表单控件 calander date time email url search</p>\n<p>新的 input 类型 color date datetime datetime-local email 移除过时标签 big font frame frameset</p>\n<p>2）canvas 绘图，支持内联 SVG。支持 MathML 3）多媒体 audio video source embed track</p>\n<ol start=\"4\">\n<li><p>本地离线存储，把需要离线存储在本地的文件列在一个 manifest 配置文件</p>\n</li>\n<li><p>web 存储。localStorage、SessionStorage</p>\n</li>\n</ol>\n<p>css3：</p>\n<p>CSS3 边框如 border-radius，box-shadow 等；CSS3 背景如 background-size， background-origin 等；CSS3 2D，3D 转换如<br>transform 等；CSS3 动画如 animation 等。 参考<br><a href=\"https://www.cnblogs.com/xkweb/p/5862612.html\"><em>https://www.cnblogs.com/xkweb/p/5862612.html</em></a></p>\n<ul>\n<li><h3 id=\"http-常见的请求方法\"><a href=\"#http-常见的请求方法\" class=\"headerlink\" title=\"http 常见的请求方法\"></a>http 常见的请求方法</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>get、post，这两个用的是最多的，还有很多比如 patch、delete、put、options 等等</p>\n<ul>\n<li><h3 id=\"get-和-post-的区别\"><a href=\"#get-和-post-的区别\" class=\"headerlink\" title=\"get 和 post 的区别\"></a>get 和 post 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>GET - 从指定的资源请求数据。</p>\n<p>POST - 向指定的资源提交要被处理的数据。</p>\n<p>GET：不同的浏览器和服务器不同，一般限制在 2~8K 之间，更加常见的是 1k 以内。GET 和 POST 的底层也是 TCP/IP，GET/POST 都是 TCP 链接。</p>\n<p>GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。</p>\n<p>对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应</p>\n<p>200（返回数据）；</p>\n<p>而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送data，服务器响应 200 ok（返回数据）。</p>\n<ul>\n<li><h3 id=\"说说-302，301，304-的状态码\"><a href=\"#说说-302，301，304-的状态码\" class=\"headerlink\" title=\"说说 302，301，304 的状态码\"></a>说说 302，301，304 的状态码</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替</p>\n<p>302 Found 临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有 URI</p>\n<p>304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</p>\n<ul>\n<li><h3 id=\"web-性能优化\"><a href=\"#web-性能优化\" class=\"headerlink\" title=\"web 性能优化\"></a>web 性能优化</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>降低请求量：合并资源，减少 HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。</p>\n<p>加快请求速度：预解析 DNS，减少域名数，并行加载，CDN 分发。</p>\n<p>缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage。</p>\n<p>渲染：JS/CSS 优化，加载顺序，服务端渲染，pipeline。</p>\n<ul>\n<li><h3 id=\"浏览器缓存机制\"><a href=\"#浏览器缓存机制\" class=\"headerlink\" title=\"浏览器缓存机制\"></a>浏览器缓存机制</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>缓存分为两种：强缓存和协商缓存，根据响应的 header 内容来决定。</p>\n<p>强缓存相关字段有 expires，cache-control。如果 cache-control 与 expires 同时存在的话，cache-control 的优先级高于 expires。</p>\n<p>协商缓存相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match</p>\n<ul>\n<li><h3 id=\"post-和-get-区别\"><a href=\"#post-和-get-区别\" class=\"headerlink\" title=\"post 和 get 区别\"></a>post 和 get 区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>GET - 从指定的资源请求数据。</p>\n<p>POST - 向指定的资源提交要被处理的数据。</p>\n<p>GET：不同的浏览器和服务器不同，一般限制在 2~8K 之间，更加常见的是 1k 以内。GET 和 POST 的底层也是 TCP/IP，GET/POST 都是 TCP 链接。</p>\n<p>GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。</p>\n<p>对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应</p>\n<p>200（返回数据）；</p>\n<p>而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送data，服务器响应 200 ok（返回数据）。</p>\n<h2 id=\"1-2-CSS\"><a href=\"#1-2-CSS\" class=\"headerlink\" title=\"1.2 | CSS\"></a>1.2 | CSS</h2><ul>\n<li><h3 id=\"说一下-css-盒模型\"><a href=\"#说一下-css-盒模型\" class=\"headerlink\" title=\"说一下 css 盒模型\"></a>说一下 css 盒模型</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>简介：就是用来装页面上的元素的矩形区域。CSS 中的盒子模型包括 IE 盒子模型和标准的 W3C 盒子模型。</p>\n<p>box-sizing(有 3 个值哦)：border-box,padding-box,content-box. 标准盒子模型：</p>\n<p><img src=\"media/image2.jpeg\"></p>\n<p><img src=\"media/image3.jpeg\"> IE 盒子模型：</p>\n<p>区别：从图中我们可以看出，这两种盒子模型最主要的区别就是 width 的包含范围， 在标准的盒子模型中，width 指 content 部分的宽度，在 IE 盒子模型中，width<br>表示content+padding+border 这三个部分的宽度，故这使得在计算整个盒子的宽度时存在着差异：</p>\n<p>标准盒子模型的盒子宽度：左右 border+左右 padding+width IE 盒子模型的盒子宽度：width</p>\n<p>在 CSS3 中引入了 box-sizing 属性，box-sizing:content-box;表示标准的盒子模型，</p>\n<p>box-sizing:border-box 表示的是 IE 盒子模型</p>\n<p>最后，前面我们还提到了，box-sizing:padding-box,这个属性值的宽度包含了左右</p>\n<p>padding+width</p>\n<p>也很好理解性记忆，包含什么，width 就从什么开始算起。</p>\n<ul>\n<li><h3 id=\"画一条-0-5px-的线\"><a href=\"#画一条-0-5px-的线\" class=\"headerlink\" title=\"画一条 0.5px 的线\"></a>画一条 0.5px 的线</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>采用 meta viewport 的方式</p>\n<meta name=\"viewport\" content=\"initial-scale=1.0, maximum-scale=1.0, user- scalable=no\" />\n\n<p>采用 border-image 的方式</p>\n<p>采用 transform: scale()的方式</p>\n<ul>\n<li><h3 id=\"link-标签和-import-标签的区别\"><a href=\"#link-标签和-import-标签的区别\" class=\"headerlink\" title=\"link 标签和 import 标签的区别\"></a>link 标签和 import 标签的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>link 属于 html 标签，而@import 是 css 提供的</p>\n<p>页面被加载时，link 会同时被加载，而@import 引用的 css 会等到页面加载结束后加载。</p>\n<p>link 是 html 标签，因此没有兼容性，而@import 只有 IE5 以上才能识别。link 方式样式的权重高于@import 的。</p>\n<ul>\n<li><h3 id=\"transition-和-animation-的区别\"><a href=\"#transition-和-animation-的区别\" class=\"headerlink\" title=\"transition 和 animation 的区别\"></a>transition 和 animation 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Animation 和 transition 大部分属性是相同的，他们都是随时间改变元素的属性值， 他们的主要区别是 transition 需要触发一个事件才能改变属性，而 animation<br>不需要触发任何事件的情况下才会随时间改变属性值，并且 transition 为 2 帧，从</p>\n<p>from to，而 animation 可以一帧一帧的。</p>\n<ul>\n<li><h3 id=\"Flex-布局\"><a href=\"#Flex-布局\" class=\"headerlink\" title=\"Flex 布局\"></a>Flex 布局</h3></li>\n</ul>\n<p>参考回答： 文章链接：</p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool%EF%BC%88%E8%AF%AD%E6%B3%95%E7%AF%87%EF%BC%89\"><em>http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool</em></a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool%EF%BC%88%E8%AF%AD%E6%B3%95%E7%AF%87%EF%BC%89\"><em>（语法篇）</em></a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-examples.html%EF%BC%88%E5%AE%9E%E4%BE%8B%E7%AF%87%EF%BC%89\"><em>http://www.ruanyifeng.com/blog/2015/07/flex-examples.html（实例篇）</em></a>Flex<br>是</p>\n<p>Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p>\n<p>布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。</p>\n<p>简单的分为容器属性和元素属性容器的属性：</p>\n<p>flex-direction：决定主轴的方向（即子 item 的排列方法）</p>\n<p>.box {</p>\n<p>flex-direction: row | row-reverse | column | column-reverse;</p>\n<p>}</p>\n<p>flex-wrap：决定换行规则</p>\n<p>.box{</p>\n<p>flex-wrap: nowrap | wrap | wrap-reverse;</p>\n<p>}</p>\n<p>flex-flow：</p>\n<p>.box {</p>\n<p>flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</p>\n<p>}</p>\n<p>justify-content：对其方式，水平主轴对齐方式align-items：对齐方式，竖直轴线方向</p>\n<p>项目的属性（元素的属性）：</p>\n<p>order 属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为 0 flex-grow 属性：定义项目的放大比例，即使存在空间，也不会放大</p>\n<p>flex-shrink 属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果定义个 item 的 flow-shrink 为 0，则为不缩小</p>\n<p>flex-basis 属性：定义了在分配多余的空间，项目占据的空间。</p>\n<p>flex：是 flex-grow 和 flex-shrink、flex-basis 的简写，默认值为 0 1 auto。align-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖<br>align-items，默认属性为 auto，表示继承父元素的 align-items</p>\n<p>比如说，用 flex 实现圣杯布局</p>\n<ul>\n<li><h3 id=\"BFC（块级格式化上下文，用于清楚浮动，防止-margin-重叠等）\"><a href=\"#BFC（块级格式化上下文，用于清楚浮动，防止-margin-重叠等）\" class=\"headerlink\" title=\"BFC（块级格式化上下文，用于清楚浮动，防止 margin 重叠等）\"></a>BFC（块级格式化上下文，用于清楚浮动，防止 margin 重叠等）</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>直译成：块级格式化上下文，是一个独立的渲染区域，并且有一定的布局规则。BFC 区域不会与 float box 重叠</p>\n<p>BFC 是页面上的一个独立容器，子元素不会影响到外面计算 BFC 的高度时，浮动元素也会参与计算</p>\n<p>那些元素会生成 BFC：</p>\n<p>根元素</p>\n<p>float 不为 none 的元素</p>\n<p>position 为 fixed 和 absolute 的元素</p>\n<p>display 为 inline-block、table-cell、table-caption，flex，inline-flex 的元素overflow 不为 visible 的元素</p>\n<ul>\n<li><h3 id=\"垂直居中的方法\"><a href=\"#垂直居中的方法\" class=\"headerlink\" title=\"垂直居中的方法\"></a>垂直居中的方法</h3></li>\n</ul>\n<p>参 考 回 答 ： (1)margin:auto 法css:</p>\n<h3 id=\"div\"><a href=\"#div\" class=\"headerlink\" title=\"div{\"></a>div{</h3><blockquote>\n<p>width: 400px; height: 400px; position: relative;</p>\n</blockquote>\n<blockquote>\n<p>border: 1px solid #465468;</p>\n</blockquote>\n<blockquote>\n<p>} img{</p>\n</blockquote>\n<blockquote>\n<p>position: absolute; margin: auto;</p>\n</blockquote>\n<blockquote>\n<p>top: 0; left: 0; right: 0; bottom: 0;</p>\n</blockquote>\n<blockquote>\n<p>} html:</p>\n</blockquote>\n<blockquote>\n<div>\n</blockquote>\n<blockquote>\n<img src=\"mm.jpg\">\n</blockquote>\n<blockquote>\n</div>\n</blockquote>\n<p>定位为上下左右为 0，margin：0 可以实现脱离文档流的居中. (2)margin 负值法</p>\n<h3 id=\"container-width-500px-height-400px\"><a href=\"#container-width-500px-height-400px\" class=\"headerlink\" title=\".container{ width: 500px; height: 400px\"></a>.container{ width: 500px; height: 400px</h3><blockquote>\n<p>border: 2px solid #379; position: relative;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.inner{ width: 480px;</p>\n</blockquote>\n<blockquote>\n<p>height: 380px; background-color: #746; position: absolute; top: 50%;</p>\n</blockquote>\n<blockquote>\n<p>left: 50%;</p>\n</blockquote>\n<p>margin-top: -190px; /*height 的一半*/ margin-left: -240px; /*width 的一半*/</p>\n<p>}</p>\n<p>补充：其实这里也可以将 marin-top 和 margin-left 负值替换成， transform：translateX(-50%) 和 transform：translateY(-50%)<br>(3)table-cell（未脱离文档流的）</p>\n<p>设置父元素的 display:table-cell,并且 vertical-align:middle，这样子元素可以实现垂直居中。</p>\n<h3 id=\"css-div\"><a href=\"#css-div\" class=\"headerlink\" title=\"css: div{\"></a>css: div{</h3><blockquote>\n<p>width: 300px; height: 300px;</p>\n</blockquote>\n<blockquote>\n<p>border: 3px solid #555; display: table-cell; vertical-align: middle; text-align: center;</p>\n</blockquote>\n<blockquote>\n<p>} img{</p>\n</blockquote>\n<blockquote>\n<p>vertical-align: middle;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ol start=\"4\">\n<li>利用 flex</li>\n</ol>\n<p>将父元素设置为 display:flex，并且设置 align-items:center;justify- content:center;</p>\n<ul>\n<li><h3 id=\"关于-JS-动画和-css3-动画的差异性\"><a href=\"#关于-JS-动画和-css3-动画的差异性\" class=\"headerlink\" title=\"关于 JS 动画和 css3 动画的差异性\"></a>关于 JS 动画和 css3 动画的差异性</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>渲染线程分为 main thread 和 compositor thread，如果 css 动画只改变 transform 和opacity，这时整个 CSS 动画得以在 compositor<br>trhead 完成（而 JS 动画则会在 main thread 执行，然后出发 compositor thread 进行下一步操作），特别注意的是如果改变 transform 和 opacity<br>是不会 layout 或者 paint 的。</p>\n<p>区别：</p>\n<p>功能涵盖面，JS 比 CSS 大</p>\n<p>实现/重构难度不一，CSS3 比 JS 更加简单，性能跳优方向固定对帧速表现不好的低版本浏览器，css3 可以做到自然降级</p>\n<p>css 动画有天然事件支持css3 有兼容性问题</p>\n<ul>\n<li><h3 id=\"说一下块元素和行元素\"><a href=\"#说一下块元素和行元素\" class=\"headerlink\" title=\"说一下块元素和行元素\"></a>说一下块元素和行元素</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>块元素：独占一行，并且有自动填满父元素，可以设置 margin 和 pading 以及高度和宽度</p>\n<p>行元素：不会独占一行，width 和 height 会失效，并且在垂直方向的 padding 和</p>\n<p>margin 会失效。</p>\n<ul>\n<li><h3 id=\"多行元素的文本省略号\"><a href=\"#多行元素的文本省略号\" class=\"headerlink\" title=\"多行元素的文本省略号\"></a>多行元素的文本省略号</h3></li>\n</ul>\n<p>参考回答：</p>\n<ul>\n<li><h3 id=\"visibility-hidden-opacity-0，display-none\"><a href=\"#visibility-hidden-opacity-0，display-none\" class=\"headerlink\" title=\"visibility=hidden, opacity=0，display:none\"></a>visibility=hidden, opacity=0，display:none</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>opacity=0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如 click 事件，那么点击该区域，也能触发点击事件的 visibility=hidden，<br>该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件display=none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样。</p>\n<ul>\n<li><h3 id=\"双边距重叠问题（外边距折叠）\"><a href=\"#双边距重叠问题（外边距折叠）\" class=\"headerlink\" title=\"双边距重叠问题（外边距折叠）\"></a>双边距重叠问题（外边距折叠）</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>多个相邻（兄弟或者父子关系）普通流的块元素垂直方向 marigin 会重叠折叠的结果为：</p>\n<p>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。</p>\n<ul>\n<li><h3 id=\"position-属性-比较\"><a href=\"#position-属性-比较\" class=\"headerlink\" title=\"position 属性 比较\"></a>position 属性 比较</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>固定定位 fixed：</p>\n<p>元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重</p>\n<p>叠。</p>\n<p>相对定位 relative：</p>\n<p>如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。<br>在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 绝对定位 absolute：</p>\n<p>绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素， 那么它的位置相对于&lt;html&gt;。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute<br>定位的元素和其他元素重叠。</p>\n<p>粘性定位 sticky：</p>\n<p>元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和containing<br>block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。</p>\n<p>默认定位 Static：</p>\n<p>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者z-index 声明）。</p>\n<p>inherit:</p>\n<p>规定应该从父元素继承 position 属性的值。</p>\n<ul>\n<li><h3 id=\"浮动清除\"><a href=\"#浮动清除\" class=\"headerlink\" title=\"浮动清除\"></a>浮动清除</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>方法一：使用带 clear 属性的空元素</p>\n<p>在浮动元素后使用一个空元素如&lt;div class=”clear”&gt;&lt;/div&gt;，并在 CSS 中赋</p>\n<p>予.clear{clear:both;}属性即可清理浮动。亦可使用&lt;br class=”clear” /&gt;或&lt;hr class=”clear” /&gt;来进行清理。</p>\n<p>方法二：使用 CSS 的 overflow 属性</p>\n<p>给浮动元素的容器添加 overflow:hidden;或 overflow:auto;可以清除浮动，另外在IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。</p>\n<p>在添加 overflow 属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。</p>\n<p>方法三：给浮动的元素的容器添加浮动</p>\n<p>给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动， 影响布局，不推荐使用。</p>\n<p>方法四：使用邻接元素处理</p>\n<p>什么都不做，给浮动元素后面的元素添加 clear 属性。方法五：使用 CSS 的:after 伪元素</p>\n<p>结合:after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素） 和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发hasLayout。</p>\n<p>给浮动元素的容器添加一个 clearfix 的 class，然后给这个 class 添加一个:after 伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。</p>\n<p>参考<br><a href=\"https://www.cnblogs.com/ForEvErNoME/p/3383539.html\"><em>https://www.cnblogs.com/ForEvErNoME/p/3383539.html</em></a></p>\n<ul>\n<li><h3 id=\"css3-新特性\"><a href=\"#css3-新特性\" class=\"headerlink\" title=\"css3 新特性\"></a>css3 新特性</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>开放题。CSS3 边框如 border-radius，box-shadow 等；CSS3 背景如 background- size，background-origin 等；CSS3 2D，3D 转换如<br>transform 等；CSS3 动画如animation 等。</p>\n<p>参考 <a href=\"https://www.cnblogs.com/xkweb/p/5862612.html\"><em>https://www.cnblogs.com/xkweb/p/5862612.html</em></a></p>\n<ul>\n<li><h3 id=\"CSS-选择器有哪些，优先级呢\"><a href=\"#CSS-选择器有哪些，优先级呢\" class=\"headerlink\" title=\"CSS 选择器有哪些，优先级呢\"></a>CSS 选择器有哪些，优先级呢</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>id 选择器，class 选择器，标签选择器，伪元素选择器，伪类选择器等</p>\n<p>同一元素引用了多个样式时，排在后面的样式属性的优先级高；</p>\n<p>样式选择器的类型不同时，优先级顺序为：id 选择器 &gt; class 选择器 &gt; 标签选择器；</p>\n<p>标签之间存在层级包含关系时，后代元素会继承祖先元素的样式。如果后代元素定义了与祖先元素相同的样式，则祖先元素的相同的样式属性会被覆盖。继承的样式的优先级比较低，至少比标签选择器的优先级低；</p>\n<p>带有!important 标记的样式属性的优先级最高；</p>\n<p>样式表的来源不同时，优先级顺序为：内联样式&gt; 内部样式 &gt; 外部样式 &gt; 浏览器用户自定义样式 &gt; 浏览器默认样式</p>\n<ul>\n<li><h3 id=\"清除浮动的方法，能讲讲吗\"><a href=\"#清除浮动的方法，能讲讲吗\" class=\"headerlink\" title=\"清除浮动的方法，能讲讲吗\"></a>清除浮动的方法，能讲讲吗</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>方法一：使用带 clear 属性的空元素</p>\n<p>在浮动元素后使用一个空元素如&lt;div class=”clear”&gt;&lt;/div&gt;，并在 CSS 中赋</p>\n<p>予.clear{clear:both;}属性即可清理浮动。亦可使用&lt;br class=”clear” /&gt;或&lt;hr class=”clear” /&gt;来进行清理。</p>\n<p>方法二：使用 CSS 的 overflow 属性</p>\n<p>给浮动元素的容器添加 overflow:hidden;或 overflow:auto;可以清除浮动，另外在IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。</p>\n<p>在添加 overflow 属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。</p>\n<p>方法三：给浮动的元素的容器添加浮动</p>\n<p>给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动， 影响布局，不推荐使用。</p>\n<p>方法四：使用邻接元素处理</p>\n<p>什么都不做，给浮动元素后面的元素添加 clear 属性。方法五：使用 CSS 的:after 伪元素</p>\n<p>结合:after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素） 和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发hasLayout。</p>\n<p>给浮动元素的容器添加一个 clearfix 的 class，然后给这个 class 添加一个:after 伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。</p>\n<p>参考<br><a href=\"https://www.cnblogs.com/ForEvErNoME/p/3383539.html\"><em>https://www.cnblogs.com/ForEvErNoME/p/3383539.html</em></a></p>\n<ul>\n<li><h3 id=\"怎么样让一个元素消失，讲讲\"><a href=\"#怎么样让一个元素消失，讲讲\" class=\"headerlink\" title=\"怎么样让一个元素消失，讲讲\"></a>怎么样让一个元素消失，讲讲</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>display:none; visibility:hidden; opacity: 0; 等等</p>\n<ul>\n<li><h3 id=\"介绍一下盒模型\"><a href=\"#介绍一下盒模型\" class=\"headerlink\" title=\"介绍一下盒模型\"></a>介绍一下盒模型</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>CSS 盒模型本质上是一个盒子，封装周围的 HTML 元素，它包括：边距，边框，填充， 和实际内容。</p>\n<p>标准盒模型：一个块的总宽度=width+margin(左右)+padding(左右)+border(左右) 怪异盒模型：一个块的总宽度=width+margin（左右）（既 width 已经包含了<br>padding 和 border 值）</p>\n<p>设置盒模型：box-sizing:border-box</p>\n<ul>\n<li><h3 id=\"position-相关属性\"><a href=\"#position-相关属性\" class=\"headerlink\" title=\"position 相关属性\"></a>position 相关属性</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>固定定位 fixed：</p>\n<p>元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重</p>\n<p>叠。</p>\n<p>相对定位 relative：</p>\n<p>如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。<br>在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 绝对定位 absolute：</p>\n<p>绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素， 那么它的位置相对于&lt;html&gt;。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute<br>定位的元素和其他元素重叠。</p>\n<p>粘性定位 sticky：</p>\n<p>元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和containing<br>block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。</p>\n<p>默认定位 Static：</p>\n<p>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者z-index 声明）。</p>\n<p>inherit:</p>\n<p>规定应该从父元素继承 position 属性的值。</p>\n<ul>\n<li><h3 id=\"css-动画如何实现\"><a href=\"#css-动画如何实现\" class=\"headerlink\" title=\"css 动画如何实现\"></a>css 动画如何实现</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>创建动画序列，需要使用 animation 属性或其子属性，该属性允许配置动画时间、时长以及其他动画细节，但该属性不能配置动画的实际表现，动画的实际表现是</p>\n<p>由 @keyframes 规则实现，具体情况参见使用 keyframes 定义动画序列小节部分。transition 也可实现动画。transition<br>强调过渡，是元素的一个或多个属性发生变化时产生的过渡效果，同一个元素通过两个不同的途径获取样式，而第二个途径当某种改变发生（例如 hover）时才能获取样式，这样就会产生过渡动画。</p>\n<ul>\n<li><h3 id=\"如何实现图片在某个容器中居中的？\"><a href=\"#如何实现图片在某个容器中居中的？\" class=\"headerlink\" title=\"如何实现图片在某个容器中居中的？\"></a>如何实现图片在某个容器中居中的？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>父元素固定宽高，利用定位及设置子元素 margin 值为自身的一半。</p>\n<p>父元素固定宽高，子元素设置 position: absolute，margin：auto 平均分配 margin css3 属 性 transform 。 子 元 素 设 置 position:<br>absolute; left: 50%; top: 50%;transform: translate(-50%,-50%);即可。</p>\n<p>将父元素设置成 display: table, 子元素设置为单元格 display: table-cell。</p>\n<p>弹性布局 display: flex。设置 align-items: center; justify-content: center</p>\n<ul>\n<li><h3 id=\"如何实现元素的垂直居中\"><a href=\"#如何实现元素的垂直居中\" class=\"headerlink\" title=\"如何实现元素的垂直居中\"></a>如何实现元素的垂直居中</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>法一：父元素 display:flex,align-items:center;</p>\n<p>法二：元素绝对定位，top:50%，margin-top：-（高度/2）</p>\n<p>法三：高度不确定用 transform：translateY（-50%）</p>\n<p>法四：父元素 table 布局，子元素设置 vertical-align:center;</p>\n<ul>\n<li><h3 id=\"CSS3-中对溢出的处理\"><a href=\"#CSS3-中对溢出的处理\" class=\"headerlink\" title=\"CSS3 中对溢出的处理\"></a>CSS3 中对溢出的处理</h3></li>\n</ul>\n<p>参考回答： cnkOhu</p>\n<p>text-overflow 属性，值为 clip 是修剪文本；ellipsis 为显示省略符号来表被修剪的文本；string 为使用给定的字符串来代表被修剪的文本。</p>\n<ul>\n<li><h3 id=\"float-的元素，display-是什么\"><a href=\"#float-的元素，display-是什么\" class=\"headerlink\" title=\"float 的元素，display 是什么\"></a>float 的元素，display 是什么</h3></li>\n</ul>\n<p>参 考 回 答 ： display 为 block</p>\n<ul>\n<li><h3 id=\"隐藏页面中某个元素的方法\"><a href=\"#隐藏页面中某个元素的方法\" class=\"headerlink\" title=\"隐藏页面中某个元素的方法\"></a>隐藏页面中某个元素的方法</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>display:none; visibility:hidden; opacity: 0; position 移到外部，z-index 涂层遮盖等等</p>\n<ul>\n<li><h3 id=\"三栏布局的实现方式，尽可能多写，浮动布局时，三个-div-的生成顺序有没有影响\"><a href=\"#三栏布局的实现方式，尽可能多写，浮动布局时，三个-div-的生成顺序有没有影响\" class=\"headerlink\" title=\"三栏布局的实现方式，尽可能多写，浮动布局时，三个 div 的生成顺序有没有影响\"></a>三栏布局的实现方式，尽可能多写，浮动布局时，三个 div 的生成顺序有没有影响</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>三列布局又分为两种，两列定宽一列自适应，以及两侧定宽中间自适应两列定宽一列自适应：</p>\n<p>1、使用 float+margin：</p>\n<p>给 div 设置 float：left，left 的 div 添加属性 margin-right：left 和 center 的间隔 px,right 的 div 添加属性<br>margin-left：left 和 center 的宽度之和加上间隔</p>\n<p>2、使用 float+overflow：</p>\n<p>给 div 设置 float：left，再给 right 的 div 设置 overflow:hidden。这样子两个盒子浮动，另一个盒子触发 bfc 达到自适应</p>\n<p>3、使用 position：</p>\n<p>父级 div 设置 position：relative，三个子级 div 设置 position：absolute，这个要计算好盒子的宽度和间隔去设置位置，兼容性比较好，</p>\n<p>4、使用 table 实现：</p>\n<p>父级 div 设置 display：table，设置 border-spacing：10px//设置间距，取值随意, 子级 div 设置<br>display:table-cell，这种方法兼容性好，适用于高度宽度未知的情况，但是 margin 失效，设计间隔比较麻烦，</p>\n<p>5、flex 实现：</p>\n<p>parent 的 div 设置 display：flex；left 和 center 的 div 设置 margin-right；然后right 的 div 设置 flex：1；这样子 right<br>自适应，但是 flex 的兼容性不好</p>\n<p>6、grid 实现：</p>\n<p>parent 的 div 设置 display：grid，设置 grid-template-columns 属性，固定第一列第二列宽度，第三列 auto，</p>\n<p>对于两侧定宽中间自适应的布局，对于这种布局需要把 center 放在前面，可以采用双飞翼布局：圣杯布局，来实现，也可以使用上述方法中的 grid，table，flex， position 实现</p>\n<ul>\n<li><h3 id=\"什么是-BFC\"><a href=\"#什么是-BFC\" class=\"headerlink\" title=\"什么是 BFC\"></a>什么是 BFC</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>BFC 也就是常说的块格式化上下文，这是一个独立的渲染区域，规定了内部如何布局， 并且这个区域的子元素不会影响到外面的元素，其中比较重要的布局规则有内部 box 垂直放置，计算 BFC<br>的高度的时候，浮动元素也参与计算，触发 BFC 的规则有根元</p>\n<p>素，浮动元素，position 为 absolute 或 fixed 的元素，display 为 inline-block，<br>table-cell，table-caption，flex，inline-flex，overflow 不为 visible 的元素</p>\n<ul>\n<li><h3 id=\"calc-属性\"><a href=\"#calc-属性\" class=\"headerlink\" title=\"calc 属性\"></a>calc 属性</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Calc 用户动态计算长度值，任何长度值都可以使用 calc()函数计算，需要注意的是， 运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；</p>\n<ul>\n<li><h3 id=\"有一个-width300，height300，怎么实现在屏幕上垂直水平居中\"><a href=\"#有一个-width300，height300，怎么实现在屏幕上垂直水平居中\" class=\"headerlink\" title=\"有一个 width300，height300，怎么实现在屏幕上垂直水平居中\"></a>有一个 width300，height300，怎么实现在屏幕上垂直水平居中</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>对于行内块级元素，</p>\n<p>1、父级元素设置 text-alig：center，然后设置 line-height 和 vertical-align 使其垂直居中，最后设置 font-size：0 消除近似居中的 bug</p>\n<p>2、父级元素设置 display：table-cell，vertical-align：middle 达到水平垂直居中3、采用绝对定位，原理是子绝父相，父元素设置<br>position：relative，子元素设置position：absolute，然后通过 transform 或 margin 组合使用达到垂直居中效果，设置<br>top：50%，left：50%，transform：translate（-50%，-50%）</p>\n<p>4、绝对居中，原理是当 top,bottom 为 0 时，margin-top&amp;bottom 设置 auto 的话会无限延伸沾满空间并平分，当 left，right 为 0<br>时,margin-left&amp;right 设置 auto 会无限延伸占满空间并平分，</p>\n<p>5、采用 flex，父元素设置 display：flex，子元素设置 margin：auto</p>\n<p>6、视窗居中，vh 为视口单位，50vh 即是视口高度的 50/100，设置 margin：50vh auto 0，transform：translate(-50%)</p>\n<ul>\n<li><h3 id=\"display：table-和本身的-table-有什么区别\"><a href=\"#display：table-和本身的-table-有什么区别\" class=\"headerlink\" title=\"display：table 和本身的 table 有什么区别\"></a>display：table 和本身的 table 有什么区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Display:table 和本身 table 是相对应的，区别在于，display：table 的 css 声明能够让一个 html 元素和它的子节点像 table 元素一样，使用基于表格的 css<br>布局，是我们能够轻松定义一个单元格的边界，背景等样式，而不会产生因为使用了 table 那样的制表标签导致的语义化问题。</p>\n<p>之所以现在逐渐淘汰了 table 系表格元素，是因为用 div+css 编写出来的文件比用table 边写出来的文件小，而且 table 必须在页面完全加载后才显示，div 则是逐行显示，table<br>的嵌套性太多，没有 div 简洁</p>\n<ul>\n<li><h3 id=\"position-属性的值有哪些及其区别\"><a href=\"#position-属性的值有哪些及其区别\" class=\"headerlink\" title=\"position 属性的值有哪些及其区别\"></a>position 属性的值有哪些及其区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Position 属性把元素放置在一个静态的，相对的，绝对的，固定的位置中， Static：位置设置为 static 的元素，他始终处于页面流给予的位置，static 元素会忽略任何<br>top,buttom,left,right 声明</p>\n<p>Relative：位置设置为 relative 的元素，可将其移至相对于其正常位置的地方，因此</p>\n<p>left：20 会将元素移至元素正常位置左边 20 个像素的位置</p>\n<p>Absolute：此元素可定位于相对包含他的元素的指定坐标，此元素可通过 left，top</p>\n<p>等属性规定</p>\n<p>Fixed：位置被设为 fiexd 的元素，可定为与相对浏览器窗口的指定坐标，可以通过</p>\n<p>left，top，right 属性来定位</p>\n<ul>\n<li><h3 id=\"z-index-的定位方法\"><a href=\"#z-index-的定位方法\" class=\"headerlink\" title=\"z-index 的定位方法\"></a>z-index 的定位方法</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol start=\"26\">\n<li>index 属性设置元素的堆叠顺序，拥有更好堆叠顺序的元素会处于较低顺序元素之前，z-index 可以为负，且z-index 只能在定位元素上奏效，该属性设置一个定位元素沿z<br>轴的位置，如果为正数，离用户越近，为负数，离用户越远，它的属性值有auto，默认，堆叠顺序与父元素相等，number，inherit，从父元素继承 z-index 属性的值</li>\n</ol>\n<ul>\n<li><h3 id=\"如果想要改变一个-DOM-元素的字体颜色，不在它本身上进行操作？\"><a href=\"#如果想要改变一个-DOM-元素的字体颜色，不在它本身上进行操作？\" class=\"headerlink\" title=\"如果想要改变一个 DOM 元素的字体颜色，不在它本身上进行操作？\"></a>如果想要改变一个 DOM 元素的字体颜色，不在它本身上进行操作？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>可以更改父元素的 color</p>\n<ul>\n<li><h3 id=\"对-CSS-的新属性有了解过的吗？\"><a href=\"#对-CSS-的新属性有了解过的吗？\" class=\"headerlink\" title=\"对 CSS 的新属性有了解过的吗？\"></a>对 CSS 的新属性有了解过的吗？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>CSS3 的新特性中，在布局方面新增了 flex 布局，在选择器方面新增了例如 first-of- type,nth-child 等选择器，在盒模型方面添加了box-sizing<br>来改变盒模型，在动画方面增加了 animation，2d 变换，3d 变换等，在颜色方面添加透明，rbga 等，在字体方面允许嵌入字体和设置字体阴影，最后还有媒体查讯等</p>\n<ul>\n<li><h3 id=\"用的最多的-css-属性是啥？\"><a href=\"#用的最多的-css-属性是啥？\" class=\"headerlink\" title=\"用的最多的 css 属性是啥？\"></a>用的最多的 css 属性是啥？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>用的目前来说最多的是 flex 属性，灵活但是兼容性方面不强。</p>\n<ul>\n<li><h3 id=\"line-height-和-height-的区别\"><a href=\"#line-height-和-height-的区别\" class=\"headerlink\" title=\"line-height 和 height 的区别\"></a>line-height 和 height 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>line-height 一般是指布局里面一段文字上下行之间的高度，是针对字体来设置的，</p>\n<p>height 一般是指容器的整体高度。</p>\n<ul>\n<li><h3 id=\"设置一个元素的背景颜色，背景颜色会填充哪些区域？\"><a href=\"#设置一个元素的背景颜色，背景颜色会填充哪些区域？\" class=\"headerlink\" title=\"设置一个元素的背景颜色，背景颜色会填充哪些区域？\"></a>设置一个元素的背景颜色，背景颜色会填充哪些区域？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>background-color 设置的背景颜色会填充元素的content、padding、border 区域。</p>\n<ul>\n<li><h3 id=\"知道属性选择器和伪类选择器的优先级吗\"><a href=\"#知道属性选择器和伪类选择器的优先级吗\" class=\"headerlink\" title=\"知道属性选择器和伪类选择器的优先级吗\"></a>知道属性选择器和伪类选择器的优先级吗</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>属性选择器和伪类选择器优先级相同</p>\n<ul>\n<li><h3 id=\"inline-block、inline-和-block-的区别；为什么-img-是-inline-还可以设置宽高\"><a href=\"#inline-block、inline-和-block-的区别；为什么-img-是-inline-还可以设置宽高\" class=\"headerlink\" title=\"inline-block、inline 和 block 的区别；为什么 img 是 inline 还可以设置宽高\"></a>inline-block、inline 和 block 的区别；为什么 img 是 inline 还可以设置宽高</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Block 是块级元素，其前后都会有换行符，能设置宽度，高度，margin/padding 水平垂直方向都有效。</p>\n<p>Inline：设置 width 和 height 无效，margin 在竖直方向上无效，padding 在水平方向垂直方向都有效，前后无换行符</p>\n<p>Inline-block：能设置宽度高度，margin/padding 水平垂直方向 都有效，前后无换行符</p>\n<ul>\n<li><h3 id=\"用-css-实现一个硬币旋转的效果\"><a href=\"#用-css-实现一个硬币旋转的效果\" class=\"headerlink\" title=\"用 css 实现一个硬币旋转的效果\"></a>用 css 实现一个硬币旋转的效果</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>虽然不认为很多人能在面试中写出来</p>\n<h3 id=\"euro-width-150px\"><a href=\"#euro-width-150px\" class=\"headerlink\" title=\"#euro { width: 150px\"></a>#euro { width: 150px</h3><blockquote>\n<p>height: 150px; margin-left: -75px; margin-top: -75px; position: absolute; top: 50%;</p>\n</blockquote>\n<blockquote>\n<p>left: 50%;</p>\n</blockquote>\n<blockquote>\n<p>transform-style: preserve-3d; animation: spin 2.5s linear infinite;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.back {</p>\n</blockquote>\n<blockquote>\n<p>background-image: url(“/uploads/160101/backeuro.png”); width: 150px;</p>\n</blockquote>\n<blockquote>\n<p>height: 150px;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.middle {</p>\n</blockquote>\n<blockquote>\n<p>background-image: url(“/uploads/160101/faceeuro.png”); width: 150px;</p>\n</blockquote>\n<blockquote>\n<p>height: 150px;</p>\n</blockquote>\n<blockquote>\n<p>transform: translateZ(1px); position: absolute;</p>\n</blockquote>\n<blockquote>\n<p>top: 0;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.front {</p>\n</blockquote>\n<blockquote>\n<p>background-image: url(“/uploads/160101/faceeuro.png”); height: 150px;</p>\n</blockquote>\n<blockquote>\n<p>position: absolute; top: 0;</p>\n</blockquote>\n<blockquote>\n<p>transform: translateZ(10px); width: 150px;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>@keyframes spin { 0% {</p>\n</blockquote>\n<blockquote>\n<p>transform: rotateY(0deg);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>100% {</p>\n</blockquote>\n<blockquote>\n<p>transform: rotateY(360deg);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"了解重绘和重排吗，知道怎么去减少重绘和重排吗，让文档脱离文档流有哪些方法\"><a href=\"#了解重绘和重排吗，知道怎么去减少重绘和重排吗，让文档脱离文档流有哪些方法\" class=\"headerlink\" title=\"了解重绘和重排吗，知道怎么去减少重绘和重排吗，让文档脱离文档流有哪些方法\"></a>了解重绘和重排吗，知道怎么去减少重绘和重排吗，让文档脱离文档流有哪些方法</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>DOM 的变化影响到了预算内宿的几何属性比如宽高，浏览器重新计算元素的几何属性， 其他元素的几何属性也会受到影响，浏览器需要重新构造渲染书，这个过程称之为重排，浏览器将受到影响的部分重新绘制在屏幕上<br>的过程称为重绘，引起重排重绘的原因有：</p>\n<p>添加或者删除可见的 DOM 元素， 元素尺寸位置的改变</p>\n<p>浏览器页面初始化，</p>\n<p>浏览器窗口大小发生改变，重排一定导致重绘，重绘不一定导致重排， 减少重绘重排的方法有：</p>\n<p>不在布局信息改变时做 DOM 查询，</p>\n<p>使用 csstext,className 一次性改变属性使用 fragment</p>\n<p>对于多次重排的元素，比如说动画。使用绝对定位脱离文档流，使其不影响其他元素</p>\n<ul>\n<li><h3 id=\"CSS-画正方体，三角形\"><a href=\"#CSS-画正方体，三角形\" class=\"headerlink\" title=\"CSS 画正方体，三角形\"></a>CSS 画正方体，三角形</h3></li>\n</ul>\n<p>参考回答： 画三角形</p>\n<h3 id=\"triangle02-width-0-height-0\"><a href=\"#triangle02-width-0-height-0\" class=\"headerlink\" title=\"#triangle02{ width: 0; height: 0\"></a>#triangle02{ width: 0; height: 0</h3><blockquote>\n<p>border-top: 50px solid blue; border-right: 50px solid red; border-bottom: 50px solid green;<br>border-left: 50px solid yellow;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<p>画正方体：</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><!DOCTYPE html></h3><blockquote>\n<html lang=\"en\">\n</blockquote>\n<blockquote>\n<head>\n</blockquote>\n<blockquote>\n<meta charset=\"UTF-8\">\n</blockquote>\n<blockquote>\n<title>perspective\\</title>\n</blockquote>\n<blockquote>\n<style>\n</blockquote>\n<blockquote>\n<p>.wrapper{ width: 50%; float: left;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.cube{</p>\n</blockquote>\n<blockquote>\n<p>font-size: 4em; width: 2em;</p>\n</blockquote>\n<blockquote>\n<p>margin: 1.5em auto; transform-style:preserve-3d;</p>\n</blockquote>\n<blockquote>\n<p>transform:rotateX(-35deg) rotateY(30deg);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.side{</p>\n</blockquote>\n<blockquote>\n<p>position: absolute; width: 2em;</p>\n</blockquote>\n<blockquote>\n<p>height: 2em;</p>\n</blockquote>\n<blockquote>\n<p>background: rgba(255,99,71,0.6); border: 1px solid rgba(0,0,0,0.5); color: white;</p>\n</blockquote>\n<blockquote>\n<p>text-align: center; line-height: 2em;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.front{ transform:translateZ(1em);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.bottom{</p>\n</blockquote>\n<blockquote>\n<p>transform:rotateX(-90deg) translateZ(1em);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.top{</p>\n</blockquote>\n<blockquote>\n<p>transform:rotateX(90deg) translateZ(1em);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.left{</p>\n</blockquote>\n<blockquote>\n<p>transform:rotateY(-90deg) translateZ(1em);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.right{</p>\n</blockquote>\n<blockquote>\n<p>transform:rotateY(90deg) translateZ(1em);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.back{ transform:translateZ(-1em);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p></style></p>\n</blockquote>\n<blockquote>\n</head>\n</blockquote>\n<blockquote>\n<body>\n</blockquote>\n<blockquote>\n<div class=\"wrapper w1\">\n</blockquote>\n<blockquote>\n<div class=\"cube\">\n</blockquote>\n<blockquote>\n<div class=\"side front\">1\\</div>\n</blockquote>\n<blockquote>\n<div class=\"side back\">6\\</div>\n</blockquote>\n<blockquote>\n<div class=\"side right\">4\\</div>\n</blockquote>\n<blockquote>\n<div class=\"side left\">3\\</div>\n</blockquote>\n<blockquote>\n<div class=\"side top\">5\\</div>\n</blockquote>\n<blockquote>\n<div class=\"side bottom\">2\\</div>\n</blockquote>\n<blockquote>\n</div>\n</blockquote>\n<blockquote>\n</div>\n</blockquote>\n<blockquote>\n<div class=\"wrapper w2\">\n</blockquote>\n<blockquote>\n<div class=\"cube\">\n</blockquote>\n<blockquote>\n<div class=\"side front\">1\\</div>\n</blockquote>\n<blockquote>\n<div class=\"side back\">6\\</div>\n</blockquote>\n<blockquote>\n<div class=\"side right\">4\\</div>\n</blockquote>\n<blockquote>\n<div class=\"side left\">3\\</div>\n</blockquote>\n<blockquote>\n<div class=\"side top\">5\\</div>\n</blockquote>\n<blockquote>\n<div class=\"side bottom\">2\\</div>\n</blockquote>\n<blockquote>\n</div>\n</blockquote>\n<blockquote>\n</div>\n</blockquote>\n<blockquote>\n</body>\n</blockquote>\n<blockquote>\n</html>\n</blockquote>\n<ul>\n<li><h3 id=\"overflow-的原理\"><a href=\"#overflow-的原理\" class=\"headerlink\" title=\"overflow 的原理\"></a>overflow 的原理</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>要讲清楚这个解决方案的原理，首先需要了解块格式化上下文，A block formatting context is a part of a visual CSS rendering of a Web<br>page. It is the region in which the layout of block boxes occurs and in which floats interact with<br>each other.翻译过来就是块格式化上下文是 CSS 可视化渲染的一部分，它是一块区域，规定了内部块盒 的渲染方式，以及浮动相互之间的影响关系</p>\n<p>当元素设置了 overflow 样式且值部位 visible 时，该元素就构建了一个 BFC，BFC 在计算高度时，内部浮动元素的高度也要计算在内，也就是说技术 BFC 区域内只有一个浮动元素，BFC<br>的高度也不会发生塌缩，所以达到了清除浮动的目的。</p>\n<ul>\n<li><h3 id=\"清除浮动的方法\"><a href=\"#清除浮动的方法\" class=\"headerlink\" title=\"清除浮动的方法\"></a>清除浮动的方法</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>给要清除浮动的元素添加样式 clear，\\</p>\n<p>父元素结束标签钱插入清除浮动的块级元素，给该元素添加样式 clear</p>\n<p>添加伪元素，在父级元素的最后，添加一个伪元素，通过清除伪元素的浮动，注意该伪元素的 display 为 block，</p>\n<p>父元素添加样式 overflow 清除浮动，overflow 设置除 visible 以外的任何位置</p>\n<ul>\n<li><h3 id=\"box-sizing-的语法和基本用处\"><a href=\"#box-sizing-的语法和基本用处\" class=\"headerlink\" title=\"box-sizing 的语法和基本用处\"></a>box-sizing 的语法和基本用处</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>box-sizing 规定两个并排的带边框的框，语法为box-sizing：content-box/border- box/inherit</p>\n<p>content-box：宽度和高度分别应用到元素的内容框，在宽度和高度之外绘制元素的内边距和边框</p>\n<p>border-box：为元素设定的宽度和高度决定了元素的边框盒， inherit：继承父元素的 box-sizing</p>\n<ul>\n<li><h3 id=\"使元素消失的方法有哪些？\"><a href=\"#使元素消失的方法有哪些？\" class=\"headerlink\" title=\"使元素消失的方法有哪些？\"></a>使元素消失的方法有哪些？</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>opacity：0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如 click 事件，那么点击该区域，也能触发点击事件的</p>\n</li>\n<li><p>visibility：hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件</p>\n</li>\n<li><p>display：none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉。</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"两个嵌套的-div，position-都是-absolute，子-div-设置-top-属性，那么这个-top-是相对于父元素的哪个位置定位的\"><a href=\"#两个嵌套的-div，position-都是-absolute，子-div-设置-top-属性，那么这个-top-是相对于父元素的哪个位置定位的\" class=\"headerlink\" title=\"两个嵌套的 div，position 都是 absolute，子 div 设置 top 属性，那么这个 top 是相对于父元素的哪个位置定位的\"></a>两个嵌套的 div，position 都是 absolute，子 div 设置 top 属性，那么这个 top 是相对于父元素的哪个位置定位的</h3></li>\n</ul>\n<p>参 考 回 答 ： margin 的外边缘</p>\n<ul>\n<li><h3 id=\"说说盒子模型\"><a href=\"#说说盒子模型\" class=\"headerlink\" title=\"说说盒子模型\"></a>说说盒子模型</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>CSS 盒模型本质上是一个盒子，封装周围的 HTML 元素，它包括：边距，边框，填充， 和实际内容。</p>\n<p>标准盒模型：一个块的总宽度=width+margin(左右)+padding(左右)+border(左右) 怪异盒模型：一个块的总宽度=width+margin（左右）（既 width 已经包含了<br>padding 和 border 值）</p>\n<p>如何设置：box-sizing:border-box</p>\n<ul>\n<li><h3 id=\"display\"><a href=\"#display\" class=\"headerlink\" title=\"display\"></a>display</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>主要取值有 none,block,inline-block,inline,flex 等。具体可参考</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/display\"><em>https://developer.mozilla.org/zh-CN/docs/Web/CSS/display</em></a></p>\n<ul>\n<li><h3 id=\"怎么隐藏一个元素\"><a href=\"#怎么隐藏一个元素\" class=\"headerlink\" title=\"怎么隐藏一个元素\"></a>怎么隐藏一个元素</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>opacity：0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如 click 事件，那么点击该区域，也能触发点击事件的</p>\n</li>\n<li><p>visibility：hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件</p>\n</li>\n<li><p>display：none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉。</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"display-none-和-visibilty-hidden-的区别\"><a href=\"#display-none-和-visibilty-hidden-的区别\" class=\"headerlink\" title=\"display:none 和 visibilty:hidden 的区别\"></a>display:none 和 visibilty:hidden 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>visibility：hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件</p>\n</li>\n<li><p>display：none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉。</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"相对布局和绝对布局，position-relative-和-obsolute\"><a href=\"#相对布局和绝对布局，position-relative-和-obsolute\" class=\"headerlink\" title=\"相对布局和绝对布局，position:relative 和 obsolute\"></a>相对布局和绝对布局，position:relative 和 obsolute</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>相对定位 relative：</p>\n<p>如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。<br>在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 绝对定位 absolute：</p>\n<p>绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素， 那么它的位置相对于&lt;html&gt;。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute<br>定位的元素和其他元素重叠。</p>\n<ul>\n<li><h3 id=\"flex-布局\"><a href=\"#flex-布局\" class=\"headerlink\" title=\"flex 布局\"></a>flex 布局</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>flex 是 Flexible Box 的缩写，意为”弹性布局”。指定容器 display: flex<br>即可。容器有以下属性：flex-direction，flex-wrap，flex-flow，justify-content， align-items，align-content。</p>\n<p>flex-direction 属性决定主轴的方向；</p>\n<p>flex-wrap 属性定义，如果一条轴线排不下，如何换行；</p>\n<p>flex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap；</p>\n<p>justify-content 属性定义了项目在主轴上的对齐方式。align-items 属性定义项目在交叉轴上如何对齐。</p>\n<p>align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>\n<p>项目（子元素）也有一些属性：order，flex-grow，flex-shrink，flex-basis，</p>\n<p>flex，align-self。</p>\n<p>order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。</p>\n<p>flex-grow 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。</p>\n<p>flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为<br>0 1 auto。后两个属性可选。</p>\n<p>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于<br>stretch。</p>\n<p>参考<br><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\"><em>http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</em></a></p>\n<ul>\n<li><h3 id=\"block、inline、inline-block-的区别\"><a href=\"#block、inline、inline-block-的区别\" class=\"headerlink\" title=\"block、inline、inline-block 的区别\"></a>block、inline、inline-block 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>block 元素会独占一行，多个 block 元素会各自新起一行。默认情况下，block 元素宽度自动填满其父元素宽度。</p>\n<p>block 元素可以设置 width,height 属性。块级元素即使设置了宽度,仍然是独占一行。block 元素可以设置 margin 和 padding 属性。</p>\n<p>inline 元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。</p>\n<p>inline 元素设置 width,height 属性无效。</p>\n<p>inline 元素的 margin 和 padding 属性，水平方向的 padding-left, padding-right, margin-left, margin-right<br>都产生边距效果；但竖直方向的 padding-top, padding- bottom, margin-top, margin-bottom 不会产生边距效果。</p>\n<p>inline-block：简单来说就是将对象呈现为 inline 对象，但是对象的内容作为 block</p>\n<p>对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个 link（a 元</p>\n<p>素）inline-block 属性值，使其既具有 block 的宽度高度特性又具有 inline 的同行特性。</p>\n<ul>\n<li><h3 id=\"css-的常用选择器\"><a href=\"#css-的常用选择器\" class=\"headerlink\" title=\"css 的常用选择器\"></a>css 的常用选择器</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>id 选择器，类选择器，伪类选择器等</p>\n<ul>\n<li><h3 id=\"css-布局\"><a href=\"#css-布局\" class=\"headerlink\" title=\"css 布局\"></a>css 布局</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>六种布局方式总结：圣杯布局、双飞翼布局、Flex 布局、绝对定位布局、表格布局、网格布局。</p>\n<p>圣杯布局是指布局从上到下分为 header、container、footer，然后 container 部分定为三栏布局。这种布局方式同样分为<br>header、container、footer。圣杯布局的缺陷在于 center 是在 container 的 padding 中的，因此宽度小的时候会出现混乱。</p>\n<p>双飞翼布局给 center 部分包裹了一个 main 通过设置 margin 主动地把页面撑开。Flex 布局是由 CSS3 提供的一种方便的布局方式。</p>\n<p>绝对定位布局是给 container 设置 position: relative 和 overflow: hidden，因为绝对定位的元素的参照物为第一个 postion 不为 static<br>的祖先元素。 left 向左浮动，right 向右浮动。center 使用绝对定位，通过设置 left 和 right 并把两边撑开。 center 设置 top: 0 和 bottom: 0<br>使其高度撑开。</p>\n<p>表格布局的好处是能使三栏的高度统一。</p>\n<p>网格布局可能是最强大的布局方式了，使用起来极其方便，但目前而言，兼容性并不好。网格布局，可以将页面分割成多个区域，或者用来定义内部元素的大小，位置， 图层关系。</p>\n<ul>\n<li><h3 id=\"css-定位\"><a href=\"#css-定位\" class=\"headerlink\" title=\"css 定位\"></a>css 定位</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>固定定位 fixed：</p>\n<p>元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重</p>\n<p>叠。</p>\n<p>相对定位 relative：</p>\n<p>如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。<br>在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 绝对定位 absolute：</p>\n<p>绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素， 那么它的位置相对于&lt;html&gt;。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute<br>定位的元素和其他元素重叠。</p>\n<p>粘性定位 sticky：</p>\n<p>元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和containing<br>block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。</p>\n<p>默认定位 Static：</p>\n<p>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者z-index 声明）。</p>\n<p>inherit:</p>\n<p>规定应该从父元素继承 position 属性的值。</p>\n<ul>\n<li><h3 id=\"relative-定位规则\"><a href=\"#relative-定位规则\" class=\"headerlink\" title=\"relative 定位规则\"></a>relative 定位规则</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。<br>在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。</p>\n<ul>\n<li><h3 id=\"垂直居中\"><a href=\"#垂直居中\" class=\"headerlink\" title=\"垂直居中\"></a>垂直居中</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>父元素固定宽高，利用定位及设置子元素 margin 值为自身的一半。</p>\n<p>父元素固定宽高，子元素设置 position: absolute，margin：auto 平均分配 margin css3 属 性 transform 。 子 元 素 设 置 position:<br>absolute; left: 50%; top: 50%;transform: translate(-50%,-50%);即可。</p>\n<p>将父元素设置成 display: table, 子元素设置为单元格 display: table-cell。</p>\n<p>弹性布局 display: flex。设置 align-items: center; justify-content: center;</p>\n<ul>\n<li><h3 id=\"css-预处理器有什么\"><a href=\"#css-预处理器有什么\" class=\"headerlink\" title=\"css 预处理器有什么\"></a>css 预处理器有什么</h3></li>\n</ul>\n<p>参考回答： less，sass 等</p>\n<ol start=\"3\">\n<li><h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"| JavaScript\"></a>| JavaScript</h2></li>\n</ol>\n<ul>\n<li><h3 id=\"get-请求传参长度的误区\"><a href=\"#get-请求传参长度的误区\" class=\"headerlink\" title=\"get 请求传参长度的误区\"></a>get 请求传参长度的误区</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。</p>\n<p>实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或 web 服务器，浏览器或 web 服务器限制了 url<br>的长度。为了明确这个概念，我们必须再次强调下面几点:</p>\n<p>HTTP 协议 未规定 GET 和 POST 的长度限制</p>\n<p>GET 的最大长度显示是因为 浏览器和 web 服务器限制了 URI 的长度不同的浏览器和 WEB 服务器，限制的最大长度不一样</p>\n<p>要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte</p>\n<ul>\n<li><h3 id=\"补充-get-和-post-请求在缓存方面的区别\"><a href=\"#补充-get-和-post-请求在缓存方面的区别\" class=\"headerlink\" title=\"补充 get 和 post 请求在缓存方面的区别\"></a>补充 get 和 post 请求在缓存方面的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>post/get 的请求区别，具体不再赘述。</p>\n<p>补充补充一个 get 和 post 在缓存方面的区别：</p>\n<p>get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</p>\n<p>post 不同，post 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此 get 请求适合于请求缓存。</p>\n<ul>\n<li><h3 id=\"说一下闭包\"><a href=\"#说一下闭包\" class=\"headerlink\" title=\"说一下闭包\"></a>说一下闭包</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>一句话可以概括：闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放。</p>\n<ul>\n<li><h3 id=\"说一下类的创建和继承\"><a href=\"#说一下类的创建和继承\" class=\"headerlink\" title=\"说一下类的创建和继承\"></a>说一下类的创建和继承</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li>类的创建（es5）：new 一个 function，在这个 function 的 prototype 里面增加属性和方法。</li>\n</ol>\n<p>下面来创建一个 Animal 类：</p>\n<p>// 定义一个动物类function Animal (name) {</p>\n<p>// 属性</p>\n<p>this.name = name || ‘Animal’;</p>\n<p>// 实例方法</p>\n<p>this.sleep = function(){ console.log(this.name + ‘正在睡觉！’);</p>\n<p>}</p>\n<p>}</p>\n<p>// 原型方法</p>\n<p>Animal.prototype.eat = function(food) { console.log(this.name + ‘正在吃：’ + food);</p>\n<p>};</p>\n<p>这样就生成了一个 Animal 类，实力化生成对象后，有方法和属性。</p>\n<ol start=\"2\">\n<li>类的继承——原型链继承</li>\n</ol>\n<p>–原型链继承</p>\n<h3 id=\"function-Cat-Cat-prototype-new-Animal-Cat-prototype-name-‘cat’\"><a href=\"#function-Cat-Cat-prototype-new-Animal-Cat-prototype-name-‘cat’\" class=\"headerlink\" title=\"function Cat(){ } Cat.prototype = new Animal(); Cat.prototype.name = ‘cat’\"></a>function Cat(){ } Cat.prototype = new Animal(); Cat.prototype.name = ‘cat’</h3><blockquote>\n<p>// Test Code</p>\n</blockquote>\n<blockquote>\n<p>var cat = new Cat(); console.log(cat.name); console.log(cat.eat(‘fish’));<br>console.log(cat.sleep());</p>\n</blockquote>\n<blockquote>\n<p>console.log(cat instanceof Animal); //true console.log(cat instanceof Cat); //true</p>\n</blockquote>\n<p>介绍：在这里我们可以看到 new 了一个空对象,这个空对象指向 Animal 并且</p>\n<p>Cat.prototype 指向了这个空对象，这种就是基于原型链的继承。特点：基于原型链，既是父类的实例，也是子类的实例</p>\n<p>缺点：无法实现多继承</p>\n<ol start=\"3\">\n<li>构造继承：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</li>\n</ol>\n<h3 id=\"function-Cat-name-Animal-call-this-this-name-name-‘Tom’\"><a href=\"#function-Cat-name-Animal-call-this-this-name-name-‘Tom’\" class=\"headerlink\" title=\"function Cat(name){ Animal.call(this); this.name = name || ‘Tom’\"></a>function Cat(name){ Animal.call(this); this.name = name || ‘Tom’</h3><blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>// Test Code</p>\n</blockquote>\n<blockquote>\n<p>var cat = new Cat(); console.log(cat.name); console.log(cat.sleep());</p>\n</blockquote>\n<blockquote>\n<p>console.log(cat instanceof Animal); // false console.log(cat instanceof Cat); // true</p>\n</blockquote>\n<p>特点：可以实现多继承</p>\n<p>缺点：只能继承父类实例的属性和方法，不能继承原型上的属性和方法。</p>\n<ol start=\"4\">\n<li>实例继承和拷贝继承</li>\n</ol>\n<p>实例继承：为父类实例添加新特性，作为子类实例返回拷贝继承：拷贝父类元素上的属性和方法</p>\n<p>上述两个实用性不强，不一一举例。</p>\n<ol start=\"5\">\n<li>组合继承：相当于构造继承和原型链继承的组合体。通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用function Cat(name){</li>\n</ol>\n<h3 id=\"Animal-call-this-this-name-name-‘Tom’\"><a href=\"#Animal-call-this-this-name-name-‘Tom’\" class=\"headerlink\" title=\"Animal.call(this); this.name = name || ‘Tom’\"></a>Animal.call(this); this.name = name || ‘Tom’</h3><blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>Cat.prototype = new Animal(); Cat.prototype.constructor = Cat;</p>\n</blockquote>\n<blockquote>\n<p>// Test Code</p>\n</blockquote>\n<blockquote>\n<p>var cat = new Cat(); console.log(cat.name); console.log(cat.sleep());</p>\n</blockquote>\n<blockquote>\n<p>console.log(cat instanceof Animal); // true console.log(cat instanceof Cat); // true</p>\n</blockquote>\n<p>特点：可以继承实例属性/方法，也可以继承原型属性/方法缺点：调用了两次父类构造函数，生成了两份实例</p>\n<ol start=\"6\">\n<li>寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性</li>\n</ol>\n<h3 id=\"function-Cat-name-Animal-call-this-this-name-name-‘Tom’-1\"><a href=\"#function-Cat-name-Animal-call-this-this-name-name-‘Tom’-1\" class=\"headerlink\" title=\"function Cat(name){ Animal.call(this); this.name = name || ‘Tom’\"></a>function Cat(name){ Animal.call(this); this.name = name || ‘Tom’</h3><blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>(function(){</p>\n</blockquote>\n<p>// 创建一个没有实例方法的类</p>\n<h3 id=\"var-Super-function-Super-prototype-Animal-prototype\"><a href=\"#var-Super-function-Super-prototype-Animal-prototype\" class=\"headerlink\" title=\"var Super = function(){}; Super.prototype = Animal.prototype\"></a>var Super = function(){}; Super.prototype = Animal.prototype</h3><p>//将实例作为子类的原型</p>\n<h3 id=\"Cat-prototype-new-Super\"><a href=\"#Cat-prototype-new-Super\" class=\"headerlink\" title=\"Cat.prototype = new Super()\"></a>Cat.prototype = new Super()</h3><blockquote>\n<p>})();</p>\n</blockquote>\n<blockquote>\n<p>// Test Code</p>\n</blockquote>\n<blockquote>\n<p>var cat = new Cat(); console.log(cat.name); console.log(cat.sleep());</p>\n</blockquote>\n<blockquote>\n<p>console.log(cat instanceof Animal); // true console.log(cat instanceof Cat); //true</p>\n</blockquote>\n<p>较为推荐</p>\n<ul>\n<li><h3 id=\"如何解决异步回调地狱\"><a href=\"#如何解决异步回调地狱\" class=\"headerlink\" title=\"如何解决异步回调地狱\"></a>如何解决异步回调地狱</h3></li>\n</ul>\n<p>参考回答：</p>\n<ul>\n<li><h3 id=\"说说前端中的事件流\"><a href=\"#说说前端中的事件流\" class=\"headerlink\" title=\"说说前端中的事件流\"></a>说说前端中的事件流</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>HTML 中与 javascript 交互是通过事件驱动来实现的，例如鼠标点击事件 onclick、页面的滚动事件 onscroll<br>等等，可以向文档或者文档中的元素添加事件侦听器来预订事件。想要知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概</p>\n<p>念。</p>\n<p>什么是事件流：事件流描述的是从页面中接收事件的顺序,DOM2 级事件流包括下面几个阶段。</p>\n<p>事件捕获阶段处于目标阶段事件冒泡阶段</p>\n<p>addEventListener：addEventListener 是 DOM2 级事件新增的指定事件处理程序的操作，这个方法接收 3<br>个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。</p>\n<p>IE 只支持事件冒泡。</p>\n<ul>\n<li><h3 id=\"如何让事件先冒泡后捕获\"><a href=\"#如何让事件先冒泡后捕获\" class=\"headerlink\" title=\"如何让事件先冒泡后捕获\"></a>如何让事件先冒泡后捕获</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>在 DOM 标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间。</p>\n<ul>\n<li><h3 id=\"说一下事件委托\"><a href=\"#说一下事件委托\" class=\"headerlink\" title=\"说一下事件委托\"></a>说一下事件委托</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>简介：事件委托指的是，不在事件的发生地（直接 dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素 DOM<br>的类型，来做出不同的响应。</p>\n<p>举例：最经典的就是 ul 和 li 标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在 li 标签上直接添加，而是在 ul 父元素上添加。</p>\n<p>好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。</p>\n<ul>\n<li><h3 id=\"说一下图片的懒加载和预加载\"><a href=\"#说一下图片的懒加载和预加载\" class=\"headerlink\" title=\"说一下图片的懒加载和预加载\"></a>说一下图片的懒加载和预加载</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。</p>\n<p>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。</p>\n<p>两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p>\n<ul>\n<li><h3 id=\"mouseover-和-mouseenter-的区别\"><a href=\"#mouseover-和-mouseenter-的区别\" class=\"headerlink\" title=\"mouseover 和 mouseenter 的区别\"></a>mouseover 和 mouseenter 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是 mouseout</p>\n<p>mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是 mouseleave</p>\n<ul>\n<li><h3 id=\"JS-的-new-操作符做了哪些事情\"><a href=\"#JS-的-new-操作符做了哪些事情\" class=\"headerlink\" title=\"JS 的 new 操作符做了哪些事情\"></a>JS 的 new 操作符做了哪些事情</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>new 操作符新建了一个空对象，这个对象原型指向构造函数的 prototype，执行构造函数后返回这个对象。</p>\n<ul>\n<li><h3 id=\"改变函数内部-this-指针的指向函数（bind，apply，call-的区别）\"><a href=\"#改变函数内部-this-指针的指向函数（bind，apply，call-的区别）\" class=\"headerlink\" title=\"改变函数内部 this 指针的指向函数（bind，apply，call 的区别）\"></a>改变函数内部 this 指针的指向函数（bind，apply，call 的区别）</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>通过 apply 和 call 改变函数的 this 指向，他们两个函数的第一个参数都是一样的表示要改变指向的那个对象，第二个参数，apply 是数组，而 call 则是<br>arg1,arg2…这种形式。通过 bind 改变 this 作用域会返回一个新的函数，这个函数不会马上执行。</p>\n<ul>\n<li><h3 id=\"JS-的各种位置，比如-clientHeight-scrollHeight-offsetHeight-以及-scrollTop-offsetTop-clientTop-的区别？\"><a href=\"#JS-的各种位置，比如-clientHeight-scrollHeight-offsetHeight-以及-scrollTop-offsetTop-clientTop-的区别？\" class=\"headerlink\" title=\"JS 的各种位置，比如 clientHeight,scrollHeight,offsetHeight ,以及 scrollTop, offsetTop,clientTop 的区别？\"></a>JS 的各种位置，比如 clientHeight,scrollHeight,offsetHeight ,以及 scrollTop, offsetTop,clientTop 的区别？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>clientHeight：表示的是可视区域的高度，不包含 border 和滚动条offsetHeight：表示可视区域的高度，包含了 border<br>和滚动条scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分。clientTop：表示边框 border 的厚度，在未指定的情况下一般为 0</p>\n<p>scrollTop：滚动后被隐藏的高度，获取对象相对于由 offsetParent 属性指定的父坐标(css 定位的元素或 body 元素)距离顶端的高度。</p>\n<ul>\n<li><h3 id=\"JS-拖拽功能的实现\"><a href=\"#JS-拖拽功能的实现\" class=\"headerlink\" title=\"JS 拖拽功能的实现\"></a>JS 拖拽功能的实现</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>首先是三个事件，分别是 mousedown，mousemove，mouseup</p>\n<p>当鼠标点击按下的时候，需要一个 tag 标识此时已经按下，可以执行 mousemove 里面的具体方法。</p>\n<p>clientX，clientY 标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用</p>\n<p>offsetX 和 offsetY 来表示元素的元素的初始坐标，移动的举例应该是：</p>\n<p>鼠标移动时候的坐标-鼠标按下去时候的坐标。</p>\n<p>也就是说定位信息为：</p>\n<p>鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的 offetLeft.</p>\n<p>还有一点也是原理性的东西，也就是拖拽的同时是绝对定位，我们改变的是绝对定位条件下的 left</p>\n<p>以及 top 等等值。</p>\n<p>补充：也可以通过 html5 的拖放（Drag 和 drop）来实现</p>\n<ul>\n<li><h3 id=\"异步加载-JS-的方法\"><a href=\"#异步加载-JS-的方法\" class=\"headerlink\" title=\"异步加载 JS 的方法\"></a>异步加载 JS 的方法</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>defer：只支持 IE 如果您的脚本不会改变文档的内容，可将 defer 属性加入到</p>\n<script>标签中，以便加快处理文档的速度。因为浏览器知道它将能够安全地读取文档的剩余部分而不用执行脚本，它将推迟对脚本的解释，直到文档已经显示给用户为止。\n\nasync，HTML5 属性仅适用于外部脚本，并且如果在 IE 中，同时存在 defer 和 async， 那么 defer 的优先级比较高，脚本将在页面完成时执行。\n\n创建 script 标签，插入到 DOM 中\n\n- ### Ajax 解决浏览器缓存问题\n\n参考回答：\n\n在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(\"If-Modified- Since\",\"0\")。\n\n在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(\"Cache-Control\",\"no- cache\")。\n\n在 URL 后面加上一个随机数： \"fresh=\" + Math.random()。\n\n在 URL 后面加上时间搓：\"nowtime=\" + new Date().getTime()。\n\n如果是使用 jQuery，直接这样就可以了 \\$.ajaxSetup({cache:false})。这样页面的所有 ajax 都会执行这条语句就是不需要保存缓存记录。\n\n- ### JS 的节流和防抖\n\n参 考 回 答 ：\n[_http://www.cnblogs.com/coco1s/p/5499469.html_](http://www.cnblogs.com/coco1s/p/5499469.html)\n\n- ### JS 中的垃圾回收机制\n\n参考回答：\n\n必要性：由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript\n程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript\n的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。\n\n这段话解释了为什么需要系统需要垃圾回收，JS 不像 C/C++，他有自己的一套垃圾回收机制（Garbage Collection）。JavaScript\n的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。例如：\n\n### var a=\"hello world\"; var b=\"world\"\n\n> var a=b;\n\n//这时，会释放掉\"hello world\"，释放内存以便再引用\n\n垃圾回收的方法：标记清除、计数引用。标记清除\n\n这是最常见的垃圾回收方式，当变量进入环境时，就标记这个变量为”进入环境“,从逻辑上讲，永远不能释放进入环境的变量所占的内存，永远不能释放进入环境变量所占用的内存，只要执行流程进入相应的环境，就可能用到他们。当离开环境时，就标记为离开环境。\n\n垃圾回收器在运行的时候会给存储在内存中的变量都加上标记（所有都加），然后去掉环境变量中的变量，以及被环境变量中的变量所引用的变量（条件性去除标记），\n删除所有被标记的变量，删除的变量无法在环境变量中被访问所以会被删除，最后垃圾回收器，完成了内存的清除工作，并回收他们所占用的内存。\n\n引用计数法\n\n另一种不太常见的方法就是引用计数法，引用计数法的意思就是每个值没引用的次 数，当声明了一个变量，并用一个引用类型的值赋值给改变量，则这个值的引用次数为\n1,；相反的，如果包含了对这个值引用的变量又取得了另外一个值，则原先的引用\n\n值引用次数就减 1，当这个值的引用次数为 0 的时候，说明没有办法再访问这个值了， 因此就把所占的内存给回收进来，这样垃圾收集器再次运行的时候，就会释放引用次数为 0 的这些值。\n\n用引用计数法会存在内存泄露，下面来看原因：\n\n### function problem() {\n\n> var objA = new Object(); var objB = new Object();\n\n> objA.someOtherObject = objB; objB.anotherObject = objA;\n\n> }\n\n在这个例子里面，objA 和 objB 通过各自的属性相互引用，这样的话，两个对象的引用次数都为 2，在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，因为计数不为\n0，这样的相互引用如果大量存在就会导致内存泄露。\n\n特别是在 DOM 对象中，也容易存在这种问题：\n\n### var element=document.getElementById（’‘）； var myObj=new Object(); myObj.element=element; element.someObject=myObj\n\n这样就不会有垃圾回收的过程。\n\n- ### eval 是做什么的\n\n参考回答：\n\n它的功能是将对应的字符串解析成 JS 并执行，应该避免使用 JS，因为非常消耗性能\n\n（2 次，一次解析成 JS，一次执行）\n\n- ### 如何理解前端模块化\n\n参考回答：\n\n前端模块化就是复杂的文件编程一个一个独立的模块，比如 JS 文件等等，分成独立的模块有利于重用（复用性）和维护（版本迭代），这样会引来模块之间相互依赖的问题，所以有了 commonJS\n规范，AMD，CMD 规范等等，以及用于 JS 打包（编译等处理） 的工具webpack\n\n- ### 说一下 CommonJS、AMD 和 CMD\n\n参考回答：\n\n一个模块是能实现特定功能的文件，有了模块就可以方便的使用别人的代码，想要什么功能就能加载什么模块。\n\nCommonJS：开始于服务器端的模块化，同步定义的模块化，每个模块都是一个单独的作用域，模块输出，modules.exports，模块加载 require()引入模块。\nAMD：中文名异步模块定义的意思。\n\nrequireJS 实现了 AMD 规范，主要用于解决下述两个问题。\n\n1. 多个文件有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器\n\n2. 加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应的时间越长。语法：requireJS 定义了一个函数 define，它是全局变量，用来定义模块。requireJS 的例子：\n\n//定义模块\n\n### define(\\['dependency'\\], function(){ var name = 'Byron'\n\n> function printName(){ console.log(name);\n\n> }\n\n> return {\n\n> printName: printName\n\n> };\n\n> });\n\n//加载模块\n\n### require(\\['myModule'\\], function (my){ my.printName()\n\n> }\n\nRequireJS 定义了一个函数 define,它是全局变量，用来定义模块：\n\ndefine(id?dependencies?,factory) 在页面上使用模块加载函数： require(\\[dependencies\\],factory)；\n\n总结 AMD 规范：require（）函数在加载依赖函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块加载成功，才会去执行。\n\n因为网页在加载 JS 的时候会停止渲染，因此我们可以通过异步的方式去加载 JS,而如果需要依赖某些，也是异步去依赖，依赖后再执行某些方法。\n\n- ### 对象深度克隆的简单实现\n\n参考回答：\n\n### function deepClone(obj){\n\n> var newObj= obj instanceof Array ? \\[\\]:{}; for(var item in obj){\n\n> var temple= typeof obj\\[item\\] == 'object' ? deepClone(obj\\[item\\]):obj\\[item\\]; newObj\\[item\\] =\n> temple;\n\n> }\n\n> return newObj;\n\n> }\n\nES5 的常用的对象克隆的一种方式。注意数组是对象，但是跟对象又有一定区别，所以我们一开始判断了一些类型，决定 newObj 是对象还是数组。\n\n- ### 实现一个 once 函数，传入函数参数只执行一次\n\n参考回答：\n\n### function ones(func){ var tag=true\n\n> return function(){ if(tag==true){ func.apply(null,arguments); tag=false;\n\n> }\n\n> return undefined\n\n> }\n\n> }\n\n- ### 将原生的 ajax 封装成 promise\n\n参考回答：\n\n### var myNewAjax=function(url){\n\n> return new Promise(function(resolve,reject){\n\n> var xhr = new XMLHttpRequest(); xhr.open('get',url); xhr.send(data);\n> xhr.onreadystatechange=function(){ if(xhr.status==200&&readyState==4){\n\n> var json=JSON.parse(xhr.responseText); resolve(json)\n\n> }else if(xhr.readyState==4&&xhr.status!=200){ reject('error');\n\n> }\n\n> }\n\n> })\n\n> }\n\n- ### JS 监听对象属性的改变\n\n参考回答：\n\n我们假设这里有一个 user 对象,\n\n1. 在 ES5 中可以通过 Object.defineProperty 来实现已有属性的监听Object.defineProperty(user,'name',{\n   set：function(key,value){\n\n### }\n\n> })\n\n缺点：如果 id 不在 user 对象中，则不能监听 id 的变化(2)在 ES6 中可以通过 Proxy 来实现\n\n### var user = new Proxy({}，{ set：function(target,key,value,receiver){\n\n> }\n\n> })\n\n这样即使有属性在 user 中不存在，通过 user.id 来定义也同样可以这样监听这个属性的变化哦。\n\n- ### 如何实现一个私有变量，用 getName 方法可以访问，不能直接访问\n\n参考回答：\n\n1. 通过 defineProperty 来实现\n\n### obj={ name:yuxiaoliang, getName:function(){ return this.name\n\n> }\n\n> } object.defineProperty(obj,\"name\",{\n\n//不可枚举不可配置\n\n});\n\n2. 通过函数的创建形式\n\n### function product(){\n\n> var name='yuxiaoliang'; this.getName=function(){ return name;\n\n> }\n\n> }\n\n> var obj=new product();\n\n### • ==和===、以及 Object.is 的区别\n\n参考回答： (1) ==\n\n主要存在：强制转换成 number,null==undefined \" \"==0 //true\n\n\"0\"==0 //true \" \" !=\"0\" //true\n\n123==\"123\" //true null==undefined //true (2)Object.js\n\n主要的区别就是+0！=-0 而 NaN==NaN (相对比===和==的改进)\n\n- ### setTimeout、setInterval 和 requestAnimationFrame 之间的区别\n\n参考回答：\n\n这里有一篇文章讲的是 requestAnimationFrame：\n[_http://www.cnblogs.com/xiaohuochai/p/5777186.html_](http://www.cnblogs.com/xiaohuochai/p/5777186.html)\n\n与 setTimeout 和 setInterval 不同，requestAnimationFrame 不需要设置时间间隔， 大多数电脑显示器的刷新频率是 60Hz，大概相当于每秒钟重绘 60\n次。大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。因此，最平滑动画的最佳循环间隔是 1000ms/60，约等于 16.6ms。RAF\n采用的是系统时间间隔，不会因为前面的任务，不会影响 RAF，但是如果前面的任务多的话，\n\n会响应 setTimeout 和 setInterval 真正运行时的时间间隔。特点：\n\n1. requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。\n\n2. 在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量\n\n3. requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销。\n\n- ### 实现一个两列等高布局，讲讲思路\n\n参考回答：\n\n为了实现两列等高，可以给每列加上 padding-bottom:9999px; margin-bottom:-9999px;同时父元素设置 overflow:hidden;\n\n- ### 自己实现一个 bind 函数\n\n参考回答：\n\n原理：通过 apply 或者 call 方法来实现。(1)初始版本\n\n### Function.prototype.bind=function(obj,arg){\n\n> var arg=Array.prototype.slice.call(arguments,1); var context=this;\n\n> return function(newArg){ arg=arg.concat(Array.prototype.slice.call(newArg)); return\n> context.apply(obj,arg);\n\n> }\n\n> }\n\n2. 考虑到原型链\n\n为什么要考虑？因为在 new 一个 bind 过生成的新函数的时候，必须的条件是要继承原函数的原型\n\n### Function.prototype.bind=function(obj,arg){\n\n> var arg=Array.prototype.slice.call(arguments,1); var context=this;\n\n> var bound=function(newArg){ arg=arg.concat(Array.prototype.slice.call(newArg)); return\n> context.apply(obj,arg);\n\n> }\n\n> var F=function(){}\n\n> //这里需要一个寄生组合继承F.prototype=context.prototype; bound.prototype=new F(); return bound;\n\n> }\n\n- ### 用 setTimeout 来实现 setInterval\n\n参考回答：\n\n1. 用 setTimeout()方法来模拟 setInterval()与 setInterval()之间的什么区别？ 首先来看 setInterval 的缺陷，使用\n   setInterval()创建的定时器确保了定时器代码规则地插入队列中。这个问题在于：如果定时器代码在代码再次添加到队列之前还没完成执行，结果就会导致定时器代码连续运行好几次。而之间没有间隔。不过幸运的\n\n是：javascript 引擎足够聪明，能够避免这个问题。当且仅当没有该定时器的如何代码实例时，才会将定时器代码添加到队列中。这确保了定时器代码加入队列中最小的时间间隔为指定时间。\n\n这种重复定时器的规则有两个问题：1.某些间隔会被跳过 2.多个定时器的代码执行时间可能会比预期小。\n\n下面举例子说明：\n\n假设，某个 onclick 事件处理程序使用啦 setInterval()来设置了一个 200ms 的重复定时器。如果事件处理程序花了 300ms 多一点的时间完成。\n\n<img width=\"626\" alt=\"2018-07-10 11 36 43\"\nsrc=\"[_https://user-_](https://user-images.githubusercontent.com/17233651/42487876-92656f2c-8435-11e8-8a5f-0a97918039da.png)\n[_images.githubusercontent.com/17233651/42487876-92656f2c-8435-11e8-8a5f-_](https://user-images.githubusercontent.com/17233651/42487876-92656f2c-8435-11e8-8a5f-0a97918039da.png)\n[_0a97918039da.png_](https://user-images.githubusercontent.com/17233651/42487876-92656f2c-8435-11e8-8a5f-0a97918039da.png)\">\n\n这个例子中的第一个定时器是在 205ms 处添加到队列中，但是要过 300ms 才能执行。在 405ms 又添加了一个副本。在一个间隔，605ms 处，第一个定时器代码还在执行中，\n而且队列中已经有了一个定时器实例，结果是 605ms 的定时器代码不会添加到队列\n\n中。结果是在 5ms 处添加的定时器代码执行结束后，405 处的代码立即执行。\n\n### function say(){\n\n> //something setTimeout(say,200);\n\n> } setTimeout(say,200) 或者\n\n> setTimeout(function(){\n\n> //do something setTimeout(arguments.callee,200);\n\n> },200);\n\n- ### JS 怎么控制一次加载一张图片，加载完后再加载下一张\n\n参考回答： (1)方法 1\n\n### <script type=\"text/javascript\"> var obj=new Image()\n\n> [obj.src=\"http://www.phpernote.com/uploadfiles/editor/2011072405022011](http://www.phpernote.com/uploadfiles/editor/2011072405022011)\n> 79.jpg\";\n\n> obj.onload=function(){\n\nalert('图片的宽度为：'+obj.width+'；图片的高度为：'+obj.height);\n\n### document.getElementById(\"mypic\").innnerHTML=\"\\<img src='\"+this.src+\"'\n\n> />\";\n\n> }\n\n> </script>\n\n<blockquote>\n<div id=\"mypic\">onloading……\\</div>\n</blockquote>\n<ol start=\"2\">\n<li>方法 2</li>\n</ol>\n<h3 id=\"var-obj-new-Image\"><a href=\"#var-obj-new-Image\" class=\"headerlink\" title=\" var obj=new Image()\"></a><script type=\"text/javascript\"> var obj=new Image()</h3><blockquote>\n<p><a href=\"http://www.phpernote.com/uploadfiles/editor/2011072405022011\">obj.src=”http://www.phpernote.com/uploadfiles/editor/2011072405022011</a><br>79.jpg”;</p>\n</blockquote>\n<blockquote>\n<p>obj.onreadystatechange=function(){ if(this.readyState==”complete”){</p>\n</blockquote>\n<p>alert(‘图片的宽度为：’+obj.width+’；图片的高度为：’+obj.height);</p>\n<h3 id=\"document-getElementById-“mypic”-innnerHTML-”-lt-img-src-’”-this-src-”‘\"><a href=\"#document-getElementById-“mypic”-innnerHTML-”-lt-img-src-’”-this-src-”‘\" class=\"headerlink\" title=\"document.getElementById(“mypic”).innnerHTML=”&lt;img src=’”+this.src+”‘\"></a>document.getElementById(“mypic”).innnerHTML=”&lt;img src=’”+this.src+”‘</h3><blockquote>\n<p>/&gt;”;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p></script></p>\n</blockquote>\n<blockquote>\n<div id=\"mypic\">onloading……\\</div>\n</blockquote>\n<ul>\n<li><h3 id=\"代码的执行顺序\"><a href=\"#代码的执行顺序\" class=\"headerlink\" title=\"代码的执行顺序\"></a>代码的执行顺序</h3></li>\n</ul>\n<blockquote>\n<p>参 考 回 答 ： setTimeout(function(){console.log(1)},0); new Promise(function(resolve,reject){<br>console.log(2);</p>\n</blockquote>\n<blockquote>\n<p>resolve();</p>\n</blockquote>\n<blockquote>\n<p>}).then(function(){console.log(3)</p>\n</blockquote>\n<blockquote>\n<p>}).then(function(){console.log(4)}); process.nextTick(function(){console.log(5)}); console.log(6);</p>\n</blockquote>\n<p>//输出 2,6,5,3,4,1</p>\n<p>为什么呢？具体请参考这篇文章：</p>\n<p><a href=\"https://github.com/forthealllight/blog/issues/5\"><em>从 promise、process.nextTick、setTimeout 出发，谈谈 Event Loop 中的 Job<br>queue</em></a></p>\n<ul>\n<li><h3 id=\"如何实现-sleep-的效果（es5-或者-es6）\"><a href=\"#如何实现-sleep-的效果（es5-或者-es6）\" class=\"headerlink\" title=\"如何实现 sleep 的效果（es5 或者 es6）\"></a>如何实现 sleep 的效果（es5 或者 es6）</h3></li>\n</ul>\n<p>参 考 回 答 ： (1)while 循环的方式</p>\n<h3 id=\"function-sleep-ms\"><a href=\"#function-sleep-ms\" class=\"headerlink\" title=\"function sleep(ms){\"></a>function sleep(ms){</h3><blockquote>\n<p>var start=Date.now(),expire=start+ms; while(Date.now()&lt;expire); console.log(‘1111’);</p>\n</blockquote>\n<blockquote>\n<p>return;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<p>执行 sleep(1000)之后，休眠了 1000ms 之后输出了 1111。上述循环的方式缺点很明显，容易造成死循环。</p>\n<ol start=\"2\">\n<li>通过 promise 来实现</li>\n</ol>\n<h3 id=\"function-sleep-ms-1\"><a href=\"#function-sleep-ms-1\" class=\"headerlink\" title=\"function sleep(ms){\"></a>function sleep(ms){</h3><blockquote>\n<p>var temple=new Promise( (resolve)=&gt;{</p>\n</blockquote>\n<blockquote>\n<p>console.log(111);setTimeout(resolve,ms)</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>return temple</p>\n</blockquote>\n<blockquote>\n<p>} sleep(500).then(function(){</p>\n</blockquote>\n<blockquote>\n<p>//console.log(222)</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<p>//先输出了 111，延迟 500ms 后输出 222 (3)通过 async 封装</p>\n<h3 id=\"function-sleep-ms-2\"><a href=\"#function-sleep-ms-2\" class=\"headerlink\" title=\"function sleep(ms){\"></a>function sleep(ms){</h3><blockquote>\n<p>return new Promise((resolve)=&gt;setTimeout(resolve,ms));</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>async function test(){</p>\n</blockquote>\n<blockquote>\n<p>var temple=await sleep(1000); console.log(1111)</p>\n</blockquote>\n<blockquote>\n<p>return temple</p>\n</blockquote>\n<blockquote>\n<p>} test();</p>\n</blockquote>\n<blockquote>\n<p>//延迟 1000ms 输出了 1111 (4).通过 generate 来实现function* sleep(ms){</p>\n</blockquote>\n<h3 id=\"yield-new-Promise-function-resolve-reject-console-log-111\"><a href=\"#yield-new-Promise-function-resolve-reject-console-log-111\" class=\"headerlink\" title=\"yield new Promise(function(resolve,reject){ console.log(111)\"></a>yield new Promise(function(resolve,reject){ console.log(111)</h3><blockquote>\n<p>setTimeout(resolve,ms);</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<blockquote>\n<p>} sleep(500).next().value.then(function(){console.log(2222)})</p>\n</blockquote>\n<ul>\n<li><h3 id=\"简单的实现一个-promise\"><a href=\"#简单的实现一个-promise\" class=\"headerlink\" title=\"简单的实现一个 promise\"></a>简单的实现一个 promise</h3></li>\n</ul>\n<p>参考回答：</p>\n<p><a href=\"https://promisesaplus.com/\"><em>首先明确什么是 promiseA+规范，参考规范的地址：primise</em></a> A+规范</p>\n<p>如何实现一个 promise，参考这篇文章：</p>\n<p><a href=\"https://github.com/forthealllight/blog/issues/4\"><em>实现一个完美符合 Promise/A+规范的 Promise</em></a></p>\n<p>一般不会问的很详细，只要能写出上述文章中的 v1.0 版本的简单 promise 即可。</p>\n<ul>\n<li><h3 id=\"Function-proto-getPrototypeOf-是什么？\"><a href=\"#Function-proto-getPrototypeOf-是什么？\" class=\"headerlink\" title=\"Function._proto_(getPrototypeOf)是什么？\"></a>Function._proto_(getPrototypeOf)是什么？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>获取一个对象的原型，在 chrome 中可以通过_proto_的形式，或者在 ES6 中可以通过</p>\n<p>Object.getPrototypeOf 的形式。</p>\n<p>那么 Function.proto 是什么么？也就是说 Function 由什么对象继承而来，我们来做如下判别。</p>\n<p>Function. proto ==Object.prototype //false Function. proto ==Function.prototype//true 我们发现 Function<br>的原型也是 Function。</p>\n<p>我们用图可以来明确这个关系：</p>\n<p><img width=\"646\" alt=\"2018-07-10 2 38 27\"\nsrc=\"[_https://user-_](https://user-images.githubusercontent.com/17233651/42493275-f55d0860-844e-11e8-983f-e04189a4f3d8.png)\n[_images.githubusercontent.com/17233651/42493275-f55d0860-844e-11e8-983f-_](https://user-images.githubusercontent.com/17233651/42493275-f55d0860-844e-11e8-983f-e04189a4f3d8.png)\n[_e04189a4f3d8.png_](https://user-images.githubusercontent.com/17233651/42493275-f55d0860-844e-11e8-983f-e04189a4f3d8.png)\"></p>\n<ul>\n<li><h3 id=\"实现-JS-中所有对象的深度克隆（包装对象，Date-对象，正则对象）\"><a href=\"#实现-JS-中所有对象的深度克隆（包装对象，Date-对象，正则对象）\" class=\"headerlink\" title=\"实现 JS 中所有对象的深度克隆（包装对象，Date 对象，正则对象）\"></a>实现 JS 中所有对象的深度克隆（包装对象，Date 对象，正则对象）</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>通过递归可以简单实现对象的深度克隆，但是这种方法不管是 ES6 还是 ES5 实现，都有同样的缺陷，就是只能实现特定的 object 的深度复制（比如数组和函数），不能实现包装对象<br>Number，String ， Boolean，以及 Date 对象，RegExp 对象的复制。(1)前文的方法</p>\n<h3 id=\"function-deepClone-obj\"><a href=\"#function-deepClone-obj\" class=\"headerlink\" title=\"function deepClone(obj){\"></a>function deepClone(obj){</h3><blockquote>\n<p>var newObj= obj instanceof Array?[]:{}; for(var i in obj){</p>\n</blockquote>\n<blockquote>\n<p>newObj[i]=typeof obj[i]==’object’? deepClone(obj[i]):obj[i];</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>return newObj;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<p>这种方法可以实现一般对象和数组对象的克隆，比如：</p>\n<h3 id=\"var-arr-1-2-3\"><a href=\"#var-arr-1-2-3\" class=\"headerlink\" title=\"var arr=[1,2,3]\"></a>var arr=[1,2,3]</h3><blockquote>\n<p>var newArr=deepClone(arr);</p>\n</blockquote>\n<blockquote>\n<p>// newArr-&gt;[1,2,3] var obj={</p>\n</blockquote>\n<blockquote>\n<p>x:1, y:2</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>var newObj=deepClone(obj);</p>\n</blockquote>\n<blockquote>\n<p>// newObj={x:1,y:2}</p>\n</blockquote>\n<p>但是不能实现例如包装对象 Number,String,Boolean,以及正则对象 RegExp 和 Date 对象的克隆，比如：</p>\n<p>//Number 包装对象</p>\n<h3 id=\"var-num-new-Number-1\"><a href=\"#var-num-new-Number-1\" class=\"headerlink\" title=\"var num=new Number(1)\"></a>var num=new Number(1)</h3><blockquote>\n<p>typeof num // “object”</p>\n</blockquote>\n<blockquote>\n<p>var newNum=deepClone(num);</p>\n</blockquote>\n<p>//newNum -&gt; {} 空 对 象</p>\n<p>//String 包装对象</p>\n<h3 id=\"var-str-new-String-“hello”-typeof-str-“object”\"><a href=\"#var-str-new-String-“hello”-typeof-str-“object”\" class=\"headerlink\" title=\"var str=new String(“hello”); typeof str //“object”\"></a>var str=new String(“hello”); typeof str //“object”</h3><blockquote>\n<p>var newStr=deepClone(str);</p>\n</blockquote>\n<blockquote>\n<p>//newStr-&gt; {0:’h’,1:’e’,2:’l’,3:’l’,4:’o’};</p>\n</blockquote>\n<p>//Boolean 包装对象</p>\n<h3 id=\"var-bol-new-Boolean-true-typeof-bol-“object”\"><a href=\"#var-bol-new-Boolean-true-typeof-bol-“object”\" class=\"headerlink\" title=\"var bol=new Boolean(true); typeof bol //“object”\"></a>var bol=new Boolean(true); typeof bol //“object”</h3><blockquote>\n<p>var newBol=deepClone(bol);</p>\n</blockquote>\n<p>// newBol -&gt;{} 空对象</p>\n<p>….</p>\n<ol start=\"2\">\n<li>valueof()函数</li>\n</ol>\n<p>所有对象都有 valueOf 方法，valueOf 方法对于：如果存在任意原始值，它就默认将对象转换为表示它的原始值。对象是复合值，而且大多数对象无法真正表示为一个原始值，因此默认的<br>valueOf()方法简单地返回对象本身，而不是返回一个原始值。数组、函数和正则表达式简单地继承了这个默认方法，调用这些类型的实例的 valueOf()方法只是简单返回这个对象本身。</p>\n<h3 id=\"对于原始值或者包装类：-function-baseClone-base-return-base-valueOf\"><a href=\"#对于原始值或者包装类：-function-baseClone-base-return-base-valueOf\" class=\"headerlink\" title=\"对于原始值或者包装类： function baseClone(base){ return base.valueOf()\"></a>对于原始值或者包装类： function baseClone(base){ return base.valueOf()</h3><blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>//Number</p>\n</blockquote>\n<blockquote>\n<p>var num=new Number(1);</p>\n</blockquote>\n<blockquote>\n<p>var newNum=baseClone(num);</p>\n</blockquote>\n<blockquote>\n<p>//newNum-&gt;1</p>\n</blockquote>\n<blockquote>\n<p>//String</p>\n</blockquote>\n<blockquote>\n<p>var str=new String(‘hello’); var newStr=baseClone(str);</p>\n</blockquote>\n<blockquote>\n<p>// newStr-&gt;”hello”</p>\n</blockquote>\n<blockquote>\n<p>//Boolean</p>\n</blockquote>\n<blockquote>\n<p>var bol=new Boolean(true); var newBol=baseClone(bol);</p>\n</blockquote>\n<blockquote>\n<p>//newBol-&gt; true</p>\n</blockquote>\n<p>其实对于包装类，完全可以用=号来进行克隆，其实没有深度克隆一说， 这里用 valueOf 实现，语法上比较符合规范。</p>\n<p>对于 Date 类型：</p>\n<p>因为 valueOf 方法，日期类定义的 valueOf()方法会返回它的一个内部表示：1970 年 1</p>\n<p>月 1 日以来的毫秒数.因此我们可以在 Date 的原型上定义克隆的方法：</p>\n<h3 id=\"Date-prototype-clone-function-return-new-Date-this-valueOf\"><a href=\"#Date-prototype-clone-function-return-new-Date-this-valueOf\" class=\"headerlink\" title=\"Date.prototype.clone=function(){ return new Date(this.valueOf())\"></a>Date.prototype.clone=function(){ return new Date(this.valueOf())</h3><blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>var date=new Date(‘2010’); var newDate=date.clone();</p>\n</blockquote>\n<blockquote>\n<p>// newDate-&gt; Fri Jan 01 2010 08:00:00 GMT+0800</p>\n</blockquote>\n<blockquote>\n<p>对 于 正 则 对 象 RegExp： RegExp.prototype.clone = function() { var pattern = this.valueOf();</p>\n</blockquote>\n<h3 id=\"var-flags-‘’\"><a href=\"#var-flags-‘’\" class=\"headerlink\" title=\"var flags = ‘’\"></a>var flags = ‘’</h3><blockquote>\n<p>flags += pattern.global ? ‘g’ : ‘’; flags += pattern.ignoreCase ? ‘i’ : ‘’; flags +=<br>pattern.multiline ? ‘m’ : ‘’;</p>\n</blockquote>\n<blockquote>\n<p>return new RegExp(pattern.source, flags);</p>\n</blockquote>\n<blockquote>\n<p>};</p>\n</blockquote>\n<blockquote>\n<p>var reg=new RegExp(‘/111/‘); var newReg=reg.clone();</p>\n</blockquote>\n<blockquote>\n<p>//newReg-&gt; /\\/111\\//</p>\n</blockquote>\n<ul>\n<li><h3 id=\"简单实现-Node-的-Events-模块\"><a href=\"#简单实现-Node-的-Events-模块\" class=\"headerlink\" title=\"简单实现 Node 的 Events 模块\"></a>简单实现 Node 的 Events 模块</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>简介：观察者模式或者说订阅模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。</p>\n<p>node 中的 Events 模块就是通过观察者模式来实现的：</p>\n<h3 id=\"var-events-require-‘events’\"><a href=\"#var-events-require-‘events’\" class=\"headerlink\" title=\"var events=require(‘events’)\"></a>var events=require(‘events’)</h3><blockquote>\n<p>var eventEmitter=new events.EventEmitter(); eventEmitter.on(‘say’,function(name){<br>console.log(‘Hello’,name);</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<blockquote>\n<p>eventEmitter.emit(‘say’,’Jony yu’);</p>\n</blockquote>\n<p>这样，eventEmitter 发出 say 事件，通过 On 接收，并且输出结果，这就是一个订阅模式的实现，下面我们来简单的实现一个 Events 模块的 EventEmitter。</p>\n<ol>\n<li>实现简单的 Event 模块的 emit 和 on 方法function Events(){ this.on=function(eventName,callBack){<br>if(!this.handles){</li>\n</ol>\n<h3 id=\"this-handles\"><a href=\"#this-handles\" class=\"headerlink\" title=\"this.handles={}\"></a>this.handles={}</h3><blockquote>\n<p>} if(!this.handles[eventName]){ this.handles[eventName]=[];</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>this.handles[eventName].push(callBack);</p>\n</blockquote>\n<blockquote>\n<p>} this.emit=function(eventName,obj){ if(this.handles[eventName]){</p>\n</blockquote>\n<blockquote>\n<p>for(var i=0;o&lt;this.handles[eventName].length;i++){ this.handles[eventName][i](obj);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>return this;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>这样我们就定义了 Events，现在我们可以开始来调用： var events=new Events(); events.on(‘say’,function(name){<br>console.log(‘Hello’,nama)</p>\n</blockquote>\n<h3 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"})\"></a>})</h3><blockquote>\n<p>events.emit(‘say’,’Jony yu’);</p>\n</blockquote>\n<p>//结果就是通过 emit 调用之后，输出了 Jony yu (2)每个对象是独立的</p>\n<p>因为是通过 new 的方式，每次生成的对象都是不相同的，因此：</p>\n<h3 id=\"var-event1-new-Events-var-event2-new-Events-event1-on-‘say’-function-console-log-‘Jony-event1’\"><a href=\"#var-event1-new-Events-var-event2-new-Events-event1-on-‘say’-function-console-log-‘Jony-event1’\" class=\"headerlink\" title=\"var event1=new Events(); var event2=new Events(); event1.on(‘say’,function(){ console.log(‘Jony event1’)\"></a>var event1=new Events(); var event2=new Events(); event1.on(‘say’,function(){ console.log(‘Jony event1’)</h3><blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>event2.on(‘say’,function(){ console.log(‘Jony event2’);</p>\n</blockquote>\n<blockquote>\n<p>}) event1.emit(‘say’); event2.emit(‘say’);</p>\n</blockquote>\n<p>//event1、event2 之间的事件监听互相不影响</p>\n<p>//输出结果为’Jony event1’ ‘Jony event2’</p>\n<ul>\n<li><h3 id=\"箭头函数中-this-指向举例\"><a href=\"#箭头函数中-this-指向举例\" class=\"headerlink\" title=\"箭头函数中 this 指向举例\"></a>箭头函数中 this 指向举例</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"var-a-11-function-test2-this-a-22\"><a href=\"#var-a-11-function-test2-this-a-22\" class=\"headerlink\" title=\"var a=11; function test2(){ this.a=22\"></a>var a=11; function test2(){ this.a=22</h3><blockquote>\n<p>let b=()=&gt;{console.log(this.a)} b();</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>var x=new test2();</p>\n</blockquote>\n<p>//输出 22</p>\n<p>定义时绑定。</p>\n<ul>\n<li><h3 id=\"JS-判断类型\"><a href=\"#JS-判断类型\" class=\"headerlink\" title=\"JS 判断类型\"></a>JS 判断类型</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>判断方法：typeof()，instanceof，Object.prototype.toString.call()等</p>\n<ul>\n<li><h3 id=\"数组常用方法\"><a href=\"#数组常用方法\" class=\"headerlink\" title=\"数组常用方法\"></a>数组常用方法</h3></li>\n</ul>\n<p>参 考 回 答 ： push()，pop()，shift()，unshift()，splice()，sort()，reverse()，map()等</p>\n<ul>\n<li><h3 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>法一：indexOf 循环去重</p>\n<p>法二：ES6 Set 去重；Array.from(new Set(array))</p>\n<p>法三：Object 键值对去重；把数组的值存成 Object 的 key 值，比如Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，<br>就说明该值是重复的。</p>\n<ul>\n<li><h3 id=\"闭包-有什么用\"><a href=\"#闭包-有什么用\" class=\"headerlink\" title=\"闭包 有什么用\"></a>闭包 有什么用</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li>什么是闭包：</li>\n</ol>\n<p>闭包是指有权访问另外一个函数作用域中的变量的函数。</p>\n<p>闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。当在一个函数内定义另外一个函数就会产生闭包。</p>\n<ol start=\"2\">\n<li>为什么要用：</li>\n</ol>\n<p>匿名自执行函数：我们知道所有的变量，如果不加上 var<br>关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用<br>var 关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，可以用闭包。 结果缓存：我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对<br>象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。</p>\n<p>封装：实现类和继承等。</p>\n<ul>\n<li><h3 id=\"事件代理在捕获阶段的实际应用\"><a href=\"#事件代理在捕获阶段的实际应用\" class=\"headerlink\" title=\"事件代理在捕获阶段的实际应用\"></a>事件代理在捕获阶段的实际应用</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>可以在父元素层面阻止事件向子元素传播，也可代替子元素执行某些操作。</p>\n<ul>\n<li><h3 id=\"去除字符串首尾空格\"><a href=\"#去除字符串首尾空格\" class=\"headerlink\" title=\"去除字符串首尾空格\"></a>去除字符串首尾空格</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>使用正则(^\\s*)|(\\s*$)即可</p>\n<ul>\n<li><h3 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h3></li>\n</ul>\n<p>参考回答： 减少 HTTP 请求</p>\n<p>使用内容发布网络（CDN） 添加本地缓存</p>\n<p>压缩资源文件</p>\n<p>将 CSS 样式表放在顶部，把 javascript 放在底部（浏览器的运行机制决定） 避免使用 CSS 表达式</p>\n<p>减少 DNS 查询</p>\n<p>使用外部 javascript 和 CSS</p>\n<p>避免重定向 图片 lazyLoad</p>\n<ul>\n<li><h3 id=\"来讲讲-JS-的闭包吧\"><a href=\"#来讲讲-JS-的闭包吧\" class=\"headerlink\" title=\"来讲讲 JS 的闭包吧\"></a>来讲讲 JS 的闭包吧</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>闭包是指有权访问另外一个函数作用域中的变量的函数。</p>\n<p>闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。当在一个函数内定义另外一个函数就会产生闭包。</p>\n<ol start=\"2\">\n<li>为什么要用：</li>\n</ol>\n<p>匿名自执行函数：我们知道所有的变量，如果不加上 var<br>关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用<br>var 关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，可以用闭包。 结果缓存：我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对<br>象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用</p>\n<p>这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。</p>\n<ul>\n<li><h3 id=\"能来讲讲-JS-的语言特性吗\"><a href=\"#能来讲讲-JS-的语言特性吗\" class=\"headerlink\" title=\"能来讲讲 JS 的语言特性吗\"></a>能来讲讲 JS 的语言特性吗</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>运行在客户端浏览器上；</p>\n<p>不用预编译，直接解析执行代码； 是弱类型语言，较为灵活；</p>\n<p>与操作系统无关，跨平台的语言； 脚本语言、解释性语言</p>\n<ul>\n<li><h3 id=\"如何判断一个数组-讲到-typeof-差点掉坑里\"><a href=\"#如何判断一个数组-讲到-typeof-差点掉坑里\" class=\"headerlink\" title=\"如何判断一个数组(讲到 typeof 差点掉坑里)\"></a>如何判断一个数组(讲到 typeof 差点掉坑里)</h3></li>\n</ul>\n<blockquote>\n<p>参 考 回 答 ： Object.prototype.call.toString() instanceof</p>\n</blockquote>\n<ul>\n<li><h3 id=\"你说到-typeof，能不能加一个限制条件达到判断条件\"><a href=\"#你说到-typeof，能不能加一个限制条件达到判断条件\" class=\"headerlink\" title=\"你说到 typeof，能不能加一个限制条件达到判断条件\"></a>你说到 typeof，能不能加一个限制条件达到判断条件</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>typeof 只能判断是 object,可以判断一下是否拥有数组的方法</p>\n<ul>\n<li><h3 id=\"JS-实现跨域\"><a href=\"#JS-实现跨域\" class=\"headerlink\" title=\"JS 实现跨域\"></a>JS 实现跨域</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>JSONP：通过动态创建 script，再请求一个带参网址实现跨域通信。document.domain</p>\n<ul>\n<li>iframe 跨域：两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域。</li>\n</ul>\n<p>location.hash + iframe 跨域：a 欲与b 跨域相互通信，通过中间页c 来实现。 三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 js<br>访问来通信。</p>\n<p>window.name + iframe 跨域：通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。</p>\n<p>postMessage 跨域：可以跨域操作的 window 属性之一。</p>\n<p>CORS：服务端设置 Access-Control-Allow-Origin 即可，前端无须设置，若要带</p>\n<p>cookie 请求，前后端都需要设置。</p>\n<p>代理跨域：启一个代理服务器，实现数据的转发</p>\n<p>参考 <a href=\"https://segmentfault.com/a/1190000011145364\"><em>https://segmentfault.com/a/1190000011145364</em></a></p>\n<ul>\n<li><h3 id=\"JS-基本数据类型\"><a href=\"#JS-基本数据类型\" class=\"headerlink\" title=\"JS 基本数据类型\"></a>JS 基本数据类型</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>基本数据类型：undefined、null、number、boolean、string、symbol</p>\n<ul>\n<li><h3 id=\"JS-深度拷贝一个元素的具体实现\"><a href=\"#JS-深度拷贝一个元素的具体实现\" class=\"headerlink\" title=\"JS 深度拷贝一个元素的具体实现\"></a>JS 深度拷贝一个元素的具体实现</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"var-deepCopy-function-obj\"><a href=\"#var-deepCopy-function-obj\" class=\"headerlink\" title=\"var deepCopy = function(obj) {\"></a>var deepCopy = function(obj) {</h3><blockquote>\n<p>if (typeof obj !== ‘object’) return;</p>\n</blockquote>\n<blockquote>\n<p>var newObj = obj instanceof Array ? [] : {}; for (var key in obj) {</p>\n</blockquote>\n<blockquote>\n<p>if (obj.hasOwnProperty(key)) {</p>\n</blockquote>\n<blockquote>\n<p>newObj[key] = typeof obj[key] === ‘object’ ? deepCopy(obj[key]) : obj[key];</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>return newObj;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"之前说了-ES6set-可以数组去重，是否还有数组去重的方法\"><a href=\"#之前说了-ES6set-可以数组去重，是否还有数组去重的方法\" class=\"headerlink\" title=\"之前说了 ES6set 可以数组去重，是否还有数组去重的方法\"></a>之前说了 ES6set 可以数组去重，是否还有数组去重的方法</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>法一：indexOf 循环去重</p>\n<p>法二：Object 键值对去重；把数组的值存成 Object 的 key 值，比如Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，<br>就说明该值是重复的。</p>\n<ul>\n<li><h3 id=\"重排和重绘，讲讲看\"><a href=\"#重排和重绘，讲讲看\" class=\"headerlink\" title=\"重排和重绘，讲讲看\"></a>重排和重绘，讲讲看</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>重绘（repaint 或<br>redraw）：当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。</p>\n<p>触发重绘的条件：改变元素外观属性。如：color，background-color 等。</p>\n<p>注意：table 及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值， 比同等元素要多花两倍时间，这就是我们尽量避免使用 table<br>布局页面的原因之一。重排（重构/回流/reflow）：当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建,<br>这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。</p>\n<p>重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。所以，重排必定会引发重绘，但重绘不一定会引发重排。</p>\n<ul>\n<li><h3 id=\"JS-的全排列\"><a href=\"#JS-的全排列\" class=\"headerlink\" title=\"JS 的全排列\"></a>JS 的全排列</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"function-permutate-str-var-result-if-str-length-gt-1\"><a href=\"#function-permutate-str-var-result-if-str-length-gt-1\" class=\"headerlink\" title=\"function permutate(str) { var result = []; if(str.length &gt; 1) {\"></a>function permutate(str) { var result = []; if(str.length &gt; 1) {</h3><blockquote>\n<p>var left = str[0];</p>\n</blockquote>\n<blockquote>\n<p>var rest = str.slice(1, str.length); var preResult = permutate(rest); for(var i=0;<br>i&lt;preResult.length; i++) {</p>\n</blockquote>\n<blockquote>\n<p>for(var j=0; j&lt;preResult[i].length; j++) {</p>\n</blockquote>\n<blockquote>\n<p>var tmp = preResult[i],slice(0, j) + left + preResult[i].slice(j, preResult[i].length);</p>\n</blockquote>\n<blockquote>\n<p>result.push(tmp);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>} else if (str.length == 1) { return [str];</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>return result;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"跨域的原理\"><a href=\"#跨域的原理\" class=\"headerlink\" title=\"跨域的原理\"></a>跨域的原理</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对 JavaScript<br>实施的安全限制，那么只要协议、域名、端口有任何一个不同，都被当作是不同的域。跨域原理，即是通过各种方式，避开浏览器的安全限制。</p>\n<ul>\n<li><h3 id=\"不同数据类型的值的比较，是怎么转换的，有什么规则\"><a href=\"#不同数据类型的值的比较，是怎么转换的，有什么规则\" class=\"headerlink\" title=\"不同数据类型的值的比较，是怎么转换的，有什么规则\"></a>不同数据类型的值的比较，是怎么转换的，有什么规则</h3></li>\n</ul>\n<p>参考回答：</p>\n<p><img src=\"media/image4.jpeg\"></p>\n<ul>\n<li><h3 id=\"null-undefined-为什么\"><a href=\"#null-undefined-为什么\" class=\"headerlink\" title=\"null == undefined 为什么\"></a>null == undefined 为什么</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>要比较相等性之前，不能将 null 和 undefined 转换成其他任何值，但 null == undefined 会返回 true 。ECMAScript 规范中是这样定义的。</p>\n<ul>\n<li><h3 id=\"this-的指向-哪几种\"><a href=\"#this-的指向-哪几种\" class=\"headerlink\" title=\"this 的指向 哪几种\"></a>this 的指向 哪几种</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>默认绑定：全局环境中，this 默认绑定到 window。</p>\n<p>隐式绑定：一般地，被直接对象所包含的函数调用时，也称为方法调用，this 隐式绑定到该直接对象。</p>\n<p>隐式丢失：隐式丢失是指被隐式绑定的函数丢失绑定对象，从而默认绑定到 window。显式绑定：通过 call()、apply()、bind()方法把对象绑定到 this 上，叫做显式绑定。</p>\n<p>new 绑定：如果函数或者方法调用之前带有关键字 new，它就构成构造函数调用。对于this 绑定来说，称为 new 绑定。</p>\n<p>【1】构造函数通常不使用 return 关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。</p>\n<p>【2】如果构造函数使用 return 语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果。</p>\n<p>【3】如果构造函数显式地使用 return 语句返回一个对象，那么调用表达式的值就是这个对象。</p>\n<ul>\n<li><h3 id=\"暂停死区\"><a href=\"#暂停死区\" class=\"headerlink\" title=\"暂停死区\"></a>暂停死区</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>在代码块内，使用 let、const 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”</p>\n<ul>\n<li><h3 id=\"写一个深度拷贝\"><a href=\"#写一个深度拷贝\" class=\"headerlink\" title=\"写一个深度拷贝\"></a>写一个深度拷贝</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"function-clone-obj-var-copy\"><a href=\"#function-clone-obj-var-copy\" class=\"headerlink\" title=\"function clone( obj ) { var copy\"></a>function clone( obj ) { var copy</h3><blockquote>\n<p>switch( typeof obj ) { case “undefined”: break;</p>\n</blockquote>\n<blockquote>\n<p>case “number”: copy = obj - 0; break;</p>\n</blockquote>\n<blockquote>\n<p>case “string”: copy = obj + “”; break;</p>\n</blockquote>\n<blockquote>\n<p>case “boolean”: copy = obj; break;</p>\n</blockquote>\n<p>case “object”: //object 分为两种情况 对象（Object）和数组（Array）</p>\n<h3 id=\"if-obj-null-copy-null\"><a href=\"#if-obj-null-copy-null\" class=\"headerlink\" title=\"if(obj === null) { copy = null\"></a>if(obj === null) { copy = null</h3><blockquote>\n<p>} else {</p>\n</blockquote>\n<blockquote>\n<p>if( Object.prototype.toString.call(obj).slice(8, -1) === “Array”) { copy = [];</p>\n</blockquote>\n<blockquote>\n<p>for( var i = 0 ; i &lt; obj.length ; i++ ) { copy.push(clone(obj[i]));</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>} else { copy = {};</p>\n</blockquote>\n<blockquote>\n<p>for( var j in obj) { copy[j] = clone(obj[j]);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>} break; default:</p>\n</blockquote>\n<blockquote>\n<p>copy = obj; break;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>return copy;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"简历中提到了-requestAnimationFrame，请问是怎么使用的\"><a href=\"#简历中提到了-requestAnimationFrame，请问是怎么使用的\" class=\"headerlink\" title=\"简历中提到了 requestAnimationFrame，请问是怎么使用的\"></a>简历中提到了 requestAnimationFrame，请问是怎么使用的</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。</p>\n<ul>\n<li><h3 id=\"有一个游戏叫做-Flappy-Bird，就是一只小鸟在飞，前面是无尽的沙漠，上下不断有钢管生成，你要躲避钢管。然后小明在玩这个游戏时候老是卡顿甚至崩溃，说出原因（3-5-个）以及解决办法（3-5-个）\"><a href=\"#有一个游戏叫做-Flappy-Bird，就是一只小鸟在飞，前面是无尽的沙漠，上下不断有钢管生成，你要躲避钢管。然后小明在玩这个游戏时候老是卡顿甚至崩溃，说出原因（3-5-个）以及解决办法（3-5-个）\" class=\"headerlink\" title=\"有一个游戏叫做 Flappy Bird，就是一只小鸟在飞，前面是无尽的沙漠，上下不断有钢管生成，你要躲避钢管。然后小明在玩这个游戏时候老是卡顿甚至崩溃，说出原因（3-5 个）以及解决办法（3-5 个）\"></a>有一个游戏叫做 Flappy Bird，就是一只小鸟在飞，前面是无尽的沙漠，上下不断有钢管生成，你要躲避钢管。然后小明在玩这个游戏时候老是卡顿甚至崩溃，说出原因（3-5 个）以及解决办法（3-5 个）</h3></li>\n</ul>\n<p>参考回答： 原因可能是：</p>\n<ol>\n<li><p>内存溢出问题。</p>\n</li>\n<li><p>资源过大问题。</p>\n</li>\n<li><p>资源加载问题。4.canvas 绘制频率问题解决办法：</p>\n</li>\n<li><p>针对内存溢出问题，我们应该在钢管离开可视区域后，销毁钢管，让垃圾收集器回收钢管，因为不断生成的钢管不及时清理容易导致内存溢出游戏崩溃。</p>\n</li>\n<li><p>针对资源过大问题，我们应该选择图片文件大小更小的图片格式，比如使用 webp、png 格式的图片，因为绘制图片需要较大计算量。</p>\n</li>\n<li><p>针对资源加载问题，我们应该在可视区域之前就预加载好资源，如果在可视区域生成钢管的话，用户的体验就认为钢管是卡顿后才生成的，不流畅。</p>\n</li>\n<li><p>针对 canvas 绘制频率问题，我们应该需要知道大部分显示器刷新频率为 60 次/s,因此游戏的每一帧绘制间隔时间需要小于 1000/60=16.7ms，才能让用户觉得不卡顿。</p>\n</li>\n</ol>\n<p>（注意因为这是单机游戏，所以回答与网络无关）</p>\n<ul>\n<li><h3 id=\"编写代码，满足以下条件：-（1）Hero-“37er”-执行结果为-Hi-This-is-37er-（2）Hero-“37er”-kill-1-recover-30-执行结果为-Hi-This-is-37er-Kill-1-bug-Recover-30-bloods-（3）-Hero-“37er”-sleep-10-kill-2-执行结果为-Hi-This-is-37er-等待-10s-后-Kill-2-bugs-注意为-bugs-（双斜线后的为提示信息，不需要打印）\"><a href=\"#编写代码，满足以下条件：-（1）Hero-“37er”-执行结果为-Hi-This-is-37er-（2）Hero-“37er”-kill-1-recover-30-执行结果为-Hi-This-is-37er-Kill-1-bug-Recover-30-bloods-（3）-Hero-“37er”-sleep-10-kill-2-执行结果为-Hi-This-is-37er-等待-10s-后-Kill-2-bugs-注意为-bugs-（双斜线后的为提示信息，不需要打印）\" class=\"headerlink\" title=\"编写代码，满足以下条件： （1）Hero(“37er”);执行结果为 Hi! This is 37er （2）Hero(“37er”).kill(1).recover(30);执行结果为 Hi! This is 37er Kill 1 bug Recover 30 bloods （3） Hero(“37er”).sleep(10).kill(2)执行结果为 Hi! This is 37er //等待 10s 后 Kill 2 bugs //注意为 bugs （双斜线后的为提示信息，不需要打印）\"></a>编写代码，满足以下条件： （1）Hero(“37er”);执行结果为 Hi! This is 37er （2）Hero(“37er”).kill(1).recover(30);执行结果为 Hi! This is 37er Kill 1 bug Recover 30 bloods （3） Hero(“37er”).sleep(10).kill(2)执行结果为 Hi! This is 37er //等待 10s 后 Kill 2 bugs //注意为 bugs （双斜线后的为提示信息，不需要打印）</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"function-Hero-name-let-o-new-Object-o-name-name-o-time-0\"><a href=\"#function-Hero-name-let-o-new-Object-o-name-name-o-time-0\" class=\"headerlink\" title=\"function Hero(name){ let o=new Object(); o.name=name; o.time=0\"></a>function Hero(name){ let o=new Object(); o.name=name; o.time=0</h3><blockquote>\n<p>console.log(“Hi! This is “+o.name); o.kill=function(bugs) { if(bugs==1){</p>\n</blockquote>\n<blockquote>\n<p>console.log(“Kill “+(bugs)+” bug”);</p>\n</blockquote>\n<blockquote>\n<p>}else { setTimeout(function () {</p>\n</blockquote>\n<blockquote>\n<p>console.log(“Kill “ + (bugs) + “ bugs”);</p>\n</blockquote>\n<blockquote>\n<p>}, 1000 * this.time);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>return o;</p>\n</blockquote>\n<blockquote>\n<p>};</p>\n</blockquote>\n<ol start=\"18\">\n<li>ecover=function (bloods) { console.log(“Recover “+(bloods)+” bloods”); return o;</li>\n</ol>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ol start=\"19\">\n<li>leep=function (sleepTime) { o.time=sleepTime;</li>\n</ol>\n<blockquote>\n<p>return o;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>return o;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"什么是按需加载\"><a href=\"#什么是按需加载\" class=\"headerlink\" title=\"什么是按需加载\"></a>什么是按需加载</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>当用户触发了动作时才加载对应的功能。触发的动作，是要看具体的业务场景而言， 包括但不限于以下几个情况：鼠标点击、输入文字、拉动滚动条，鼠标移动、窗口大小更改等。加载的文件，可以是<br>JS、图片、CSS、HTML 等。</p>\n<ul>\n<li><h3 id=\"说一下什么是-virtual-dom\"><a href=\"#说一下什么是-virtual-dom\" class=\"headerlink\" title=\"说一下什么是 virtual dom\"></a>说一下什么是 virtual dom</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树， 插到文档当中 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异<br>把所记录的差异应用到所构建的真正的 DOM 树上，视图就更新了。Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。</p>\n<ul>\n<li><h3 id=\"webpack-用来干什么的\"><a href=\"#webpack-用来干什么的\" class=\"headerlink\" title=\"webpack 用来干什么的\"></a>webpack 用来干什么的</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency<br>graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p>\n<ul>\n<li><h3 id=\"ant-design-优点和缺点\"><a href=\"#ant-design-优点和缺点\" class=\"headerlink\" title=\"ant-design 优点和缺点\"></a>ant-design 优点和缺点</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>优点：组件非常全面，样式效果也都比较不错。</p>\n<p>缺点：框架自定义程度低，默认 UI 风格修改困难。</p>\n<ul>\n<li><h3 id=\"JS-中继承实现的几种方式\"><a href=\"#JS-中继承实现的几种方式\" class=\"headerlink\" title=\"JS 中继承实现的几种方式\"></a>JS 中继承实现的几种方式</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>1、原型链继承，将父类的实例作为子类的原型，他的特点是实例是子类的实例也是父类的实例，父类新增的原型方法/属性，子类都能够访问，并且原型链继承简单易于实现，缺点是来自原型对象的所有属性被所有实例共享，无法实现多继承，无法向父类构造函数传参。</p>\n<p>2、构造继承，使用父类的构造函数来增强子类实例，即复制父类的实例属性给子类， 构造继承可以向父类传递参数，可以实现多继承，通过 call<br>多个父类对象。但是构造继承只能继承父类的实例属性和方法，不能继承原型属性和方法，无法实现函数服</p>\n<p>用，每个子类都有父类实例函数的副本，影响性能</p>\n<p>3、实例继承，为父类实例添加新特性，作为子类实例返回，实例继承的特点是不限制调用方法，不管是 new 子类（）还是子类（）返回的对象具有相同的效果，缺点是实例是父类的实例，不是子类的实例，不支持多继承</p>\n<p>4、拷贝继承：特点：支持多继承，缺点：效率较低，内存占用高（因为要拷贝父类的属性）无法获取父类不可枚举的方法（不可枚举方法，不能使用 for in 访问到）</p>\n<p>5、组合继承：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<p>6、寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</p>\n<ul>\n<li><h3 id=\"写一个函数，第一秒打印-1，第二秒打印-2\"><a href=\"#写一个函数，第一秒打印-1，第二秒打印-2\" class=\"headerlink\" title=\"写一个函数，第一秒打印 1，第二秒打印 2\"></a>写一个函数，第一秒打印 1，第二秒打印 2</h3></li>\n</ul>\n<p>参考回答：</p>\n<blockquote>\n<p>两个方法，第一个是用 let 块级作用域for(let i=0;i&lt;5;i++){ setTimeout(function(){ console.log(i)</p>\n</blockquote>\n<h3 id=\"1000-i\"><a href=\"#1000-i\" class=\"headerlink\" title=\"},1000*i)\"></a>},1000*i)</h3><blockquote>\n<p>}</p>\n</blockquote>\n<p>第二个方法闭包</p>\n<h3 id=\"for-var-i-0-i-lt-5-i-function-i-setTimeout-function-console-log-i\"><a href=\"#for-var-i-0-i-lt-5-i-function-i-setTimeout-function-console-log-i\" class=\"headerlink\" title=\"for(var i=0;i&lt;5;i++){ (function(i){ setTimeout(function(){ console.log(i)\"></a>for(var i=0;i&lt;5;i++){ (function(i){ setTimeout(function(){ console.log(i)</h3><blockquote>\n<p>},1000*i)</p>\n</blockquote>\n<blockquote>\n<p>})(i)</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"Vue-的生命周期\"><a href=\"#Vue-的生命周期\" class=\"headerlink\" title=\"Vue 的生命周期\"></a>Vue 的生命周期</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是 Vue 的生命周期。通俗说就是 Vue<br>实例从创建到销毁的过程，就是生命周期。</p>\n<p>每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁。</p>\n<p>实例、组件通过 new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行beforeCreate 钩子函数，这个时候，数据还没有挂载呢，只是一个空壳，无法访问到数据和真实的<br>dom，一般不做操作</p>\n<p>挂载数据，绑定事件等等，然后执行 created 函数，这个时候已经可以使用到数据， 也可以更改数据,在这里更改数据不会触发 updated<br>函数，在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取</p>\n<p>接下来开始找实例或者组件对应的模板，编译模板为虚拟 dom 放入到 render 函数中准备渲染，然后执行 beforeMount 钩子函数，在这个函数中虚拟 dom<br>已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发 updated，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取 接下来开始<br>render，渲染出真实 dom，然后执行 mounted 钩子函数，此时，组件已经出现在页面中，数据、真实 dom 都已经处理好了,事件都已经挂载好了，可以在这里操作真实 dom 等事情…</p>\n<p>当组件或实例的数据更改之后，会立即执行 beforeUpdate，然后 Vue 的虚拟 dom 机制会重新构建虚拟 dom 与上一次的虚拟 dom 树利用 diff<br>算法进行对比之后重新渲染，一般不做什么事儿</p>\n<p>当更新完成后，执行 updated，数据已经更改完成，dom 也重新 render 完成，可以操作更新后的虚拟 dom</p>\n<p>当经过某种途径调用$destroy 方法后，立即执行beforeDestroy，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等</p>\n<p>组件的数据绑定、监听…去掉后只剩下 dom 空壳，这个时候，执行 destroyed，在这里做善后工作也可以</p>\n<ul>\n<li><h3 id=\"简单介绍一下-symbol\"><a href=\"#简单介绍一下-symbol\" class=\"headerlink\" title=\"简单介绍一下 symbol\"></a>简单介绍一下 symbol</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Symbol 是 ES6 的新增属性，代表用给定名称作为唯一标识，这种类型的值可以这样创建，let id=symbol(“id”)</p>\n<p>Symbl 确保唯一，即使采用相同的名称，也会产生不同的值，我们创建一个字段，仅为知道对应 symbol 的人能访问，使用 symbol 很有用，symbol 并不是 100%隐藏，有内置方法<br>Object.getOwnPropertySymbols(obj)可以获得所有的 symbol。</p>\n<p>也有一个方法 Reflect.ownKeys(obj)返回对象所有的键，包括 symbol。</p>\n<p>所以并不是真正隐藏。但大多数库内置方法和语法结构遵循通用约定他们是隐藏的。</p>\n<ul>\n<li><h3 id=\"什么是事件监听\"><a href=\"#什么是事件监听\" class=\"headerlink\" title=\"什么是事件监听\"></a>什么是事件监听</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>addEventListener()方法，用于向指定元素添加事件句柄，它可以更简单的控制事件，语法为</p>\n<p>element.addEventListener(event, function, useCapture);</p>\n<p>第一个参数是事件的类型(如 “click” 或 “mousedown”). 第二个参数是事件触发后调用的函数。</p>\n<p>第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。事件传递有两种方式，冒泡和捕获</p>\n<p>事件传递定义了元素事件触发的顺序，如果你将P 元素插入到 div 元素中，用户点击P</p>\n<p>元素，</p>\n<p>在冒泡中，内部元素先被触发，然后再触发外部元素， 捕获中，外部元素先被触发，在触发内部元素。</p>\n<ul>\n<li><h3 id=\"介绍一下-promise，及其底层如何实现\"><a href=\"#介绍一下-promise，及其底层如何实现\" class=\"headerlink\" title=\"介绍一下 promise，及其底层如何实现\"></a>介绍一下 promise，及其底层如何实现</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Promise 是一个对象，保存着未来将要结束的事件，她有两个特征:</p>\n<p>1、对象的状态不受外部影响，Promise 对象代表一个异步操作，有三种状态，pending 进行中，fulfilled 已成功，rejected<br>已失败，只有异步操作的结果，才可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也就是 promise 名字的由来2、一旦状态改变，就不会再变，promise 对象状态改变只有两种可能，从<br>pending 改到 fulfilled 或者从 pending 改到 rejected，只要这两种情况发生，状态就凝固了， 不会再改变，这个时候就称为定型 resolved,</p>\n<p>Promise 的基本用法，</p>\n<h3 id=\"let-promise1-new-Promise-function-resolve-reject-setTimeout-function\"><a href=\"#let-promise1-new-Promise-function-resolve-reject-setTimeout-function\" class=\"headerlink\" title=\"let promise1 = new Promise(function(resolve,reject){ setTimeout(function(){\"></a>let promise1 = new Promise(function(resolve,reject){ setTimeout(function(){</h3><blockquote>\n<p>resolve(‘ok’)</p>\n</blockquote>\n<blockquote>\n<p>},1000)</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<blockquote>\n<p>promise1.then(function success(val){ console.log(val)</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<blockquote>\n<p>最简单代码实现 promise class PromiseM { constructor (process) { this.status = ‘pending’ this.msg = ‘’</p>\n</blockquote>\n<blockquote>\n<p>process(this.resolve.bind(this), this.reject.bind(this)) return this</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>resolve (val) { this.status = ‘fulfilled’ this.msg = val</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>reject (err) { this.status = ‘rejected’ this.msg = err</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>then (fufilled, reject) { if(this.status === ‘fulfilled’) { fufilled(this.msg)</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>if(this.status === ‘rejected’) { reject(this.msg)</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<p>//测试代码</p>\n<h3 id=\"var-mm-new-PromiseM-function-resolve-reject-resolve-‘123’\"><a href=\"#var-mm-new-PromiseM-function-resolve-reject-resolve-‘123’\" class=\"headerlink\" title=\"var mm=new PromiseM(function(resolve,reject){ resolve(‘123’)\"></a>var mm=new PromiseM(function(resolve,reject){ resolve(‘123’)</h3><blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>mm.then(function(success){ console.log(success);</p>\n</blockquote>\n<blockquote>\n<p>},function(){</p>\n</blockquote>\n<blockquote>\n<p>console.log(‘fail!’);</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<ul>\n<li><h3 id=\"说说-C-Java，JavaScript-这三种语言的区别\"><a href=\"#说说-C-Java，JavaScript-这三种语言的区别\" class=\"headerlink\" title=\"说说 C++,Java，JavaScript 这三种语言的区别\"></a>说说 C++,Java，JavaScript 这三种语言的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>从静态类型还是动态类型来看</p>\n<p>静态类型，编译的时候就能够知道每个变量的类型，编程的时候也需要给定类型，如</p>\n<p>Java 中的整型 int，浮点型 float 等。C、C++、Java 都属于静态类型语言。</p>\n<p>动态类型，运行的时候才知道每个变量的类型，编程的时候无需显示指定类型，如JavaScript 中的 var、PHP 中的$。JavaScript、Ruby、Python<br>都属于动态类型语言。静态类型还是动态类型对语言的性能有很大影响。</p>\n<p>对于静态类型，在编译后会大量利用已知类型的优势，如 int 类型，占用 4 个字节， 编译后的代码就可以用内存地址加偏移量的方法存取变量，而地址加偏移量的算法汇编很容易实现。</p>\n<p>对于动态类型，会当做字符串通通存下来，之后存取就用字符串匹配。从编译型还是解释型来看</p>\n<p>编译型语言，像C、C++，需要编译器编译成本地可执行程序后才能运行，由开发人员在编写完成后手动实施。用户只使用这些编译好的本地代码，这些本地代码由系统加载器执行，由操作系统的 CPU<br>直接执行，无需其他额外的虚拟机等。</p>\n<p>源代码=》抽象语法树=》中间表示=》本地代码</p>\n<p>解释性语言，像 JavaScript、Python，开发语言写好后直接将代码交给用户，用户使用脚本解释器将脚本文件解释执行。对于脚本语言，没有开发人员的编译过程，当 然，也不绝对。</p>\n<p>源代码=》抽象语法树=》解释器解释执行。</p>\n<p>对于 JavaScript，随着 Java 虚拟机 JIT 技术的引入，工作方式也发生了改变。可以将抽象语法树转成中间表示（字节码），再转成本地代码，如<br>JavaScriptCore，这样可以大大提高执行效率。也可以从抽象语法树直接转成本地代码，如 V8</p>\n<p>Java 语言，分为两个阶段。首先像 C++语言一样，经过编译器编译。和 C++的不同， C++编译生成本地代码，Java 编译后，生成字节码，字节码与平台无关。第二阶段，由Java 的运行环境也就是<br>Java 虚拟机运行字节码，使用解释器执行这些代码。一般情况下，Java 虚拟机都引入了 JIT 技术，将字节码转换成本地代码来提高执行效率。</p>\n<p>注意，在上述情况中，编译器的编译过程没有时间要求，所以编译器可以做大量的代码优化措施。</p>\n<p>对于 JavaScript 与 Java 它们还有的不同：</p>\n<p>对于 Java，Java 语言将源代码编译成字节码，这个同执行阶段是分开的。也就是从源代码到抽象语法树到字节码这段时间的长短是无所谓的。</p>\n<p>对于 JavaScript，这些都是在网页和 JavaScript 文件下载后同执行阶段一起在网页的加载和渲染过程中实施的，所以对于它们的处理时间有严格要求。</p>\n<ul>\n<li><h3 id=\"JS-原型链，原型链的顶端是什么？Object-的原型是什么？Object-的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法\"><a href=\"#JS-原型链，原型链的顶端是什么？Object-的原型是什么？Object-的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法\" class=\"headerlink\" title=\"JS 原型链，原型链的顶端是什么？Object 的原型是什么？Object 的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法\"></a>JS 原型链，原型链的顶端是什么？Object 的原型是什么？Object 的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>能够把这个讲清楚弄明白是一件很困难的事，</p>\n<p>首先明白原型是什么，在 ES6 之前，JS 没有类和继承的概念，JS 是通过原型来实现继承的，在 JS 中一个构造函数默认带有一个 prototype 属性，这个的属性值是一个对象，同时这个<br>prototype 对象自带有一个 constructor 属性，这个属性指向这个构造函数，同时每一个实例都会有一个_proto_属性指向这个 prototype<br>对象，我们可以把这个叫做隐式原型，我们在使用一个实例的方法的时候，会先检查这个实例中是否有这个方法，没有的话就会检查这个 prototype 对象是否有这个方法，</p>\n<p>基于这个规则，如果让原型对象指向另一个类型的实例，即constructor1.protoytpe=instance2，这时候如果试图引用 constructor1 构造的实例instance1<br>的某个属性 p1,</p>\n<p>首先会在 instance1 内部属性中找一遍，</p>\n<p>接着会在 instance1._proto_（constructor1.prototype）即是 instance2 中寻找 p1</p>\n<p>搜寻轨迹：</p>\n<p>instance1-&gt;instance2-&gt;constructor2.prototype……-&gt;Object.prototype;这即是原型链，原型链顶端是 Object.prototype</p>\n<p>补充学习：</p>\n<p>每个函数都有一个 prototype 属性，这个属性指向了一个对象，这个对象正是调用该函数而创建的实例的原型，那么什么是原型呢，可以这样理解，每一个 JavaScript<br>对象在创建的时候就会预制管理另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型继承属性，如图：</p>\n<p><img src=\"media/image5.jpeg\"></p>\n<p>那么怎么表示实例与实例原型的关系呢，这时候就要用到第二个属性_proto_ 这是每一个 JS 对象都会有的一个属性，指向这个对象的原型，如图：</p>\n<blockquote>\n<p><img src=\"media/image6.jpeg\"></p>\n</blockquote>\n<p>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢，指向实例是没有的，因为一个构造函数可以生成多个实例，但是原型有属性可以直接指向构造函数，通过constructor 即可</p>\n<p>接下来讲解实例和原型的关系：</p>\n<p>当读取实例的属性时，如果找不到，就会查找与对象相关的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层，那么原型的原型是什么呢，首先，原型也是一个对象，既然是对象，我们就可以通过构造函数的方式创建它，所以原型对象就是通过<br>Object 构造函数生成的，如图：</p>\n<p><img src=\"media/image7.jpeg\"></p>\n<p>那么 Object.prototype 的原型呢，我们可以打印</p>\n<p>console.log(Object.prototype. proto === null)，返回 true</p>\n<p>null 表示没有对象，即该处不应有值，所以 Object.prototype 没有原型，如图：</p>\n<p><img src=\"media/image8.jpeg\"></p>\n<p>图中这条蓝色的线即是原型链， 最 后 补 充 三 点 ： constructor：</p>\n<p>function Person(){</p>\n<p>}</p>\n<p>var person = new Person(); console.log(Person === person.constructor);</p>\n<p>原本 person 中没有 constructor 属性，当不能读取到 constructor 属性时，会从</p>\n<p>person 的原型中读取，所以指向构造函数 Person</p>\n<p>proto ：</p>\n<p>绝大部分浏览器支持这个非标准的方法访问原型，然而它并不存在与Person.prototype 中，实际上它来自 Object.prototype，当使用 obj. proto 时， 可以理解为返回来<br>Object.getPrototype(obj)</p>\n<p>继承：</p>\n<p>前面说到，每个对象都会从原型继承属性，但是引用《你不知道的 JS》中的话，继承意味着复制操作，然而 JS 默认不会复制对象的属性，相反，JS<br>只是在两个对象之间创建一个关联，这样子一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，叫委托更合适。</p>\n<ul>\n<li><h3 id=\"什么是-js-的闭包？有什么作用，用闭包写个单例模式\"><a href=\"#什么是-js-的闭包？有什么作用，用闭包写个单例模式\" class=\"headerlink\" title=\"什么是 js 的闭包？有什么作用，用闭包写个单例模式\"></a>什么是 js 的闭包？有什么作用，用闭包写个单例模式</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>MDN 对闭包的定义是：闭包是指那些能够访问自由变量的函数，自由变量是指在函数中使用的，但既不是函数参数又不是函数的局部变量的变量，由此可以看出，闭包=函数</p>\n<p>+函数能够访问的自由变量，所以从技术的角度讲，所有 JS 函数都是闭包，但是这是理论上的闭包，还有一个实践角度上的闭包，从实践角度上来说，只有满足<br>1、即使创建它的上下文已经销毁，它仍然存在，2、在代码中引入了自由变量，才称为闭包</p>\n<p>闭包的应用：</p>\n<p>模仿块级作用域。2、保存外部函数的变量。3、封装私有变量单例模式：</p>\n<h3 id=\"var-Singleton-function-var-instance\"><a href=\"#var-Singleton-function-var-instance\" class=\"headerlink\" title=\"var Singleton = (function(){ var instance\"></a>var Singleton = (function(){ var instance</h3><blockquote>\n<p>var CreateSingleton = function (name) { this.name = name;</p>\n</blockquote>\n<blockquote>\n<p>if(instance) { return instance;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<p>// 打印实例名字</p>\n<h3 id=\"this-getName\"><a href=\"#this-getName\" class=\"headerlink\" title=\"this.getName()\"></a>this.getName()</h3><blockquote>\n<p>// instance = this;</p>\n</blockquote>\n<blockquote>\n<p>// return instance; return instance = this;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>// 获取实例的名字CreateSingleton.prototype.getName = function() { console.log(this.name)</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>return CreateSingleton;</p>\n</blockquote>\n<blockquote>\n<p>})();</p>\n</blockquote>\n<p>// 创建实例对象 1</p>\n<h3 id=\"var-a-new-Singleton-‘a’\"><a href=\"#var-a-new-Singleton-‘a’\" class=\"headerlink\" title=\"var a = new Singleton(‘a’)\"></a>var a = new Singleton(‘a’)</h3><p>// 创建实例对象 2</p>\n<h3 id=\"var-b-new-Singleton-‘b’-console-log-a-b\"><a href=\"#var-b-new-Singleton-‘b’-console-log-a-b\" class=\"headerlink\" title=\"var b = new Singleton(‘b’); console.log(a===b)\"></a>var b = new Singleton(‘b’); console.log(a===b)</h3><ul>\n<li><h3 id=\"promise-Generator-Async-的使用\"><a href=\"#promise-Generator-Async-的使用\" class=\"headerlink\" title=\"promise+Generator+Async 的使用\"></a>promise+Generator+Async 的使用</h3></li>\n</ul>\n<p>参考回答： Promise</p>\n<p>解决的问题:回调地狱Promise 规范:</p>\n<p>promise 有三种状态，等待（pending）、已完成（fulfilled/resolved）、已拒绝</p>\n<p>（rejected）.Promise 的状态只能从“等待”转到“完成”或者“拒绝”，不能逆向转换，同时“完成”和“拒绝”也不能相互转换.</p>\n<p>promise 必须提供一个 then 方法以访问其当前值、终值和据因。promise.then(resolve, reject),resolve 和 reject 都是可选参数。如果 resolve<br>或 reject 不是函数，其必须被忽略.</p>\n<p>then 方法必须返回一个 promise 对象.</p>\n<p>使用:</p>\n<p>实例化 promise 对象需要传入函数(包含两个参数),resolve 和 reject,内部确定状态.resolve 和 reject 函数可以传入参数在回调函数中使用.</p>\n<blockquote>\n<p>resolve 和 reject 都是函数,传入的参数在 then 的回调函数中接收. var promise = new Promise(function(resolve, reject) {<br>setTimeout(function(){</p>\n</blockquote>\n<h3 id=\"resolve-‘好哈哈哈哈’\"><a href=\"#resolve-‘好哈哈哈哈’\" class=\"headerlink\" title=\"resolve(‘好哈哈哈哈’)\"></a>resolve(‘好哈哈哈哈’)</h3><blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>promise.then(function(val){ console.log(val)</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<p>then 接收两个函数,分别对应 resolve 和 reject 状态的回调,函数中接收实例化时传入的参数.</p>\n<h3 id=\"promise-then-val-gt\"><a href=\"#promise-then-val-gt\" class=\"headerlink\" title=\"promise.then(val=&gt;{\"></a>promise.then(val=&gt;{</h3><blockquote>\n<p>//resolved</p>\n</blockquote>\n<blockquote>\n<p>},reason=&gt;{</p>\n</blockquote>\n<blockquote>\n<p>//rejected</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<p>catch 相当于.then(null, rejection)</p>\n<p>当 then 中没有传入 rejection 时,错误会冒泡进入 catch 函数中,若传入了 rejection, 则错误会被 rejection 捕获,而且不会进入 catch.此外,then<br>中的回调函数中发生的错误只会在下一级的 then 中被捕获,不会影响该 promise 的状态.</p>\n<h3 id=\"new-Promise-resolve-reject-gt-throw-new-Error-‘错误’\"><a href=\"#new-Promise-resolve-reject-gt-throw-new-Error-‘错误’\" class=\"headerlink\" title=\"new Promise((resolve,reject)=&gt;{ throw new Error(‘错误’)\"></a>new Promise((resolve,reject)=&gt;{ throw new Error(‘错误’)</h3><blockquote>\n<p>}).then(null,(err)=&gt;{ console.log(err,1);//此处捕获</p>\n</blockquote>\n<blockquote>\n<p>}).catch((err)=&gt;{ console.log(err,2);</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<h3 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"// 对比\"></a>// 对比</h3><blockquote>\n<p>new Promise((resolve,reject)=&gt;{</p>\n</blockquote>\n<blockquote>\n<p>throw new Error(‘错误’)</p>\n</blockquote>\n<blockquote>\n<p>}).then(null,null).catch((err)=&gt;{ console.log(err,2);//此处捕获</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>// 错误示例</p>\n</blockquote>\n<blockquote>\n<p>new Promise((resolve,reject)=&gt;{ resolve(‘正常’);</p>\n</blockquote>\n<blockquote>\n<p>}).then((val)=&gt;{</p>\n</blockquote>\n<blockquote>\n<p>throw new Error(‘回调函数中错误’)</p>\n</blockquote>\n<blockquote>\n<p>},(err)=&gt;{ console.log(err,1);</p>\n</blockquote>\n<blockquote>\n<p>}).then(null,(err)=&gt;{ console.log(err,2);//此处捕获,也可用 catch</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<p>两者不等价的情况:</p>\n<p>此时，catch 捕获的并不是 p1 的错误，而是 p2 的错误，</p>\n<h3 id=\"p1-then-res-gt\"><a href=\"#p1-then-res-gt\" class=\"headerlink\" title=\"p1().then(res=&gt;{\"></a>p1().then(res=&gt;{</h3><blockquote>\n<p>return p2()//p2 返回一个 promise 对象</p>\n</blockquote>\n<blockquote>\n<p>}).catch(err=&gt; console.log(err))</p>\n</blockquote>\n<p>一个错误捕获的错误用例:</p>\n<p>该函数调用中即使发生了错误依然会进入 then 中的 resolve 的回调函数,因为函数 p1 中实例化 promise 对象时已经调用了 catch,若发生错误会进入 catch<br>中,此时会返回一个新的 promise,因此即使发生错误依然会进入 p1 函数的 then 链中的 resolve 回调函数.</p>\n<h3 id=\"function-p1-val\"><a href=\"#function-p1-val\" class=\"headerlink\" title=\"function p1(val){\"></a>function p1(val){</h3><blockquote>\n<p>return new Promise((resolve,reject)=&gt;{ if(val){</p>\n</blockquote>\n<blockquote>\n<p>var len = val.length;//传入 null 会发生错误,进入 catch 捕获错resolve(len);</p>\n</blockquote>\n<blockquote>\n<p>}else{ reject();</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}).catch((err)=&gt;{ console.log(err)</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<blockquote>\n<p>}; p1(null).then((len)=&gt;{</p>\n</blockquote>\n<blockquote>\n<p>console.log(len,’resolved’);</p>\n</blockquote>\n<blockquote>\n<p>},()=&gt;{</p>\n</blockquote>\n<blockquote>\n<p>console.log(‘rejected’);</p>\n</blockquote>\n<blockquote>\n<p>}).catch((err)=&gt;{</p>\n</blockquote>\n<blockquote>\n<p>console.log(err,’catch’);</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<p>Promise 回调链:</p>\n<p>promise 能够在回调函数里面使用 return 和 throw， 所以在 then 中可以 return 出一个 promise 对象或其他值，也可以 throw 出一个错误对象，但如果没有<br>return，将默认返回 undefined，那么后面的 then 中的回调参数接收到的将是 undefined. function p1(val){</p>\n<h3 id=\"return-new-Promise-resolve-reject-gt-val-1-resolve-1-reject\"><a href=\"#return-new-Promise-resolve-reject-gt-val-1-resolve-1-reject\" class=\"headerlink\" title=\"return new Promise((resolve,reject)=&gt;{ val==1?resolve(1):reject()\"></a>return new Promise((resolve,reject)=&gt;{ val==1?resolve(1):reject()</h3><blockquote>\n<p>})</p>\n</blockquote>\n<blockquote>\n<p>};</p>\n</blockquote>\n<blockquote>\n<p>function p2(val){</p>\n</blockquote>\n<blockquote>\n<p>return new Promise((resolve,reject)=&gt;{ val==2?resolve(2):reject();</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<blockquote>\n<p>};</p>\n</blockquote>\n<blockquote>\n<p>let promimse = new Promise(function(resolve,reject){ resolve(1)</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<blockquote>\n<p>.then(function(data1) {</p>\n</blockquote>\n<blockquote>\n<p>return p1(data1)//如果去掉 return,则返回 undefined 而不是 p1 的返回值, 会导致报错</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<blockquote>\n<p>.then(function(data2){ return p2(data2+1)</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<blockquote>\n<p>.then(res=&gt;console.log(res))</p>\n</blockquote>\n<p>Generator 函 数 ： generator 函数使用:</p>\n<p>1、分段执行，可以暂停</p>\n<p>2、可以控制阶段和每个阶段的返回值</p>\n<p>3、可以知道是否执行到结尾</p>\n<h3 id=\"function-g-var-o-1-yield-o-yield-o\"><a href=\"#function-g-var-o-1-yield-o-yield-o\" class=\"headerlink\" title=\"function* g() { var o = 1; yield o++; yield o++\"></a>function* g() { var o = 1; yield o++; yield o++</h3><blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>var gen = g();</p>\n</blockquote>\n<blockquote>\n<p>console.log(gen.next()); // Object {value: 1, done: false} var xxx = g();</p>\n</blockquote>\n<blockquote>\n<p>console.log(gen.next()); // Object {value: 2, done: false} console.log(xxx.next()); // Object<br>{value: 1, done: false} console.log(gen.next()); // Object {value: undefined, done: true}</p>\n</blockquote>\n<p>generator 和异步控制:</p>\n<p>利用 Generator 函数的暂停执行的效果，可以把异步操作写在 yield 语句里面，等到调用 next 方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在<br>yield 语句下面，反正要等到调用 next 方法时再执行。所以， Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。</p>\n<p>async 和异步: 用法:</p>\n<p>async 表示这是一个 async 函数，await 只能用在这个函数里面。await 表示在这里等待异步操作返回结果，再继续执行。</p>\n<p>await 后一般是一个 promise 对象</p>\n<p>示例:async 用于定义一个异步函数，该函数返回一个 Promise。</p>\n<p>如果 async 函数返回的是一个同步的值，这个值将被包装成一个理解 resolve 的</p>\n<p>Promise，等同于 return Promise.resolve(value)。</p>\n<p>await 用于一个异步操作之前，表示要“等待”这个异步操作的返回值。await 也可以用于一个同步的值。</p>\n<h3 id=\"let-timer-async-function-timer-return-new-Promise-resolve-reject-gt-setTimeout-gt\"><a href=\"#let-timer-async-function-timer-return-new-Promise-resolve-reject-gt-setTimeout-gt\" class=\"headerlink\" title=\"let timer = async function timer(){ return new Promise((resolve,reject) =&gt; { setTimeout(() =&gt; {\"></a>let timer = async function timer(){ return new Promise((resolve,reject) =&gt; { setTimeout(() =&gt; {</h3><blockquote>\n<p>resolve(‘500’);</p>\n</blockquote>\n<blockquote>\n<p>},500);</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>timer().then(result =&gt; { console.log(result); //500</p>\n</blockquote>\n<blockquote>\n<p>}).catch(err =&gt; { console.log(err.message);</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>//返回一个同步的值</p>\n</blockquote>\n<blockquote>\n<p>let sayHi = async function sayHi(){ let hi = await ‘hello world’;</p>\n</blockquote>\n<blockquote>\n<p>return hi; //等同于 return Promise.resolve(hi);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>sayHi().then(result =&gt; { console.log(result);</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<ul>\n<li><h3 id=\"事件委托以及冒泡原理\"><a href=\"#事件委托以及冒泡原理\" class=\"headerlink\" title=\"事件委托以及冒泡原理\"></a>事件委托以及冒泡原理</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>事件委托是利用冒泡阶段的运行机制来实现的，就是把一个元素响应事件的函数委托到另一个元素，一般是把一组元素的事件委托到他的父元素上，委托的优点是</p>\n<p>减少内存消耗，节约效率动态绑定事件</p>\n<p>事件冒泡，就是元素自身的事件被触发后，如果父元素有相同的事件，如 onclick 事件，那么元素本身的触发状态就会传递，也就是冒到父元素，父元素的相同事件也会一级一级根据嵌套关系向外触发，直到<br>document/window，冒泡过程结束。</p>\n<ul>\n<li><h3 id=\"写个函数，可以转化下划线命名到驼峰命名\"><a href=\"#写个函数，可以转化下划线命名到驼峰命名\" class=\"headerlink\" title=\"写个函数，可以转化下划线命名到驼峰命名\"></a>写个函数，可以转化下划线命名到驼峰命名</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"public-static-String-UnderlineToHump-String-para-StringBuilder-result-new-StringBuilder\"><a href=\"#public-static-String-UnderlineToHump-String-para-StringBuilder-result-new-StringBuilder\" class=\"headerlink\" title=\"public static String UnderlineToHump(String para){ StringBuilder result=new StringBuilder()\"></a>public static String UnderlineToHump(String para){ StringBuilder result=new StringBuilder()</h3><blockquote>\n<p>String a[]=para.split(“_“); for(String s:a){ if(result.length()==0){<br>result.append(s.toLowerCase());</p>\n</blockquote>\n<blockquote>\n<p>}else{</p>\n</blockquote>\n<blockquote>\n<p>result.append(s.substring(0, 1).toUpperCase()); result.append(s.substring(1).toLowerCase());</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>return result.toString();</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"深浅拷贝的区别和实现\"><a href=\"#深浅拷贝的区别和实现\" class=\"headerlink\" title=\"深浅拷贝的区别和实现\"></a>深浅拷贝的区别和实现</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>数组的浅拷贝：</p>\n<p>如果是数组，我们可以利用数组的一些方法，比如 slice，concat 方法返回一个新数组的特性来实现拷贝，但假如数组嵌套了对象或者数组的话，使用 concat<br>方法克隆并不完整，如果数组元素是基本类型，就会拷贝一份，互不影响，而如果是对象或数<br>组，就会只拷贝对象和数组的引用，这样我们无论在新旧数组进行了修改，两者都会发生变化，我们把这种复制引用的拷贝方法称为浅拷贝，</p>\n<p>深拷贝就是指完全的拷贝一个对象，即使嵌套了对象，两者也互相分离，修改一个对象的属性，不会影响另一个</p>\n<p>如何深拷贝一个数组</p>\n<h3 id=\"1、这里介绍一个技巧，不仅适用于数组还适用于对象！那就是：-var-arr-‘old’-1-true-‘old1’-‘old2’-old-1-var-new-arr-JSON-parse-JSON-stringify-arr-console-log-new-arr\"><a href=\"#1、这里介绍一个技巧，不仅适用于数组还适用于对象！那就是：-var-arr-‘old’-1-true-‘old1’-‘old2’-old-1-var-new-arr-JSON-parse-JSON-stringify-arr-console-log-new-arr\" class=\"headerlink\" title=\"1、这里介绍一个技巧，不仅适用于数组还适用于对象！那就是： var arr = [‘old’, 1, true, [‘old1’, ‘old2’], {old: 1}] var new_arr = JSON.parse( JSON.stringify(arr) ); console.log(new_arr)\"></a>1、这里介绍一个技巧，不仅适用于数组还适用于对象！那就是： var arr = [‘old’, 1, true, [‘old1’, ‘old2’], {old: 1}] var new_arr = JSON.parse( JSON.stringify(arr) ); console.log(new_arr)</h3><p>原理是 JOSN 对象中的 stringify 可以把一个 js 对象序列化为一个 JSON 字符串， parse 可以把 JSON 字符串反序列化为一个 js<br>对象，通过这两个方法，也可以实现对象的深复制。</p>\n<p>但是这个方法不能够拷贝函数浅拷贝的实现：</p>\n<p>以上三个方法 concat,slice ,JSON.stringify<br>都是技巧类，根据实际项目情况选择使用，我们可以思考下如何实现一个对象或数组的浅拷贝，遍历对象，然后把属性和属性值都放在一个新的对象里即可</p>\n<h3 id=\"var-shallowCopy-function-obj\"><a href=\"#var-shallowCopy-function-obj\" class=\"headerlink\" title=\"var shallowCopy = function(obj) {\"></a>var shallowCopy = function(obj) {</h3><blockquote>\n<p>// 只拷贝对象</p>\n</blockquote>\n<blockquote>\n<p>if (typeof obj !== ‘object’) return;</p>\n</blockquote>\n<blockquote>\n<p>// 根据 obj 的类型判断是新建一个数组还是对象var newObj = obj instanceof Array ? [] : {};</p>\n</blockquote>\n<blockquote>\n<p>// 遍历 obj，并且判断是 obj 的属性才拷贝</p>\n</blockquote>\n<blockquote>\n<p>for (var key in obj) {</p>\n</blockquote>\n<blockquote>\n<p>if (obj.hasOwnProperty(key)) { newObj[key] = obj[key];</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>return newObj;</p>\n</blockquote>\n<p>深拷贝的实现</p>\n<p>那如何实现一个深拷贝呢？说起来也好简单，我们在拷贝的时候判断一下属性值的类型，如果是对象，我们递归调用深拷贝函数不就好了~</p>\n<h3 id=\"var-deepCopy-function-obj-1\"><a href=\"#var-deepCopy-function-obj-1\" class=\"headerlink\" title=\"var deepCopy = function(obj) {\"></a>var deepCopy = function(obj) {</h3><blockquote>\n<p>if (typeof obj !== ‘object’) return;</p>\n</blockquote>\n<blockquote>\n<p>var newObj = obj instanceof Array ? [] : {}; for (var key in obj) {</p>\n</blockquote>\n<blockquote>\n<p>if (obj.hasOwnProperty(key)) {</p>\n</blockquote>\n<blockquote>\n<p>newObj[key] = typeof obj[key] === ‘object’ ? deepCopy(obj[key]) : obj[key];</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>return newObj;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"JS-中-string-的-startwith-和-indexof-两种方法的区别\"><a href=\"#JS-中-string-的-startwith-和-indexof-两种方法的区别\" class=\"headerlink\" title=\"JS 中 string 的 startwith 和 indexof 两种方法的区别\"></a>JS 中 string 的 startwith 和 indexof 两种方法的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>JS 中 startwith 函数，其参数有 3 个，stringObj,要搜索的字符串对象，str，搜索的字符串，position，可选，从哪个位置开始搜索，如果以 position<br>开始的字符串以搜索字符串开头，则返回 true，否则返回 false</p>\n<p>Indexof 函数，indexof 函数可返回某个指定字符串在字符串中首次出现的位置。</p>\n<ul>\n<li><h3 id=\"JS-字符串转数字的方法\"><a href=\"#JS-字符串转数字的方法\" class=\"headerlink\" title=\"JS 字符串转数字的方法\"></a>JS 字符串转数字的方法</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>通过函数 parseInt（），可解析一个字符串，并返回一个整数，语法为 parseInt</p>\n<p>（string ,radix） string：被解析的字符串</p>\n<p>radix：表示要解析的数字的基数，默认是十进制，如果 radix&lt;2 或&gt;36,则返回 NaN</p>\n<ul>\n<li><h3 id=\"let-const-var-的区别-，什么是块级作用域，如何用-ES5-的方法实现块级作用域（立即执行函数），ES6-呢\"><a href=\"#let-const-var-的区别-，什么是块级作用域，如何用-ES5-的方法实现块级作用域（立即执行函数），ES6-呢\" class=\"headerlink\" title=\"let const var 的区别 ，什么是块级作用域，如何用 ES5 的方法实现块级作用域（立即执行函数），ES6 呢\"></a>let const var 的区别 ，什么是块级作用域，如何用 ES5 的方法实现块级作用域（立即执行函数），ES6 呢</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>提起这三个最明显的区别是 var 声明的变量是全局或者整个函数块的，而 let,const 声明的变量是块级的变量，var 声明的变量存在变量提升，let,const 不存在，let<br>声明的变量允许重新赋值，const 不允许。</p>\n<ul>\n<li><h3 id=\"ES6-箭头函数的特性\"><a href=\"#ES6-箭头函数的特性\" class=\"headerlink\" title=\"ES6 箭头函数的特性\"></a>ES6 箭头函数的特性</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>ES6 增加了箭头函数，基本语法为let func = value =&gt; value;</p>\n<p>相当于</p>\n<p>let func = function (value) { return value;</p>\n<p>};</p>\n<p>箭头函数与普通函数的区别在于：</p>\n<p>1、箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值，这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this，</p>\n<p>2、箭头函数没有自己的 arguments 对象，但是可以访问外围函数的 arguments 对象3、不能通过 new 关键字调用，同样也没有 new.target 值和原型</p>\n<ul>\n<li><h3 id=\"setTimeout-和-Promise-的执行顺序\"><a href=\"#setTimeout-和-Promise-的执行顺序\" class=\"headerlink\" title=\"setTimeout 和 Promise 的执行顺序\"></a>setTimeout 和 Promise 的执行顺序</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>首先我们来看这样一道题：</p>\n<h3 id=\"setTimeout-function\"><a href=\"#setTimeout-function\" class=\"headerlink\" title=\"setTimeout(function() {\"></a>setTimeout(function() {</h3><blockquote>\n<p>console.log(1)</p>\n</blockquote>\n<blockquote>\n<p>}, 0);</p>\n</blockquote>\n<blockquote>\n<p>new Promise(function(resolve, reject) { console.log(2)</p>\n</blockquote>\n<blockquote>\n<p>for (var i = 0; i &lt; 10000; i++) { if(i === 10) {console.log(10)}</p>\n</blockquote>\n<blockquote>\n<p>i == 9999 &amp;&amp; resolve();</p>\n</blockquote>\n<blockquote>\n<p>} console.log(3)</p>\n</blockquote>\n<blockquote>\n<p>}).then(function() { console.log(4)</p>\n</blockquote>\n<blockquote>\n<p>}) console.log(5);</p>\n</blockquote>\n<p>输出答案为 2 10 3 5 4 1</p>\n<p>要先弄清楚 settimeout（fun,0）何时执行，promise 何时执行，then 何时执行settimeout<br>这种异步操作的回调，只有主线程中没有执行任何同步代码的前提下，才会执行异步回调，而 settimeout（fun,0）表示立刻执行，也就是用来改变任务的执行顺序，要求浏览器尽可能快的进行回调</p>\n<p>promise 何时执行，由上图可知 promise 新建后立即执行，所以 promise 构造函数里代码同步执行的，</p>\n<p>then 方法指向的回调将在当前脚本所有同步任务执行完成后执行，</p>\n<p>那么 then 为什么比 settimeout 执行的早呢，因为 settimeout（fun,0）不是真的立即执行，</p>\n<p>经过测试得出结论：执行顺序为：同步执行的代码-》promise.then-&gt;settimeout</p>\n<ul>\n<li><h3 id=\"有了解过事件模型吗，DOM0-级和-DOM2-级有什么区别，DOM-的分级是什么\"><a href=\"#有了解过事件模型吗，DOM0-级和-DOM2-级有什么区别，DOM-的分级是什么\" class=\"headerlink\" title=\"有了解过事件模型吗，DOM0 级和 DOM2 级有什么区别，DOM 的分级是什么\"></a>有了解过事件模型吗，DOM0 级和 DOM2 级有什么区别，DOM 的分级是什么</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>JSDOM 事件流存在如下三个阶段： 事件捕获阶段</p>\n<p>处于目标阶段事件冒泡阶段</p>\n<p>JSDOM 标准事件流的触发的先后顺序为：先捕获再冒泡，点击 DOM 节点时，事件传播顺序：事件捕获阶段，从上往下传播，然后到达事件目标节点，最后是冒泡阶段，从下往上传播</p>\n<p>DOM 节点添加事件监听方法 addEventListener，中参数 capture 可以指定该监听是添加在事件捕获阶段还是事件冒泡阶段，为 false 是事件冒泡，为 true<br>是事件捕获，并非所有的事件都支持冒泡，比如 focus，blur 等等，我们可以通过 event.bubbles 来判断</p>\n<p>事件模型有三个常用方法：</p>\n<p>event.stopPropagation:阻止捕获和冒泡阶段中，当前事件的进一步传播， event.stopImmediatePropagetion，阻止调用相同事件的其他侦听器，</p>\n<p>event.preventDefault，取消该事件（假如事件是可取消的）而不停止事件的进一步传播，</p>\n<p>event.target：指向触发事件的元素，在事件冒泡过程中这个值不变event.currentTarget = this，时间帮顶的当前元素，只有被点击时目标元素的target 才会等于<br>currentTarget，</p>\n<p>最后，对于执行顺序的问题，如果 DOM<br>节点同时绑定了两个事件监听函数，一个用于捕获，一个用于冒泡，那么两个事件的执行顺序真的是先捕获在冒泡吗，答案是否定的，绑定在被点击元素的事件是按照代码添加顺序执行的，其他函数是先捕获再冒泡</p>\n<ul>\n<li><h3 id=\"平时是怎么调试-JS-的\"><a href=\"#平时是怎么调试-JS-的\" class=\"headerlink\" title=\"平时是怎么调试 JS 的\"></a>平时是怎么调试 JS 的</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>一般用 Chrome 自带的控制台</p>\n<ul>\n<li><h3 id=\"JS-的基本数据类型有哪些，基本数据类型和引用数据类型的区别，NaN-是什么的缩写，JS-的作用域类型，undefined-null-返回的结果是什么，undefined-与-null-的区别在哪，写一个函数判断变量类型\"><a href=\"#JS-的基本数据类型有哪些，基本数据类型和引用数据类型的区别，NaN-是什么的缩写，JS-的作用域类型，undefined-null-返回的结果是什么，undefined-与-null-的区别在哪，写一个函数判断变量类型\" class=\"headerlink\" title=\"JS 的基本数据类型有哪些，基本数据类型和引用数据类型的区别，NaN 是什么的缩写，JS 的作用域类型，undefined==null 返回的结果是什么，undefined 与 null 的区别在哪，写一个函数判断变量类型\"></a>JS 的基本数据类型有哪些，基本数据类型和引用数据类型的区别，NaN 是什么的缩写，JS 的作用域类型，undefined==null 返回的结果是什么，undefined 与 null 的区别在哪，写一个函数判断变量类型</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>JS 的基本数据类型有字符串，数字，布尔，数组，对象，Null，Undefined,基本数据类型是按值访问的，也就是说我们可以操作保存在变量中的实际的值，</p>\n<p>基本数据类型和引用数据类型的区别如下：</p>\n<p>基本数据类型的值是不可变的，任何方法都无法改变一个基本类型的值，当这个变量重新赋值后看起来变量的值是改变了，但是这里变量名只是指向变量的一个指针，所以改变的是指针的指向改变，该变量是不变的，但是引用类型可以改变</p>\n<p>基本数据类型不可以添加属性和方法，但是引用类型可以</p>\n<p>基本数据类型的赋值是简单赋值，如果从一个变量向另一个变量赋值基本类型的值， 会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上，引用数据类型的赋值是对象引用，</p>\n<p>基本数据类型的比较是值的比较，引用类型的比较是引用的比较，比较对象的内存地址是否相同</p>\n<p>基本数据类型是存放在栈区的，引用数据类型同事保存在栈区和堆区</p>\n<p>NaN 是 JS 中的特殊值，表示非数字，NaN 不是数字，但是他的数据类型是数字，它不等于任何值，包括自身，在布尔运算时被当做 false，NaN 与任何数运算得到的结果都是<br>NaN，党员算失败或者运算无法返回正确的数值的就会返回 NaN，一些数学函数的运算结果也会出现 NaN ,</p>\n<p>JS 的作用域类型：</p>\n<p>一般认为的作用域是词法作用域，此外 JS 还提供了一些动态改变作用域的方法，常见的作用域类型有：</p>\n<p>函数作用域，如果在函数内部我们给未定义的一个变量赋值，这个变量会转变成为一个全局变量，</p>\n<p>块作用域：块作用域吧标识符限制在{}中， 改变函数作用域的方法：</p>\n<p>eval（），这个方法接受一个字符串作为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码，</p>\n<p>with 关键字：通常被当做重复引用同一个对象的多个属性的快捷方式</p>\n<p>undefined 与 null：目前 null 和 undefined 基本是同义的，只有一些细微的差别， null 表示没有对象，undefined<br>表示缺少值，就是此处应该有一个值但是还没有定义，因此 undefined==null 返回 false</p>\n<p>此外了解== 和===的区别：</p>\n<p>在做==比较时。不同类型的数据会先转换成一致后在做比较，===中如果类型不一致就直接返回 false，一致的才会比较</p>\n<p>类型判断函数，使用 typeof 即可，首先判断是否为 null，之后用 typeof 哦按段，如果是 object 的话，再用 array.isarray 判断是否为数组，如果是数字的话用<br>isNaN 判断是否是 NaN 即可</p>\n<p>扩展学习：</p>\n<p>JS 采用的是词法作用域，也就是静态作用域，所以函数的作用域在函数定义的时候就决定了，</p>\n<p>看如下例子：</p>\n<h3 id=\"var-value-1-function-foo-console-log-value\"><a href=\"#var-value-1-function-foo-console-log-value\" class=\"headerlink\" title=\"var value = 1; function foo() { console.log(value)\"></a>var value = 1; function foo() { console.log(value)</h3><blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>function bar() { var value = 2; foo();</p>\n</blockquote>\n<blockquote>\n<p>} bar();</p>\n</blockquote>\n<p>假设 JavaScript 采用静态作用域，让我们分析下执行过程：</p>\n<p>执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。</p>\n<p>假设 JavaScript 采用动态作用域，让我们分析下执行过程：</p>\n<p>执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印<br>2。前面我们已经说了，JavaScript 采用的是静态作用域，所以这个例子的结果是 1。</p>\n<ul>\n<li><h3 id=\"setTimeout-fn-100-100-毫秒是如何权衡的\"><a href=\"#setTimeout-fn-100-100-毫秒是如何权衡的\" class=\"headerlink\" title=\"setTimeout(fn,100);100 毫秒是如何权衡的\"></a>setTimeout(fn,100);100 毫秒是如何权衡的</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>setTimeout()函数只是将事件插入了任务列表，必须等到当前代码执行完，主线程才会去执行它指定的回调函数，有可能要等很久，所以没有办法保证回调函数一定会在setTimeout<br>指定的时间内执行，100 毫秒是插入队列的时间+等待的时间</p>\n<ul>\n<li><h3 id=\"JS-的垃圾回收机制\"><a href=\"#JS-的垃圾回收机制\" class=\"headerlink\" title=\"JS 的垃圾回收机制\"></a>JS 的垃圾回收机制</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>GC（garbage collection），GC 执行时，中断代码，停止其他操作，遍历所有对象， 对于不可访问的对象进行回收，在 V8 引擎中使用两种优化方法，</p>\n<p>分代回收，2、增量 GC，目的是通过对象的使用频率，存在时长来区分新生代和老生代对象，多回收新生代区，少回收老生代区，减少每次遍历的时间，从而减少 GC 的耗时回收方法：</p>\n<p>引用计次，当对象被引用的次数为零时进行回收，但是循环引用时，两个对象都至少被引用了一次，因此导致内存泄漏，</p>\n<p>标记清除</p>\n<ul>\n<li><h3 id=\"写一个-newBind-函数，完成-bind-的功能\"><a href=\"#写一个-newBind-函数，完成-bind-的功能\" class=\"headerlink\" title=\"写一个 newBind 函数，完成 bind 的功能\"></a>写一个 newBind 函数，完成 bind 的功能</h3></li>\n</ul>\n<p>参考回答：</p>\n<blockquote>\n<p>bind（）方法，创建一个新函数，当这个新函数被调用时，bind（）的第一个参数将作为它运行时的<br>this，之后的一序列参数将会在传递的实参前传入作为它的参数Function.prototype.bind2 = function (context) {</p>\n</blockquote>\n<h3 id=\"if-typeof-this-“function”\"><a href=\"#if-typeof-this-“function”\" class=\"headerlink\" title=\"if (typeof this !== “function”) {\"></a>if (typeof this !== “function”) {</h3><blockquote>\n<p>throw new Error(“Function.prototype.bind - what is trying to be bound is not callable”);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>var self = this;</p>\n</blockquote>\n<blockquote>\n<p>var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () {};</p>\n</blockquote>\n<blockquote>\n<p>var fbound = function () {</p>\n</blockquote>\n<blockquote>\n<p>self.apply(this instanceof self ? this : context,<br>args.concat(Array.prototype.slice.call(arguments)));</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>fNOP.prototype = this.prototype; fbound.prototype = new fNOP(); return fbound;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"怎么获得对象上的属性：比如说通过-Object-key（）\"><a href=\"#怎么获得对象上的属性：比如说通过-Object-key（）\" class=\"headerlink\" title=\"怎么获得对象上的属性：比如说通过 Object.key（）\"></a>怎么获得对象上的属性：比如说通过 Object.key（）</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>从 ES5 开始，有三种方法可以列出对象的属性</p>\n<p>for（let I in<br>obj）该方法依次访问一个对象及其原型链中所有可枚举的类型object.keys:返回一个数组，包括所有可枚举的属性名称object.getOwnPropertyNames:返回一个数组包含不可枚举的属性</p>\n<ul>\n<li><h3 id=\"简单讲一讲-ES6-的一些新特性\"><a href=\"#简单讲一讲-ES6-的一些新特性\" class=\"headerlink\" title=\"简单讲一讲 ES6 的一些新特性\"></a>简单讲一讲 ES6 的一些新特性</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>ES6 在变量的声明和定义方面增加了 let、const 声明变量，有局部变量的概念，赋值中有比较吸引人的结构赋值，同时 ES6 对字符串、<br>数组、正则、对象、函数等拓展了一些方法，如字符串方面的模板字符串、函数方面的默认参数、对象方面属性的简洁表达方式，ES6 也 引入了新的数据类型 symbol，新的数据结构 set 和<br>map,symbol 可以通过 typeof 检测出来，为解决异步回调问题，引入了 promise 和 generator，还有最为吸引人了实现 Class 和模块，通过 Class<br>可以更好的面向对象编程，使用模块加载方便模块化编程，当然考虑到 浏览器兼容性，我们在实际开发中需要使用 babel 进行编译</p>\n<p>重要的特性：</p>\n<p>块级作用域：ES5 只有全局作用域和函数作用域，块级作用域的好处是不再需要立即执行的函数表达式，循环体中的闭包不再有问题</p>\n<p>rest 参数：用于获取函数的多余参数，这样就不需要使用 arguments 对象了， promise:一种异步编程的解决方案，比传统的解决方案回调函数和事件更合理强大<br>模块化：其模块功能主要有两个命令构成，export 和 import，export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能</p>\n<ul>\n<li><h3 id=\"call-和-apply-是用来做什么？\"><a href=\"#call-和-apply-是用来做什么？\" class=\"headerlink\" title=\"call 和 apply 是用来做什么？\"></a>call 和 apply 是用来做什么？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Call 和 apply 的作用是一模一样的，只是传参的形式有区别而已1、改变 this 的指向</p>\n<p>2、借用别的对象的方法，</p>\n<p>3、调用函数，因为 apply，call 方法会使函数立即执行</p>\n<ul>\n<li><h3 id=\"了解事件代理吗，这样做有什么好处\"><a href=\"#了解事件代理吗，这样做有什么好处\" class=\"headerlink\" title=\"了解事件代理吗，这样做有什么好处\"></a>了解事件代理吗，这样做有什么好处</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>事件代理/事件委托：利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的事件，</p>\n<p>简而言之：事件代理就是说我们将事件添加到本来要添加的事件的父节点，将事件委托给父节点来触发处理函数，这通常会使用在大量的同级元素需要添加同一类事件的时候，比如一个动态的非常多的列表，需要为每个列表项都添加点击事件，这时就可以使用事件代理，通过判断<br>e.target.nodeName 来判断发生的具体元素，这样做的好处是减少事件绑定，同事动态的 DOM 结构任然可以监听，事件代理发生在冒泡阶段</p>\n<ul>\n<li><h3 id=\"如何写一个继承？\"><a href=\"#如何写一个继承？\" class=\"headerlink\" title=\"如何写一个继承？\"></a>如何写一个继承？</h3></li>\n</ul>\n<p>参考回答： 原型链继承</p>\n<p>核心： 将父类的实例作为子类的原型特点：</p>\n<p>非常纯粹的继承关系，实例是子类的实例，也是父类的实例父类新增原型方法/原型属性，子类都能访问到</p>\n<p>简单，易于实现缺点：</p>\n<p>要想为子类新增属性和方法，不能放到构造器中无法实现多继承</p>\n<p>来自原型对象的所有属性被所有实例共享 创建子类实例时，无法向父类构造函数传参</p>\n<p>构造继承</p>\n<p>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p>\n<p>特点：</p>\n<p>解决了子类实例共享父类引用属性的问题创建子类实例时，可以向父类传递参数 可以实现多继承（call 多个父类对象） 缺点：</p>\n<p>实例并不是父类的实例，只是子类的实例</p>\n<p>只能继承父类的实例属性和方法，不能继承原型属性/方法</p>\n<p>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</p>\n<p>实例继承</p>\n<p>核心：为父类实例添加新特性，作为子类实例返回特点：</p>\n<p>不限制调用方式，不管是 new 子类()还是子类(),返回的对象具有相同的效果</p>\n<p>缺点：</p>\n<p>实例是父类的实例，不是子类的实例不支持多继承</p>\n<p>拷贝继承特点：</p>\n<p>支持多继承缺点：</p>\n<p>效率较低，内存占用高（因为要拷贝父类的属性）</p>\n<p>组合继承</p>\n<p>核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<p>特点：</p>\n<p>可以继承实例属性/方法，也可以继承原型属性/方法既是子类的实例，也是父类的实例</p>\n<p>不存在引用属性共享问题可传参</p>\n<p>函数可复用</p>\n<p>寄生组合继承</p>\n<p>核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<p>参考 <a href=\"https://www.cnblogs.com/humin/p/4556820.html\"><em>https://www.cnblogs.com/humin/p/4556820.html</em></a></p>\n<ul>\n<li><h3 id=\"给出以下代码，输出的结果是什么？原因？-for-var-i-0-i-lt-5-i\"><a href=\"#给出以下代码，输出的结果是什么？原因？-for-var-i-0-i-lt-5-i\" class=\"headerlink\" title=\"给出以下代码，输出的结果是什么？原因？ for(var i=0;i&lt;5;i++)\"></a>给出以下代码，输出的结果是什么？原因？ for(var i=0;i&lt;5;i++)</h3></li>\n</ul>\n<blockquote>\n<p>{ setTimeout(function(){ console.log(i); },1000); } console.log(i)</p>\n</blockquote>\n<p>参考回答：</p>\n<p>在一秒后输出 5 个 5</p>\n<p>每次 for 循环的时候 setTimeout 都会执行，但是里面的 function 则不会执行被放入任务队列，因此放了 5 次；for 循环的 5 次执行完之后不到 1000 毫秒；1000<br>毫秒后全部执行任务队列中的函数，所以就是输出 5 个 5。</p>\n<ul>\n<li><h3 id=\"给两个构造函数-A-和-B，如何实现-A-继承-B？\"><a href=\"#给两个构造函数-A-和-B，如何实现-A-继承-B？\" class=\"headerlink\" title=\"给两个构造函数 A 和 B，如何实现 A 继承 B？\"></a>给两个构造函数 A 和 B，如何实现 A 继承 B？</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"function-A-…-A-prototype\"><a href=\"#function-A-…-A-prototype\" class=\"headerlink\" title=\"function A(…) {} A.prototype\"></a>function A(…) {} A.prototype</h3><blockquote>\n<p>function B(…) {} B.prototype… A.prototype = Object.create(B.prototype);</p>\n</blockquote>\n<blockquote>\n<p>// 再在A 的构造函数里 new B(props); for(var i = 0; i &lt; lis.length; i++) {</p>\n</blockquote>\n<blockquote>\n<p>lis[i].addEventListener(‘click’, function(e) { alert(i);</p>\n</blockquote>\n<blockquote>\n<p>}, false)</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"问能不能正常打印索引\"><a href=\"#问能不能正常打印索引\" class=\"headerlink\" title=\"问能不能正常打印索引\"></a>问能不能正常打印索引</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>在 click 的时候，已经变成 length 了</p>\n<ul>\n<li><h3 id=\"如果已经有三个-promise，A、B-和-C，想串行执行，该怎么写？\"><a href=\"#如果已经有三个-promise，A、B-和-C，想串行执行，该怎么写？\" class=\"headerlink\" title=\"如果已经有三个 promise，A、B 和 C，想串行执行，该怎么写？\"></a>如果已经有三个 promise，A、B 和 C，想串行执行，该怎么写？</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"promise-A-then-B-then-C-catch-…\"><a href=\"#promise-A-then-B-then-C-catch-…\" class=\"headerlink\" title=\"// promise A.then(B).then(C).catch(…)\"></a>// promise A.then(B).then(C).catch(…)</h3><blockquote>\n<p>// async/await (async ()=&gt;{ await a(); await b(); await c();</p>\n</blockquote>\n<blockquote>\n<p>})()</p>\n</blockquote>\n<ul>\n<li><h3 id=\"知道-private-和-public-吗\"><a href=\"#知道-private-和-public-吗\" class=\"headerlink\" title=\"知道 private 和 public 吗\"></a>知道 private 和 public 吗</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>public：public 表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用</p>\n<p>private：private 表示私有，私有的意思就是除了 class 自己之外，任何人都不可以直接使用</p>\n<ul>\n<li><h3 id=\"基础的-js\"><a href=\"#基础的-js\" class=\"headerlink\" title=\"基础的 js\"></a>基础的 js</h3></li>\n</ul>\n<p>参 考 回 答 ： Function.prototype.a = 1; Object.prototype.b = 2; function A() {}</p>\n<p>var a = new A();</p>\n<p>console.log(a.a, a.b); // undefined, 2 console.log(A.a, A.b); // 1, 2</p>\n<ul>\n<li><h3 id=\"async-和-await-具体该怎么用？\"><a href=\"#async-和-await-具体该怎么用？\" class=\"headerlink\" title=\"async 和 await 具体该怎么用？\"></a>async 和 await 具体该怎么用？</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"async-gt-await-new-promise\"><a href=\"#async-gt-await-new-promise\" class=\"headerlink\" title=\"(async () = &gt; { await new promise()\"></a>(async () = &gt; { await new promise()</h3><blockquote>\n<p>})()</p>\n</blockquote>\n<ul>\n<li><h3 id=\"知道哪些-ES6，ES7-的语法\"><a href=\"#知道哪些-ES6，ES7-的语法\" class=\"headerlink\" title=\"知道哪些 ES6，ES7 的语法\"></a>知道哪些 ES6，ES7 的语法</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>promise，await/async，let、const、块级作用域、箭头函数</p>\n<ul>\n<li><h3 id=\"promise-和-await-async-的关系\"><a href=\"#promise-和-await-async-的关系\" class=\"headerlink\" title=\"promise 和 await/async 的关系\"></a>promise 和 await/async 的关系</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>都是异步编程的解决方案</p>\n<ul>\n<li><h3 id=\"JS-的数据类型\"><a href=\"#JS-的数据类型\" class=\"headerlink\" title=\"JS 的数据类型\"></a>JS 的数据类型</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>字符串，数字，布尔，数组，null，Undefined，symbol，对象。</p>\n<ul>\n<li><h3 id=\"JS-加载过程阻塞，解决方法\"><a href=\"#JS-加载过程阻塞，解决方法\" class=\"headerlink\" title=\"JS 加载过程阻塞，解决方法\"></a>JS 加载过程阻塞，解决方法</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>指定 script 标签的 async 属性。</p>\n<p>如果 async=”async”，脚本相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本将被执行）</p>\n<p>如果不使用 async 且 defer=”defer”：脚本将在页面完成解析时执行</p>\n<ul>\n<li><h3 id=\"JS-对象类型，基本对象类型以及引用对象类型的区别\"><a href=\"#JS-对象类型，基本对象类型以及引用对象类型的区别\" class=\"headerlink\" title=\"JS 对象类型，基本对象类型以及引用对象类型的区别\"></a>JS 对象类型，基本对象类型以及引用对象类型的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>分为基本对象类型和引用对象类型</p>\n<p>基本数据类型：按值访问，可操作保存在变量中的实际的值。基本类型值指的是简单的数据段。基本数据类型有这六种:undefined、null、string、number、boolean、symbol。</p>\n<p>引用类型：当复制保存着对象的某个变量时，操作的是对象的引用，但在为对象添加属性时，操作的是实际的对象。引用类型值指那些可能为多个值构成的对象。</p>\n<p>引用类型有这几种：Object、Array、RegExp、Date、Function、特殊的基本包装类型</p>\n<p>(String、Number、Boolean)以及单体内置对象(Global、Math)。</p>\n<ul>\n<li><h3 id=\"JavaScript-中的轮播实现原理？假如一个页面上有两个轮播，你会怎么实现？\"><a href=\"#JavaScript-中的轮播实现原理？假如一个页面上有两个轮播，你会怎么实现？\" class=\"headerlink\" title=\"JavaScript 中的轮播实现原理？假如一个页面上有两个轮播，你会怎么实现？\"></a>JavaScript 中的轮播实现原理？假如一个页面上有两个轮播，你会怎么实现？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>图片轮播的原理就是图片排成一行，然后准备一个只有一张图片大小的容器，对这个容器设置超出部分隐藏，在控制定时器来让这些图片整体左移或右移，这样呈现出来的效果就是图片在轮播了。</p>\n<p>如果有两个轮播，可封装一个轮播组件，供两处调用</p>\n<ul>\n<li><h3 id=\"怎么实现一个计算一年中有多少周？\"><a href=\"#怎么实现一个计算一年中有多少周？\" class=\"headerlink\" title=\"怎么实现一个计算一年中有多少周？\"></a>怎么实现一个计算一年中有多少周？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>首先你得知道是不是闰年，也就是一年是 365 还是 366.</p>\n<p>其次你得知道当年 1 月 1 号是周几。假如是周五，一年 365 天把 1 号 2 号 3 号减去， 也就是把第一个不到一周的天数减去等于 362</p>\n<p>还得知道最后一天是周几，加入是周五，需要把周一到周五减去，也就是 362-5=357.</p>\n<p>正常情况 357 这个数计算出来是 7 的倍数。357/7=51 。即为周数。</p>\n<ul>\n<li><h3 id=\"面向对象的继承方式\"><a href=\"#面向对象的继承方式\" class=\"headerlink\" title=\"面向对象的继承方式\"></a>面向对象的继承方式</h3></li>\n</ul>\n<p>参考回答： 原型链继承</p>\n<p>核心： 将父类的实例作为子类的原型特点：</p>\n<p>非常纯粹的继承关系，实例是子类的实例，也是父类的实例父类新增原型方法/原型属性，子类都能访问到</p>\n<p>简单，易于实现缺点：</p>\n<p>要想为子类新增属性和方法，不能放到构造器中无法实现多继承</p>\n<p>来自原型对象的所有属性被所有实例共享 创建子类实例时，无法向父类构造函数传参</p>\n<p>构造继承</p>\n<p>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p>\n<p>特点：</p>\n<p>解决了子类实例共享父类引用属性的问题创建子类实例时，可以向父类传递参数 可以实现多继承（call 多个父类对象） 缺点：</p>\n<p>实例并不是父类的实例，只是子类的实例</p>\n<p>只能继承父类的实例属性和方法，不能继承原型属性/方法</p>\n<p>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</p>\n<p>实例继承</p>\n<p>核心：为父类实例添加新特性，作为子类实例返回特点：</p>\n<p>不限制调用方式，不管是 new 子类()还是子类(),返回的对象具有相同的效果</p>\n<p>缺点：</p>\n<p>实例是父类的实例，不是子类的实例不支持多继承</p>\n<p>拷贝继承特点：</p>\n<p>支持多继承</p>\n<p>缺点：</p>\n<p>效率较低，内存占用高（因为要拷贝父类的属性）</p>\n<p>组合继承</p>\n<p>核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<p>特点：</p>\n<p>可以继承实例属性/方法，也可以继承原型属性/方法既是子类的实例，也是父类的实例</p>\n<p>不存在引用属性共享问题可传参</p>\n<p>函数可复用</p>\n<p>寄生组合继承</p>\n<p>核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<p>参考 <a href=\"https://www.cnblogs.com/humin/p/4556820.html\"><em>https://www.cnblogs.com/humin/p/4556820.html</em></a></p>\n<ul>\n<li><h3 id=\"JS-的数据类型-1\"><a href=\"#JS-的数据类型-1\" class=\"headerlink\" title=\"JS 的数据类型\"></a>JS 的数据类型</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>字符串，数字，布尔，数组，null，Undefined，symbol，对象。</p>\n<ul>\n<li><h3 id=\"引用类型常见的对象\"><a href=\"#引用类型常见的对象\" class=\"headerlink\" title=\"引用类型常见的对象\"></a>引用类型常见的对象</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Object、Array、RegExp、Date、Function、特殊的基本包装类型(String、Number、Boolean)以及单体内置对象(Global、Math)等</p>\n<ul>\n<li><h3 id=\"es6-的常用\"><a href=\"#es6-的常用\" class=\"headerlink\" title=\"es6 的常用\"></a>es6 的常用</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>promise，await/async，let、const、块级作用域、箭头函数</p>\n<ul>\n<li><h3 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过 class 关键字，可以定义类。</p>\n<ul>\n<li><h3 id=\"口述数组去重\"><a href=\"#口述数组去重\" class=\"headerlink\" title=\"口述数组去重\"></a>口述数组去重</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>法一：indexOf 循环去重</p>\n<p>法二：ES6 Set 去重；Array.from(new Set(array))</p>\n<p>法三：Object 键值对去重；把数组的值存成 Object 的 key 值，比如Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，<br>就说明该值是重复的。</p>\n<ul>\n<li><h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3></li>\n</ul>\n<p>参考回答： 原型链继承</p>\n<p>核心： 将父类的实例作为子类的原型特点：</p>\n<p>非常纯粹的继承关系，实例是子类的实例，也是父类的实例父类新增原型方法/原型属性，子类都能访问到</p>\n<p>简单，易于实现缺点：</p>\n<p>要想为子类新增属性和方法，不能放到构造器中无法实现多继承</p>\n<p>来自原型对象的所有属性被所有实例共享 创建子类实例时，无法向父类构造函数传参</p>\n<p>构造继承</p>\n<p>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p>\n<p>特点：</p>\n<p>解决了子类实例共享父类引用属性的问题创建子类实例时，可以向父类传递参数 可以实现多继承（call 多个父类对象） 缺点：</p>\n<p>实例并不是父类的实例，只是子类的实例</p>\n<p>只能继承父类的实例属性和方法，不能继承原型属性/方法</p>\n<p>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</p>\n<p>实例继承</p>\n<p>核心：为父类实例添加新特性，作为子类实例返回特点：</p>\n<p>不限制调用方式，不管是 new 子类()还是子类(),返回的对象具有相同的效果</p>\n<p>缺点：</p>\n<p>实例是父类的实例，不是子类的实例不支持多继承</p>\n<p>拷贝继承特点：</p>\n<p>支持多继承缺点：</p>\n<p>效率较低，内存占用高（因为要拷贝父类的属性）</p>\n<p>组合继承</p>\n<p>核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<p>特点：</p>\n<p>可以继承实例属性/方法，也可以继承原型属性/方法既是子类的实例，也是父类的实例</p>\n<p>不存在引用属性共享问题可传参</p>\n<p>函数可复用</p>\n<p>寄生组合继承</p>\n<p>核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<p>参考 <a href=\"https://www.cnblogs.com/humin/p/4556820.html\"><em>https://www.cnblogs.com/humin/p/4556820.html</em></a></p>\n<ul>\n<li><h3 id=\"call-和-apply-的区别\"><a href=\"#call-和-apply-的区别\" class=\"headerlink\" title=\"call 和 apply 的区别\"></a>call 和 apply 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即 A 对象应用B 对象的方法。</p>\n<p>call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即 A 对象调用B 对象的方法。</p>\n<ul>\n<li><h3 id=\"es6-的常用特性\"><a href=\"#es6-的常用特性\" class=\"headerlink\" title=\"es6 的常用特性\"></a>es6 的常用特性</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>promise，await/async，let、const、块级作用域、箭头函数</p>\n<ul>\n<li><h3 id=\"箭头函数和-function-有什么区别\"><a href=\"#箭头函数和-function-有什么区别\" class=\"headerlink\" title=\"箭头函数和 function 有什么区别\"></a>箭头函数和 function 有什么区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>箭头函数根本就没有绑定自己的 this，在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用</p>\n<ul>\n<li><h3 id=\"new-操作符原理\"><a href=\"#new-操作符原理\" class=\"headerlink\" title=\"new 操作符原理\"></a>new 操作符原理</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>创建一个类的实例：创建一个空对象 obj，然后把这个空对象的 proto 设置为构造函数的 prototype。</p>\n</li>\n<li><p>初始化实例：构造函数被传入参数并调用，关键字 this 被设定指向该实例 obj。</p>\n</li>\n<li><p>返回实例 obj。</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"bind-apply-call\"><a href=\"#bind-apply-call\" class=\"headerlink\" title=\"bind,apply,call\"></a>bind,apply,call</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即 A 对象应用B 对象的方法。</p>\n<p>call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即 A 对象调用B 对象的方法。</p>\n<p>bind 除了返回是函数以外，它的参数和 call 一样。</p>\n<ul>\n<li><h3 id=\"bind-和-apply-的区别\"><a href=\"#bind-和-apply-的区别\" class=\"headerlink\" title=\"bind 和 apply 的区别\"></a>bind 和 apply 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>返回不同：bind 返回是函数</p>\n<p>参数不同：apply(A, arguments)，bind(A, args1,args2)</p>\n<ul>\n<li><h3 id=\"数组的去重\"><a href=\"#数组的去重\" class=\"headerlink\" title=\"数组的去重\"></a>数组的去重</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>法一：indexOf 循环去重</p>\n<p>法二：ES6 Set 去重；Array.from(new Set(array))</p>\n<p>法三：Object 键值对去重；把数组的值存成 Object 的 key 值，比如Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，<br>就说明该值是重复的。</p>\n<ul>\n<li><h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li>什么是闭包：</li>\n</ol>\n<p>闭包是指有权访问另外一个函数作用域中的变量的函数。</p>\n<p>闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。当在一个函数内定义另外一个函数就会产生闭包。</p>\n<ol start=\"2\">\n<li>为什么要用：</li>\n</ol>\n<p>匿名自执行函数：我们知道所有的变量，如果不加上 var 关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可</p>\n<p>能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用 var<br>关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，可以用闭包。 结果缓存：我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对<br>象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。</p>\n<ul>\n<li><h3 id=\"promise-实现\"><a href=\"#promise-实现\" class=\"headerlink\" title=\"promise 实现\"></a>promise 实现</h3></li>\n</ul>\n<p>参 考 回 答 ： Promise 实现如下</p>\n<h3 id=\"function-Promise-fn-var-state-‘pending’-value-null-callbacks\"><a href=\"#function-Promise-fn-var-state-‘pending’-value-null-callbacks\" class=\"headerlink\" title=\"function Promise(fn) { var state = ‘pending’, value = null, callbacks = []\"></a>function Promise(fn) { var state = ‘pending’, value = null, callbacks = []</h3><blockquote>\n<p>this.then = function (onFulfilled, onRejected) { return new Promise(function (resolve, reject) {<br>handle({</p>\n</blockquote>\n<blockquote>\n<p>onFulfilled: onFulfilled || null, onRejected: onRejected || null, resolve: resolve,</p>\n</blockquote>\n<blockquote>\n<p>reject: reject</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>};</p>\n</blockquote>\n<blockquote>\n<p>function handle(callback) { if (state === ‘pending’) { callbacks.push(callback); return;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>var cb = state === ‘fulfilled’ ? callback.onFulfilled : callback.onRejected,</p>\n</blockquote>\n<blockquote>\n<p>ret;</p>\n</blockquote>\n<blockquote>\n<p>if (cb === null) {</p>\n</blockquote>\n<blockquote>\n<p>cb = state === ‘fulfilled’ ? callback.resolve : callback.reject; cb(value);</p>\n</blockquote>\n<blockquote>\n<p>return;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>ret = cb(value); callback.resolve(ret);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>function resolve(newValue) {</p>\n</blockquote>\n<blockquote>\n<p>if (newValue &amp;&amp; (typeof newValue === ‘object’ || typeof newValue === ‘function’)) {</p>\n</blockquote>\n<blockquote>\n<p>var then = newValue.then;</p>\n</blockquote>\n<blockquote>\n<p>if (typeof then === ‘function’) { then.call(newValue, resolve, reject); return;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>state = ‘fulfilled’; value = newValue; execute();</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>function reject(reason) { state = ‘rejected’;</p>\n</blockquote>\n<blockquote>\n<p>value = reason; execute();</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>function execute() { setTimeout(function () { callbacks.forEach(function (callback) {<br>handle(callback);</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>}, 0);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>fn(resolve, reject);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"assign-的深拷贝\"><a href=\"#assign-的深拷贝\" class=\"headerlink\" title=\"assign 的深拷贝\"></a>assign 的深拷贝</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"function-clone-obj-var-copy-1\"><a href=\"#function-clone-obj-var-copy-1\" class=\"headerlink\" title=\"function clone( obj ) { var copy\"></a>function clone( obj ) { var copy</h3><blockquote>\n<p>switch( typeof obj ) { case “undefined”: break;</p>\n</blockquote>\n<blockquote>\n<p>case “number”: copy = obj - 0; break;</p>\n</blockquote>\n<blockquote>\n<p>case “string”: copy = obj + “”; break;</p>\n</blockquote>\n<blockquote>\n<p>case “boolean”:</p>\n</blockquote>\n<blockquote>\n<p>copy = obj; break;</p>\n</blockquote>\n<p>case “object”: //object 分为两种情况 对象（Object）和数组（Array）</p>\n<ul>\n<li><h3 id=\"说-promise，没有-promise-怎么办\"><a href=\"#说-promise，没有-promise-怎么办\" class=\"headerlink\" title=\"说 promise，没有 promise 怎么办\"></a>说 promise，没有 promise 怎么办</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>没有 promise，可以用回调函数代替</p>\n<ul>\n<li><h3 id=\"事件委托\"><a href=\"#事件委托\" class=\"headerlink\" title=\"事件委托\"></a>事件委托</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>把一个元素响应事件（click、keydown. ）的函数委托到另一个元素；</p>\n<p>优点：减少内存消耗、动态绑定事件。</p>\n<ul>\n<li><h3 id=\"箭头函数和-function-的区别\"><a href=\"#箭头函数和-function-的区别\" class=\"headerlink\" title=\"箭头函数和 function 的区别\"></a>箭头函数和 function 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>箭头函数根本就没有绑定自己的 this，在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用</p>\n<ul>\n<li><h3 id=\"arguments\"><a href=\"#arguments\" class=\"headerlink\" title=\"arguments\"></a>arguments</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>arguments 是类数组对象，有 length 属性，不能调用数组方法可用 Array.from()转换</p>\n<ul>\n<li><h3 id=\"箭头函数获取-arguments\"><a href=\"#箭头函数获取-arguments\" class=\"headerlink\" title=\"箭头函数获取 arguments\"></a>箭头函数获取 arguments</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>可用…rest 参数获取</p>\n<ul>\n<li><h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Promise 对象是 CommonJS 工作组提出的一种规范，目的是为异步编程提供统一接口。每一个异步任务返回一个 Promise 对象，该对象有一个 then 方法，允许指定回调函数。</p>\n<p>f1().then(f2);</p>\n<p>一个 promise 可能有三种状态：等待（pending）、已完成（resolved，又称</p>\n<p>fulfilled）、已拒绝（rejected）。</p>\n<p>promise 必须实现 then 方法（可以说，then 就是 promise 的核心），而且 then 必须返回一个 promise，同一个 promise 的 then<br>可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致。</p>\n<p>then 方法接受两个参数，第一个参数是成功时的回调，在 promise 由“等待”态转换到“完成”态时调用，另一个是失败时的回调，在 promise<br>由“等待”态转换到“拒绝”态时调用。同时，then 可以接受另一个 promise 传入，也接受一个“类then”的对象或方法，即 thenable 对象。</p>\n<ul>\n<li><h3 id=\"事件代理\"><a href=\"#事件代理\" class=\"headerlink\" title=\"事件代理\"></a>事件代理</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>事件代理是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a; 比如给最里面的a 加一个 click<br>点击事件，那么这个事件就会一层一层的往外执行， 执行顺序 a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的 div 加点击事件，那么里面的 ul，li，a<br>做点击事件的时候，都会冒泡到最外层的 div 上，所以都会触发， 这就是事件代理，代理它们父级代为执行事件。</p>\n<ul>\n<li><h3 id=\"Eventloop\"><a href=\"#Eventloop\" class=\"headerlink\" title=\"Eventloop\"></a>Eventloop</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>任务队列中，在每一次事件循环中，macrotask 只会提取一个执行，而 microtask 会一直提取，直到 microsoft 队列为空为止。</p>\n<p>也就是说如果某个 microtask 任务被推入到执行中，那么当主线程任务执行完成后， 会循环调用该队列任务中的下一个任务来执行，直到该任务队列到最后一个任务为 止。而事件循环每次只会入栈一个<br>macrotask,主线程执行完成该任务后又会检查microtasks 队列并完成里面的所有任务后再执行macrotask 的任务。</p>\n<p>macrotasks: setTimeout, setInterval, setImmediate, I/O, UI rendering microtasks: process.nextTick,<br>Promise, MutationObserver</p>\n<h1 id=\"2-前端核心\"><a href=\"#2-前端核心\" class=\"headerlink\" title=\"2 | 前端核心\"></a>2 | 前端核心</h1><ol>\n<li><h2 id=\"服务端编程\"><a href=\"#服务端编程\" class=\"headerlink\" title=\"| 服务端编程\"></a>| 服务端编程</h2></li>\n</ol>\n<ul>\n<li><h3 id=\"JSONP-的缺点\"><a href=\"#JSONP-的缺点\" class=\"headerlink\" title=\"JSONP 的缺点\"></a>JSONP 的缺点</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。</p>\n<ul>\n<li><h3 id=\"跨域（jsonp，ajax）\"><a href=\"#跨域（jsonp，ajax）\" class=\"headerlink\" title=\"跨域（jsonp，ajax）\"></a>跨域（jsonp，ajax）</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>JSONP：ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数</p>\n<p>据，而是返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。</p>\n<ul>\n<li><h3 id=\"如何实现跨域\"><a href=\"#如何实现跨域\" class=\"headerlink\" title=\"如何实现跨域\"></a>如何实现跨域</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>JSONP：通过动态创建 script，再请求一个带参网址实现跨域通信。document.domain</p>\n<ul>\n<li>iframe 跨域：两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域。</li>\n</ul>\n<p>location.hash + iframe 跨域：a 欲与b 跨域相互通信，通过中间页c 来实现。 三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 js<br>访问来通信。</p>\n<p>window.name + iframe 跨域：通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。</p>\n<p>postMessage 跨域：可以跨域操作的 window 属性之一。</p>\n<p>CORS：服务端设置 Access-Control-Allow-Origin 即可，前端无须设置，若要带</p>\n<p>cookie 请求，前后端都需要设置。</p>\n<p>代理跨域：起一个代理服务器，实现数据的转发</p>\n<ul>\n<li><h3 id=\"dom-是什么，你的理解？\"><a href=\"#dom-是什么，你的理解？\" class=\"headerlink\" title=\"dom 是什么，你的理解？\"></a>dom 是什么，你的理解？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>文档对象模型（Document Object Model，简称 DOM），是 W3C<br>组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为 DOM。</p>\n<ul>\n<li><h3 id=\"关于-dom-的-api-有什么\"><a href=\"#关于-dom-的-api-有什么\" class=\"headerlink\" title=\"关于 dom 的 api 有什么\"></a>关于 dom 的 api 有什么</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>节点创建型 api，页面修改型 API，节点查询型 API，节点关系型 api，元素属性型api，元素样式型 api 等</p>\n<ol start=\"2\">\n<li><h2 id=\"Ajax\"><a href=\"#Ajax\" class=\"headerlink\" title=\"| Ajax\"></a>| Ajax</h2></li>\n</ol>\n<ul>\n<li><h3 id=\"ajax-返回的状态\"><a href=\"#ajax-返回的状态\" class=\"headerlink\" title=\"ajax 返回的状态\"></a>ajax 返回的状态</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>0 － （未初始化）还没有调用 send()方法</p>\n<p>1 － （载入）已调用 send()方法，正在发送请求</p>\n<p>2 － （载入完成）send()方法执行完成，已经接收到全部响应内容</p>\n<p>3 － （交互）正在解析响应内容</p>\n<p>4 － （完成）响应内容解析完成，可以在客户端调用了</p>\n<ul>\n<li><h3 id=\"实现一个-Ajax\"><a href=\"#实现一个-Ajax\" class=\"headerlink\" title=\"实现一个 Ajax\"></a>实现一个 Ajax</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>AJAX 创建异步对象 XMLHttpRequest</p>\n<p>操作 XMLHttpRequest 对象</p>\n<ol>\n<li><p>设置请求参数（请求方式，请求页面的相对路径，是否异步）</p>\n</li>\n<li><p>设置回调函数，一个处理服务器响应的函数，使用 onreadystatechange ，类似函数指针</p>\n</li>\n<li><p>获取异步对象的 readyState 属性：该属性存有服务器响应的状态信息。每当readyState 改变时，onreadystatechange 函数就会被执行。</p>\n</li>\n<li><p>判断响应报文的状态，若为 200 说明服务器正常运行并返回响应数据。</p>\n</li>\n<li><p>读取响应数据，可以通过 responseText 属性来取回由服务器返回的数据。</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"如何实现-ajax-请求，假如我有多个请求，我需要让这些-ajax-请求按照某种顺序一次执行，有什么办法呢？如何处理-ajax-跨域\"><a href=\"#如何实现-ajax-请求，假如我有多个请求，我需要让这些-ajax-请求按照某种顺序一次执行，有什么办法呢？如何处理-ajax-跨域\" class=\"headerlink\" title=\"如何实现 ajax 请求，假如我有多个请求，我需要让这些 ajax 请求按照某种顺序一次执行，有什么办法呢？如何处理 ajax 跨域\"></a>如何实现 ajax 请求，假如我有多个请求，我需要让这些 ajax 请求按照某种顺序一次执行，有什么办法呢？如何处理 ajax 跨域</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>通过实例化一个 XMLHttpRequest 对象得到一个实例，调用实例的 open 方法为这次ajax 请求设定相应的 http 方法，相应的地址和是否异步，以异步为例，调用 send<br>方法，这个方法可以设定需要发送的报文主体，然后通过监听 readystatechange 事件， 通过这个实例 的 readyState 属性来判断这个 ajax 请求状态，其中分为 0，1，2，3，<br>4 这四种状态（0 未初始化，1 载入/正在发送请求 2 载入完成/数据接收，3 交互/解析数据，4 接收数据完成），当状态为 4 的时候也就是接受数据完成的时候，这时候可以通过实例的 status<br>属性判断这个请求是否成功</p>\n<h3 id=\"var-xhr-new-XMLHttpRequest-xhr-open-‘get’-‘aabb-php’-true-xhr-send-null-xhr-onreadystatechange-function-if-xhr-readyState-4-if-xhr-status-200-console-log-xhr-responseText\"><a href=\"#var-xhr-new-XMLHttpRequest-xhr-open-‘get’-‘aabb-php’-true-xhr-send-null-xhr-onreadystatechange-function-if-xhr-readyState-4-if-xhr-status-200-console-log-xhr-responseText\" class=\"headerlink\" title=\"var xhr = new XMLHttpRequest(); xhr.open(‘get’, ‘aabb.php’, true); xhr.send(null); xhr.onreadystatechange = function() { if(xhr.readyState==4) { if(xhr.status==200) { console.log(xhr.responseText)\"></a>var xhr = new XMLHttpRequest(); xhr.open(‘get’, ‘aabb.php’, true); xhr.send(null); xhr.onreadystatechange = function() { if(xhr.readyState==4) { if(xhr.status==200) { console.log(xhr.responseText)</h3><blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<p>使 ajax 请求按照队列顺序执行，通过调用递归函数：</p>\n<p>//按顺序执行多个 ajax 命令，因为数量不定，所以采用递归</p>\n<h3 id=\"function-send-action-arg2\"><a href=\"#function-send-action-arg2\" class=\"headerlink\" title=\"function send(action, arg2) {\"></a>function send(action, arg2) {</h3><blockquote>\n<p>//将多个命令按顺序封装成数组对象，递归执行</p>\n</blockquote>\n<blockquote>\n<p>//利用了 deferred 对象控制回调函数的特点</p>\n</blockquote>\n<blockquote>\n<p>$.when(send_action(action[0], arg2))</p>\n</blockquote>\n<blockquote>\n<p>.done(function () {</p>\n</blockquote>\n<blockquote>\n<p>//前一个 ajax 回调函数完毕之后判断队列长度</p>\n</blockquote>\n<blockquote>\n<p>if (action.length &gt; 1) {</p>\n</blockquote>\n<blockquote>\n<p>//队列长度大于 1，则弹出第一个，继续递归执行该队列</p>\n</blockquote>\n<blockquote>\n<p>action.shift();</p>\n</blockquote>\n<blockquote>\n<p>send(action, arg2);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}).fail(function (){</p>\n</blockquote>\n<blockquote>\n<p>//队列中元素请求失败后的逻辑</p>\n</blockquote>\n<blockquote>\n<p>//</p>\n</blockquote>\n<blockquote>\n<p>//重试发送</p>\n</blockquote>\n<blockquote>\n<p>//send(action, arg2);</p>\n</blockquote>\n<blockquote>\n<p>//</p>\n</blockquote>\n<blockquote>\n<p>//忽略错误进行下个</p>\n</blockquote>\n<blockquote>\n<p>//if (action.length &gt; 1) {</p>\n</blockquote>\n<blockquote>\n<p>//队列长度大于 1，则弹出第一个，继续递归执行该队列</p>\n</blockquote>\n<blockquote>\n<p>// action.shift();</p>\n</blockquote>\n<blockquote>\n<p>// send(action, arg2);</p>\n</blockquote>\n<blockquote>\n<p>//}</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>//处理每个命令的 ajax 请求以及回调函数function send_action(command, arg2) {</p>\n</blockquote>\n<blockquote>\n<p>var dtd = $.Deferred();//定义 deferred 对象</p>\n</blockquote>\n<blockquote>\n<p>$.post( “url”,</p>\n</blockquote>\n<blockquote>\n<p>{</p>\n</blockquote>\n<blockquote>\n<p>command: command, arg2: arg2</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>).done(function (json) { json = $.parseJSON(json);</p>\n</blockquote>\n<blockquote>\n<p>//每次请求回调函数的处理逻辑</p>\n</blockquote>\n<blockquote>\n<p>//</p>\n</blockquote>\n<blockquote>\n<p>//</p>\n</blockquote>\n<blockquote>\n<p>//</p>\n</blockquote>\n<blockquote>\n<p>//逻辑结束</p>\n</blockquote>\n<blockquote>\n<p>dtd.resolve();</p>\n</blockquote>\n<blockquote>\n<p>}).fail(function (){</p>\n</blockquote>\n<blockquote>\n<p>//ajax 请求失败的逻辑dtd.reject();</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>return dtd.promise();//返回 Deferred 对象的 promise，防止在外部</p>\n</blockquote>\n<ul>\n<li><h3 id=\"写出原生-Ajax\"><a href=\"#写出原生-Ajax\" class=\"headerlink\" title=\"写出原生 Ajax\"></a>写出原生 Ajax</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Ajax 能够在不重新加载整个页面的情况下与服务器交换数据并更新部分网页内容，实现局部刷新，大大降低了资源的浪费，是一门用于快速创建动态网页的技术，ajax 的使用分为四部分：</p>\n<p>1、创建 XMLHttpRequest 对象 var xhr = new XMLHttpRequest();</p>\n<p>2、向服务器发送请求，使用 xmlHttpRequest 对象的 open 和 send 方法， 3、监听状态变化，执行相应回调函数</p>\n<h3 id=\"var-xhr-new-XMLHttpRequest-xhr-open-‘get’-‘aabb-php’-true-xhr-send-null-xhr-onreadystatechange-function-if-xhr-readyState-4-if-xhr-status-200-console-log-xhr-responseText-1\"><a href=\"#var-xhr-new-XMLHttpRequest-xhr-open-‘get’-‘aabb-php’-true-xhr-send-null-xhr-onreadystatechange-function-if-xhr-readyState-4-if-xhr-status-200-console-log-xhr-responseText-1\" class=\"headerlink\" title=\"var xhr = new XMLHttpRequest(); xhr.open(‘get’, ‘aabb.php’, true); xhr.send(null); xhr.onreadystatechange = function() { if(xhr.readyState==4) { if(xhr.status==200) { console.log(xhr.responseText)\"></a>var xhr = new XMLHttpRequest(); xhr.open(‘get’, ‘aabb.php’, true); xhr.send(null); xhr.onreadystatechange = function() { if(xhr.readyState==4) { if(xhr.status==200) { console.log(xhr.responseText)</h3><blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li><h3 id=\"如何实现一个-ajax-请求？如果我想发出两个有顺序的-ajax-需要怎么做？\"><a href=\"#如何实现一个-ajax-请求？如果我想发出两个有顺序的-ajax-需要怎么做？\" class=\"headerlink\" title=\"如何实现一个 ajax 请求？如果我想发出两个有顺序的 ajax 需要怎么做？\"></a>如何实现一个 ajax 请求？如果我想发出两个有顺序的 ajax 需要怎么做？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>AJAX 创建异步对象 XMLHttpRequest</p>\n<p>操作 XMLHttpRequest 对象</p>\n<ol>\n<li><p>设置请求参数（请求方式，请求页面的相对路径，是否异步）</p>\n</li>\n<li><p>设置回调函数，一个处理服务器响应的函数，使用 onreadystatechange ，类似函数指针</p>\n</li>\n<li><p>获取异步对象的 readyState 属性：该属性存有服务器响应的状态信息。每当readyState 改变时，onreadystatechange 函数就会被执行。</p>\n</li>\n<li><p>判断响应报文的状态，若为 200 说明服务器正常运行并返回响应数据。</p>\n</li>\n<li><p>读取响应数据，可以通过 responseText 属性来取回由服务器返回的数据。</p>\n</li>\n</ol>\n<p>发出两个有顺序的 ajax，可以用回调函数，也可以使用 Promise.then 或者 async 等。</p>\n<ul>\n<li><h3 id=\"Fetch-和-Ajax-比有什么优缺点？\"><a href=\"#Fetch-和-Ajax-比有什么优缺点？\" class=\"headerlink\" title=\"Fetch 和 Ajax 比有什么优缺点？\"></a>Fetch 和 Ajax 比有什么优缺点？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>promise 方便异步，在不想用 jQuery 的情况下，相比原生的 ajax，也比较好写。</p>\n<ul>\n<li><h3 id=\"原生-JS-的-ajax\"><a href=\"#原生-JS-的-ajax\" class=\"headerlink\" title=\"原生 JS 的 ajax\"></a>原生 JS 的 ajax</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>AJAX 创建异步对象 XMLHttpRequest</p>\n<p>操作 XMLHttpRequest 对象</p>\n<ol>\n<li><p>设置请求参数（请求方式，请求页面的相对路径，是否异步）</p>\n</li>\n<li><p>设置回调函数，一个处理服务器响应的函数，使用 onreadystatechange ，类似函数指针</p>\n</li>\n<li><p>获取异步对象的 readyState 属性：该属性存有服务器响应的状态信息。每当readyState 改变时，onreadystatechange 函数就会被执行。</p>\n</li>\n<li><p>判断响应报文的状态，若为 200 说明服务器正常运行并返回响应数据。</p>\n</li>\n<li><p>读取响应数据，可以通过 responseText 属性来取回由服务器返回的数据。</p>\n</li>\n<li><h2 id=\"移动-web-开发\"><a href=\"#移动-web-开发\" class=\"headerlink\" title=\"| 移动 web 开发\"></a>| 移动 web 开发</h2></li>\n</ol>\n<ul>\n<li><h3 id=\"知道-PWA-吗\"><a href=\"#知道-PWA-吗\" class=\"headerlink\" title=\"知道 PWA 吗\"></a>知道 PWA 吗</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>PWA 全称 Progressive Web App，即渐进式 WEB 应用。一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和<br>Service Worker 来实现 PWA 的安装和离线等功能</p>\n<ul>\n<li><h3 id=\"移动布局方案\"><a href=\"#移动布局方案\" class=\"headerlink\" title=\"移动布局方案\"></a>移动布局方案</h3></li>\n</ul>\n<p>参 考 回 答 ：<br><a href=\"https://links.jianshu.com/go?to=https://juejin.im/post/599970f4518825243a78b9d5%23heading-22\"><em>https://juejin.im/post/599970f4518825243a78b9d5#heading-22</em></a></p>\n<blockquote>\n<p><img src=\"media/image9.jpeg\"></p>\n</blockquote>\n<ul>\n<li><h3 id=\"Rem-Em\"><a href=\"#Rem-Em\" class=\"headerlink\" title=\"Rem, Em\"></a>Rem, Em</h3></li>\n</ul>\n<p>参 考 回 答 ：<br><a href=\"https://links.jianshu.com/go?to=https://blog.csdn.net/romantic_love/article/details/80875462\"><em>https://blog.csdn.net/romantic_love/article/details/80875462</em></a><br>一、rem 单位如何转换为像素值</p>\n<ol>\n<li>当使用 rem 单位的时候，页面转换为像素大小取决于叶根元素的字体大小，即 HTML 元素的字体大小。根元素字体大小乘 rem 的值。例如，根元素的字体大小为 16px，那么 10rem<br>就等同于 10*16=160px。</li>\n</ol>\n<p>二、em 是如何转换成 px 的</p>\n<p>当使用 em 单位的时候，像素值是将 em 值乘以使用 em 单位的元素的字体大小。例如一个 div 的字体为 18px，设置它的宽高为 10em，那么此时宽高就是 18px*10em=180px。</p>\n<h3 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\".test{\"></a>.test{</h3><blockquote>\n<p>width: 10em;</p>\n</blockquote>\n<blockquote>\n<p>height: 10em;</p>\n</blockquote>\n<blockquote>\n<p>background-color: #ff7d42;</p>\n</blockquote>\n<blockquote>\n<p>font-size: 18px;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<p>一定要记住的是，em 是根据使用它的元素的 font-size 的大小来变化的，而不是根据父元素字体大小。有些元素大小是父元素的多少倍那是因为继承了父元素中 font-size<br>的设定，所以才起到的作用。</p>\n<ol start=\"2\">\n<li>em 单位的继承效果。</li>\n</ol>\n<p>使用 em 单位存在继承的时候，每个元素将自动继承其父元素的字体大小，继承的效果只能被明确的字体单位覆盖，比如 px 和 vw。只要父级元素上面一直有 fontsize 为 em<br>单位，则会一直继承，但假如自己设置了 font-size 的单位为 px 的时候，则会直接使用自己的 px 单位的值。</p>\n<p>三、根 html 的元素将会继承浏览器中设置的字体大小</p>\n<p>除非显式的设置固定值去覆盖。所以 html 元素的字体大小虽然是直接确定 rem 的值， 但这个字体大小首先是来源于浏览器的设置。（所以一定要设置 html<br>的值的大小，因为有可能用户的浏览器字体大小是不一致的。）</p>\n<p>四、当 em 单位设置在 html 元素上时</p>\n<p>它将转换为 em 值乘以浏览器字体大小的设置。例如：</p>\n<h3 id=\"html\"><a href=\"#html\" class=\"headerlink\" title=\"html{\"></a>html{</h3><blockquote>\n<p>font-size: 1.5em;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<p>可以看到，因为浏览器默认字体大小为 16px，所以当设置 HTML 的 fontsize 的值为</p>\n<ol start=\"5\">\n<li>em 的售后，其对应的 px 的值为 16*1.5=24px</li>\n</ol>\n<p>所以此时，再设置其他元素的 rem 的值的时候，其对应的像素值为 n*24px。</p>\n<p>例如，test 的 rem 的值为 10，</p>\n<h3 id=\"test-1\"><a href=\"#test-1\" class=\"headerlink\" title=\".test{\"></a>.test{</h3><blockquote>\n<p>width: 10rem;</p>\n</blockquote>\n<blockquote>\n<p>height: 10rem;</p>\n</blockquote>\n<blockquote>\n<p>background-color: #ff7d42;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<p><img src=\"media/image10.jpeg\"></p>\n<p>可以看到 test 的 font-size 继承了 html 的值 24px，而此时宽高为 24*10=240px</p>\n<p>总结</p>\n<ol>\n<li><p>rem 单位翻译为像素值的时候是由 html 元素的字体大小决定的。此字体大小会被浏览器中字体大小的设置影响，除非显式的在 html 为 font-size 重写一个单位。</p>\n</li>\n<li><p>em 单位转换为像素值的时候，取决于使用它们的元素的 font-size 的大小，但是有因为有继承关系，所以比较复杂。</p>\n</li>\n</ol>\n<p>优缺点</p>\n<p>em 可以让我们的页面更灵活，更健壮，比起到处写死的 px 值，em 似乎更有张力，改动父元素的字体大小，子元素会等比例变化，这一变化似乎预示了无限可能,</p>\n<p>em 做弹性布局的缺点还在于牵一发而动全身，一旦某个节点的字体大小发生变化，那么其后代元素都得重新计算</p>\n<ul>\n<li><h3 id=\"flex-布局及优缺点\"><a href=\"#flex-布局及优缺点\" class=\"headerlink\" title=\"flex 布局及优缺点\"></a>flex 布局及优缺点</h3></li>\n</ul>\n<p>参 考 回 答 ：<br><a href=\"https://links.jianshu.com/go?to=https://juejin.im/post/599970f4518825243a78b9d5%23heading-22\"><em>https://juejin.im/post/599970f4518825243a78b9d5#heading-22</em></a></p>\n<p>css3 引入的，flex 布局；优点在于其容易上手，根据 flex 规则很容易达到某个布局效果，然而缺点是：浏览器兼容性比较差，只能兼容到 ie9 及以上；</p>\n<p><img src=\"media/image11.jpeg\"></p>\n<p><img src=\"media/image12.jpeg\"></p>\n<ul>\n<li><h3 id=\"Rem-布局及其优缺点\"><a href=\"#Rem-布局及其优缺点\" class=\"headerlink\" title=\"Rem 布局及其优缺点\"></a>Rem 布局及其优缺点</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>首先 Rem 相对于根(html)的 font-size 大小来计算。简单的说它就是一个相对单例如:font-size:10px;,那么（1rem = 10px）了解计算原理后</p>\n<p>首先解决怎么在不同设备上设置 html 的 font-size 大小。其实 rem 布局的本质是等比缩放，一般是基于宽度。</p>\n<p>优点</p>\n<p>可以快速适用移动端布局 字体图片 高度缺点</p>\n<p>①目前 ie 不支持，对 pc 页面来讲使用次数不多；</p>\n<p>②数据量大：所有的图片，盒子都需要我们去给一个准确的值；才能保证不同机型的适配；</p>\n<p>③在响应式布局中，必须通过 js 来动态控制根元素 font-size 的大小。</p>\n<p>也就是说 css 样式和 js 代码有一定的耦合性。且必须将改变 font-size 的代码放在</p>\n<p>css 样式之前。</p>\n<ul>\n<li><h3 id=\"百分比布局\"><a href=\"#百分比布局\" class=\"headerlink\" title=\"百分比布局\"></a>百分比布局</h3></li>\n</ul>\n<p>参考回答： 1、具体分析</p>\n<p>除了用 px 结合媒体查询实现响应式布局外，我们也可以通过百分比单位 “ % “<br>来实现响应式的效果。比如当浏览器的宽度或者高度发生变化时，通过百分比单位，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。为了了解百分比布局，首先要了解的问题是：css<br>中的子元素中的百分比</p>\n<p>（%）到底是谁的百分比？</p>\n<p>直观的理解，我们可能会认为子元素的百分比完全相对于直接父元素，height 百分比相对于 height，width 百分比相对于 width。当然这种理解是正确的，但是根据 css 的盒式模型，除了<br>height、width 属性外，还具有 padding、border、margin 等等属</p>\n<p>性。那么这些属性设置成百分比，是根据父元素的那些属性呢？此外还有 border- radius 和 translate 等属性中的百分比，又是相对于什么呢？下面来具体分析。</p>\n<p>padding、border、margin 等等属不论是垂直方向还是水平方向，都相对于直接父元素的 width。</p>\n<p>除了 border-radius 外，还有比如 translate、background-size 等都是相对于自身的。</p>\n<p>2、百分比单位布局应用</p>\n<p>比如我们要实现一个固定长宽比的长方形，比如要实现一个长宽比为 4:3 的长方形,我们可以根据 padding 属性来实现，因为 padding<br>不管是垂直方向还是水平方向，百分比单位都相对于父元素的宽度，因此我们可以设置 padding-top 为百分比来实现，长宽自适应的长方形：</p>\n<h3 id=\"trangle\"><a href=\"#trangle\" class=\"headerlink\" title=\".trangle{\"></a>.trangle{</h3><blockquote>\n<p>height:0;</p>\n</blockquote>\n<blockquote>\n<p>width:100%;</p>\n</blockquote>\n<blockquote>\n<p>padding-top:75%;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<p>3、百分比单位缺点</p>\n<p>从上述对于百分比单位的介绍我们很容易看出如果全部使用百分比单位来实现响应式的布局，有明显的以下两个缺点：</p>\n<ol>\n<li><p>计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。</p>\n</li>\n<li><p>从小节 1 可以看出，各个属性中如果使用百分比，相对父元素的属性并不是唯一的。比如 width 和 height 相对于父元素的 width 和 height，而 margin、padding<br>不管垂直还是水平方向都相对比父元素的宽度、border-radius 则是相对于元素自身等等， 造成我们使用百分比单位容易使布局问题变得复杂。</p>\n</li>\n</ol>\n<p><img src=\"media/image13.jpeg\"> <img src=\"media/image14.jpeg\"></p>\n<ul>\n<li><h3 id=\"移动端适配-1px-的问题\"><a href=\"#移动端适配-1px-的问题\" class=\"headerlink\" title=\"移动端适配 1px 的问题\"></a>移动端适配 1px 的问题</h3></li>\n</ul>\n<p>参 考 回 答 ：<br><a href=\"https://links.jianshu.com/go?to=https://blog.csdn.net/weixin_43675871/article/details/84023447\"><em>https://blog.csdn.net/weixin_43675871/article/details/84023447</em></a><br>首先，我们了解 devicePixelRatio（DPR）这个东西</p>\n<h3 id=\"在-window-对象中有一个-devicePixelRatio-属性，他可以反应-css-中的像素与设备的像素比。然而-1px-在不同的移动设备上都等于这个移动设备的-1px，这是因为不同的移动设备有不同的像素密度。有关这个属性，它的官方的定义-为：设备物理像素和设备独立像素的比例，也就是-devicePixelRatio-物理像素-独立像素-1px-变粗的原因：viewport-的设置和屏幕物理分辨率是按比例而不是相同的-移动端-window-对象有个-devicePixelRatio-属性-它表示设备\"><a href=\"#在-window-对象中有一个-devicePixelRatio-属性，他可以反应-css-中的像素与设备的像素比。然而-1px-在不同的移动设备上都等于这个移动设备的-1px，这是因为不同的移动设备有不同的像素密度。有关这个属性，它的官方的定义-为：设备物理像素和设备独立像素的比例，也就是-devicePixelRatio-物理像素-独立像素-1px-变粗的原因：viewport-的设置和屏幕物理分辨率是按比例而不是相同的-移动端-window-对象有个-devicePixelRatio-属性-它表示设备\" class=\"headerlink\" title=\"在 window 对象中有一个 devicePixelRatio 属性，他可以反应 css 中的像素与设备的像素比。然而 1px 在不同的移动设备上都等于这个移动设备的 1px，这是因为不同的移动设备有不同的像素密度。有关这个属性，它的官方的定义 为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素 1px 变粗的原因：viewport 的设置和屏幕物理分辨率是按比例而不是相同的. 移动端 window 对象有个 devicePixelRatio 属性,它表示设备\"></a>在 window 对象中有一个 devicePixelRatio 属性，他可以反应 css 中的像素与设备的像素比。然而 1px 在不同的移动设备上都等于这个移动设备的 1px，这是因为不同的移动设备有不同的像素密度。有关这个属性，它的官方的定义 为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素 1px 变粗的原因：viewport 的设置和屏幕物理分辨率是按比例而不是相同的. 移动端 window 对象有个 devicePixelRatio 属性,它表示设备</h3><blockquote>\n<p>物理像素和 css 像素的比例, 在 retina 屏的iphone 手机上, 这个值为 2 或</p>\n</blockquote>\n<blockquote>\n<p>3,css 里写的 1px 长度映射到物理像素上就有 2px 或 3px 那么长</p>\n</blockquote>\n<ol>\n<li>用小数来写 px 值 （不推荐）</li>\n</ol>\n<p>IOS8 下已经支持带小数的 px 值, media query 对应 devicePixelRatio 有个查询值 - webkit-min-device-pixel-ratio, css<br>可以写成这样</p>\n<p>通过-webkit-min-device-pixel-ratio 设置。</p>\n<h3 id=\"border-border-1px-solid-999\"><a href=\"#border-border-1px-solid-999\" class=\"headerlink\" title=\".border { border: 1px solid #999 }\"></a>.border { border: 1px solid #999 }</h3><blockquote>\n<p>@media screen and (-webkit-min-device-pixel-ratio: 2) {</p>\n</blockquote>\n<blockquote>\n<p>.border { border: 0.5px solid #999 }</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>@media screen and (-webkit-min-device-pixel-ratio: 3) {</p>\n</blockquote>\n<blockquote>\n<p>.border { border: 0.333333px solid #999 }</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<p>如果使用 less/sass 的话只是加了 1 句 mixin</p>\n<p>缺点: 安卓与低版本 IOS 不适用, 这个或许是未来的标准写法, 现在不做指望 2、flexible.js</p>\n<p>这是淘宝移动端采取的方案, github<br>的地址:<a href=\"https://links.jianshu.com/go?to=https://github.com/amfe/lib-flexible\"><em>https://github.com/amfe/lib-</em></a><br><a href=\"https://links.jianshu.com/go?to=https://github.com/amfe/lib-flexible\"><em>flexible</em></a>. 前面已经说过<br>1px 变粗的原因就在于一刀切的设置 viewport 宽度, 如果能把 viewport 宽度设置为实际的设备物理宽度, css 里的 1px 不就等于实际 1px 长了么. flexible.js<br>就是这样干的.</p>\n<meta name=”viewport”>里面的 scale 值指的是对 ideal viewport 的缩放, flexible.js 检测到 IOS 机型, 会算出 scale =\n1/devicePixelRatio, 然后设置viewport\n\n<p>3、伪类+transform 实现</p>\n<p>对于解决 1px 边框问题，我个人觉得最完美的解决办法还是伪类+transform 比较好。原理：是把原先元素的 border 去掉，然后利用 :before 或者 :after 重做</p>\n<p>border ，并 transform 的 scale 缩小一半，原先的元素相对定位，新做的 border</p>\n<p>绝对定位。media query</p>\n<p>通过媒体查询，可以通过给不同分辨率的设备编写不同的样式来实现响应式的布局， 比如我们为不同分辨率的屏幕，设置不同的背景图片。比如给小屏幕手机设置@2x 图， 为大屏幕手机设置@3x<br>图，通过媒体查询就能很方便的实现。</p>\n<p>但是媒体查询的缺点也很明显，如果在浏览器大小改变时，需要改变的样式太多，那么多套样式代码会很繁琐。</p>\n<h3 id=\"media-screen-and-min-width-320px\"><a href=\"#media-screen-and-min-width-320px\" class=\"headerlink\" title=\"@media screen and (min-width: 320px) {\"></a>@media screen and (min-width: 320px) {</h3><blockquote>\n<p>html {</p>\n</blockquote>\n<blockquote>\n<p>font-size: 50px;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<p>@media</p>\n<p>方便应用广泛 适用于 pc 端 手机页面，通常做自适应布局时 我们比较常用。缺点：相对于代码要重复很多，得知道设备的宽度，手机的分辨率很多所以麻烦了点，不过性能方面肯定最高； 可能存在闪屏的问题</p>\n<p>@media 处理手机和 pc 端界面兼容的问题，在 IE 上的访问出现问题，百度方法，找找两 种 ， 一 种 是 respond.js， 另 一 种 是<br><a href=\"https://links.jianshu.com/go?to=css3-mediaquerieshttp://blog.csdn.net/small_tu/article/details/47317453\"><em>css3-</em></a><br><a href=\"https://links.jianshu.com/go?to=css3-mediaquerieshttp://blog.csdn.net/small_tu/article/details/47317453\"><em>mediaquerieshttp://blog.csdn.net/small_tu/article/details/47317453</em></a></p>\n<ul>\n<li><h3 id=\"移动端性能优化相关经验\"><a href=\"#移动端性能优化相关经验\" class=\"headerlink\" title=\"移动端性能优化相关经验\"></a>移动端性能优化相关经验</h3></li>\n</ul>\n<p>参 考 回 答 ：<br><a href=\"https://links.jianshu.com/go?to=https://blog.csdn.net/tangxiujiang/article/details/79791545\"><em>https://blog.csdn.net/tangxiujiang/article/details/79791545</em></a></p>\n<ul>\n<li><h3 id=\"toB-和-toC-项目的区别\"><a href=\"#toB-和-toC-项目的区别\" class=\"headerlink\" title=\"toB 和 toC 项目的区别\"></a>toB 和 toC 项目的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>to B（business）即面向企业，to C（ customer）即面向普通用户</p>\n<p>简单的事情重复去做，重复的事情用心去做，长期坚持，自然功成，无论是 B 端还是C</p>\n<p>端都同样适用。Tob 与 Toc 的区别</p>\n<p>作者 猪八戒网 • 10-11 10:18:49 阅读 419 oB 产品价值何来？</p>\n<p>最近团队在 toB 产品研究的过程中，得出结论，相对于 toC 产品与服务，toC 产品更注重产品用户的共性而淡化角色关系，而 toB 产品则更强调面向用户、客户的角色关</p>\n<p>系，而淡化共性提取。实际上，这是由服务对象所引起的，C 端产品的服务对象，由终端所限，是一个面向个体的服务。而B 端服务使用最终是面向一个系统体系组织，在干系人间配合使用中发挥产品价值。</p>\n<p>一个好的产品 toB 可以让组织的系统变得更好，最终反哺于系统中的各个单位。需求动力之不同 toC<br>的产品方法论，用户体验是几乎最为重要的需求来源，腾讯此前，也以”以用户体验为归依”来驱动企业产品打造。</p>\n<p>但B 端产品则不同，B 端在一个商业的背景之下，B 端的决策思路是，”以企业获益为归依”，系统是否有利于企业的生产力，竞争力等，单纯的用户体验，仅能让员工得到片刻的享受，<br>但无法说服企业，企业并不会为一个不能”赚钱”的东西买单。</p>\n<p>需求动力的不同，引发的这是购买使用决策体系的变化。</p>\n<p>toB 产品应更考虑 获益与系统性价值，部分情况还有可能会牺牲掉局部个体的利益， 对于使用者而言应该是自律或他律的，toC<br>产品则更考虑的是个体用户的偏好，并长时间内，基于技术效率的提升，产品的服务中心更多地围绕着更高效地帮助用户的”欲望”释放进行设计，对于使用者而言是一个释放自我的存在。</p>\n<ul>\n<li><h3 id=\"移动端兼容性\"><a href=\"#移动端兼容性\" class=\"headerlink\" title=\"移动端兼容性\"></a>移动端兼容性</h3></li>\n</ul>\n<p>参 考 回 答 ：<br><a href=\"https://links.jianshu.com/go?to=https://zhuanlan.zhihu.com/p/28206065\"><em>https://zhuanlan.zhihu.com/p/28206065</em></a><br>1.IOS 移动端 click 事件 300ms 的延迟相应</p>\n<ol start=\"3\">\n<li>h5 底部输入框被键盘遮挡问题</li>\n</ol>\n<p>10.CSS 动画页面闪白,动画卡顿</p>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><ol>\n<li>尽可能地使用合成属性 transform 和 opacity 来设计 CSS3 动画，不使用</li>\n</ol>\n<blockquote>\n<p>position 的 left 和 top 来定位</p>\n</blockquote>\n<ol start=\"2\">\n<li><p>开启硬件加速</p>\n</li>\n<li><p>上下拉动滚动条时卡顿、慢</p>\n</li>\n</ol>\n<h3 id=\"body-webkit-overflow-scrolling-touch-overflow-scrolling-touch\"><a href=\"#body-webkit-overflow-scrolling-touch-overflow-scrolling-touch\" class=\"headerlink\" title=\"body {-webkit-overflow-scrolling: touch;overflow-scrolling: touch;}\"></a>body {-webkit-overflow-scrolling: touch;overflow-scrolling: touch;}</h3><blockquote>\n<p>Android3+和 iOS5+支持 CSS3 的新属性为 overflow-scrolling</p>\n</blockquote>\n<ul>\n<li>小程序</li>\n</ul>\n<p>参考回答： 移动端手势</p>\n<blockquote>\n<p><img src=\"media/image15.jpeg\"></p>\n</blockquote>\n<p><img src=\"media/image16.jpeg\"></p>\n<ul>\n<li><h3 id=\"2X-图-3X-图适配\"><a href=\"#2X-图-3X-图适配\" class=\"headerlink\" title=\"2X 图 3X 图适配\"></a>2X 图 3X 图适配</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>实际程序开发当中，我们代码中用的值是指逻辑分辨率 pt，而不是像素分辨率 px，比如我们定义一个按钮的高度为 45，这个 45 指的是 45pt 而不是 45px。在非 Retina 屏下 1pt =<br>1px，4 和 4.7 寸 Retina 屏下 1pt = 2px，5.5 和x 下 1pt = 3px.我们制作不同尺寸的图片，比如@1x 为 22px，则@2x 为 44px，@3x 为<br>66px，命名分别为image.png，在项目的 Assets.xcassets 中新建 New Image Set，修改名字为 image， 并把相应尺寸的图片拖放至相应位置。</p>\n<p>/* 根据 dpr 显示 2x 图/3x 图 */</p>\n<h3 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a></h3><blockquote>\n<p>.bg-image(@url){</p>\n</blockquote>\n<blockquote>\n<p>background-image:~“url(‘@{url}@2x.png’)”;</p>\n</blockquote>\n<blockquote>\n<p>@media (-webkit-min-device-pixel-ratio: 3),(min-device-pixel- ratio: 3){</p>\n</blockquote>\n<blockquote>\n<p>background-image:~“url(‘@{url}@3x.png’)”;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>.bg-color(@color) {</p>\n</blockquote>\n<blockquote>\n<p>background-color: @color;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<ul>\n<li>图片在安卓上，有些设备模糊问题</li>\n</ul>\n<p><img src=\"media/image17.jpeg\"> 参考回答：</p>\n<ul>\n<li><h3 id=\"固定定位布局键盘挡住输入框内容\"><a href=\"#固定定位布局键盘挡住输入框内容\" class=\"headerlink\" title=\"固定定位布局键盘挡住输入框内容\"></a>固定定位布局键盘挡住输入框内容</h3></li>\n</ul>\n<p>参考回答：</p>\n<p><img src=\"media/image18.jpeg\"> <img src=\"media/image19.jpeg\"></p>\n<ul>\n<li><h3 id=\"click-的-300ms-延迟问题和点击穿透问题\"><a href=\"#click-的-300ms-延迟问题和点击穿透问题\" class=\"headerlink\" title=\"click 的 300ms 延迟问题和点击穿透问题\"></a>click 的 300ms 延迟问题和点击穿透问题</h3></li>\n</ul>\n<p><img src=\"media/image20.jpeg\"> 参 考 回 答 ：<br><a href=\"https://www.jianshu.com/p/6e2b68a93c88\"><em>https://www.jianshu.com/p/6e2b68a93c88</em></a></p>\n<p>方案二：FastClick</p>\n<p><img src=\"media/image21.jpeg\"><br><a href=\"https://links.jianshu.com/go?to=https://github.com/ftlabs/fastclick\"><em>FastClick</em></a> 是<br><a href=\"https://links.jianshu.com/go?to=http://labs.ft.com/\"><em>FT Labs</em></a> 专门为解决移动端浏览器 300<br>毫秒点击延迟问题所开发的一个轻量级的库。FastClick 的实现原理是在检测到 touchend 事件的时候，会通过 DOM 自定义事件立即出发模拟一个 click 事件，并把浏览器在 300ms<br>之后的 click 事件阻止掉。</p>\n<ul>\n<li><h3 id=\"phone-及-ipad-下输入框默认内阴影\"><a href=\"#phone-及-ipad-下输入框默认内阴影\" class=\"headerlink\" title=\"phone 及 ipad 下输入框默认内阴影\"></a>phone 及 ipad 下输入框默认内阴影</h3></li>\n</ul>\n<p><img src=\"media/image22.jpeg\"> 参考回答：</p>\n<ul>\n<li><h3 id=\"防止手机中页面放大和缩小\"><a href=\"#防止手机中页面放大和缩小\" class=\"headerlink\" title=\"防止手机中页面放大和缩小\"></a>防止手机中页面放大和缩小</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a><meta name=\"viewport\" content=\"user-scalable=no\"></h3><blockquote>\n<meta name=\"viewport\" content=\"initial-scale=1,maximum-scale=1\">\n</blockquote>\n<ul>\n<li>px、em、rem、%、vw、vh、vm 这些单位的区别</li>\n</ul>\n<p>参 考 回 答 ： <a href=\"https://www.jianshu.com/p/ba26509bc5b3\"><em>https://www.jianshu.com/p/ba26509bc5b3</em></a></p>\n<ul>\n<li><h3 id=\"移动端适配-dpr-浅析\"><a href=\"#移动端适配-dpr-浅析\" class=\"headerlink\" title=\"移动端适配- dpr 浅析\"></a>移动端适配- dpr 浅析</h3></li>\n</ul>\n<p>参 考 回 答 ： <a href=\"https://www.jianshu.com/p/cf600c2930cb\"><em>https://www.jianshu.com/p/cf600c2930cb</em></a> dpr =<br>物理像素 / css 像素</p>\n<p>在 dpr = 2； 1px 的 css 像素在设备中是 2px 的物理像素，这会导致在设备上看上去</p>\n<p>1px 的边框是 2px</p>\n<p>解决方法：</p>\n<h3 id=\"用-transfrom：-scale（）缩小-dpr-倍数在-meta-标签中设定-scale-缩小两倍\"><a href=\"#用-transfrom：-scale（）缩小-dpr-倍数在-meta-标签中设定-scale-缩小两倍\" class=\"headerlink\" title=\"用 transfrom： scale（）缩小 dpr 倍数在 meta 标签中设定 scale 缩小两倍\"></a>用 transfrom： scale（）缩小 dpr 倍数在 meta 标签中设定 scale 缩小两倍</h3><ul>\n<li>移动端扩展点击区域</li>\n</ul>\n<p>参考回答： 父级代理事件</p>\n<p>将a 标签设置成块级元素</p>\n<ul>\n<li><h3 id=\"上下拉动滚动条时卡顿、慢\"><a href=\"#上下拉动滚动条时卡顿、慢\" class=\"headerlink\" title=\"上下拉动滚动条时卡顿、慢\"></a>上下拉动滚动条时卡顿、慢</h3></li>\n</ul>\n<p>参考回答：</p>\n<blockquote>\n<p><img src=\"media/image23.jpeg\"></p>\n</blockquote>\n<ul>\n<li><h3 id=\"长时间按住页面出现闪退\"><a href=\"#长时间按住页面出现闪退\" class=\"headerlink\" title=\"长时间按住页面出现闪退\"></a>长时间按住页面出现闪退</h3></li>\n</ul>\n<p>参考回答：</p>\n<p><img src=\"media/image24.jpeg\"></p>\n<ul>\n<li><h3 id=\"ios-和-android-下触摸元素时出现半透明灰色遮罩\"><a href=\"#ios-和-android-下触摸元素时出现半透明灰色遮罩\" class=\"headerlink\" title=\"ios 和 android 下触摸元素时出现半透明灰色遮罩\"></a>ios 和 android 下触摸元素时出现半透明灰色遮罩</h3></li>\n</ul>\n<p><img src=\"media/image25.jpeg\"> 参考回答：</p>\n<ul>\n<li><h3 id=\"active-兼容处理-即-伪类：active-失效\"><a href=\"#active-兼容处理-即-伪类：active-失效\" class=\"headerlink\" title=\"active 兼容处理 即 伪类：active 失效\"></a>active 兼容处理 即 伪类：active 失效</h3></li>\n</ul>\n<p>参 考 回 答 ：<br><a href=\"https://links.jianshu.com/go?to=https://blog.csdn.net/diaobuwei1238/article/details/101716814\"><em>https://blog.csdn.net/diaobuwei1238/article/details/101716814</em></a></p>\n<p>将 :visited 放到最后，则会导致以下结果：若链接已经被访问过，a:visited 会覆盖:active 和:hover<br>的样式声明，链接将总是呈现为紫色，无论鼠标悬停还是按下激活，链接都将保持为紫色。</p>\n<p>基于此原因，上述代码必须按照顺序定义，一般称为 LVHA-order: :link — :visited</p>\n<p>— :hover — :active，为方便记忆，可记为“LOVE HATE”</p>\n<p><img src=\"media/image26.jpeg\"></p>\n<ul>\n<li><h3 id=\"webkit-mask-兼容处理\"><a href=\"#webkit-mask-兼容处理\" class=\"headerlink\" title=\"webkit mask 兼容处理\"></a>webkit mask 兼容处理</h3></li>\n</ul>\n<p>参 考 回 答 ：<br><a href=\"https://links.jianshu.com/go?to=https://segmentfault.com/a/1190000011838367\"><em>https://segmentfault.com/a/1190000011838367</em></a></p>\n<blockquote>\n<p><img src=\"media/image27.jpeg\"></p>\n</blockquote>\n<p><img src=\"media/image28.jpeg\"></p>\n<ul>\n<li><h3 id=\"transiton-闪屏\"><a href=\"#transiton-闪屏\" class=\"headerlink\" title=\"transiton 闪屏\"></a>transiton 闪屏</h3></li>\n</ul>\n<p>参考回答：</p>\n<h3 id=\"设置内联的元素在-3D-空间如何呈现：保留-3D-webkit-transform-style-preserve-3D\"><a href=\"#设置内联的元素在-3D-空间如何呈现：保留-3D-webkit-transform-style-preserve-3D\" class=\"headerlink\" title=\"//设置内联的元素在 3D 空间如何呈现：保留 3D-webkit-transform- style:preserve-3D\"></a>//设置内联的元素在 3D 空间如何呈现：保留 3D-webkit-transform- style:preserve-3D</h3><blockquote>\n<p>//设置进行转换的元素的背面在面对用户时是否可见：隐藏-webkit-backface- visibility:hidden;</p>\n</blockquote>\n<ul>\n<li>圆角 bug</li>\n</ul>\n<p><img src=\"media/image29.jpeg\"> 参考回答：</p>\n<h3 id=\"作者：Aniugel\"><a href=\"#作者：Aniugel\" class=\"headerlink\" title=\"作者：Aniugel\"></a>作者：Aniugel</h3><blockquote>\n<p>链接：<a href=\"https://www.jianshu.com/p/610123c6ed45\"><em>https://www.jianshu.com/p/610123c6ed45</em></a> 来源：简书</p>\n</blockquote>\n<h1 id=\"3-前端进阶\"><a href=\"#3-前端进阶\" class=\"headerlink\" title=\"3 | 前端进阶\"></a>3 | 前端进阶</h1><ol>\n<li><h2 id=\"前端工程化\"><a href=\"#前端工程化\" class=\"headerlink\" title=\"| 前端工程化\"></a>| 前端工程化</h2></li>\n</ol>\n<ul>\n<li><h3 id=\"Babel-的原理是什么\"><a href=\"#Babel-的原理是什么\" class=\"headerlink\" title=\"Babel 的原理是什么?\"></a>Babel 的原理是什么?</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>babel 的转译过程也分为三个阶段，这三步具体是：</p>\n<ul>\n<li><p>解析 Parse: 将代码解析生成抽象语法树( 即 AST )，即词法分析与语法分析的过程</p>\n</li>\n<li><p>转换 Transform: 对于 AST 进行变换一系列的操作，babel 接受得到AST 并通过 babel-traverse 对其进行遍历，在此过程中进行添加、更新及移除等操作</p>\n</li>\n<li><p>生成 Generate: 将变换后的 AST 再转换为 JS 代码, 使用到的模块是babel-generator</p>\n</li>\n</ul>\n<p><img src=\"media/image30.jpeg\"></p>\n<ul>\n<li><h3 id=\"如何写一个-babel-插件\"><a href=\"#如何写一个-babel-插件\" class=\"headerlink\" title=\"如何写一个 babel 插件?\"></a>如何写一个 babel 插件?</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Babel 解析成 AST，然后插件更改 AST，最后由 Babel 输出代码</p>\n<p>那么 Babel 的插件模块需要你暴露一个 function，function 内返回 visitor</p>\n<h3 id=\"module-export-function-babel\"><a href=\"#module-export-function-babel\" class=\"headerlink\" title=\"module.export = function(babel){\"></a>module.export = function(babel){</h3><blockquote>\n<p>return {</p>\n</blockquote>\n<blockquote>\n<p>visitor:{</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>visitor 是对各类型的 AST 节点做处理的地方，那么我们怎么知道 Babel 生成了的 AST 有哪些节点呢？</p>\n</blockquote>\n<blockquote>\n<p>很简单，你可以把 Babel 转换的结果打印出来，或者这里有传送门:<a href=\"https://astexplorer.net/\"><em>AST</em></a><br><a href=\"https://astexplorer.net/\"><em>explorer</em></a></p>\n</blockquote>\n<p><img src=\"media/image31.jpeg\"></p>\n<blockquote>\n<p>这里我们看到 const result = 1 + 2 中的 1 + 1 是一个 BinaryExpression 节点， 那么在 visitor 中，我们就处理这个节点</p>\n</blockquote>\n<h3 id=\"var-babel-require-‘babel-core’-var-t-require-‘babel-types’-const-visitor\"><a href=\"#var-babel-require-‘babel-core’-var-t-require-‘babel-types’-const-visitor\" class=\"headerlink\" title=\"var babel = require(‘babel-core’); var t = require(‘babel-types’); const visitor = {\"></a>var babel = require(‘babel-core’); var t = require(‘babel-types’); const visitor = {</h3><blockquote>\n<p>BinaryExpression(path) {</p>\n</blockquote>\n<blockquote>\n<p>const node = path.node;</p>\n</blockquote>\n<blockquote>\n<p>let result;</p>\n</blockquote>\n<blockquote>\n<p>// 判断表达式两边，是否都是数字</p>\n</blockquote>\n<blockquote>\n<p>if (t.isNumericLiteral(node.left) &amp;&amp; t.isNumericLiteral(node.right)) {</p>\n</blockquote>\n<blockquote>\n<p>// 根据不同的操作符作运算</p>\n</blockquote>\n<blockquote>\n<p>switch (node.operator) {</p>\n</blockquote>\n<blockquote>\n<p>case “+”:</p>\n</blockquote>\n<blockquote>\n<p>result = node.left.value + node.right.value;</p>\n</blockquote>\n<blockquote>\n<p>break</p>\n</blockquote>\n<blockquote>\n<p>case “-“:</p>\n</blockquote>\n<blockquote>\n<p>result = node.left.value - node.right.value;</p>\n</blockquote>\n<blockquote>\n<p>break;</p>\n</blockquote>\n<blockquote>\n<p>case “*“:</p>\n</blockquote>\n<blockquote>\n<p>result = node.left.value * node.right.value;</p>\n</blockquote>\n<blockquote>\n<p>break;</p>\n</blockquote>\n<blockquote>\n<p>case “/“:</p>\n</blockquote>\n<blockquote>\n<p>result = node.left.value / node.right.value;</p>\n</blockquote>\n<blockquote>\n<p>break;</p>\n</blockquote>\n<blockquote>\n<p>case “**“:</p>\n</blockquote>\n<blockquote>\n<p>let i = node.right.value;</p>\n</blockquote>\n<blockquote>\n<p>while (–i) {</p>\n</blockquote>\n<blockquote>\n<p>result = result || node.left.value;</p>\n</blockquote>\n<blockquote>\n<p>result = result * node.left.value;</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>break;</p>\n</blockquote>\n<blockquote>\n<p>default:</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>// 如果上面的运算有结果的话</p>\n</blockquote>\n<blockquote>\n<p>if (result !== undefined) {</p>\n</blockquote>\n<blockquote>\n<p>// 把表达式节点替换成 number 字面量</p>\n</blockquote>\n<blockquote>\n<p>path.replaceWith(t.numericLiteral(result));</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>};</p>\n</blockquote>\n<blockquote>\n<p>module.exports = function (babel) {</p>\n</blockquote>\n<blockquote>\n<p>return {</p>\n</blockquote>\n<blockquote>\n<p>visitor</p>\n</blockquote>\n<blockquote>\n<p>};</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>插件写好了，我们运行下插件试试</p>\n</blockquote>\n<blockquote>\n<p>const babel = require(“babel-core”);</p>\n</blockquote>\n<blockquote>\n<p>const result = babel.transform(“const result = 1 + 2;”,{</p>\n</blockquote>\n<blockquote>\n<p>plugins:[</p>\n</blockquote>\n<blockquote>\n<p>require(“./index”)</p>\n</blockquote>\n<blockquote>\n<p>]</p>\n</blockquote>\n<blockquote>\n<p>});</p>\n</blockquote>\n<blockquote>\n<p>console.log(result.code); // const result = 3;</p>\n</blockquote>\n<blockquote>\n<p>与预期一致，那么转换 const result = 1 + 2 + 3 + 4 + 5;呢?</p>\n</blockquote>\n<h3 id=\"结果是-const-result-3-3-4-5\"><a href=\"#结果是-const-result-3-3-4-5\" class=\"headerlink\" title=\"结果是: const result = 3 + 3 + 4 + 5\"></a>结果是: const result = 3 + 3 + 4 + 5</h3><p>这就奇怪了，为什么只计算了 1 + 2 之后，就没有继续往下运算了? 我们看一下这个表达式的 AST 树</p>\n<p><img src=\"media/image32.jpeg\"></p>\n<p>你会发现 Babel 解析成表达式里面再嵌套表达式。</p>\n<h3 id=\"表达式-表达式-表达式-表达式-1-2-3-4-5-而我们的判断条件并不符合所有的，只符合-1-2\"><a href=\"#表达式-表达式-表达式-表达式-1-2-3-4-5-而我们的判断条件并不符合所有的，只符合-1-2\" class=\"headerlink\" title=\"表达式( 表达式( 表达式( 表达式(1 + 2) + 3) + 4) + 5) 而我们的判断条件并不符合所有的，只符合 1 + 2\"></a>表达式( 表达式( 表达式( 表达式(1 + 2) + 3) + 4) + 5) 而我们的判断条件并不符合所有的，只符合 1 + 2</h3><blockquote>\n<p>// 判断表达式两边，是否都是数字</p>\n</blockquote>\n<blockquote>\n<p>if (t.isNumericLiteral(node.left) &amp;&amp; t.isNumericLiteral(node.right)) {}</p>\n</blockquote>\n<p>那么我们得改一改</p>\n<blockquote>\n<p>第一次计算 1 + 2 之后，我们会得到这样的表达式</p>\n</blockquote>\n<h3 id=\"表达式-表达式-表达式-3-3-4-5\"><a href=\"#表达式-表达式-表达式-3-3-4-5\" class=\"headerlink\" title=\"表达式( 表达式( 表达式(3 + 3) + 4) + 5)\"></a>表达式( 表达式( 表达式(3 + 3) + 4) + 5)</h3><p>其中 3 + 3 又符合了我们的条件， 我们通过向上递归的方式遍历父级节点又转换成这样:</p>\n<h3 id=\"表达式-表达式-6-4-5-表达式-10-5\"><a href=\"#表达式-表达式-6-4-5-表达式-10-5\" class=\"headerlink\" title=\"表达式( 表达式(6 + 4) + 5) 表达式(10 + 5)\"></a>表达式( 表达式(6 + 4) + 5) 表达式(10 + 5)</h3><blockquote>\n<p>15</p>\n</blockquote>\n<h3 id=\"如果上面的运算有结果的话\"><a href=\"#如果上面的运算有结果的话\" class=\"headerlink\" title=\"// 如果上面的运算有结果的话\"></a>// 如果上面的运算有结果的话</h3><blockquote>\n<p>if (result !== undefined) {</p>\n</blockquote>\n<blockquote>\n<p>// 把表达式节点替换成 number 字面量</p>\n</blockquote>\n<blockquote>\n<p>path.replaceWith(t.numericLiteral(result));</p>\n</blockquote>\n<blockquote>\n<p>let parentPath = path.parentPath;</p>\n</blockquote>\n<blockquote>\n<p>// 向上遍历父级节点</p>\n</blockquote>\n<blockquote>\n<p>parentPath &amp;&amp; visitor.BinaryExpression.call(this, parentPath);</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>到这里，我们就得出了结果 const result = 15;</p>\n</blockquote>\n<h3 id=\"那么其他运算呢\"><a href=\"#那么其他运算呢\" class=\"headerlink\" title=\"那么其他运算呢\"></a>那么其他运算呢</h3><blockquote>\n<p>const result = 100 + 10 - 50&gt;&gt;&gt;const result = 60; const result = (100 / 2) + 50&gt;&gt;&gt;const result<br>= 100;</p>\n</blockquote>\n<blockquote>\n<p>const result = (((100 / 2) + 50 * 2) / 50) ** 2&gt;&gt;&gt;const result = 9;</p>\n</blockquote>\n<ul>\n<li><h3 id=\"你的-git-工作流是怎样的\"><a href=\"#你的-git-工作流是怎样的\" class=\"headerlink\" title=\"你的 git 工作流是怎样的?\"></a>你的 git 工作流是怎样的?</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>GitFlow 是由 Vincent Driessen 提出的一个 git 操作流程标准。包含如下几个关键分支：</p>\n<p>master 主分支 develop 主开发分支，包含确定即将发布的代码</p>\n<p>feature 新功能分支，一般一个新功能对应一个分支，对于功能的拆分需要比较合理， 以避免一些后面不必要的代码冲突</p>\n<p>release 发布分支，发布时候用的分支，一般测试时候发现的</p>\n<p>bug 在这个分支进行修复 hotfixhotfix 分支，紧急修 bug 的时候用GitFlow 的优势有如下几点：</p>\n<ul>\n<li>并行开发：GitFlow 可以很方便的实现并行开发：每个新功能都会建立一个新的 feature 分支，从而和已经完成的功能隔离开来，而且只有在新功能完成开发的情况下，其对应的 feature<br>分支才会合并到主开发分支上（也就是我们经常说的 develop 分支）。另外，如果你正在开发某个功能，同时又有一个新的功能需要开发，你只需要提交当前 feature 的代码，然后创建另外一个<br>feature 分支并完成新功能开发。然后再切回之前</li>\n</ul>\n<blockquote>\n<p>的 feature 分支即可继续完成之前功能的开发。</p>\n</blockquote>\n<ul>\n<li><p>协作开发：GitFlow 还支持多人协同开发，因为每个 feature 分支上改动的代码都只是为了让某个新的 feature 可以独立运行。同时我们也很容易知道每个人都在干啥。</p>\n</li>\n<li><p>发布阶段：当一个新 feature 开发完成的时候，它会被合并</p>\n</li>\n</ul>\n<blockquote>\n<p>到 develop 分支，这个分支主要用来暂时保存那些还没有发布的内容，所以如果需要再开发新的 feature，我们只需要从 develop 分支创建新分支，即可包含所有已经完成的 feature<br>。</p>\n</blockquote>\n<ul>\n<li>支持紧急修复：GitFlow 还包含了 hotfix 分支。这种类型的分支是从某个已经发布的 tag 上创建出来并做一个紧急的修复，而且这个紧急修复只影响这个已经发布的<br>tag，而不会影响到你正在开发的新 feature。</li>\n</ul>\n<p>然后就是 GitFlow 最经典的几张流程图，一定要理解：</p>\n<p><img src=\"media/image33.jpeg\"></p>\n<blockquote>\n<p>feature 分支都是从 develop 分支创建，完成后再合并到 develop 分支上， 等待发布。</p>\n</blockquote>\n<p><img src=\"media/image34.jpeg\"></p>\n<blockquote>\n<p>当需要发布时，我们从 develop 分支创建一个 release 分支</p>\n</blockquote>\n<p><img src=\"media/image35.jpeg\"></p>\n<p>然后这个 release 分支会发布到测试环境进行测试，如果发现问题就在这个分支直接进行修复。在所有问题修复之前，我们会不停的重复发布-&gt;测试-&gt;修复-&gt;重新发布-&gt;重新测试这个流程。</p>\n<blockquote>\n<p>发布结束后，这个 release 分支会合并到 develop 和 master 分支，从而保证不会有代码丢失。</p>\n</blockquote>\n<p><img src=\"media/image36.jpeg\"></p>\n<blockquote>\n<p>master 分支只跟踪已经发布的代码，合并到 master 上的 commit 只能来自 release 分支和 hotfix 分支。</p>\n</blockquote>\n<blockquote>\n<p>hotfix 分支的作用是紧急修复一些 Bug。</p>\n</blockquote>\n<blockquote>\n<p>它们都是从 master 分支上的某个 tag 建立，修复结束后再合并到 develop 和 master 分 支 上 。</p>\n</blockquote>\n<ul>\n<li><h3 id=\"rebase-与-merge-的区别\"><a href=\"#rebase-与-merge-的区别\" class=\"headerlink\" title=\"rebase 与 merge 的区别?\"></a>rebase 与 merge 的区别?</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>git rebase 和 git merge 一样都是用于从一个分支获取并且合并到当前分支. 假设一个场景,就是我们开发的[feature/todo]分支要合并到 master<br>主分支,那么用rebase 或者 merge 有什么不同呢?</p>\n<p><img src=\"media/image37.jpeg\"></p>\n<ul>\n<li><p>marge 特点：自动创建一个新的 commit 如果合并的时候遇到冲突，仅需要修改后重新 commit</p>\n</li>\n<li><p>优点：记录了真实的 commit 情况，包括每个分支的详情</p>\n</li>\n<li><p>缺点：因为每次 merge 会自动产生一个 merge commit，所以在使用一些 git 的 GUI tools，特别是 commit 比较频繁时，看到分支很杂乱。</p>\n</li>\n</ul>\n<blockquote>\n<p><img src=\"media/image38.jpeg\"></p>\n</blockquote>\n<ul>\n<li><p>rebase 特点：会合并之前的 commit 历史</p>\n</li>\n<li><p>优点：得到更简洁的项目历史，去掉了 merge commit</p>\n</li>\n<li><p>缺点：如果合并出现代码问题不容易定位，因为 re-write 了 history</p>\n</li>\n</ul>\n<p>因此,当需要保留详细的合并信息的时候建议使用 git merge，特别是需要将分支合并</p>\n<p>进入 master 分支时；当发现自己修改某个功能时，频繁进行了 git commit 提交时， 发现其实过多的提交信息没有必要时，可以尝试 git rebase.</p>\n<ul>\n<li><h3 id=\"git-reset、git-revert-和-git-checkout-有什么区别\"><a href=\"#git-reset、git-revert-和-git-checkout-有什么区别\" class=\"headerlink\" title=\"git reset、git revert 和 git checkout 有什么区别\"></a>git reset、git revert 和 git checkout 有什么区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>这个问题同样也需要先了解 git 仓库的三个组成部分：工作区（Working Directory）、暂存区（Stage）和历史记录区（History）。</p>\n<ul>\n<li><p>工作区：在 git 管理下的正常目录都算是工作区，我们平时的编辑工作都是在工作区完成</p>\n</li>\n<li><p>暂存区：临时区域。里面存放将要提交文件的快照</p>\n</li>\n<li><p>历史记录区：git commit 后的记录区三个区的转换关系以及转换所使用的命令：</p>\n</li>\n</ul>\n<blockquote>\n<p><img src=\"media/image39.jpeg\"></p>\n</blockquote>\n<p>git reset、git revert 和 git checkout 的共同点：用来撤销代码仓库中的某些更改。</p>\n<p>然后是不同点：</p>\n<p>首先，从 commit 层面来说：</p>\n<ul>\n<li><p>git reset 可以将一个分支的末端指向之前的一个 commit。然后再下次 git 执行垃圾回收的时候，会把这个 commit 之后的 commit 都扔掉。git reset<br>还支持三种标记，用来标记 reset 指令影响的范围：</p>\n<ul>\n<li><p>–mixed：会影响到暂存区和历史记录区。也是默认选项</p>\n</li>\n<li><p>–soft：只影响历史记录区</p>\n</li>\n<li><p>–hard：影响工作区、暂存区和历史记录区</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"注意：因为-git-reset-是直接删除-commit-记录，从而会影响到其他开发人员的分支，所以不要在公共分支（比如-develop）做这个操作\"><a href=\"#注意：因为-git-reset-是直接删除-commit-记录，从而会影响到其他开发人员的分支，所以不要在公共分支（比如-develop）做这个操作\" class=\"headerlink\" title=\"注意：因为 git reset 是直接删除 commit 记录，从而会影响到其他开发人员的分支，所以不要在公共分支（比如 develop）做这个操作\"></a>注意：因为 git reset 是直接删除 commit 记录，从而会影响到其他开发人员的分支，所以不要在公共分支（比如 develop）做这个操作</h3><ul>\n<li><p>git checkout 可以将 HEAD 移到一个新的分支，并更新工作目录。因为可能会覆盖本地的修改，所以执行这个指令之前，你需要 stash 或者 commit 暂存区和工作区的更改。</p>\n</li>\n<li><p>git revert 和 git reset 的目的是一样的，但是做法不同，它会以创建新的 commit 的方式来撤销 commit，这样能保留之前的 commit<br>历史，比较安全。另外，同样因为可能会覆盖本地的修改，所以执行这个指令之前，你需要 stash 或者 commit 暂存区和工作区的更改。</p>\n</li>\n</ul>\n<blockquote>\n<p>然后，从文件层面来说：</p>\n</blockquote>\n<ul>\n<li><p>git reset 只是把文件从历史记录区拿到暂存区，不影响工作区的内容，而且不支持 –mixed、–soft 和 –hard。</p>\n</li>\n<li><p>git checkout 则是把文件从历史记录拿到工作区，不影响暂存区的内容。</p>\n</li>\n<li><p>git revert 不支持文件层面的操作。</p>\n</li>\n</ul>\n<h3 id=\"版权声明：本文为取经猿作者的原创文章，转载请附上原文出处链接及本声明\"><a href=\"#版权声明：本文为取经猿作者的原创文章，转载请附上原文出处链接及本声明\" class=\"headerlink\" title=\"版权声明：本文为取经猿作者的原创文章，转载请附上原文出处链接及本声明\"></a>版权声明：本文为取经猿作者的原创文章，转载请附上原文出处链接及本声明</h3><blockquote>\n<p>原文链接：<a href=\"https://www.teaspect.com/detail/5623?pn=21\"><em>https://www.teaspect.com/detail/5623?pn=21</em></a></p>\n</blockquote>\n<ul>\n<li><h3 id=\"webpack-和-gulp-区别（模块化与流的区别）\"><a href=\"#webpack-和-gulp-区别（模块化与流的区别）\" class=\"headerlink\" title=\"webpack 和 gulp 区别（模块化与流的区别）\"></a>webpack 和 gulp 区别（模块化与流的区别）</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>gulp 强调的是前端开发的工作流程，我们可以通过配置一系列的 task，定义 task 处理的事务（例如文件压缩合并、雪碧图、启动 server、版本控制等），然后定义执行顺序，来让 gulp<br>执行这些 task，从而构建项目的整个前端开发流程。</p>\n<p>webpack 是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js 文件、css 文件等）都看成模块，通过 loader（加载器）和 plugins（插件）<br>对资源进行处理，打包成符合生产环境部署的前端资源。</p>\n<ol>\n<li><h2 id=\"Vue-框架\"><a href=\"#Vue-框架\" class=\"headerlink\" title=\"| Vue 框架\"></a>| Vue 框架</h2></li>\n</ol>\n<ul>\n<li><h3 id=\"有使用过-Vue-吗？说说你对-Vue-的理解\"><a href=\"#有使用过-Vue-吗？说说你对-Vue-的理解\" class=\"headerlink\" title=\"有使用过 Vue 吗？说说你对 Vue 的理解\"></a>有使用过 Vue 吗？说说你对 Vue 的理解</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Vue 是一个构建数据驱动的渐进性框架，它的目标是通过 API 实现响应数据绑定和视图更新。</p>\n<ul>\n<li><h3 id=\"说说-Vue-的优缺点\"><a href=\"#说说-Vue-的优缺点\" class=\"headerlink\" title=\"说说 Vue 的优缺点\"></a>说说 Vue 的优缺点</h3></li>\n</ul>\n<p>参考回答：</p>\n<blockquote>\n<p>优点：</p>\n</blockquote>\n<h3 id=\"1、数据驱动视图，对真实-dom-进行抽象出-virtual-dom（本质就是一个-js-对象），并配合-diff-算法、响应式和观察者、异步队列等手段以最小代价更新dom，渲染页面\"><a href=\"#1、数据驱动视图，对真实-dom-进行抽象出-virtual-dom（本质就是一个-js-对象），并配合-diff-算法、响应式和观察者、异步队列等手段以最小代价更新dom，渲染页面\" class=\"headerlink\" title=\"1、数据驱动视图，对真实 dom 进行抽象出 virtual dom（本质就是一个 js 对象），并配合 diff 算法、响应式和观察者、异步队列等手段以最小代价更新dom，渲染页面\"></a>1、数据驱动视图，对真实 dom 进行抽象出 virtual dom（本质就是一个 js 对象），并配合 diff 算法、响应式和观察者、异步队列等手段以最小代价更新dom，渲染页面</h3><blockquote>\n<p>2、组件化，组件用单文件的形式进行代码的组织编写，使得我们可以在一个文件里编写 html\\css（scoped 属性配置 css 隔离）\\js 并且配合 Vue-loader<br>之后，支持更强大的预处理器等功能</p>\n</blockquote>\n<blockquote>\n<p>3、强大且丰富的 API 提供一系列的 api 能满足业务开发中各类需求</p>\n</blockquote>\n<blockquote>\n<p>4、由于采用虚拟 dom，让 Vue ssr 先天就足</p>\n</blockquote>\n<blockquote>\n<p>5、生命周期钩子函数，选项式的代码组织方式，写熟了还是蛮顺畅的，但仍然有优化空间（Vue3 composition-api）</p>\n</blockquote>\n<blockquote>\n<p>6、生态好，社区活跃</p>\n</blockquote>\n<blockquote>\n<p>缺点：</p>\n</blockquote>\n<h3 id=\"1、由于底层基于-Object-defineProperty-实现响应式，而这个-api-本身不支持\"><a href=\"#1、由于底层基于-Object-defineProperty-实现响应式，而这个-api-本身不支持\" class=\"headerlink\" title=\"1、由于底层基于 Object.defineProperty 实现响应式，而这个 api 本身不支持\"></a>1、由于底层基于 Object.defineProperty 实现响应式，而这个 api 本身不支持</h3><blockquote>\n<p>IE8 及以下浏览器</p>\n</blockquote>\n<blockquote>\n<p>2、csr 的先天不足，首屏性能问题（白屏）</p>\n</blockquote>\n<blockquote>\n<p>3、由于百度等搜索引擎爬虫无法爬取 js 中的内容，故 spa 先天就对 seo 优化心有余力不足（谷歌的 puppeteer 就挺牛逼的，实现预渲染底层也是用到了这个工具）</p>\n</blockquote>\n<ul>\n<li><h3 id=\"Vue-和-React-有什么不同？使用场景分别是什么？\"><a href=\"#Vue-和-React-有什么不同？使用场景分别是什么？\" class=\"headerlink\" title=\"Vue 和 React 有什么不同？使用场景分别是什么？\"></a>Vue 和 React 有什么不同？使用场景分别是什么？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>1、Vue 是完整一套由官方维护的框架，核心库主要有由尤雨溪大神独自维护，而 React 是不要脸的书维护（很多库由社区维护），曾经一段时间很多人质疑 Vue 的后续维护性，似乎这并不是问题。</p>\n<p>2、Vue 上手简单，进阶式框架，白话说你可以学一点，就可以在你项目中去用一点， 你不一定需要一次性学习整个 Vue 才能去使用它，而 React，恐怕如果你这样会面对项目束手无策。</p>\n<p>3、语法上 Vue 并不限制你必须 es6+完全 js 形式编写页面，可以视图和 js 逻辑尽可能分离，减少很多人看不惯 React-jsx 的恶心嵌套，毕竟都是作为前端开发者，还是更习惯于 html<br>干净。</p>\n<p>4、很多人说 React 适合大型项目，适合什么什么，Vue 轻量级，适合移动端中小型项目，其实我想说，说这话的人是心里根本没点逼数，Vue 完全可以应对复杂的大型应用，甚至于说如果你 React<br>学的不是很好，写出来的东西或根本不如 Vue 写的，毕竟Vue 跟着官方文档撸就行，自有人帮你规范，而 React 比较懒散自由，可以自由发挥5、Vue 在国内人气明显胜过<br>React，这很大程度上得益于它的很多语法包括编程思维更符合国人思想。</p>\n<ul>\n<li><h3 id=\"什么是虚拟-DOM？\"><a href=\"#什么是虚拟-DOM？\" class=\"headerlink\" title=\"什么是虚拟 DOM？\"></a>什么是虚拟 DOM？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>虚拟 dom 是相对于浏览器所渲染出来的真实 dom 的，在 react，vue 等技术出现之</p>\n<p>前，我们要改变页面展示的内容只能通过遍历查询 dom 树的方式找到需要修改的 dom 然后修改样式行为或者结构，来达到更新 ui 的目的。</p>\n<p>这种方式相当消耗计算资源，因为每次查询 dom 几乎都需要遍历整颗 dom 树，如果建立一个与 dom 树对应的虚拟 dom 对象（ js 对象），以对象嵌套的方式来表示dom 树，那么每次 dom<br>的更改就变成了 js 对象的属性的更改，这样一来就能查找js 对象的属性变化要比查询 dom 树的性能开销小。</p>\n<ul>\n<li><h3 id=\"请描述下-vue-的生命周期是什么？\"><a href=\"#请描述下-vue-的生命周期是什么？\" class=\"headerlink\" title=\"请描述下 vue 的生命周期是什么？\"></a>请描述下 vue 的生命周期是什么？</h3></li>\n</ul>\n<p>参考回答：</p>\n<ul>\n<li>生命周期就是 vue 从开始创建到销毁的过程，分为四大步（创建，挂载，更新，销毁），每一步又分为两小步，如 beforeCreate， created。beforeCreate 前，也就是 new<br>Vue 的时候会初始化事件和生命周期；beforeCreate 和 created 之间会挂载 Data，绑定事件；接下来会根据 el 挂载页面元素，如果没有设置 el<br>则生命周期结束，直到手动挂载；el 挂载结束后，根据 templete/outerHTML(el)渲染页面；在beforeMount 前虚拟 DOM 已经创建完成；之后在 mounted 前，将<br>vm.$el 替换掉页面元素 el;mounted 将虚拟 dom 挂载到真实页面（此时页面已经全部渲染完成）；之后发生数据变化时触发 beforeUpdate 和updated<br>进行一些操作；最后主动调用销毁函数或者组件自动销毁时</li>\n</ul>\n<blockquote>\n<p>beforeDestroy，手动撤销监听事件，计时器等；destroyed 时仅存在Dom 节点，其他所有东西已自动销毁。这就是我所理解的 vue 的一个完整的生命周期。</p>\n</blockquote>\n<p>-</p>\n<p><img src=\"media/image40.jpeg\"></p>\n<ul>\n<li><h3 id=\"vue-如何监听键盘事件？\"><a href=\"#vue-如何监听键盘事件？\" class=\"headerlink\" title=\"vue 如何监听键盘事件？\"></a>vue 如何监听键盘事件？</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li>@keyup. 方 法</li>\n</ol>\n<h3 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"\"></a><template></h3><blockquote>\n<p>&lt;input ref=”myInput” type=”text” value=”hello world” autofocus @keyup.enter=”handleKey”&gt;</p>\n</blockquote>\n<blockquote>\n</template>\n</blockquote>\n<blockquote>\n<script>\n</blockquote>\n<blockquote>\n<p>export default {</p>\n</blockquote>\n<blockquote>\n<p>methods: {</p>\n</blockquote>\n<blockquote>\n<p>handleKey(e) {</p>\n</blockquote>\n<blockquote>\n<p>console.log(e)</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p></script></p>\n</blockquote>\n<ol start=\"2\">\n<li>addEventListener</li>\n</ol>\n<h3 id=\"-5\"><a href=\"#-5\" class=\"headerlink\" title=\"\"></a><script></h3><blockquote>\n<p>export default {</p>\n</blockquote>\n<blockquote>\n<p>mounted() {</p>\n</blockquote>\n<blockquote>\n<p>document.addEventListener(‘keyup’, this.handleKey)</p>\n</blockquote>\n<blockquote>\n<p>},</p>\n</blockquote>\n<blockquote>\n<p>beforeDestroy() {</p>\n</blockquote>\n<blockquote>\n<p>document.removeEventListener(‘keyup’, this.handleKey)</p>\n</blockquote>\n<blockquote>\n<p>},</p>\n</blockquote>\n<blockquote>\n<p>methods: {</p>\n</blockquote>\n<blockquote>\n<p>handleKey(e) {</p>\n</blockquote>\n<blockquote>\n<p>console.log(e)</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p></script><script></p>\n</blockquote>\n<blockquote>\n<p>export default {</p>\n</blockquote>\n<blockquote>\n<p>mounted() {</p>\n</blockquote>\n<blockquote>\n<p>document.addEventListener(‘keyup’, this.handleKey)</p>\n</blockquote>\n<blockquote>\n<p>},</p>\n</blockquote>\n<blockquote>\n<p>beforeDestroy() {</p>\n</blockquote>\n<blockquote>\n<p>document.removeEventListener(‘keyup’, this.handleKey)</p>\n</blockquote>\n<blockquote>\n<p>},</p>\n</blockquote>\n<blockquote>\n<p>methods: {</p>\n</blockquote>\n<blockquote>\n<p>handleKey(e) {</p>\n</blockquote>\n<blockquote>\n<p>console.log(e)</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p></script></p>\n</blockquote>\n<ul>\n<li><h3 id=\"watch-怎么深度监听对象变化\"><a href=\"#watch-怎么深度监听对象变化\" class=\"headerlink\" title=\"watch 怎么深度监听对象变化\"></a>watch 怎么深度监听对象变化</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>deep 设置为 true 就可以监听到对象的变化</p>\n<h3 id=\"let-vm-new-Vue\"><a href=\"#let-vm-new-Vue\" class=\"headerlink\" title=\"let vm=new Vue({\"></a>let vm=new Vue({</h3><blockquote>\n<p>el:”#first”,</p>\n</blockquote>\n<blockquote>\n<p>data:{msg:{name:’北京’}},</p>\n</blockquote>\n<blockquote>\n<p>watch:{</p>\n</blockquote>\n<blockquote>\n<p>msg:{</p>\n</blockquote>\n<blockquote>\n<p>handler (newMsg,oldMsg){</p>\n</blockquote>\n<blockquote>\n<p>console.log(newMsg);</p>\n</blockquote>\n<blockquote>\n<p>},</p>\n</blockquote>\n<blockquote>\n<p>immediate:true,</p>\n</blockquote>\n<blockquote>\n<p>deep:true</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>}</p>\n</blockquote>\n<blockquote>\n<p>})</p>\n</blockquote>\n<ul>\n<li><h3 id=\"删除数组用-delete-和-Vue-delete-有什么区别？\"><a href=\"#删除数组用-delete-和-Vue-delete-有什么区别？\" class=\"headerlink\" title=\"删除数组用 delete 和 Vue.delete 有什么区别？\"></a>删除数组用 delete 和 Vue.delete 有什么区别？</h3></li>\n</ul>\n<p>参考回答：</p>\n<ul>\n<li><p>delete：只是被删除数组成员变为 empty / undefined，其他元素键值不变</p>\n</li>\n<li><p>Vue.delete：直接删了数组成员，并改变了数组的键值（对象是响应式的，确保删除能触发更新视图，这个方法主要用于避开 Vue 不能检测到属性被删除的限制）</p>\n</li>\n<li><h3 id=\"watch-和计算属性有什么区别？\"><a href=\"#watch-和计算属性有什么区别？\" class=\"headerlink\" title=\"watch 和计算属性有什么区别？\"></a>watch 和计算属性有什么区别？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>通俗来讲，既能用 computed 实现又可以用 watch 监听来实现的功能，推荐用computed，重点在于 computed 的缓存功能</p>\n<p>computed 计算属性是用来声明式的描述一个值依赖了其它的值，当所依赖的值或者变量改变时，计算属性也会跟着改变；</p>\n<p>watch 监听的是已经在 data 中定义的变量，当该变量变化时，会触发 watch 中的方法。</p>\n<ul>\n<li><h3 id=\"Vue-双向绑定原理\"><a href=\"#Vue-双向绑定原理\" class=\"headerlink\" title=\"Vue 双向绑定原理\"></a>Vue 双向绑定原理</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Vue 数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。利用了Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)。</p>\n<ul>\n<li><h3 id=\"v-model-是什么？有什么用呢？\"><a href=\"#v-model-是什么？有什么用呢？\" class=\"headerlink\" title=\"v-model 是什么？有什么用呢？\"></a>v-model 是什么？有什么用呢？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>一则语法糖，相当于v-bind:value=”xxx” 和 @input，意思是绑定了一个 value 属性的值，子组件可对 value 属性监听，通过$emit(‘input’,<br>xxx)的方式给父组件通讯。自己实现v-model 方式的组件也是这样的思路。</p>\n<ul>\n<li><h3 id=\"axios-是什么？怎样使用它？怎么解决跨域的问题？\"><a href=\"#axios-是什么？怎样使用它？怎么解决跨域的问题？\" class=\"headerlink\" title=\"axios 是什么？怎样使用它？怎么解决跨域的问题？\"></a>axios 是什么？怎样使用它？怎么解决跨域的问题？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>axios 的是一种异步请求，用法和 ajax 类似，安装 npm install axios –save 即可使用，请求中包括 get,post,put, patch ,delete<br>等五种请求方式，解决跨域可以在请求头中添加 Access-Control-Allow-Origin，也可以在 index.js 文件中更改proxyTable 配置等解决跨域问题。</p>\n<ul>\n<li><h3 id=\"在-vue-项目中如何引入第三方库（比如-jQuery）？有哪些方法可以做到？\"><a href=\"#在-vue-项目中如何引入第三方库（比如-jQuery）？有哪些方法可以做到？\" class=\"headerlink\" title=\"在 vue 项目中如何引入第三方库（比如 jQuery）？有哪些方法可以做到？\"></a>在 vue 项目中如何引入第三方库（比如 jQuery）？有哪些方法可以做到？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>1、绝对路径直接引入</p>\n<p>在 index.html 中用 script 引入</p>\n<h3 id=\"-6\"><a href=\"#-6\" class=\"headerlink\" title=\"\"></a><script src=\"./static/jquery-1.12.4.js\"></script></h3><blockquote>\n<p>然 后 在 webpack 中 配 置 external externals: { ‘jquery’: ‘jQuery’ } 在组件中使用时 import</p>\n</blockquote>\n<blockquote>\n<p>import $ from ‘jquery’ 2 、在 webpack 中配置 alias</p>\n</blockquote>\n<h3 id=\"resolve-extensions-‘-js’-‘-vue’-‘-json’-alias-‘-’-resolve-‘src’-‘jquery’-resolve-‘static-jquery-1-12-4-js’-然后在组件中-import\"><a href=\"#resolve-extensions-‘-js’-‘-vue’-‘-json’-alias-‘-’-resolve-‘src’-‘jquery’-resolve-‘static-jquery-1-12-4-js’-然后在组件中-import\" class=\"headerlink\" title=\"resolve: { extensions: [‘.js’, ‘.vue’, ‘.json’], alias: { ‘@’: resolve(‘src’), ‘jquery’: resolve(‘static/jquery-1.12.4.js’) } } 然后在组件中 import\"></a>resolve: { extensions: [‘.js’, ‘.vue’, ‘.json’], alias: { ‘@’: resolve(‘src’), ‘jquery’: resolve(‘static/jquery-1.12.4.js’) } } 然后在组件中 import</h3><p>3、在 webpack 中配置 plugins</p>\n<h3 id=\"plugins-new-webpack-ProvidePlugin-‘jquery’\"><a href=\"#plugins-new-webpack-ProvidePlugin-‘jquery’\" class=\"headerlink\" title=\"plugins: [ new webpack.ProvidePlugin({ $: ‘jquery’ }) ]\"></a>plugins: [ new webpack.ProvidePlugin({ $: ‘jquery’ }) ]</h3><p>全局使用，但在使用 eslint 情况下会报错，需要在使用了 $ 的代码前添加 /* eslint-disable*/ 来去掉 ESLint 的检查。</p>\n<ul>\n<li><h3 id=\"说说-Vue-React-angularjs-jquery-的区别\"><a href=\"#说说-Vue-React-angularjs-jquery-的区别\" class=\"headerlink\" title=\"说说 Vue React angularjs jquery 的区别\"></a>说说 Vue React angularjs jquery 的区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>JQuery 与另外几者最大的区别是，JQuery 是事件驱动，其他两者是数据驱动。JQuery 业务逻辑和 UI 更改该混在一起， UI 里面还参杂这交互逻辑，让本来混乱的逻辑更加混乱。</p>\n<p>Angular，Vue 是双向绑定，而 React 不是其他还有设计理念上的区别等</p>\n<ul>\n<li>Vue3.0 里为什么要用 Proxy API 替代 defineProperty API？</li>\n</ul>\n<p>参考回答： 响应式优化。</p>\n<ol>\n<li>defineProperty API 的局限性最大原因是它只能针对单例属性做监听。</li>\n</ol>\n<p>Vue2.x 中的响应式实现正是基于 defineProperty 中的 descriptor，对 data 中的属性做了遍历 + 递归，为每个属性设置了 getter、setter。</p>\n<p>这也就是为什么 Vue 只能对 data 中预定义过的属性做出响应的原因，在 Vue 中使用下标的方式直接修改属性的值或者添加一个预先不存在的对象属性是无法做到 setter 监听的，这是<br>defineProperty 的局限性。</p>\n<ol start=\"2\">\n<li>Proxy API 的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，</li>\n</ol>\n<p>这就完全可以代理所有属性，将会带来很大的性能提升和更优的代码。</p>\n<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>\n<ol start=\"3\">\n<li>响应式是惰性的</li>\n</ol>\n<p>在 Vue.js 2.x 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的变化，就需要递归遍历这个对象，执行 Object.defineProperty<br>把每一层对象数据都变成响应式的，这无疑会有很大的性能消耗。</p>\n<p>在 Vue.js 3.0 中，使用 Proxy API 并不能监听到对象内部深层次的属性变化，因此它的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部属性才会</p>\n<p>变成响应式，简单的可以说是按需实现响应式，减少性能消耗。基础用法：</p>\n<p><img src=\"media/image41.jpeg\"></p>\n<ul>\n<li>Vue3.0 编译做了哪些优化？</li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li>生成 Block tree</li>\n</ol>\n<p><img src=\"media/image42.jpeg\"> Vue.js 2.x 的数据更新并触发重新渲染的粒度是组件级的，单个组件内部 需要遍历该组件的整个 vnode 树。在 2.0<br>里，渲染效率的快慢与组件大小成正相关：组件越大， 渲染效率越慢。并且，对于一些静态节点，又无数据更新，这些遍历都是性能浪费。Vue.js 3.0 做到了通过编译阶段对静态模板的分析，编译生成了<br>Block tree。 Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个 区块内部的节点结构是固定的，每个区块只需要追踪自身包含的动态节点。所以，在 3.0<br>里，渲染效率不再与模板大小成正相关，而是与模板中动态节点的数量成正相关。</p>\n<ol start=\"2\">\n<li>slot 编译优化</li>\n</ol>\n<p>Vue.js 2.x 中，如果有一个组件传入了 slot，那么每次父组件更新的时候，会强制使子组件 update，造成性能的浪费。</p>\n<p>Vue.js 3.0 优化了 slot 的生成，使得非动态 slot 中属性的更新只会触发子组件的更</p>\n<p>新。动态 slot 指的是在 slot 上面使用 v-if，v-for，动态 slot 名字等会导致 slot 产</p>\n<p>生运行时动态变化但是又无法被子组件 track 的操作。c. diff 算法优化</p>\n<ul>\n<li>Vue3.0 新特性 —— Composition API 与 React.js 中 Hooks 的异同点</li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li>React.js 中的 Hooks 基本使用</li>\n</ol>\n<p>React Hooks 允许你 “勾入” 诸如组件状态和副作用处理等 React 功能中。Hooks 只能用在函数组件中，并允许我们在不需要创建类的情况下将状态、副作用处理和更多东西带入组件中。</p>\n<p>React 核心团队奉上的采纳策略是不反对类组件，所以你可以升级 React 版本、在新组件中开始尝试 Hooks，并保持既有组件不做任何更改。</p>\n<p>案例：</p>\n<blockquote>\n<p><img src=\"media/image43.jpeg\"></p>\n</blockquote>\n<p>useState 和 useEffect 是 React Hooks 中的一些例子，使得函数组件中也能增加状态和运行副作用。</p>\n<p>我们也可以自定义一个 Hooks，它打开了代码复用性和扩展性的新大门。</p>\n<ol start=\"2\">\n<li>Vue Composition API 基本使用</li>\n</ol>\n<p>Vue Composition API 围绕一个新的组件选项 setup 而创建。setup() 为 Vue 组件提供了状态、计算值、watcher 和生命周期钩子。</p>\n<p>并没有让原来的 API（Options-based API）消失。允许开发者 结合使用新旧两种 API</p>\n<p>（向下兼容）。</p>\n<blockquote>\n<p><img src=\"media/image44.jpeg\"></p>\n</blockquote>\n<ol start=\"3\">\n<li>原理</li>\n</ol>\n<p>React hook 底层是基于链表实现，调用的条件是每次组件被 render 的时候都会顺序执行所有的 hooks。</p>\n<p>Vue hook 只会被注册调用一次，Vue 能避开这些麻烦的问题，原因在于它对数据的响</p>\n<p>应是基于 proxy 的，对数据直接代理观察。（这种场景下，只要任何一个更改 data 的</p>\n<p>地方，相关的 function 或者 template 都会被重新计算，因此避开了 React 可能遇到的性能上的问题）。</p>\n<p>React 中，数据更改的时候，会导致重新 render，重新 render 又会重新把 hooks 重新注册一次，所以 React 复杂程度会高一些。</p>\n<ul>\n<li><h3 id=\"Vue3-0-是如何变得更快的？（底层，源码）\"><a href=\"#Vue3-0-是如何变得更快的？（底层，源码）\" class=\"headerlink\" title=\"Vue3.0 是如何变得更快的？（底层，源码）\"></a>Vue3.0 是如何变得更快的？（底层，源码）</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li>diff 方法优化</li>\n</ol>\n<p>Vue2.x 中的虚拟 dom 是进行全量的对比。</p>\n<p>Vue3.0 中新增了静态标记（PatchFlag）：在与上次虚拟结点进行对比的时候，值对比带有 patch flag 的节点，并且可以通过 flag 的信息得知当前节点要对比的具体内容化。</p>\n<ol start=\"2\">\n<li>hoistStatic 静态提升</li>\n</ol>\n<p>Vue2.x : 无论元素是否参与更新，每次都会重新创建。</p>\n<p>Vue3.0 : 对不参与更新的元素，只会被创建一次，之后会在每次渲染时候被不停的复用。</p>\n<ol start=\"3\">\n<li>cacheHandlers 事件侦听器缓存</li>\n</ol>\n<p>默认情况下 onClick 会被视为动态绑定，所以每次都会去追踪它的变化但是因为是同一个函数，所以没有追踪变化，直接缓存起来复用即可。</p>\n<p>原作者姓名： 欧阳呀</p>\n<ul>\n<li><h3 id=\"vue-要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？\"><a href=\"#vue-要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？\" class=\"headerlink\" title=\"vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？\"></a>vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>按 钮 级 别 的 权 限 ：<br><a href=\"https://panjiachen.github.io/vue-element-admin-site/zh/guide/essentials/permission.html#%E6%8C%87%E4%BB%A4%E6%9D%83%E9%99%90\"><em>https://panjiachen.github.io/vue-element-admin-</em></a></p>\n<p><a href=\"https://panjiachen.github.io/vue-element-admin-site/zh/guide/essentials/permission.html#%E6%8C%87%E4%BB%A4%E6%9D%83%E9%99%90\"><em>site/zh/guide/essentials/permission.html#%E6%8C%87%E4%BB%A4%E6%9D%83%E9%99%</em></a><br><a href=\"https://panjiachen.github.io/vue-element-admin-site/zh/guide/essentials/permission.html#%E6%8C%87%E4%BB%A4%E6%9D%83%E9%99%90\"><em>90</em></a></p>\n<ul>\n<li><h3 id=\"vue-在-created-和-mounted-这两个生命周期中请求数据有什么区别呢？\"><a href=\"#vue-在-created-和-mounted-这两个生命周期中请求数据有什么区别呢？\" class=\"headerlink\" title=\"vue 在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？\"></a>vue 在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>看实际情况，一般在 created（或 beforeRouter） 里面就可以，如果涉及到需要页面加载完成之后的话就用 mounted。</p>\n<p>在 created 的时候，视图中的 html 并没有渲染出来，所以此时如果直接去操作 html</p>\n<p>的 dom 节点，一定找不到相关的元素</p>\n<p>而在 mounted 中，由于此时 html 已经渲染出来了，所以可以直接操作 dom 节点，（此时 document.getelementById 即可生效了）。</p>\n<ul>\n<li><h3 id=\"说说你对-proxy-的理解\"><a href=\"#说说你对-proxy-的理解\" class=\"headerlink\" title=\"说说你对 proxy 的理解\"></a>说说你对 proxy 的理解</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>vue 的数据劫持有两个缺点:</p>\n<p>1、无法监听通过索引修改数组的值的变化</p>\n<p>2、无法监听 object 也就是对象的值的变化所以 vue2.x 中才会有$set 属性的存在</p>\n<p>proxy 是 es6 中推出的新 api，可以弥补以上两个缺点，所以 vue3.x 版本用 proxy 替换 object.defineproperty。</p>\n<ol>\n<li><h2 id=\"React-框架\"><a href=\"#React-框架\" class=\"headerlink\" title=\"| React 框架\"></a>| React 框架</h2></li>\n</ol>\n<ul>\n<li><h3 id=\"angularJs-和-React-区别\"><a href=\"#angularJs-和-React-区别\" class=\"headerlink\" title=\"angularJs 和 React 区别\"></a>angularJs 和 React 区别</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>React 对比 Angular 是思想上的转变，它也并不是一个库，是一种开发理念，组件化， 分治的管理，数据与 view 的一体化。它只有一个中心,发出状态，渲染 view，对于虚拟 dom<br>它并没有提高渲染页面的性能，它提供更多的是利用 jsx 便捷生成 dom 元素， 利用组件概念进行分治管理页面每个部分(例如 header section footer slider)</p>\n<ul>\n<li><h3 id=\"redux-中间件\"><a href=\"#redux-中间件\" class=\"headerlink\" title=\"redux 中间件\"></a>redux 中间件</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>中间件提供第三方插件的模式，自定义拦截 action -&gt; reducer 的过程。变为action -&gt; middlewares -&gt; reducer<br>。这种机制可以让我们改变数据流，实现如异步action ，action 过滤，日志输出，异常报告等功能。</p>\n<p>常见的中间件： redux-logger：提供日志输出；redux-thunk：处理异步操作；</p>\n<p>redux-promise：处理异步操作；actionCreator 的返回值是 promise</p>\n<ul>\n<li><h3 id=\"redux-有什么缺点\"><a href=\"#redux-有什么缺点\" class=\"headerlink\" title=\"redux 有什么缺点\"></a>redux 有什么缺点</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>一个组件所需要的数据，必须由父组件传过来，而不能像 flux 中直接从 store 取。</p>\n</li>\n<li><p>当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新render，可能会有效率影响，或者需要写复杂的 shouldComponentUpdate 进行判断。</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"React-组件的划分业务组件技术组件？\"><a href=\"#React-组件的划分业务组件技术组件？\" class=\"headerlink\" title=\"React 组件的划分业务组件技术组件？\"></a>React 组件的划分业务组件技术组件？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>根据组件的职责通常把组件分为 UI 组件和容器组件。UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。两者通过 React-Redux 提供 connect 方法联系起来。</p>\n<ul>\n<li><h3 id=\"React-生命周期函数\"><a href=\"#React-生命周期函数\" class=\"headerlink\" title=\"React 生命周期函数\"></a>React 生命周期函数</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>一、初始化阶段：</p>\n<p>getDefaultProps:获取实例的默认属性</p>\n<p>getInitialState:获取每个实例的初始化状态</p>\n<p>componentWillMount：组件即将被装载、渲染到页面上</p>\n<p>render:组件在这里生成虚拟的 DOM 节点</p>\n<p>componentDidMount:组件真正在被装载之后</p>\n<p>二、运行中状态：</p>\n<p>componentWillReceiveProps:组件将要接收到属性的时候调用</p>\n<p>shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）</p>\n<p>componentWillUpdate:组件即将更新不能修改属性和状态</p>\n<p>render:组件重新描绘</p>\n<p>componentDidUpdate:组件已经更新</p>\n<p>三、销毁阶段：</p>\n<p>componentWillUnmount:组件即将销毁</p>\n<ul>\n<li><h3 id=\"React-性能优化是哪个周期函数？\"><a href=\"#React-性能优化是哪个周期函数？\" class=\"headerlink\" title=\"React 性能优化是哪个周期函数？\"></a>React 性能优化是哪个周期函数？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate<br>方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。</p>\n<ul>\n<li><h3 id=\"为什么虚拟-dom-会提高性能\"><a href=\"#为什么虚拟-dom-会提高性能\" class=\"headerlink\" title=\"为什么虚拟 dom 会提高性能?\"></a>为什么虚拟 dom 会提高性能?</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。</p>\n<p>具体实现步骤如下：</p>\n<ol>\n<li>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM</li>\n</ol>\n<p>树，插到文档当中；</p>\n<ol start=\"2\">\n<li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较， 记录两棵树差异；</li>\n</ol>\n<p>把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。</p>\n<ul>\n<li><h3 id=\"diff-算法\"><a href=\"#diff-算法\" class=\"headerlink\" title=\"diff 算法?\"></a>diff 算法?</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>把树形结构按照层级分解，只比较同级元素。</p>\n</li>\n<li><p>给列表结构的每个单元添加唯一的 key 属性，方便比较。</p>\n</li>\n<li><p>React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）</p>\n</li>\n<li><p>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.</p>\n</li>\n</ol>\n<p>到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.</p>\n<ol start=\"6\">\n<li>选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。</li>\n</ol>\n<ul>\n<li><h3 id=\"React-性能优化方案\"><a href=\"#React-性能优化方案\" class=\"headerlink\" title=\"React 性能优化方案\"></a>React 性能优化方案</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>重写 shouldComponentUpdate 来避免不必要的 dom 操作。</p>\n</li>\n<li><p>使用 production 版本的 React.js。</p>\n</li>\n<li><p>使用 key 来帮助 React 识别列表中所有子组件的最小变化</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"简述-flux-思想\"><a href=\"#简述-flux-思想\" class=\"headerlink\" title=\"简述 flux 思想\"></a>简述 flux 思想</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Flux 的最大特点，就是数据的”单向流动”。</p>\n<ol>\n<li><p>用户访问 View</p>\n</li>\n<li><p>View 发出用户的 Action</p>\n</li>\n<li><p>Dispatcher 收到 Action，要求 Store 进行相应的更新</p>\n</li>\n<li><p>Store 更新后，发出一个”change”事件</p>\n</li>\n<li><p>View 收到”change”事件后，更新页面</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"React-项目用过什么脚手架？Mern-Yeoman\"><a href=\"#React-项目用过什么脚手架？Mern-Yeoman\" class=\"headerlink\" title=\"React 项目用过什么脚手架？Mern? Yeoman?\"></a>React 项目用过什么脚手架？Mern? Yeoman?</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Mern：MERN 是脚手架的工具，它可以很容易地使用 Mongo, Express, React and NodeJS 生成同构 JS<br>应用。它最大限度地减少安装时间，并得到您使用的成熟技术来加速开发。</p>\n<ul>\n<li><h3 id=\"你了解-React-吗？\"><a href=\"#你了解-React-吗？\" class=\"headerlink\" title=\"你了解 React 吗？\"></a>你了解 React 吗？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>了解，React 是 facebook 搞出来的一个轻量级的组件库，用于解决前端视图层的一些问题，就是 MVC 中V 层的问题，它内部的 Instagram 网站就是用 React 搭建的。</p>\n<ul>\n<li><h3 id=\"React-解决了什么问题？\"><a href=\"#React-解决了什么问题？\" class=\"headerlink\" title=\"React 解决了什么问题？\"></a>React 解决了什么问题？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>解决了三个问题： 1.组件复用问题， 2.性能问题，3.兼容性问题：</p>\n<ul>\n<li><h3 id=\"React-的协议？\"><a href=\"#React-的协议？\" class=\"headerlink\" title=\"React 的协议？\"></a>React 的协议？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>React 遵循的协议是“BSD 许可证 + 专利开源协议”，这个协议比较奇葩，如果你的产品跟 facebook 没有竞争关系，你可以自由的使用 React，但是如果有竞争关系，你的 React<br>的使用许可将会被取消</p>\n<ul>\n<li><h3 id=\"了解-shouldComponentUpdate-吗？\"><a href=\"#了解-shouldComponentUpdate-吗？\" class=\"headerlink\" title=\"了解 shouldComponentUpdate 吗？\"></a>了解 shouldComponentUpdate 吗？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>React 虚拟 dom 技术要求不断的将 dom 和虚拟 dom 进行 diff 比较，如果 dom 树比价大，这种比较操作会比较耗时，因此 React 提供了<br>shouldComponentUpdate 这种补丁函数，如果对于一些变化，如果我们不希望某个组件刷新，或者刷新后跟原来其实一样，就可以使用这个函数直接告诉 React，省去 diff<br>操作，进一步的提高了效率。</p>\n<ul>\n<li><h3 id=\"React-的工作原理？\"><a href=\"#React-的工作原理？\" class=\"headerlink\" title=\"React 的工作原理？\"></a>React 的工作原理？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>React 会创建一个虚拟 DOM(virtual DOM)。当一个组件中的状态改变时，React 首先会通过 “diffing” 算法来标记虚拟 DOM<br>中的改变，第二步是调节(reconciliation)，会用 diff 的结果来更新 DOM。</p>\n<ul>\n<li><h3 id=\"使用-React-有何优点？\"><a href=\"#使用-React-有何优点？\" class=\"headerlink\" title=\"使用 React 有何优点？\"></a>使用 React 有何优点？</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>只需查看 render 函数就会很容易知道一个组件是如何被渲染的</p>\n</li>\n<li><p>JSX 的引入，使得组件的代码更加可读，也更容易看懂组件的布局，或者组件之间是如何互相引用的</p>\n</li>\n<li><p>支持服务端渲染，这可以改进 SEO 和性能</p>\n</li>\n<li><p>易于测试</p>\n</li>\n<li><p>React 只关注 View 层，所以可以和其它任何框架(如 Backbone.js, Angular.js)一起使用</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"展示组件-Presentational-component-和容器组件-Container-component-之间有何不同？\"><a href=\"#展示组件-Presentational-component-和容器组件-Container-component-之间有何不同？\" class=\"headerlink\" title=\"展示组件(Presentational component)和容器组件(Container component)之间有何不同？\"></a>展示组件(Presentational component)和容器组件(Container component)之间有何不同？</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。</p>\n</li>\n<li><p>容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 Flux<br>actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"类组件-Class-component-和函数式组件-Functional-component-之间有何不同？\"><a href=\"#类组件-Class-component-和函数式组件-Functional-component-之间有何不同？\" class=\"headerlink\" title=\"类组件(Class component)和函数式组件(Functional component)之间有何不同？\"></a>类组件(Class component)和函数式组件(Functional component)之间有何不同？</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态</p>\n</li>\n<li><p>当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 ‘无状态组件(stateless<br>component)’，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"组件的-状态-state-和属性-props-之间有何不同？\"><a href=\"#组件的-状态-state-和属性-props-之间有何不同？\" class=\"headerlink\" title=\"(组件的)状态(state)和属性(props)之间有何不同？\"></a>(组件的)状态(state)和属性(props)之间有何不同？</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li><p>State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。</p>\n</li>\n<li><p>Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的<br>props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据–回调函数也可以通过 props 传递。</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"应该在-React-组件的何处发起-Ajax-请求？\"><a href=\"#应该在-React-组件的何处发起-Ajax-请求？\" class=\"headerlink\" title=\"应该在 React 组件的何处发起 Ajax 请求？\"></a>应该在 React 组件的何处发起 Ajax 请求？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>在 React 组件中，应该在 componentDidMount 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到<br>DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在<br>componentDidMount 中发起网络请求将保证这有一个组件可以更新了。</p>\n<ul>\n<li><h3 id=\"在-React-中，refs-的作用是什么？\"><a href=\"#在-React-中，refs-的作用是什么？\" class=\"headerlink\" title=\"在 React 中，refs 的作用是什么？\"></a>在 React 中，refs 的作用是什么？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Refs 可以用于获取一个 DOM 节点或者 React 组件的引用。何时使用 refs 的好的示例有管理焦点/文本选择，触发命令动画，或者和第三方 DOM 库集成。你应该避免使用 String<br>类型的 Refs 和内联的 ref 回调。Refs 回调是 React 所推荐的。</p>\n<ul>\n<li><h3 id=\"何为高阶组件-higher-order-component-？\"><a href=\"#何为高阶组件-higher-order-component-？\" class=\"headerlink\" title=\"何为高阶组件(higher order component)？\"></a>何为高阶组件(higher order component)？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC 最好的方式是共享<br>React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。</p>\n<ul>\n<li><h3 id=\"使用箭头函数-arrow-functions-的优点是什么？\"><a href=\"#使用箭头函数-arrow-functions-的优点是什么？\" class=\"headerlink\" title=\"使用箭头函数(arrow functions)的优点是什么？\"></a>使用箭头函数(arrow functions)的优点是什么？</h3></li>\n</ul>\n<p>参考回答：</p>\n<ol>\n<li>作用域安全：在箭头函数之前，每一个新创建的函数都有定义自身的 this 值(在构造函数中是新对象；在严格模式下，函数调用中的 this 是未定义的；如果函数被</li>\n</ol>\n<p>称为“对象方法”，则为基础对象等)，但箭头函数不会，它会使用封闭执行上下文的this 值。</p>\n<ol start=\"2\">\n<li><p>简单：箭头函数易于阅读和书写</p>\n</li>\n<li><p>清晰：当一切都是一个箭头函数，任何常规函数都可以立即用于定义作用域。开发者总是可以查找 next-higher 函数语句，以查看 this 的值</p>\n</li>\n</ol>\n<ul>\n<li><h3 id=\"为什么建议传递给-setState-的参数是一个-callback-而不是一个对象？\"><a href=\"#为什么建议传递给-setState-的参数是一个-callback-而不是一个对象？\" class=\"headerlink\" title=\"为什么建议传递给 setState 的参数是一个 callback 而不是一个对象？\"></a>为什么建议传递给 setState 的参数是一个 callback 而不是一个对象？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state。</p>\n<ul>\n<li><h3 id=\"除了在构造函数中绑定-this，还有其它方式吗？\"><a href=\"#除了在构造函数中绑定-this，还有其它方式吗？\" class=\"headerlink\" title=\"除了在构造函数中绑定 this，还有其它方式吗？\"></a>除了在构造函数中绑定 this，还有其它方式吗？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>可以使用属性初始值设定项(property initializers)来正确绑定回调，create- React-app<br>也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。</p>\n<ul>\n<li><h3 id=\"怎么阻止组件的渲染？\"><a href=\"#怎么阻止组件的渲染？\" class=\"headerlink\" title=\"怎么阻止组件的渲染？\"></a>怎么阻止组件的渲染？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>在组件的 render 方法中返回 null 并不会影响触发组件的生命周期方法</p>\n<ul>\n<li><h3 id=\"当渲染一个列表时，何为-key？设置-key-的目的是什么？\"><a href=\"#当渲染一个列表时，何为-key？设置-key-的目的是什么？\" class=\"headerlink\" title=\"当渲染一个列表时，何为 key？设置 key 的目的是什么？\"></a>当渲染一个列表时，何为 key？设置 key 的目的是什么？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>Keys 会有助于 React 识别哪些 items 改变了，被添加了或者被移除了。Keys 应该被赋予数组内的元素以赋予(DOM)元素一个稳定的标识，选择一个 key<br>的最佳方法是使用一个字符串，该字符串能惟一地标识一个列表项。很多时候你会使用数据中的 IDs 作为 keys，当你没有稳定的 IDs 用于被渲染的 items 时，可以使用项目索引作为渲染项的<br>key，但这种方式并不推荐，如果 items 可以重新排序，就会导致 re- render 变慢</p>\n<ul>\n<li>(在构造函数中)调用 super(props) 的目的是什么？</li>\n</ul>\n<p>参考回答：</p>\n<p>在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在constructor 中调用 super()。传递 props 给 super()<br>的原因则是便于(在子类中) 能在 constructor 访问 this.props。</p>\n<ul>\n<li><h3 id=\"何为-JSX-？\"><a href=\"#何为-JSX-？\" class=\"headerlink\" title=\"何为 JSX ？\"></a>何为 JSX ？</h3></li>\n</ul>\n<p>参考回答：</p>\n<p>JSX 是 JavaScript 语法的一种语法扩展，并拥有 JavaScript 的全部功能。JSX 生产 React “元素”，你可以将任何的 JavaScript<br>表达式封装在花括号里，然后将其嵌入到 JSX 中。在编译完成之后，JSX 表达式就变成了常规的 JavaScript 对象，这意味着你可以在 if 语句和 for 循环内部使用<br>JSX，将它赋值给变量，接受它作为参数，并从函数中返回它。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl75kqn2t0001yu3l4ulu2aat","category_id":"cl75kqn310004yu3l42zyecob","_id":"cl75kqn3i000gyu3l7quzffwm"},{"post_id":"cl75kqn2z0003yu3l5sb834w5","category_id":"cl75kqn310004yu3l42zyecob","_id":"cl75kqn3k000lyu3ld6pd02q7"},{"post_id":"cl75kqn3f000eyu3l41yp1zmk","category_id":"cl75kqn310004yu3l42zyecob","_id":"cl75kqn3u000qyu3l5y074h4p"},{"post_id":"cl75kqn350008yu3l38b1a4gq","category_id":"cl75kqn3h000fyu3l8xy6ffol","_id":"cl75kqn3v000tyu3l6uj43gdb"},{"post_id":"cl75kqn350009yu3l8ugc35cq","category_id":"cl75kqn3m000nyu3l4kmne2v2","_id":"cl75kqn3w000zyu3lclpp6367"},{"post_id":"cl75kqn3v000wyu3lg6mz1gml","category_id":"cl75kqn3v000uyu3lal1ehi7o","_id":"cl75kqn3y0015yu3lhy7i3t5z"},{"post_id":"cl75kqn3i000iyu3l9svhhi0v","category_id":"cl75kqn3v000uyu3lal1ehi7o","_id":"cl75kqn3y0017yu3l2ztkdu6o"},{"post_id":"cl75kqn3w000yyu3l9dcz9dtr","category_id":"cl75kqn3v000uyu3lal1ehi7o","_id":"cl75kqn40001byu3l5kt444g1"},{"post_id":"cl75kqn3x0011yu3l4uglah2n","category_id":"cl75kqn3v000uyu3lal1ehi7o","_id":"cl75kqn40001eyu3lhfxydpbz"},{"post_id":"cl75kqn3y0016yu3lfelz49fn","category_id":"cl75kqn3w0010yu3l4r3bdnsj","_id":"cl75kqn41001iyu3l3w15h00z"},{"post_id":"cl75kqn3j000kyu3lcjd91mbx","category_id":"cl75kqn3w0010yu3l4r3bdnsj","_id":"cl75kqn42001myu3l4y1520j9"},{"post_id":"cl75kqn3j000kyu3lcjd91mbx","category_id":"cl75kqn3v000uyu3lal1ehi7o","_id":"cl75kqn43001pyu3l7d030f99"},{"post_id":"cl75kqn40001dyu3l7vo89zjo","category_id":"cl75kqn3v000uyu3lal1ehi7o","_id":"cl75kqn43001ryu3ldlf1bdnw"},{"post_id":"cl75kqn41001hyu3ldmkt88ky","category_id":"cl75kqn3v000uyu3lal1ehi7o","_id":"cl75kqn44001tyu3l33o18bst"},{"post_id":"cl75kqn3u000syu3l7k1a10v1","category_id":"cl75kqn3v000uyu3lal1ehi7o","_id":"cl75kqn44001vyu3l4omnd05e"},{"post_id":"cl75kqn3o000pyu3lfo2w0kgl","category_id":"cl75kqn3w0010yu3l4r3bdnsj","_id":"cl75kqn44001xyu3lcf3icd6h"},{"post_id":"cl75kqn3o000pyu3lfo2w0kgl","category_id":"cl75kqn3v000uyu3lal1ehi7o","_id":"cl75kqn44001zyu3l4yy30hqn"},{"post_id":"cl75kqn41001kyu3l8bqh41w5","category_id":"cl75kqn3v000uyu3lal1ehi7o","_id":"cl75kqn450021yu3l6ks20ldo"},{"post_id":"cl75kqn42001oyu3lfr5p2jmn","category_id":"cl75kqn42001lyu3l4fhlcqrn","_id":"cl75kqn450023yu3l3ugoc3bu"},{"post_id":"cl75kqn3x0014yu3l00m94s4j","category_id":"cl75kqn42001lyu3l4fhlcqrn","_id":"cl75kqn450024yu3l4oqgblx7"},{"post_id":"cl75kqn4i002nyu3l41ti0n64","category_id":"cl75kqn310004yu3l42zyecob","_id":"cl75kqn4k002syu3la2ggfj8g"},{"post_id":"cl75kqn4d002iyu3l1w079pp5","category_id":"cl75kqn4f002kyu3lb0xb02m0","_id":"cl75kqn4k002tyu3l810bce6t"},{"post_id":"cl75kqn4e002jyu3l3ketaj5a","category_id":"cl75kqn4j002oyu3lcbtq4o3s","_id":"cl75kqn4k002vyu3l7hzv6y35"},{"post_id":"cl75kqn4l002wyu3l4lhb1e7f","category_id":"cl75kqn4m002xyu3l9hdicbbk","_id":"cl75kqn4m0030yu3l8m5mdnln"},{"post_id":"cl75kqn4p0031yu3lc9ypavik","category_id":"cl75kqn310004yu3l42zyecob","_id":"cl75kqn4p0033yu3l3hdqamac"}],"PostTag":[{"post_id":"cl75kqn2t0001yu3l4ulu2aat","tag_id":"cl75kqn320005yu3leglv8ct5","_id":"cl75kqn3b000cyu3ldu9a2lnt"},{"post_id":"cl75kqn2z0003yu3l5sb834w5","tag_id":"cl75kqn36000byu3l9zjlbtsc","_id":"cl75kqn3j000jyu3lgaf25z3d"},{"post_id":"cl75kqn3f000eyu3l41yp1zmk","tag_id":"cl75kqn36000byu3l9zjlbtsc","_id":"cl75kqn3k000myu3l5yy1hsuj"},{"post_id":"cl75kqn350008yu3l38b1a4gq","tag_id":"cl75kqn3i000hyu3lfdgy81xp","_id":"cl75kqn3u000ryu3l5ssx0cxx"},{"post_id":"cl75kqn350009yu3l8ugc35cq","tag_id":"cl75kqn3n000oyu3l11ymauak","_id":"cl75kqn3w000xyu3lasks0nph"},{"post_id":"cl75kqn3i000iyu3l9svhhi0v","tag_id":"cl75kqn3v000vyu3l30e6dzfv","_id":"cl75kqn3x0013yu3lbh68dho4"},{"post_id":"cl75kqn3j000kyu3lcjd91mbx","tag_id":"cl75kqn3x0012yu3leb8g45of","_id":"cl75kqn40001cyu3l9065cw49"},{"post_id":"cl75kqn3o000pyu3lfo2w0kgl","tag_id":"cl75kqn3z0019yu3ldusd7bgy","_id":"cl75kqn41001jyu3lb62tfuhh"},{"post_id":"cl75kqn3u000syu3l7k1a10v1","tag_id":"cl75kqn41001gyu3l8xhk7xyq","_id":"cl75kqn43001qyu3lcapqcyqv"},{"post_id":"cl75kqn3v000wyu3lg6mz1gml","tag_id":"cl75kqn41001gyu3l8xhk7xyq","_id":"cl75kqn44001uyu3l458qdp8j"},{"post_id":"cl75kqn3w000yyu3l9dcz9dtr","tag_id":"cl75kqn41001gyu3l8xhk7xyq","_id":"cl75kqn44001yyu3l3s80f10n"},{"post_id":"cl75kqn3x0011yu3l4uglah2n","tag_id":"cl75kqn41001gyu3l8xhk7xyq","_id":"cl75kqn450022yu3ldkn1hqx4"},{"post_id":"cl75kqn3x0014yu3l00m94s4j","tag_id":"cl75kqn450020yu3ld72p2fzi","_id":"cl75kqn450026yu3lenz05064"},{"post_id":"cl75kqn3y0016yu3lfelz49fn","tag_id":"cl75kqn450025yu3l4f9h41ty","_id":"cl75kqn480028yu3l7kz96tb3"},{"post_id":"cl75kqn40001dyu3l7vo89zjo","tag_id":"cl75kqn450027yu3lbvgp1o5z","_id":"cl75kqn48002byu3lhlmu0i8c"},{"post_id":"cl75kqn40001dyu3l7vo89zjo","tag_id":"cl75kqn480029yu3l3f5zd2ry","_id":"cl75kqn48002cyu3l2h5y40m8"},{"post_id":"cl75kqn41001hyu3ldmkt88ky","tag_id":"cl75kqn480029yu3l3f5zd2ry","_id":"cl75kqn49002eyu3lexm1c7bh"},{"post_id":"cl75kqn41001kyu3l8bqh41w5","tag_id":"cl75kqn480029yu3l3f5zd2ry","_id":"cl75kqn4a002gyu3l5kc173ke"},{"post_id":"cl75kqn42001oyu3lfr5p2jmn","tag_id":"cl75kqn49002fyu3lcuhu6385","_id":"cl75kqn4a002hyu3l2x6zasrz"},{"post_id":"cl75kqn4i002nyu3l41ti0n64","tag_id":"cl75kqn36000byu3l9zjlbtsc","_id":"cl75kqn4k002qyu3lbdjl1mcv"},{"post_id":"cl75kqn4d002iyu3l1w079pp5","tag_id":"cl75kqn4g002lyu3lamui2v0w","_id":"cl75kqn4k002ryu3l6bjigk04"},{"post_id":"cl75kqn4e002jyu3l3ketaj5a","tag_id":"cl75kqn4k002pyu3lc1xh87dv","_id":"cl75kqn4k002uyu3lc6v50v1o"},{"post_id":"cl75kqn4l002wyu3l4lhb1e7f","tag_id":"cl75kqn4m002yyu3lap5rbt20","_id":"cl75kqn4m002zyu3lebz9clf0"},{"post_id":"cl75kqn4p0031yu3lc9ypavik","tag_id":"cl75kqn36000byu3l9zjlbtsc","_id":"cl75kqn4p0032yu3l007f0o0n"}],"Tag":[{"name":"前端实习生","_id":"cl75kqn320005yu3leglv8ct5"},{"name":"前端","_id":"cl75kqn36000byu3l9zjlbtsc"},{"name":"Mobx","_id":"cl75kqn3i000hyu3lfdgy81xp"},{"name":"webpack","_id":"cl75kqn3n000oyu3l11ymauak"},{"name":"React TypeScript","_id":"cl75kqn3v000vyu3l30e6dzfv"},{"name":"useEffect","_id":"cl75kqn3x0012yu3leb8g45of"},{"name":"useCallback","_id":"cl75kqn3z0019yu3ldusd7bgy"},{"name":"Hook","_id":"cl75kqn41001gyu3l8xhk7xyq"},{"name":"utils","_id":"cl75kqn450020yu3ld72p2fzi"},{"name":"闭包","_id":"cl75kqn450025yu3l4f9h41ty"},{"name":"React","_id":"cl75kqn450027yu3lbvgp1o5z"},{"name":"HooK","_id":"cl75kqn480029yu3l3f5zd2ry"},{"name":"map","_id":"cl75kqn49002fyu3lcuhu6385"},{"name":"vscode","_id":"cl75kqn4g002lyu3lamui2v0w"},{"name":"Vue3","_id":"cl75kqn4k002pyu3lc1xh87dv"},{"name":"TypeScript","_id":"cl75kqn4m002yyu3lap5rbt20"}]}}