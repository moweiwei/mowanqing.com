{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1},{"_id":"source/img/2021-12-01-1.png","path":"img/2021-12-01-1.png","modified":1,"renderable":0},{"_id":"source/img/2021-12-15-1.png","path":"img/2021-12-15-1.png","modified":1,"renderable":0},{"_id":"source/img/2021-12-22-1.png","path":"img/2021-12-22-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-01-1.jpeg","path":"img/2022-01-01-1.jpeg","modified":1,"renderable":0},{"_id":"source/img/2022-01-13-1.png","path":"img/2022-01-13-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-14-1.png","path":"img/2022-01-14-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-14-2.png","path":"img/2022-01-14-2.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-14-3.png","path":"img/2022-01-14-3.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-22-1.jpeg","path":"img/2022-01-22-1.jpeg","modified":1,"renderable":0},{"_id":"source/img/2022-01-24-1.png","path":"img/2022-01-24-1.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-24-2.png","path":"img/2022-01-24-2.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-24-3.png","path":"img/2022-01-24-3.png","modified":1,"renderable":0},{"_id":"source/img/2022-01-24-4.png","path":"img/2022-01-24-4.png","modified":1,"renderable":0},{"_id":"source/img/2022-02-08-1.jpeg","path":"img/2022-02-08-1.jpeg","modified":1,"renderable":0},{"_id":"source/img/2022-02-16-1.jpeg","path":"img/2022-02-16-1.jpeg","modified":1,"renderable":0},{"_id":"source/img/2022-02-22-1.jpeg","path":"img/2022-02-22-1.jpeg","modified":1,"renderable":0},{"_id":"source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":0},{"_id":"source/img/default.jpg","path":"img/default.jpg","modified":1,"renderable":0},{"_id":"source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":0},{"_id":"source/img/index-img.png","path":"img/index-img.png","modified":1,"renderable":0},{"_id":"source/img/miaomiao.JPG","path":"img/miaomiao.JPG","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"76aac0ad9b5cf8b05622ca5b0d56a11dfb93bd6b","modified":1646013422426},{"_id":"source/_drafts/2021-12-15-1.md","hash":"dc59ebbc7e5d0b68acb8759164c74e1ffd63bd2a","modified":1646102800356},{"_id":"source/_drafts/2022-01-01-1.md","hash":"4b3f2936993a7da0441c1c591e932b7e4fcd2fc5","modified":1646534265437},{"_id":"source/_drafts/2022-02-08-1.md","hash":"65d14b79d69b3bc74275d3247784fbc5dfa63a3e","modified":1646102805810},{"_id":"source/_posts/2022-01-01-1.md","hash":"711571da1ab4609336ab5b261f9d348ef22a62c6","modified":1646561282020},{"_id":"source/_drafts/2021-12-22-1.md","hash":"9451cd81dc24149e0aa36981010b2bf5e845b6fa","modified":1646102803070},{"_id":"source/_drafts/2022-02-22-1.md","hash":"8e9b37c10d7938e1295824780aa62dd35c4b1443","modified":1646186560709},{"_id":"source/_posts/2021-12-01-1.md","hash":"b409f3cc70c74732362f1ab9b98c269c0d2b531e","modified":1646103372118},{"_id":"source/_posts/2022-01-13-1.md","hash":"a81748df39bbc7f339ce166670daecd5252cf864","modified":1646103372117},{"_id":"source/_posts/2022-01-14-3.md","hash":"dbc4124c1e5d4e14d87040cef30da1d92e08e3f4","modified":1646103372119},{"_id":"source/_posts/2022-01-14-2.md","hash":"752a5a596d426c067bceca23ad460c76fe9bc1eb","modified":1646103372119},{"_id":"source/_posts/2022-01-14-1.md","hash":"1ea53e212b4364debaa0b1ba30f01246c55d4ad9","modified":1646103372115},{"_id":"source/_posts/2022-01-22-1.md","hash":"7136e5e112fc88a8139a4384ddba4edb1baff547","modified":1646103372121},{"_id":"source/about/index.md","hash":"620975b1605593924abc83376419b88505002570","modified":1646117194534},{"_id":"source/_posts/2022-02-15-1.md","hash":"28bc58841e3e48526800802ce5690f190dfb7348","modified":1646103372120},{"_id":"source/css/custom.css","hash":"f24fec7800ead60a19749e06b7f7f64c00a4633d","modified":1645772214842},{"_id":"source/img/2021-12-01-1.png","hash":"62808e649d5dd5c68db4bad0bc894d3e8158e784","modified":1646102636847},{"_id":"source/img/.DS_Store","hash":"e08573c5d06518bf87ab62165176cc6eee9fa975","modified":1646126682526},{"_id":"source/img/2021-12-15-1.png","hash":"0bb7c1fe8c45832813e1b155a1b93859bdb64d6c","modified":1646015938987},{"_id":"source/img/2022-01-01-1.jpeg","hash":"637bfc4c59e0448a36da0992dab88b32449bacc2","modified":1646014956663},{"_id":"source/img/2022-01-13-1.png","hash":"ca711c0f3099cc42172cb5b0e72a322d7f6d3eae","modified":1646015981781},{"_id":"source/img/2022-01-14-1.png","hash":"457563e3b79c3c5f22d065b8bb966b58ed413e77","modified":1646016128450},{"_id":"source/img/2022-01-14-2.png","hash":"1b573758b98a28cb7b9f276413152c4ff826ea38","modified":1646016169557},{"_id":"source/img/2022-01-14-3.png","hash":"038e34cdfb8ee37c9b12ce22a931c3f54b765756","modified":1646016196232},{"_id":"source/img/2022-01-24-1.png","hash":"7cac7a9aef2c512af1e8b8b1cc8a8b20cac94745","modified":1646016262776},{"_id":"source/img/2022-01-24-2.png","hash":"6fa5684418ffd50020153e1173830e3d8ee71327","modified":1646016305143},{"_id":"source/img/2022-01-22-1.jpeg","hash":"104465a44f28ae47be6bb42740896883fc6e9d97","modified":1646016233814},{"_id":"source/img/2022-01-24-3.png","hash":"30f86b353805b575ed8516fccb258143fa79d01e","modified":1646016394604},{"_id":"source/img/2022-01-24-4.png","hash":"868d8a69b778000e352ab17d22aa72c3b8eed312","modified":1646016437004},{"_id":"source/img/2022-02-08-1.jpeg","hash":"3e4ed33f30d6f54d5bf437062ec55c6348a4fc66","modified":1646016830499},{"_id":"source/img/2022-02-16-1.jpeg","hash":"c049a498846cbc8d2bf6e45be0b43c97fd3d9edf","modified":1646016606165},{"_id":"source/img/2022-02-22-1.jpeg","hash":"e34dc1856ace7e149c338048fbc92d21d21d8cd1","modified":1646016746310},{"_id":"source/img/avatar.png","hash":"7ba2b5e584fdcff16ac464c31012e0717df0e154","modified":1642143447663},{"_id":"source/js/custom.js","hash":"c8d2f0fa59c1803a6d50f5976d08525b518332c7","modified":1645769871072},{"_id":"source/img/favicon.png","hash":"7ba2b5e584fdcff16ac464c31012e0717df0e154","modified":1642143447663},{"_id":"source/img/miaomiao.JPG","hash":"60b94fd56002070d8be535b35adfef67f0b4be6c","modified":1642146142925},{"_id":"source/img/2021-12-22-1.png","hash":"023912be2857823f083116c0bb43078f83cb9c2a","modified":1646014018177},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"source/img/index-img.png","hash":"f7314828a14a3e236deecbe33816f99d0f65c5cf","modified":1646016966643},{"_id":"node_modules/hexo-theme-fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"df5b54be535593d5442cebafbea34eb9bd69b987","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"03cfa8e5f149514b57ef80dcb84eb7fea261370d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"ee5f90b4642735bb42161c389e4b86b00bc4fac5","modified":1642149993961},{"_id":"node_modules/hexo-theme-fluid/README_en.md","hash":"ca8fd19a4948de1f253616a62c0e8a7d81f692f5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"8a7f1534c228538e2ab56249d5a65829650170ed","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"13a6a799415fc2f6f69ebd1a399fb44426a5d641","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a0c7984495d4f2d33b64adfa33adebbf768a5ac3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"1a6d415446da11dee5c5f400e7d67544fbe743ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"ad6fed7b646d3ca961db83db0fbe020e3a5d42ad","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"f3ae4395e751c4a02d5895e07856b1e8edfdda08","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"58291dfec65c36889dfce0ddc603540b67e4c598","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"472d0813ca5b88000a7bc6039f33b7e27b5a3216","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"20c2a195a109d2a263b5fa6e79cbcc62932508ad","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7f566edf750241e62d7c54abfbb0c504fdab850a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"2a7b49f0f9aecf07550b5a0b99242aab5654cf2b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"1014b901d396f4fc445cb1ffc938d5380d894d71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"0ad89eb7c92a822980fa9a85285e6d94ad845d1d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"16d33eb89ecf90f4046720fde5395d972c7ba1fd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"79e3679a7069351a6172c281b9d09f59d7580484","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"af977ed0792508bb0766ea8afe82d34ef1e8fb3c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"44faef3e77ab08b91e4c5c6f1cd9087a9faff443","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"6c37e9f1ac1d6d00b3c32794e02e244dba942cd9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"cde964c8cd3217268a231de5e018a62c53c2e047","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"3aa5b4ea879cd34d3a32468d88da18d72cbcc8e0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"b917b893b1777e6ffcb53188f9f5644510e5f20d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"649457796374c79e49a19bd541e4ad8e78fe8995","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/beian.ejs","hash":"58b4bbe36386de4305a8da5ffd7d56802df23049","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/css.ejs","hash":"c363829a4b80f74fc1c565e41f6dab41c95006ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/archive-list.ejs","hash":"53a4f6029373a40394a87aba9284696a71610f90","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/footer.ejs","hash":"a62278c38a310da495d96c39abacacef266945cb","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/nav.ejs","hash":"e71b3c4aa263163597d31b1f91e5a1a877084cfd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/scripts.ejs","hash":"0ee838b6fcd895d21a29d9d67dbb99b752d623d1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/head.ejs","hash":"f7f3494ed001e8cdcdc3e8a1d2cd1195cff2ded5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/post-meta.ejs","hash":"32a17edadeed40da6db21d2d8031bd47d2fc9bf4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/toc.ejs","hash":"3d2fb5552f373e5a0c56bc356702d807bcbcb411","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"f1fdd512f3ef92ff5db4a49f5a3143d5ddea9858","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"633f0142c657805359b0197f287e12ae4bcde731","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"53987b7a668ea0623370eb83ed5311766221b557","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"b5fd5a2d9c463eb59318af0f47c591c485b6ad27","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"28e186c32576eb3d5d923273471a001c47fe8071","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"fd5fcb6a61ad865197a778eeae889b80484227dd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"c1db1a4f9eca6e36b660530641e3a4fb6a30c8d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"d058f30bd09b28769c4d8313428ff23dfc8d52dd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"4a43f2700e91937650bef511fd438825b001c4c6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/twikoo.ejs","hash":"1af53bc0be642610a3a4d4e7c05287854a821508","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/utterances.ejs","hash":"e1ed6530dfd7310f91060a75766a93ac3c39be3a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/valine.ejs","hash":"4052ab2a8f78efa92f0fe17abe8f66135943390a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/waline.ejs","hash":"21e00443054802e893aac1f668b69d5bb4b39b3a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/math.ejs","hash":"df6941bd3b860180d01fd39ee859ed2d42f4d1f0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/typed.ejs","hash":"e8e01c5db46b383748855452aecd70fcda99f598","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"08b455b848b21d57e0563b87071c4bae2b63bafe","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"c2d8bfd04bf0734b387c049402b46a06a05fc582","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"80098e8354069631bde8edcd1181a53091a92949","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"d547ab0b91f84eb0acd0bc0c5d716ce17c30361a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/rewrite.styl","hash":"a2993f23701de9a83e3f428300e62c5c52b4ff4b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"616c1f7147078c3d532dd1cfd2af09c0c3a816f0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post.styl","hash":"5e86487de0f16c30ca3e16460ab94b57620e31c5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/tag_plugin.styl","hash":"b89b96c8a6a433a6f372b42710554b05cab85a24","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"7e32a3268accf3d524209c213e15e2d5d5e2e1a6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"30f8fab95a5214d79df0ccc02b937df8bd885676","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"9f932ca3f9625c13aa5353f58319881e62c0c653","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"0ce7552dc4993926426019398d73e817cfd841a1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"d8011325756eb6e4ce619b3e7b4d6d80c2de8a57","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"55e10a6965462f8f62f85e75fd5e143af02a4b44","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":499162500000},{"_id":"source/img/default.jpg","hash":"d48e1d1c2a174a0286776448c0e74f95aaa5fa5e","modified":1645520847967},{"_id":"public/css/custom.css","hash":"f24fec7800ead60a19749e06b7f7f64c00a4633d","modified":1646561286505},{"_id":"public/js/custom.js","hash":"c8d2f0fa59c1803a6d50f5976d08525b518332c7","modified":1646561286505},{"_id":"public/baidusitemap.xml","hash":"ae785f62c40896624b725972acac320d7549ca83","modified":1646561286505},{"_id":"public/atom.xml","hash":"cec042fad4ffb508dc8053798a5ce2a49014739c","modified":1646561286505},{"_id":"public/sitemap.xml","hash":"12e9c3f29a2bd6694aa26307fd2a99e1d0f7144b","modified":1646561286505},{"_id":"public/local-search.xml","hash":"8c17086ba3aac9dd644fb969d9698f92d09290b6","modified":1646561286505},{"_id":"public/about/index.html","hash":"7f5aae8ce4e61e4c77602a4324aeb775b4ce91a0","modified":1646561286505},{"_id":"public/archives/2021/index.html","hash":"69c5cc4a715eb02ac7eb6d140267de1e2a4e0f01","modified":1646561286505},{"_id":"public/archives/2021/12/index.html","hash":"ef443ce37bed3d7295740f193208863142d42408","modified":1646561286505},{"_id":"public/archives/index.html","hash":"9b8ccef70739d5e6569883c1af032cdf9d16857b","modified":1646561286505},{"_id":"public/archives/2022/index.html","hash":"e52312de09a40a55a06813c675766ced0a78934f","modified":1646561286505},{"_id":"public/archives/2022/01/index.html","hash":"5f845e2fa338fdbfaf19a8461eed4c200fbc4c60","modified":1646561286505},{"_id":"public/archives/2022/02/index.html","hash":"4b7e4d8f9981a80e31b6e5351a090290e8030cc5","modified":1646561286505},{"_id":"public/categories/JS/index.html","hash":"bb553dd3c6fc31d7f97dfbef8798c8aa44a8991d","modified":1646561286505},{"_id":"public/categories/面试/index.html","hash":"2c49e062d290f743557b617d915f8c83196a56f1","modified":1646561286505},{"_id":"public/categories/React/index.html","hash":"2a84cce76370f14f7c54c8b2e24a6fdfcc10a407","modified":1646561286505},{"_id":"public/categories/Vue/index.html","hash":"ed3ff0d3125540c7dfdd29fffcf21180a503d151","modified":1646561286505},{"_id":"public/tags/React/index.html","hash":"10b757b488edca2442e7c7048c4e2a48386b4626","modified":1646561286505},{"_id":"public/tags/HooK/index.html","hash":"46b7fb650de57e7e0da2444769a4460fa336e923","modified":1646561286505},{"_id":"public/tags/map/index.html","hash":"121eaa9a05d142209e42b1c286553f2c56c282b9","modified":1646561286505},{"_id":"public/tags/前端/index.html","hash":"654583965c15e1596ac3f127e38354a4367e6b15","modified":1646561286505},{"_id":"public/tags/面试/index.html","hash":"3fd18a9616ef9e1f734bda6c60d019d442ff86bc","modified":1646561286505},{"_id":"public/tags/Vue3/index.html","hash":"ea8c26ab843d5bd377a52e2e04e11089d8316e0a","modified":1646561286505},{"_id":"public/tags/index.html","hash":"83e13521c905b1f117771e3d2704012b8d5dfcea","modified":1646561286505},{"_id":"public/categories/index.html","hash":"d6e12fa6a4e6b8ce460a17edde1e51f911fcf31c","modified":1646561286505},{"_id":"public/404.html","hash":"2659a51e5a23c04da9856817d158a89d27d989e5","modified":1646561286505},{"_id":"public/links/index.html","hash":"26936002a591de2e2a711e935a8eb26eec0b8cd9","modified":1646561286505},{"_id":"public/posts/a18c0ac9/index.html","hash":"0ba46eb4e6b44764d9610fd5e15e271c702202fe","modified":1646561286505},{"_id":"public/posts/e372be48/index.html","hash":"310a29ccd6f97aadd975740789631d4cb07f7629","modified":1646561286505},{"_id":"public/posts/d177e434/index.html","hash":"4c6baad32c0d4a862058565d2df363366a7f8f34","modified":1646561286505},{"_id":"public/posts/ee7a9294/index.html","hash":"0e9f14446614d521878cecd579222f30f22cf2e1","modified":1646561286505},{"_id":"public/posts/b195fb80/index.html","hash":"8dba5988c5e6583ffee77abce9a81da6453c4a0f","modified":1646561286505},{"_id":"public/posts/bb88c12/index.html","hash":"92d8775c7a7fcc7c26292f452b8df7ea546a522b","modified":1646561286505},{"_id":"public/posts/12d2438b/index.html","hash":"16fabbd796391ea5430a604a4c05119eaba7a633","modified":1646561286505},{"_id":"public/posts/25d325e2/index.html","hash":"739a6638f1b6979ea026b1c707699d7977f321cd","modified":1646561286505},{"_id":"public/index.html","hash":"b52bf0270121c4d197266950f38378821e811821","modified":1646561286505},{"_id":"public/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1646561286505},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1646561286505},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1646561286505},{"_id":"public/img/favicon.png","hash":"7ba2b5e584fdcff16ac464c31012e0717df0e154","modified":1646561286505},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1646561286505},{"_id":"public/img/2021-12-01-1.png","hash":"62808e649d5dd5c68db4bad0bc894d3e8158e784","modified":1646561286505},{"_id":"public/img/2021-12-15-1.png","hash":"0bb7c1fe8c45832813e1b155a1b93859bdb64d6c","modified":1646561286505},{"_id":"public/img/2022-01-13-1.png","hash":"ca711c0f3099cc42172cb5b0e72a322d7f6d3eae","modified":1646561286505},{"_id":"public/img/2022-01-01-1.jpeg","hash":"637bfc4c59e0448a36da0992dab88b32449bacc2","modified":1646561286505},{"_id":"public/img/2022-01-14-1.png","hash":"457563e3b79c3c5f22d065b8bb966b58ed413e77","modified":1646561286505},{"_id":"public/img/2022-01-14-3.png","hash":"038e34cdfb8ee37c9b12ce22a931c3f54b765756","modified":1646561286505},{"_id":"public/img/2022-01-14-2.png","hash":"1b573758b98a28cb7b9f276413152c4ff826ea38","modified":1646561286505},{"_id":"public/img/2022-01-22-1.jpeg","hash":"104465a44f28ae47be6bb42740896883fc6e9d97","modified":1646561286505},{"_id":"public/img/2022-01-24-2.png","hash":"6fa5684418ffd50020153e1173830e3d8ee71327","modified":1646561286505},{"_id":"public/img/2022-01-24-3.png","hash":"30f86b353805b575ed8516fccb258143fa79d01e","modified":1646561286505},{"_id":"public/img/2022-01-24-4.png","hash":"868d8a69b778000e352ab17d22aa72c3b8eed312","modified":1646561286505},{"_id":"public/img/2022-02-08-1.jpeg","hash":"3e4ed33f30d6f54d5bf437062ec55c6348a4fc66","modified":1646561286505},{"_id":"public/img/2022-02-16-1.jpeg","hash":"c049a498846cbc8d2bf6e45be0b43c97fd3d9edf","modified":1646561286505},{"_id":"public/img/2022-02-22-1.jpeg","hash":"e34dc1856ace7e149c338048fbc92d21d21d8cd1","modified":1646561286505},{"_id":"public/img/2022-01-24-1.png","hash":"7cac7a9aef2c512af1e8b8b1cc8a8b20cac94745","modified":1646561286505},{"_id":"public/img/avatar.png","hash":"7ba2b5e584fdcff16ac464c31012e0717df0e154","modified":1646561286505},{"_id":"public/img/miaomiao.JPG","hash":"60b94fd56002070d8be535b35adfef67f0b4be6c","modified":1646561286505},{"_id":"public/img/2021-12-22-1.png","hash":"023912be2857823f083116c0bb43078f83cb9c2a","modified":1646561286505},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1646561286505},{"_id":"public/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":1646561286505},{"_id":"public/js/color-schema.js","hash":"f1fdd512f3ef92ff5db4a49f5a3143d5ddea9858","modified":1646561286505},{"_id":"public/js/local-search.js","hash":"633f0142c657805359b0197f287e12ae4bcde731","modified":1646561286505},{"_id":"public/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":1646561286505},{"_id":"public/js/leancloud.js","hash":"53987b7a668ea0623370eb83ed5311766221b557","modified":1646561286505},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1646561286505},{"_id":"public/js/utils.js","hash":"4a43f2700e91937650bef511fd438825b001c4c6","modified":1646561286505},{"_id":"public/js/plugins.js","hash":"d058f30bd09b28769c4d8313428ff23dfc8d52dd","modified":1646561286505},{"_id":"public/css/main.css","hash":"63bc59b8ca4b03afa2b93883143c349d461b1052","modified":1646561286505},{"_id":"public/img/index-img.png","hash":"f7314828a14a3e236deecbe33816f99d0f65c5cf","modified":1646561286505},{"_id":"public/img/default.jpg","hash":"d48e1d1c2a174a0286776448c0e74f95aaa5fa5e","modified":1646561286505}],"Category":[{"name":"JS","_id":"cl0f42s2g0004vw3lf8zyh7ry"},{"name":"webpack","_id":"cl0f42s2j000avw3l8ubbdv5i"},{"name":"Mobx","_id":"cl0f42s2n000gvw3lcyazasuo"},{"name":"面试","_id":"cl0f42s2p000mvw3l1oq7cphr"},{"name":"React","_id":"cl0f42s2r000svw3l5xln9m0y"},{"name":"Vue","_id":"cl0f42s30001fvw3l22miffh5"}],"Data":[],"Page":[{"title":"about","date":"2022-01-12T15:32:19.000Z","layout":"about","_content":"\n1、关于我\n\n```text\n  前端开发一枚、家有贤妻、女儿奴、有只蓝白，叫喵喵。\n```\n\n2、职业技能\n\n- 前端主流技术栈、框架\n- HTML、CSS、JS、TS\n- React 技术栈\n- Vue 技术栈\n- Node\n- Kubernetes、Docker 简单概念，日常操作, CKA\n\n3、工作状况\n\n- 目前就职于九州云\n- 容器云相关\n\n4、学习计划\n\n- 深入学习 React\n\n5、联系我\n\n- Email: moweiwei6@gmail.com\n- GitHub: https://github.com/moweiwei\n\n6、END\n\n- Stay hungry. Stay foolish.\n- 知人者智，自知者明。胜人者有力，自胜者强。\n\n---\n\n![](/img/miaomiao.JPG)\n\n---\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2022-01-12 23:32:19\nlayout: about\n---\n\n1、关于我\n\n```text\n  前端开发一枚、家有贤妻、女儿奴、有只蓝白，叫喵喵。\n```\n\n2、职业技能\n\n- 前端主流技术栈、框架\n- HTML、CSS、JS、TS\n- React 技术栈\n- Vue 技术栈\n- Node\n- Kubernetes、Docker 简单概念，日常操作, CKA\n\n3、工作状况\n\n- 目前就职于九州云\n- 容器云相关\n\n4、学习计划\n\n- 深入学习 React\n\n5、联系我\n\n- Email: moweiwei6@gmail.com\n- GitHub: https://github.com/moweiwei\n\n6、END\n\n- Stay hungry. Stay foolish.\n- 知人者智，自知者明。胜人者有力，自胜者强。\n\n---\n\n![](/img/miaomiao.JPG)\n\n---\n","updated":"2022-03-01T06:46:34.534Z","path":"about/index.html","comments":1,"_id":"cl0f42s270000vw3l2hw0fazh","content":"<p>1、关于我</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs text\">前端开发一枚、家有贤妻、女儿奴、有只蓝白，叫喵喵。<br></code></pre></div></td></tr></table></figure>\n\n<p>2、职业技能</p>\n<ul>\n<li>前端主流技术栈、框架</li>\n<li>HTML、CSS、JS、TS</li>\n<li>React 技术栈</li>\n<li>Vue 技术栈</li>\n<li>Node</li>\n<li>Kubernetes、Docker 简单概念，日常操作, CKA</li>\n</ul>\n<p>3、工作状况</p>\n<ul>\n<li>目前就职于九州云</li>\n<li>容器云相关</li>\n</ul>\n<p>4、学习计划</p>\n<ul>\n<li>深入学习 React</li>\n</ul>\n<p>5、联系我</p>\n<ul>\n<li>Email: <a href=\"mailto:&#109;&#111;&#119;&#101;&#105;&#119;&#101;&#105;&#x36;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;\">&#109;&#111;&#119;&#101;&#105;&#119;&#101;&#105;&#x36;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;</a></li>\n<li>GitHub: <a href=\"https://github.com/moweiwei\">https://github.com/moweiwei</a></li>\n</ul>\n<p>6、END</p>\n<ul>\n<li>Stay hungry. Stay foolish.</li>\n<li>知人者智，自知者明。胜人者有力，自胜者强。</li>\n</ul>\n<hr>\n<p><img src=\"/img/miaomiao.JPG\"></p>\n<hr>\n","site":{"data":{}},"wordcount":347,"excerpt":"","more":"<p>1、关于我</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">前端开发一枚、家有贤妻、女儿奴、有只蓝白，叫喵喵。<br></code></pre></td></tr></table></figure>\n\n<p>2、职业技能</p>\n<ul>\n<li>前端主流技术栈、框架</li>\n<li>HTML、CSS、JS、TS</li>\n<li>React 技术栈</li>\n<li>Vue 技术栈</li>\n<li>Node</li>\n<li>Kubernetes、Docker 简单概念，日常操作, CKA</li>\n</ul>\n<p>3、工作状况</p>\n<ul>\n<li>目前就职于九州云</li>\n<li>容器云相关</li>\n</ul>\n<p>4、学习计划</p>\n<ul>\n<li>深入学习 React</li>\n</ul>\n<p>5、联系我</p>\n<ul>\n<li>Email: <a href=\"mailto:&#109;&#111;&#119;&#101;&#105;&#119;&#101;&#105;&#x36;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;\">&#109;&#111;&#119;&#101;&#105;&#119;&#101;&#105;&#x36;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;</a></li>\n<li>GitHub: <a href=\"https://github.com/moweiwei\">https://github.com/moweiwei</a></li>\n</ul>\n<p>6、END</p>\n<ul>\n<li>Stay hungry. Stay foolish.</li>\n<li>知人者智，自知者明。胜人者有力，自胜者强。</li>\n</ul>\n<hr>\n<p><img src=\"/img/miaomiao.JPG\"></p>\n<hr>\n"},{"_content":"/* 代码块折叠 */\nfigure.highlight {\n  background: #21252b;\n  border-radius: 0.5rem;\n}\nfigure.highlight table {\n  border-radius: 0 0 0.5rem 0.5rem;\n}\nfigure.highlight > i {\n  color: #777;\n  margin-left: 10px;\n  line-height: 2rem;\n  transform: rotate(90deg);\n  transition: transform 0.2s ease-in-out;\n}\nfigure.highlight > i.collapsed {\n  transform: rotate(0deg);\n}\nfigure.highlight > span {\n  color: #777;\n  margin-left: 5px;\n  font-size: 0.875rem;\n}\nfigure.highlight td:first-child {\n  position: sticky;\n  left: 0;\n  z-index: 1;\n}\nfigure.highlight > i:before {\n  content: \"\\f2c3\";\n}\n\n/* 复制 */\n.copy-btn {\n  top: 5px;\n  font-size: 0.875rem;\n}\n.copy-btn > i {\n  font-size: 0.875rem;\n}\n.copy-btn-dark {\n  color: #2f4f4f;\n}\n","source":"css/custom.css","raw":"/* 代码块折叠 */\nfigure.highlight {\n  background: #21252b;\n  border-radius: 0.5rem;\n}\nfigure.highlight table {\n  border-radius: 0 0 0.5rem 0.5rem;\n}\nfigure.highlight > i {\n  color: #777;\n  margin-left: 10px;\n  line-height: 2rem;\n  transform: rotate(90deg);\n  transition: transform 0.2s ease-in-out;\n}\nfigure.highlight > i.collapsed {\n  transform: rotate(0deg);\n}\nfigure.highlight > span {\n  color: #777;\n  margin-left: 5px;\n  font-size: 0.875rem;\n}\nfigure.highlight td:first-child {\n  position: sticky;\n  left: 0;\n  z-index: 1;\n}\nfigure.highlight > i:before {\n  content: \"\\f2c3\";\n}\n\n/* 复制 */\n.copy-btn {\n  top: 5px;\n  font-size: 0.875rem;\n}\n.copy-btn > i {\n  font-size: 0.875rem;\n}\n.copy-btn-dark {\n  color: #2f4f4f;\n}\n","date":"2022-02-25T06:56:54.842Z","updated":"2022-02-25T06:56:54.842Z","path":"css/custom.css","layout":"false","title":"","comments":1,"_id":"cl0f42s2f0002vw3lg1ov6s55","content":"/* 代码块折叠 */\nfigure.highlight {\n  background: #21252b;\n  border-radius: 0.5rem;\n}\nfigure.highlight table {\n  border-radius: 0 0 0.5rem 0.5rem;\n}\nfigure.highlight > i {\n  color: #777;\n  margin-left: 10px;\n  line-height: 2rem;\n  transform: rotate(90deg);\n  transition: transform 0.2s ease-in-out;\n}\nfigure.highlight > i.collapsed {\n  transform: rotate(0deg);\n}\nfigure.highlight > span {\n  color: #777;\n  margin-left: 5px;\n  font-size: 0.875rem;\n}\nfigure.highlight td:first-child {\n  position: sticky;\n  left: 0;\n  z-index: 1;\n}\nfigure.highlight > i:before {\n  content: \"\\f2c3\";\n}\n\n/* 复制 */\n.copy-btn {\n  top: 5px;\n  font-size: 0.875rem;\n}\n.copy-btn > i {\n  font-size: 0.875rem;\n}\n.copy-btn-dark {\n  color: #2f4f4f;\n}\n","site":{"data":{}},"wordcount":580,"excerpt":"","more":"/* 代码块折叠 */\nfigure.highlight {\n  background: #21252b;\n  border-radius: 0.5rem;\n}\nfigure.highlight table {\n  border-radius: 0 0 0.5rem 0.5rem;\n}\nfigure.highlight > i {\n  color: #777;\n  margin-left: 10px;\n  line-height: 2rem;\n  transform: rotate(90deg);\n  transition: transform 0.2s ease-in-out;\n}\nfigure.highlight > i.collapsed {\n  transform: rotate(0deg);\n}\nfigure.highlight > span {\n  color: #777;\n  margin-left: 5px;\n  font-size: 0.875rem;\n}\nfigure.highlight td:first-child {\n  position: sticky;\n  left: 0;\n  z-index: 1;\n}\nfigure.highlight > i:before {\n  content: \"\\f2c3\";\n}\n\n/* 复制 */\n.copy-btn {\n  top: 5px;\n  font-size: 0.875rem;\n}\n.copy-btn > i {\n  font-size: 0.875rem;\n}\n.copy-btn-dark {\n  color: #2f4f4f;\n}\n"},{"_content":"// 代码语言标准形式（这里应该有更合理的解决方式，但是我不会写）\nvar code_language = {\n  txt: \"\",\n  md: \"Markdown\",\n  markdwon: \"Markdown\",\n\n  yml: \"YAML\",\n  yaml: \"YAML\",\n  json: \"JSON\",\n\n  xml: \"XML\",\n  html: \"HTML\",\n  css: \"CSS\",\n  styl: \"Stylus\",\n  stylus: \"Stylus\",\n\n  js: \"JavaScript\",\n  javascript: \"JavaScript\",\n  ts: \"TypeScript\",\n  typescript: \"TypeScript\",\n  py: \"Python\",\n  python: \"Python\",\n\n  c: \"C\",\n  \"c++\": \"C++\",\n  cpp: \"C++\",\n  cxx: \"C++\",\n  \"c#\": \"C#\",\n  cs: \"C#\",\n  csharp: \"C#\",\n  java: \"Java\"\n};\n\n// 代码语言格式化\nfunction getLanguage(lang) {\n  var lang_lower = lang.toLowerCase();\n  return lang_lower in code_language ? code_language[lang_lower] : lang;\n}\n\n// 获取唯一 ID\nfunction getUuiD() {\n  return Math.random().toString(36).substring(2, 8) + Date.now().toString(36);\n}\n\nfunction addLanguage() {\n  // 获取所有 figure.highlight 元素\n  var hs = $(\"figure.highlight\");\n  for (var i = 0; i < hs.length; i++) {\n    // 获取代码语言\n    var lang = hs[i].firstChild.firstChild.firstChild.lastChild.firstChild.firstChild.firstChild.classList[1];\n\n    // 折叠块的 id\n    var id = `kiyan-collapse-${getUuiD()}`;\n    // 前面折叠按钮，这里我使用了 FAS 图标\n    // 注意：这里是 bootstrap 的 collapse 功能的简略代码，使用时会自动补全，补全后的 HTML 可以通过浏览器 F12 查看，此外也可查看官方文档\n    var btn = `<i class=\"iconfont .icon-arrowdown\" type=\"button\" data-toggle=\"collapse\" data-target=\"#${id}\"></i>`;\n    // 代码语言\n    var span = `<span>${getLanguage(lang)}</span>`;\n    // 折叠块包裹原来的内容\n    var div = `<div class=\"collapse show\" id=\"${id}\">${hs[i].innerHTML}</div>`;\n    hs[i].innerHTML = btn + span + div;\n  }\n}\n\n$(document).ready(addLanguage);\n","source":"js/custom.js","raw":"// 代码语言标准形式（这里应该有更合理的解决方式，但是我不会写）\nvar code_language = {\n  txt: \"\",\n  md: \"Markdown\",\n  markdwon: \"Markdown\",\n\n  yml: \"YAML\",\n  yaml: \"YAML\",\n  json: \"JSON\",\n\n  xml: \"XML\",\n  html: \"HTML\",\n  css: \"CSS\",\n  styl: \"Stylus\",\n  stylus: \"Stylus\",\n\n  js: \"JavaScript\",\n  javascript: \"JavaScript\",\n  ts: \"TypeScript\",\n  typescript: \"TypeScript\",\n  py: \"Python\",\n  python: \"Python\",\n\n  c: \"C\",\n  \"c++\": \"C++\",\n  cpp: \"C++\",\n  cxx: \"C++\",\n  \"c#\": \"C#\",\n  cs: \"C#\",\n  csharp: \"C#\",\n  java: \"Java\"\n};\n\n// 代码语言格式化\nfunction getLanguage(lang) {\n  var lang_lower = lang.toLowerCase();\n  return lang_lower in code_language ? code_language[lang_lower] : lang;\n}\n\n// 获取唯一 ID\nfunction getUuiD() {\n  return Math.random().toString(36).substring(2, 8) + Date.now().toString(36);\n}\n\nfunction addLanguage() {\n  // 获取所有 figure.highlight 元素\n  var hs = $(\"figure.highlight\");\n  for (var i = 0; i < hs.length; i++) {\n    // 获取代码语言\n    var lang = hs[i].firstChild.firstChild.firstChild.lastChild.firstChild.firstChild.firstChild.classList[1];\n\n    // 折叠块的 id\n    var id = `kiyan-collapse-${getUuiD()}`;\n    // 前面折叠按钮，这里我使用了 FAS 图标\n    // 注意：这里是 bootstrap 的 collapse 功能的简略代码，使用时会自动补全，补全后的 HTML 可以通过浏览器 F12 查看，此外也可查看官方文档\n    var btn = `<i class=\"iconfont .icon-arrowdown\" type=\"button\" data-toggle=\"collapse\" data-target=\"#${id}\"></i>`;\n    // 代码语言\n    var span = `<span>${getLanguage(lang)}</span>`;\n    // 折叠块包裹原来的内容\n    var div = `<div class=\"collapse show\" id=\"${id}\">${hs[i].innerHTML}</div>`;\n    hs[i].innerHTML = btn + span + div;\n  }\n}\n\n$(document).ready(addLanguage);\n","date":"2022-02-25T06:17:51.072Z","updated":"2022-02-25T06:17:51.072Z","path":"js/custom.js","layout":"false","title":"","comments":1,"_id":"cl0f42s2h0006vw3l28vf2gcx","content":"// 代码语言标准形式（这里应该有更合理的解决方式，但是我不会写）\nvar code_language = {\n  txt: \"\",\n  md: \"Markdown\",\n  markdwon: \"Markdown\",\n\n  yml: \"YAML\",\n  yaml: \"YAML\",\n  json: \"JSON\",\n\n  xml: \"XML\",\n  html: \"HTML\",\n  css: \"CSS\",\n  styl: \"Stylus\",\n  stylus: \"Stylus\",\n\n  js: \"JavaScript\",\n  javascript: \"JavaScript\",\n  ts: \"TypeScript\",\n  typescript: \"TypeScript\",\n  py: \"Python\",\n  python: \"Python\",\n\n  c: \"C\",\n  \"c++\": \"C++\",\n  cpp: \"C++\",\n  cxx: \"C++\",\n  \"c#\": \"C#\",\n  cs: \"C#\",\n  csharp: \"C#\",\n  java: \"Java\"\n};\n\n// 代码语言格式化\nfunction getLanguage(lang) {\n  var lang_lower = lang.toLowerCase();\n  return lang_lower in code_language ? code_language[lang_lower] : lang;\n}\n\n// 获取唯一 ID\nfunction getUuiD() {\n  return Math.random().toString(36).substring(2, 8) + Date.now().toString(36);\n}\n\nfunction addLanguage() {\n  // 获取所有 figure.highlight 元素\n  var hs = $(\"figure.highlight\");\n  for (var i = 0; i < hs.length; i++) {\n    // 获取代码语言\n    var lang = hs[i].firstChild.firstChild.firstChild.lastChild.firstChild.firstChild.firstChild.classList[1];\n\n    // 折叠块的 id\n    var id = `kiyan-collapse-${getUuiD()}`;\n    // 前面折叠按钮，这里我使用了 FAS 图标\n    // 注意：这里是 bootstrap 的 collapse 功能的简略代码，使用时会自动补全，补全后的 HTML 可以通过浏览器 F12 查看，此外也可查看官方文档\n    var btn = `<i class=\"iconfont .icon-arrowdown\" type=\"button\" data-toggle=\"collapse\" data-target=\"#${id}\"></i>`;\n    // 代码语言\n    var span = `<span>${getLanguage(lang)}</span>`;\n    // 折叠块包裹原来的内容\n    var div = `<div class=\"collapse show\" id=\"${id}\">${hs[i].innerHTML}</div>`;\n    hs[i].innerHTML = btn + span + div;\n  }\n}\n\n$(document).ready(addLanguage);\n","site":{"data":{}},"wordcount":1108,"excerpt":"","more":"// 代码语言标准形式（这里应该有更合理的解决方式，但是我不会写）\nvar code_language = {\n  txt: \"\",\n  md: \"Markdown\",\n  markdwon: \"Markdown\",\n\n  yml: \"YAML\",\n  yaml: \"YAML\",\n  json: \"JSON\",\n\n  xml: \"XML\",\n  html: \"HTML\",\n  css: \"CSS\",\n  styl: \"Stylus\",\n  stylus: \"Stylus\",\n\n  js: \"JavaScript\",\n  javascript: \"JavaScript\",\n  ts: \"TypeScript\",\n  typescript: \"TypeScript\",\n  py: \"Python\",\n  python: \"Python\",\n\n  c: \"C\",\n  \"c++\": \"C++\",\n  cpp: \"C++\",\n  cxx: \"C++\",\n  \"c#\": \"C#\",\n  cs: \"C#\",\n  csharp: \"C#\",\n  java: \"Java\"\n};\n\n// 代码语言格式化\nfunction getLanguage(lang) {\n  var lang_lower = lang.toLowerCase();\n  return lang_lower in code_language ? code_language[lang_lower] : lang;\n}\n\n// 获取唯一 ID\nfunction getUuiD() {\n  return Math.random().toString(36).substring(2, 8) + Date.now().toString(36);\n}\n\nfunction addLanguage() {\n  // 获取所有 figure.highlight 元素\n  var hs = $(\"figure.highlight\");\n  for (var i = 0; i < hs.length; i++) {\n    // 获取代码语言\n    var lang = hs[i].firstChild.firstChild.firstChild.lastChild.firstChild.firstChild.firstChild.classList[1];\n\n    // 折叠块的 id\n    var id = `kiyan-collapse-${getUuiD()}`;\n    // 前面折叠按钮，这里我使用了 FAS 图标\n    // 注意：这里是 bootstrap 的 collapse 功能的简略代码，使用时会自动补全，补全后的 HTML 可以通过浏览器 F12 查看，此外也可查看官方文档\n    var btn = `<i class=\"iconfont .icon-arrowdown\" type=\"button\" data-toggle=\"collapse\" data-target=\"#${id}\"></i>`;\n    // 代码语言\n    var span = `<span>${getLanguage(lang)}</span>`;\n    // 折叠块包裹原来的内容\n    var div = `<div class=\"collapse show\" id=\"${id}\">${hs[i].innerHTML}</div>`;\n    hs[i].innerHTML = btn + span + div;\n  }\n}\n\n$(document).ready(addLanguage);\n"}],"Post":[{"title":"JS 代码 Bad & Good","index_img":"/img/2021-12-15-1.png","date":"2021-12-15T15:13:22.000Z","_content":"\n","source":"_drafts/2021-12-15-1.md","raw":"---\ntitle: JS 代码 Bad & Good\nindex_img: /img/2021-12-15-1.png\ndate: 2021-12-15 23:13:22\ntags: Bad&Good\ncategories: JS\n---\n\n","slug":"1","published":0,"updated":"2022-03-01T02:46:40.356Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0f42s2b0001vw3le6ow7azd","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""},{"title":"Webpack 原理分析","index_img":"/img/2022-02-08-1.jpeg","date":"2022-02-08T02:29:04.000Z","_content":"\n","source":"_drafts/2022-02-08-1.md","raw":"---\ntitle: Webpack 原理分析\nindex_img: /img/2022-02-08-1.jpeg\ndate: 2022-02-08 10:29:04\ntags: webpack\ncategories: webpack\n---\n\n","slug":"1","published":0,"updated":"2022-03-01T02:46:45.810Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0f42s2f0003vw3l6c453t6j","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""},{"title":"Mobx 原理分析","index_img":"/img/2021-12-22-1.png","date":"2021-12-22T15:12:17.000Z","_content":"\n","source":"_drafts/2021-12-22-1.md","raw":"---\ntitle: Mobx 原理分析\nindex_img: /img/2021-12-22-1.png\ndate: 2021-12-22 23:12:17\ntags: Mobx\ncategories: Mobx\n---\n\n","slug":"1","published":0,"updated":"2022-03-01T02:46:43.070Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0f42s2h0007vw3l5ddqf42n","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""},{"title":"实习生前端工程师面试题","index_img":"/img/2022-02-22-1.jpeg","date":"2022-02-22T10:03:22.000Z","_content":"\n\n## CSS\n\n- 介绍下 BFC 及其应用\n\n  BFC（Block Format Context）块级格式化上下文，是页面盒模型中的一种 `CSS` 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。\n\n  创建 `BFC` 的方式有：\n\n  1. `html` 根元素\n  2. `float` 浮动\n  3. 绝对定位\n  4. `overflow` 不为 `visible`\n  5. `display` 为表格布局或者弹性布局；\n\n  `BFC` 主要的作用是：\n\n  1. 清除浮动\n  2. 防止同一 `BFC` 容器中的相邻元素间的外边距重叠问题\n\n- 怎么让一个 div 水平垂直居中？\n\n  ```html\n  <div class=\"parent\">\n    <div class=\"child\"></div>\n  </div>\n  ```\n\n  ```css\n  <!-- 1 -->\n  div.parent {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n  <!-- 2 -->\n  div.parent {\n    position: relative;\n  }\n  div.child {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%);\n  }\n  <!-- 3 -->\n  div.parent {\n    display: grid;\n  }\n  div.child {\n    justify-self: center;\n    align-self: center;\n  }\n  <!-- 4 -->\n  div.parent {\n    font-size: 0;\n    text-align: center;\n    &::before {\n      content: \"\";\n      display: inline-block;\n      width: 0;\n      height: 100%;\n      vertical-align: middle;\n    }\n  }\n  div.child {\n    display: inline-block;\n    vertical-align: middle;\n  }\n  ```\n\n- 简述 Rem 及其转换原理\n\n  `rem` 是 CSS3 新增的相对长度单位，是指相对于根元素 `html` 的 `font-size` 计算值的大小。\n\n  默认根元素的 `font-size` 都是 `16px`的。如果想要设置 `12px` 的字体大小也就是 `12px/16px = 0.75rem`。\n\n  - 由于 `px` 是相对固定单位，字号大小直接被定死，无法随着浏览器进行缩放；\n  - `rem` 直接相对于根元素 `html`，避开层级关系，移动端新型浏览器对其支持较好；\n\n  个人用 `vw` + 百分比布局用的比较多，可以使用 `webpack` 的 `postcss-loader` 的一个插件 `postcss-px-to-viewport` 实现对 `px` 到 `vw` 的自动转换，非常适合开发。\n\n- 简述伪类和伪元素\n\n  - 伪类\n\n  伪类用于当已有元素处于某种状态时，为其添加对应的样式，这个状态是根据用户行为变化而变化的。比如说 `:hover`。它只有处于 dom 树无法描述的状态才能为元素添加样式，所以称为伪类。\n\n  -  伪元素\n\n  伪元素用于创建一些原本不在文档树中的元素，并为其添加样式，比如说 `::before`。虽然用户可以看到这些内容，但是其实他不在文档树中。\n\n\n  - 区别\n\n  伪类的操作对象是文档树中已存在的元素，而伪元素是创建一个文档树外的元素。\n\n  css 规范中用双冒号 `::` 表示伪元素，用一个冒号 `:` 表示伪类。\n\n## JS\n\n### JS 中数据类型有哪些？\n\n数值（number）、字符串（string）、布尔值（boolean）、undefined、null、对象（object）\n\n","source":"_drafts/2022-02-22-1.md","raw":"---\ntitle: 实习生前端工程师面试题\nindex_img: /img/2022-02-22-1.jpeg\ndate: 2022-02-22 18:03:22\ntags: 前端实习生\ncategories: 面试\n---\n\n\n## CSS\n\n- 介绍下 BFC 及其应用\n\n  BFC（Block Format Context）块级格式化上下文，是页面盒模型中的一种 `CSS` 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。\n\n  创建 `BFC` 的方式有：\n\n  1. `html` 根元素\n  2. `float` 浮动\n  3. 绝对定位\n  4. `overflow` 不为 `visible`\n  5. `display` 为表格布局或者弹性布局；\n\n  `BFC` 主要的作用是：\n\n  1. 清除浮动\n  2. 防止同一 `BFC` 容器中的相邻元素间的外边距重叠问题\n\n- 怎么让一个 div 水平垂直居中？\n\n  ```html\n  <div class=\"parent\">\n    <div class=\"child\"></div>\n  </div>\n  ```\n\n  ```css\n  <!-- 1 -->\n  div.parent {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n  <!-- 2 -->\n  div.parent {\n    position: relative;\n  }\n  div.child {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%);\n  }\n  <!-- 3 -->\n  div.parent {\n    display: grid;\n  }\n  div.child {\n    justify-self: center;\n    align-self: center;\n  }\n  <!-- 4 -->\n  div.parent {\n    font-size: 0;\n    text-align: center;\n    &::before {\n      content: \"\";\n      display: inline-block;\n      width: 0;\n      height: 100%;\n      vertical-align: middle;\n    }\n  }\n  div.child {\n    display: inline-block;\n    vertical-align: middle;\n  }\n  ```\n\n- 简述 Rem 及其转换原理\n\n  `rem` 是 CSS3 新增的相对长度单位，是指相对于根元素 `html` 的 `font-size` 计算值的大小。\n\n  默认根元素的 `font-size` 都是 `16px`的。如果想要设置 `12px` 的字体大小也就是 `12px/16px = 0.75rem`。\n\n  - 由于 `px` 是相对固定单位，字号大小直接被定死，无法随着浏览器进行缩放；\n  - `rem` 直接相对于根元素 `html`，避开层级关系，移动端新型浏览器对其支持较好；\n\n  个人用 `vw` + 百分比布局用的比较多，可以使用 `webpack` 的 `postcss-loader` 的一个插件 `postcss-px-to-viewport` 实现对 `px` 到 `vw` 的自动转换，非常适合开发。\n\n- 简述伪类和伪元素\n\n  - 伪类\n\n  伪类用于当已有元素处于某种状态时，为其添加对应的样式，这个状态是根据用户行为变化而变化的。比如说 `:hover`。它只有处于 dom 树无法描述的状态才能为元素添加样式，所以称为伪类。\n\n  -  伪元素\n\n  伪元素用于创建一些原本不在文档树中的元素，并为其添加样式，比如说 `::before`。虽然用户可以看到这些内容，但是其实他不在文档树中。\n\n\n  - 区别\n\n  伪类的操作对象是文档树中已存在的元素，而伪元素是创建一个文档树外的元素。\n\n  css 规范中用双冒号 `::` 表示伪元素，用一个冒号 `:` 表示伪类。\n\n## JS\n\n### JS 中数据类型有哪些？\n\n数值（number）、字符串（string）、布尔值（boolean）、undefined、null、对象（object）\n\n","slug":"1","published":0,"updated":"2022-03-02T02:02:40.709Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0f42s2j0008vw3lblvbc3h5","content":"<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><ul>\n<li><p>介绍下 BFC 及其应用</p>\n<p>BFC（Block Format Context）块级格式化上下文，是页面盒模型中的一种 <code>CSS</code> 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。</p>\n<p>创建 <code>BFC</code> 的方式有：</p>\n<ol>\n<li><code>html</code> 根元素</li>\n<li><code>float</code> 浮动</li>\n<li>绝对定位</li>\n<li><code>overflow</code> 不为 <code>visible</code></li>\n<li><code>display</code> 为表格布局或者弹性布局；</li>\n</ol>\n<p><code>BFC</code> 主要的作用是：</p>\n<ol>\n<li>清除浮动</li>\n<li>防止同一 <code>BFC</code> 容器中的相邻元素间的外边距重叠问题</li>\n</ol>\n</li>\n<li><p>怎么让一个 div 水平垂直居中？</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;parent&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;child&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs css\">&lt;!-- <span class=\"hljs-number\">1</span> --&gt;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;<br>  <span class=\"hljs-attribute\">display</span>: flex;<br>  <span class=\"hljs-attribute\">justify-content</span>: center;<br>  <span class=\"hljs-attribute\">align-items</span>: center;<br>&#125;<br>&lt;!-- <span class=\"hljs-number\">2</span> --&gt;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;<br>  <span class=\"hljs-attribute\">position</span>: relative;<br>&#125;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.child</span> &#123;<br>  <span class=\"hljs-attribute\">position</span>: absolute;<br>  <span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">50%</span>;<br>  <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">50%</span>;<br>  <span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-built_in\">translate</span>(-<span class=\"hljs-number\">50%</span>, -<span class=\"hljs-number\">50%</span>);<br>&#125;<br>&lt;!-- <span class=\"hljs-number\">3</span> --&gt;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;<br>  <span class=\"hljs-attribute\">display</span>: grid;<br>&#125;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.child</span> &#123;<br>  justify-self: center;<br>  <span class=\"hljs-attribute\">align-self</span>: center;<br>&#125;<br>&lt;!-- <span class=\"hljs-number\">4</span> --&gt;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;<br>  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-attribute\">text-align</span>: center;<br>  &amp;<span class=\"hljs-selector-pseudo\">::before</span> &#123;<br>    <span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">&quot;&quot;</span>;<br>    <span class=\"hljs-attribute\">display</span>: inline-block;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100%</span>;<br>    <span class=\"hljs-attribute\">vertical-align</span>: middle;<br>  &#125;<br>&#125;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.child</span> &#123;<br>  <span class=\"hljs-attribute\">display</span>: inline-block;<br>  <span class=\"hljs-attribute\">vertical-align</span>: middle;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>\n<li><p>简述 Rem 及其转换原理</p>\n<p><code>rem</code> 是 CSS3 新增的相对长度单位，是指相对于根元素 <code>html</code> 的 <code>font-size</code> 计算值的大小。</p>\n<p>默认根元素的 <code>font-size</code> 都是 <code>16px</code>的。如果想要设置 <code>12px</code> 的字体大小也就是 <code>12px/16px = 0.75rem</code>。</p>\n<ul>\n<li>由于 <code>px</code> 是相对固定单位，字号大小直接被定死，无法随着浏览器进行缩放；</li>\n<li><code>rem</code> 直接相对于根元素 <code>html</code>，避开层级关系，移动端新型浏览器对其支持较好；</li>\n</ul>\n<p>个人用 <code>vw</code> + 百分比布局用的比较多，可以使用 <code>webpack</code> 的 <code>postcss-loader</code> 的一个插件 <code>postcss-px-to-viewport</code> 实现对 <code>px</code> 到 <code>vw</code> 的自动转换，非常适合开发。</p>\n</li>\n<li><p>简述伪类和伪元素</p>\n<ul>\n<li>伪类</li>\n</ul>\n<p>伪类用于当已有元素处于某种状态时，为其添加对应的样式，这个状态是根据用户行为变化而变化的。比如说 <code>:hover</code>。它只有处于 dom 树无法描述的状态才能为元素添加样式，所以称为伪类。</p>\n<ul>\n<li> 伪元素</li>\n</ul>\n<p>伪元素用于创建一些原本不在文档树中的元素，并为其添加样式，比如说 <code>::before</code>。虽然用户可以看到这些内容，但是其实他不在文档树中。</p>\n</li>\n</ul>\n<ul>\n<li>区别</li>\n</ul>\n<p>  伪类的操作对象是文档树中已存在的元素，而伪元素是创建一个文档树外的元素。</p>\n<p>  css 规范中用双冒号 <code>::</code> 表示伪元素，用一个冒号 <code>:</code> 表示伪类。</p>\n<h2 id=\"JS\"><a href=\"#JS\" class=\"headerlink\" title=\"JS\"></a>JS</h2><h3 id=\"JS-中数据类型有哪些？\"><a href=\"#JS-中数据类型有哪些？\" class=\"headerlink\" title=\"JS 中数据类型有哪些？\"></a>JS 中数据类型有哪些？</h3><p>数值（number）、字符串（string）、布尔值（boolean）、undefined、null、对象（object）</p>\n","site":{"data":{}},"wordcount":1542,"excerpt":"","more":"<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><ul>\n<li><p>介绍下 BFC 及其应用</p>\n<p>BFC（Block Format Context）块级格式化上下文，是页面盒模型中的一种 <code>CSS</code> 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。</p>\n<p>创建 <code>BFC</code> 的方式有：</p>\n<ol>\n<li><code>html</code> 根元素</li>\n<li><code>float</code> 浮动</li>\n<li>绝对定位</li>\n<li><code>overflow</code> 不为 <code>visible</code></li>\n<li><code>display</code> 为表格布局或者弹性布局；</li>\n</ol>\n<p><code>BFC</code> 主要的作用是：</p>\n<ol>\n<li>清除浮动</li>\n<li>防止同一 <code>BFC</code> 容器中的相邻元素间的外边距重叠问题</li>\n</ol>\n</li>\n<li><p>怎么让一个 div 水平垂直居中？</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;parent&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;child&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">&lt;!-- <span class=\"hljs-number\">1</span> --&gt;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;<br>  <span class=\"hljs-attribute\">display</span>: flex;<br>  <span class=\"hljs-attribute\">justify-content</span>: center;<br>  <span class=\"hljs-attribute\">align-items</span>: center;<br>&#125;<br>&lt;!-- <span class=\"hljs-number\">2</span> --&gt;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;<br>  <span class=\"hljs-attribute\">position</span>: relative;<br>&#125;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.child</span> &#123;<br>  <span class=\"hljs-attribute\">position</span>: absolute;<br>  <span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">50%</span>;<br>  <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">50%</span>;<br>  <span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-built_in\">translate</span>(-<span class=\"hljs-number\">50%</span>, -<span class=\"hljs-number\">50%</span>);<br>&#125;<br>&lt;!-- <span class=\"hljs-number\">3</span> --&gt;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;<br>  <span class=\"hljs-attribute\">display</span>: grid;<br>&#125;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.child</span> &#123;<br>  justify-self: center;<br>  <span class=\"hljs-attribute\">align-self</span>: center;<br>&#125;<br>&lt;!-- <span class=\"hljs-number\">4</span> --&gt;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.parent</span> &#123;<br>  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-attribute\">text-align</span>: center;<br>  &amp;<span class=\"hljs-selector-pseudo\">::before</span> &#123;<br>    <span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">&quot;&quot;</span>;<br>    <span class=\"hljs-attribute\">display</span>: inline-block;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100%</span>;<br>    <span class=\"hljs-attribute\">vertical-align</span>: middle;<br>  &#125;<br>&#125;<br><span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-class\">.child</span> &#123;<br>  <span class=\"hljs-attribute\">display</span>: inline-block;<br>  <span class=\"hljs-attribute\">vertical-align</span>: middle;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>简述 Rem 及其转换原理</p>\n<p><code>rem</code> 是 CSS3 新增的相对长度单位，是指相对于根元素 <code>html</code> 的 <code>font-size</code> 计算值的大小。</p>\n<p>默认根元素的 <code>font-size</code> 都是 <code>16px</code>的。如果想要设置 <code>12px</code> 的字体大小也就是 <code>12px/16px = 0.75rem</code>。</p>\n<ul>\n<li>由于 <code>px</code> 是相对固定单位，字号大小直接被定死，无法随着浏览器进行缩放；</li>\n<li><code>rem</code> 直接相对于根元素 <code>html</code>，避开层级关系，移动端新型浏览器对其支持较好；</li>\n</ul>\n<p>个人用 <code>vw</code> + 百分比布局用的比较多，可以使用 <code>webpack</code> 的 <code>postcss-loader</code> 的一个插件 <code>postcss-px-to-viewport</code> 实现对 <code>px</code> 到 <code>vw</code> 的自动转换，非常适合开发。</p>\n</li>\n<li><p>简述伪类和伪元素</p>\n<ul>\n<li>伪类</li>\n</ul>\n<p>伪类用于当已有元素处于某种状态时，为其添加对应的样式，这个状态是根据用户行为变化而变化的。比如说 <code>:hover</code>。它只有处于 dom 树无法描述的状态才能为元素添加样式，所以称为伪类。</p>\n<ul>\n<li> 伪元素</li>\n</ul>\n<p>伪元素用于创建一些原本不在文档树中的元素，并为其添加样式，比如说 <code>::before</code>。虽然用户可以看到这些内容，但是其实他不在文档树中。</p>\n</li>\n</ul>\n<ul>\n<li>区别</li>\n</ul>\n<p>  伪类的操作对象是文档树中已存在的元素，而伪元素是创建一个文档树外的元素。</p>\n<p>  css 规范中用双冒号 <code>::</code> 表示伪元素，用一个冒号 <code>:</code> 表示伪类。</p>\n<h2 id=\"JS\"><a href=\"#JS\" class=\"headerlink\" title=\"JS\"></a>JS</h2><h3 id=\"JS-中数据类型有哪些？\"><a href=\"#JS-中数据类型有哪些？\" class=\"headerlink\" title=\"JS 中数据类型有哪些？\"></a>JS 中数据类型有哪些？</h3><p>数值（number）、字符串（string）、布尔值（boolean）、undefined、null、对象（object）</p>\n"},{"title":"日常使用的容器镜像操作命令","index_img":"/img/2021-12-01-1.png","abbrlink":"25d325e2","date":"2021-12-01T02:25:42.000Z","_content":"\n构建镜像\n\n```sh\ndocker build -t user-manage:v1.0 .\n```\n\n运行容器镜像\n\n```sh\ndocker run --rm -d -p 8089:80 --name k8s-installer-test -v ~/gitlab/k8s-installer-ui/dist:/usr/share/nginx/html -v ~/default.conf:/etc/nginx/conf.d/default.conf nginx\n\n# --rm container 停止后删除 container\n# -d 后台运行容器\n# -p 80:80 前者本地端口，后者是 dockerfile 暴露端口\n# --name 指定容器名称\n# -v 挂载替换容器内指定文件\n```\n\n将镜像打成 tar 包\n\n```sh\ndocker save user-manage:latest > ~/Downloads/usermanage.tar\n```\n\n上传 tar 包到指定服务器\n\n```sh\nscp ~/Downloads/usermanage.tar root@172.16.60.99:/tmp/\n```\n\n从服务器下载 tar 包到本地\n\n```sh\nscp -r caas-aio:~/tmp/origin-web-console.tar ~/Downloads/test/\n```\n\n从 tar 包加载镜像\n\n```sh\ndocker load < /tmp/usermanage.tar\n# 可以查看到\ndocker images \n```\n\n给镜像重新打 tag\n\n```sh\ndocker tag user-manage:latest docker.io/user-manage:latest\n```\n\n进入容器内部\n\n```sh\n# 镜像 id\ndocker exec -it 73bee1a2a355 /bin/bash\n# 或者 /bin/sh\n```\n\n查看镜像元数据，常用来查看 commit-id\n\n```sh\ndocker inspect <image-id>\n```\n\n","source":"_posts/2021-12-01-1.md","raw":"---\ntitle: 日常使用的容器镜像操作命令\nindex_img: /img/2021-12-01-1.png\nabbrlink: 25d325e2\ndate: 2021-12-01 10:25:42\ntags:\ncategories:\n---\n\n构建镜像\n\n```sh\ndocker build -t user-manage:v1.0 .\n```\n\n运行容器镜像\n\n```sh\ndocker run --rm -d -p 8089:80 --name k8s-installer-test -v ~/gitlab/k8s-installer-ui/dist:/usr/share/nginx/html -v ~/default.conf:/etc/nginx/conf.d/default.conf nginx\n\n# --rm container 停止后删除 container\n# -d 后台运行容器\n# -p 80:80 前者本地端口，后者是 dockerfile 暴露端口\n# --name 指定容器名称\n# -v 挂载替换容器内指定文件\n```\n\n将镜像打成 tar 包\n\n```sh\ndocker save user-manage:latest > ~/Downloads/usermanage.tar\n```\n\n上传 tar 包到指定服务器\n\n```sh\nscp ~/Downloads/usermanage.tar root@172.16.60.99:/tmp/\n```\n\n从服务器下载 tar 包到本地\n\n```sh\nscp -r caas-aio:~/tmp/origin-web-console.tar ~/Downloads/test/\n```\n\n从 tar 包加载镜像\n\n```sh\ndocker load < /tmp/usermanage.tar\n# 可以查看到\ndocker images \n```\n\n给镜像重新打 tag\n\n```sh\ndocker tag user-manage:latest docker.io/user-manage:latest\n```\n\n进入容器内部\n\n```sh\n# 镜像 id\ndocker exec -it 73bee1a2a355 /bin/bash\n# 或者 /bin/sh\n```\n\n查看镜像元数据，常用来查看 commit-id\n\n```sh\ndocker inspect <image-id>\n```\n\n","slug":"1","published":1,"updated":"2022-03-01T02:56:12.118Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0f42s2j0009vw3l63fh0xfl","content":"<p>构建镜像</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">docker build -t user-manage:v1.0 .<br></code></pre></div></td></tr></table></figure>\n\n<p>运行容器镜像</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">docker run --rm -d -p 8089:80 --name k8s-installer-test -v ~/gitlab/k8s-installer-ui/dist:/usr/share/nginx/html -v ~/default.conf:/etc/nginx/conf.d/default.conf nginx<br><br><span class=\"hljs-comment\"># --rm container 停止后删除 container</span><br><span class=\"hljs-comment\"># -d 后台运行容器</span><br><span class=\"hljs-comment\"># -p 80:80 前者本地端口，后者是 dockerfile 暴露端口</span><br><span class=\"hljs-comment\"># --name 指定容器名称</span><br><span class=\"hljs-comment\"># -v 挂载替换容器内指定文件</span><br></code></pre></div></td></tr></table></figure>\n\n<p>将镜像打成 tar 包</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">docker save user-manage:latest &gt; ~/Downloads/usermanage.tar<br></code></pre></div></td></tr></table></figure>\n\n<p>上传 tar 包到指定服务器</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">scp ~/Downloads/usermanage.tar root@172.16.60.99:/tmp/<br></code></pre></div></td></tr></table></figure>\n\n<p>从服务器下载 tar 包到本地</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">scp -r caas-aio:~/tmp/origin-web-console.tar ~/Downloads/<span class=\"hljs-built_in\">test</span>/<br></code></pre></div></td></tr></table></figure>\n\n<p>从 tar 包加载镜像</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">docker load &lt; /tmp/usermanage.tar<br><span class=\"hljs-comment\"># 可以查看到</span><br>docker images <br></code></pre></div></td></tr></table></figure>\n\n<p>给镜像重新打 tag</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">docker tag user-manage:latest docker.io/user-manage:latest<br></code></pre></div></td></tr></table></figure>\n\n<p>进入容器内部</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># 镜像 id</span><br>docker <span class=\"hljs-built_in\">exec</span> -it 73bee1a2a355 /bin/bash<br><span class=\"hljs-comment\"># 或者 /bin/sh</span><br></code></pre></div></td></tr></table></figure>\n\n<p>查看镜像元数据，常用来查看 commit-id</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">docker inspect &lt;image-id&gt;<br></code></pre></div></td></tr></table></figure>\n\n","site":{"data":{}},"wordcount":742,"excerpt":"","more":"<p>构建镜像</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">docker build -t user-manage:v1.0 .<br></code></pre></td></tr></table></figure>\n\n<p>运行容器镜像</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">docker run --rm -d -p 8089:80 --name k8s-installer-test -v ~/gitlab/k8s-installer-ui/dist:/usr/share/nginx/html -v ~/default.conf:/etc/nginx/conf.d/default.conf nginx<br><br><span class=\"hljs-comment\"># --rm container 停止后删除 container</span><br><span class=\"hljs-comment\"># -d 后台运行容器</span><br><span class=\"hljs-comment\"># -p 80:80 前者本地端口，后者是 dockerfile 暴露端口</span><br><span class=\"hljs-comment\"># --name 指定容器名称</span><br><span class=\"hljs-comment\"># -v 挂载替换容器内指定文件</span><br></code></pre></td></tr></table></figure>\n\n<p>将镜像打成 tar 包</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">docker save user-manage:latest &gt; ~/Downloads/usermanage.tar<br></code></pre></td></tr></table></figure>\n\n<p>上传 tar 包到指定服务器</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">scp ~/Downloads/usermanage.tar root@172.16.60.99:/tmp/<br></code></pre></td></tr></table></figure>\n\n<p>从服务器下载 tar 包到本地</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">scp -r caas-aio:~/tmp/origin-web-console.tar ~/Downloads/<span class=\"hljs-built_in\">test</span>/<br></code></pre></td></tr></table></figure>\n\n<p>从 tar 包加载镜像</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">docker load &lt; /tmp/usermanage.tar<br><span class=\"hljs-comment\"># 可以查看到</span><br>docker images <br></code></pre></td></tr></table></figure>\n\n<p>给镜像重新打 tag</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">docker tag user-manage:latest docker.io/user-manage:latest<br></code></pre></td></tr></table></figure>\n\n<p>进入容器内部</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># 镜像 id</span><br>docker <span class=\"hljs-built_in\">exec</span> -it 73bee1a2a355 /bin/bash<br><span class=\"hljs-comment\"># 或者 /bin/sh</span><br></code></pre></td></tr></table></figure>\n\n<p>查看镜像元数据，常用来查看 commit-id</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">docker inspect &lt;image-id&gt;<br></code></pre></td></tr></table></figure>\n\n"},{"title":"使用 useRef 跨生命周期保存变量","index_img":"/img/2022-01-13-1.png","abbrlink":"bb88c12","date":"2022-01-13T07:23:54.000Z","_content":"\nref 这一种访问 DOM 的主要方式。然而，useRef() 比 ref 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式.\n\n当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。\n\n## 场景 1：只在更新时运行 useEffect\n\n使用一个可变的 ref 手动存储一个布尔值来表示是首次渲染还是后续渲染.\n\n```jsx\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  const prevCountRef = useRef(false);\n  useEffect(() => {\n    if (prevCountRef.current) {\n      console.log(\"只在更新时候执行\");\n    } else {\n      console.log(\"首次渲染执行\");\n      prevCountRef.current = true;\n    }\n  });\n\n  return (\n    <div>\n      <div>{count}</div>\n      <button\n        onClick={() => {\n          setCount(count + 1);\n        }}\n      >\n        +\n      </button>\n    </div>\n  );\n}\n```\n\n抽成自定义 hook：\n\n```jsx\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  const update = useUpdate();\n  console.log(update, \"是否更新\");\n\n  return (\n    <div>\n      <div>{count}</div>\n      <button\n        onClick={() => {\n          setCount(count + 1);\n        }}\n      >\n        +\n      </button>\n    </div>\n  );\n}\n\nfunction useUpdate() {\n  const ref = useRef(false);\n  useEffect(() => {\n    ref.current = true;\n  });\n  return ref.current;\n}\n```\n\n## 场景 2：获取上一轮的 props 或 state\n\n为什么 ref.current 拿到是上次的值？原因：\n\n1. useEffect 很重要的一点是：它是在每次渲染之后才会触发的，是延迟执行的。\n2. return 语句是同步的，所以 return 的时候，ref.current 还是旧值。\n3. 以下代码的执行顺序是 1 3 2\n\n```jsx\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  const prevCountRef = useRef();\n\n  console.log(\"1\", count);\n  useEffect(() => {\n    console.log(\"2.\", count);\n    prevCountRef.current = count;\n  });\n\n  const prevCount = prevCountRef.current;\n\n  console.log(`3.之前的状态: ${prevCount};现在状态: ${count}`);\n  return (\n    <div>\n      <div>{count}</div>\n      <button\n        onClick={() => {\n          setCount(count + 1);\n        }}\n      >\n        +\n      </button>\n    </div>\n  );\n}\n```\n\n抽取成自定义 Hook:\n\n```jsx\nexport default function usePrevious(value) {\n  const ref = useRef();\n\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref.current;\n}\n```\n\n## 场景 3：解决 hooks 时，由于异步闭包无法获取最新 state 的问题\n\n```jsx\nimport React, { useState, useEffect, useRef } from \"react\";\n\nconst RefComponent = () => {\n  // 使用 useState 存放和改变展示的 number\n  const [number, setNumber] = useState(0);\n  // 使用 useRef 生成一个独立的 ref 对象\n  // 在它的 current 属性单独存放一个展示的 number, 初始值为 0\n  const numRef = useRef(0);\n\n  function incrementAndDelayLogging() {\n    // 点击按钮 number + 1\n    setNumber(number + 1);\n    // 同时 ref 对象的 current 属性值也 + 1\n    numRef.current++;\n    // 定时器函数中产生了闭包, 这里 number 的是组件更新前的 number 对象, 所以值一直会滞后 1\n    setTimeout(() => alert(`state: ${number} | ref: ${numRef.current}`), 1000);\n  }\n\n  // 直接渲染的组件是正常情况, 可以获取到最新的 state,\n  // 所以 ref.current 和 state 存储的值显示一致\n  return (\n    <div>\n      <h1>solving closure by useRef</h1>\n      <button onClick={incrementAndDelayLogging}>alert in setTimeout</button>\n      <h4>state: {number}</h4>\n      <h4>ref: {numRef.current}</h4>\n    </div>\n  );\n};\n```\n","source":"_posts/2022-01-13-1.md","raw":"---\ntitle: 使用 useRef 跨生命周期保存变量\ntags:\n  - React\n  - HooK\nindex_img: /img/2022-01-13-1.png\ncategories: React\nabbrlink: bb88c12\ndate: 2022-01-13 15:23:54\n---\n\nref 这一种访问 DOM 的主要方式。然而，useRef() 比 ref 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式.\n\n当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。\n\n## 场景 1：只在更新时运行 useEffect\n\n使用一个可变的 ref 手动存储一个布尔值来表示是首次渲染还是后续渲染.\n\n```jsx\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  const prevCountRef = useRef(false);\n  useEffect(() => {\n    if (prevCountRef.current) {\n      console.log(\"只在更新时候执行\");\n    } else {\n      console.log(\"首次渲染执行\");\n      prevCountRef.current = true;\n    }\n  });\n\n  return (\n    <div>\n      <div>{count}</div>\n      <button\n        onClick={() => {\n          setCount(count + 1);\n        }}\n      >\n        +\n      </button>\n    </div>\n  );\n}\n```\n\n抽成自定义 hook：\n\n```jsx\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  const update = useUpdate();\n  console.log(update, \"是否更新\");\n\n  return (\n    <div>\n      <div>{count}</div>\n      <button\n        onClick={() => {\n          setCount(count + 1);\n        }}\n      >\n        +\n      </button>\n    </div>\n  );\n}\n\nfunction useUpdate() {\n  const ref = useRef(false);\n  useEffect(() => {\n    ref.current = true;\n  });\n  return ref.current;\n}\n```\n\n## 场景 2：获取上一轮的 props 或 state\n\n为什么 ref.current 拿到是上次的值？原因：\n\n1. useEffect 很重要的一点是：它是在每次渲染之后才会触发的，是延迟执行的。\n2. return 语句是同步的，所以 return 的时候，ref.current 还是旧值。\n3. 以下代码的执行顺序是 1 3 2\n\n```jsx\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  const prevCountRef = useRef();\n\n  console.log(\"1\", count);\n  useEffect(() => {\n    console.log(\"2.\", count);\n    prevCountRef.current = count;\n  });\n\n  const prevCount = prevCountRef.current;\n\n  console.log(`3.之前的状态: ${prevCount};现在状态: ${count}`);\n  return (\n    <div>\n      <div>{count}</div>\n      <button\n        onClick={() => {\n          setCount(count + 1);\n        }}\n      >\n        +\n      </button>\n    </div>\n  );\n}\n```\n\n抽取成自定义 Hook:\n\n```jsx\nexport default function usePrevious(value) {\n  const ref = useRef();\n\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref.current;\n}\n```\n\n## 场景 3：解决 hooks 时，由于异步闭包无法获取最新 state 的问题\n\n```jsx\nimport React, { useState, useEffect, useRef } from \"react\";\n\nconst RefComponent = () => {\n  // 使用 useState 存放和改变展示的 number\n  const [number, setNumber] = useState(0);\n  // 使用 useRef 生成一个独立的 ref 对象\n  // 在它的 current 属性单独存放一个展示的 number, 初始值为 0\n  const numRef = useRef(0);\n\n  function incrementAndDelayLogging() {\n    // 点击按钮 number + 1\n    setNumber(number + 1);\n    // 同时 ref 对象的 current 属性值也 + 1\n    numRef.current++;\n    // 定时器函数中产生了闭包, 这里 number 的是组件更新前的 number 对象, 所以值一直会滞后 1\n    setTimeout(() => alert(`state: ${number} | ref: ${numRef.current}`), 1000);\n  }\n\n  // 直接渲染的组件是正常情况, 可以获取到最新的 state,\n  // 所以 ref.current 和 state 存储的值显示一致\n  return (\n    <div>\n      <h1>solving closure by useRef</h1>\n      <button onClick={incrementAndDelayLogging}>alert in setTimeout</button>\n      <h4>state: {number}</h4>\n      <h4>ref: {numRef.current}</h4>\n    </div>\n  );\n};\n```\n","slug":"1","published":1,"updated":"2022-03-01T02:56:12.117Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0f42s2k000dvw3lacz572a0","content":"<p>ref 这一种访问 DOM 的主要方式。然而，useRef() 比 ref 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式.</p>\n<p>当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。</p>\n<h2 id=\"场景-1：只在更新时运行-useEffect\"><a href=\"#场景-1：只在更新时运行-useEffect\" class=\"headerlink\" title=\"场景 1：只在更新时运行 useEffect\"></a>场景 1：只在更新时运行 useEffect</h2><p>使用一个可变的 ref 手动存储一个布尔值来表示是首次渲染还是后续渲染.</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);<br><br>  <span class=\"hljs-keyword\">const</span> prevCountRef = useRef(<span class=\"hljs-literal\">false</span>);<br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (prevCountRef.current) &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;只在更新时候执行&quot;</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;首次渲染执行&quot;</span>);<br>      prevCountRef.current = <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>  &#125;);<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span></span></span><br><span class=\"hljs-tag\"><span class=\"xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span><br><span class=\"xml\">          setCount(count + 1);</span><br><span class=\"xml\">        &#125;&#125;</span><br><span class=\"xml\">      &gt;</span><br><span class=\"xml\">        +</span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>抽成自定义 hook：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);<br><br>  <span class=\"hljs-keyword\">const</span> update = useUpdate();<br>  <span class=\"hljs-built_in\">console</span>.log(update, <span class=\"hljs-string\">&quot;是否更新&quot;</span>);<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span></span></span><br><span class=\"hljs-tag\"><span class=\"xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span><br><span class=\"xml\">          setCount(count + 1);</span><br><span class=\"xml\">        &#125;&#125;</span><br><span class=\"xml\">      &gt;</span><br><span class=\"xml\">        +</span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useUpdate</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> ref = useRef(<span class=\"hljs-literal\">false</span>);<br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    ref.current = <span class=\"hljs-literal\">true</span>;<br>  &#125;);<br>  <span class=\"hljs-keyword\">return</span> ref.current;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"场景-2：获取上一轮的-props-或-state\"><a href=\"#场景-2：获取上一轮的-props-或-state\" class=\"headerlink\" title=\"场景 2：获取上一轮的 props 或 state\"></a>场景 2：获取上一轮的 props 或 state</h2><p>为什么 ref.current 拿到是上次的值？原因：</p>\n<ol>\n<li>useEffect 很重要的一点是：它是在每次渲染之后才会触发的，是延迟执行的。</li>\n<li>return 语句是同步的，所以 return 的时候，ref.current 还是旧值。</li>\n<li>以下代码的执行顺序是 1 3 2</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);<br><br>  <span class=\"hljs-keyword\">const</span> prevCountRef = useRef();<br><br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;1&quot;</span>, count);<br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;2.&quot;</span>, count);<br>    prevCountRef.current = count;<br>  &#125;);<br><br>  <span class=\"hljs-keyword\">const</span> prevCount = prevCountRef.current;<br><br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`3.之前的状态: <span class=\"hljs-subst\">$&#123;prevCount&#125;</span>;现在状态: <span class=\"hljs-subst\">$&#123;count&#125;</span>`</span>);<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span></span></span><br><span class=\"hljs-tag\"><span class=\"xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span><br><span class=\"xml\">          setCount(count + 1);</span><br><span class=\"xml\">        &#125;&#125;</span><br><span class=\"xml\">      &gt;</span><br><span class=\"xml\">        +</span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>抽取成自定义 Hook:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">usePrevious</span>(<span class=\"hljs-params\">value</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> ref = useRef();<br><br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    ref.current = value;<br>  &#125;, [value]);<br><br>  <span class=\"hljs-keyword\">return</span> ref.current;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"场景-3：解决-hooks-时，由于异步闭包无法获取最新-state-的问题\"><a href=\"#场景-3：解决-hooks-时，由于异步闭包无法获取最新-state-的问题\" class=\"headerlink\" title=\"场景 3：解决 hooks 时，由于异步闭包无法获取最新 state 的问题\"></a>场景 3：解决 hooks 时，由于异步闭包无法获取最新 state 的问题</h2><figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React, &#123; useState, useEffect, useRef &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> RefComponent = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-comment\">// 使用 useState 存放和改变展示的 number</span><br>  <span class=\"hljs-keyword\">const</span> [number, setNumber] = useState(<span class=\"hljs-number\">0</span>);<br>  <span class=\"hljs-comment\">// 使用 useRef 生成一个独立的 ref 对象</span><br>  <span class=\"hljs-comment\">// 在它的 current 属性单独存放一个展示的 number, 初始值为 0</span><br>  <span class=\"hljs-keyword\">const</span> numRef = useRef(<span class=\"hljs-number\">0</span>);<br><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">incrementAndDelayLogging</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-comment\">// 点击按钮 number + 1</span><br>    setNumber(number + <span class=\"hljs-number\">1</span>);<br>    <span class=\"hljs-comment\">// 同时 ref 对象的 current 属性值也 + 1</span><br>    numRef.current++;<br>    <span class=\"hljs-comment\">// 定时器函数中产生了闭包, 这里 number 的是组件更新前的 number 对象, 所以值一直会滞后 1</span><br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> alert(<span class=\"hljs-string\">`state: <span class=\"hljs-subst\">$&#123;number&#125;</span> | ref: <span class=\"hljs-subst\">$&#123;numRef.current&#125;</span>`</span>), <span class=\"hljs-number\">1000</span>);<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 直接渲染的组件是正常情况, 可以获取到最新的 state,</span><br>  <span class=\"hljs-comment\">// 所以 ref.current 和 state 存储的值显示一致</span><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>solving closure by useRef<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;incrementAndDelayLogging&#125;</span>&gt;</span>alert in setTimeout<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h4</span>&gt;</span>state: &#123;number&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h4</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h4</span>&gt;</span>ref: &#123;numRef.current&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h4</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n","site":{"data":{}},"wordcount":2888,"excerpt":"","more":"<p>ref 这一种访问 DOM 的主要方式。然而，useRef() 比 ref 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式.</p>\n<p>当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。</p>\n<h2 id=\"场景-1：只在更新时运行-useEffect\"><a href=\"#场景-1：只在更新时运行-useEffect\" class=\"headerlink\" title=\"场景 1：只在更新时运行 useEffect\"></a>场景 1：只在更新时运行 useEffect</h2><p>使用一个可变的 ref 手动存储一个布尔值来表示是首次渲染还是后续渲染.</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);<br><br>  <span class=\"hljs-keyword\">const</span> prevCountRef = useRef(<span class=\"hljs-literal\">false</span>);<br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (prevCountRef.current) &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;只在更新时候执行&quot;</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;首次渲染执行&quot;</span>);<br>      prevCountRef.current = <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>  &#125;);<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span></span></span><br><span class=\"hljs-tag\"><span class=\"xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span><br><span class=\"xml\">          setCount(count + 1);</span><br><span class=\"xml\">        &#125;&#125;</span><br><span class=\"xml\">      &gt;</span><br><span class=\"xml\">        +</span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>抽成自定义 hook：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Example</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);<br><br>  <span class=\"hljs-keyword\">const</span> update = useUpdate();<br>  <span class=\"hljs-built_in\">console</span>.log(update, <span class=\"hljs-string\">&quot;是否更新&quot;</span>);<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span></span></span><br><span class=\"hljs-tag\"><span class=\"xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span><br><span class=\"xml\">          setCount(count + 1);</span><br><span class=\"xml\">        &#125;&#125;</span><br><span class=\"xml\">      &gt;</span><br><span class=\"xml\">        +</span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useUpdate</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> ref = useRef(<span class=\"hljs-literal\">false</span>);<br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    ref.current = <span class=\"hljs-literal\">true</span>;<br>  &#125;);<br>  <span class=\"hljs-keyword\">return</span> ref.current;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"场景-2：获取上一轮的-props-或-state\"><a href=\"#场景-2：获取上一轮的-props-或-state\" class=\"headerlink\" title=\"场景 2：获取上一轮的 props 或 state\"></a>场景 2：获取上一轮的 props 或 state</h2><p>为什么 ref.current 拿到是上次的值？原因：</p>\n<ol>\n<li>useEffect 很重要的一点是：它是在每次渲染之后才会触发的，是延迟执行的。</li>\n<li>return 语句是同步的，所以 return 的时候，ref.current 还是旧值。</li>\n<li>以下代码的执行顺序是 1 3 2</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> [count, setCount] = useState(<span class=\"hljs-number\">0</span>);<br><br>  <span class=\"hljs-keyword\">const</span> prevCountRef = useRef();<br><br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;1&quot;</span>, count);<br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;2.&quot;</span>, count);<br>    prevCountRef.current = count;<br>  &#125;);<br><br>  <span class=\"hljs-keyword\">const</span> prevCount = prevCountRef.current;<br><br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`3.之前的状态: <span class=\"hljs-subst\">$&#123;prevCount&#125;</span>;现在状态: <span class=\"hljs-subst\">$&#123;count&#125;</span>`</span>);<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span></span></span><br><span class=\"hljs-tag\"><span class=\"xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;</span><br><span class=\"xml\">          setCount(count + 1);</span><br><span class=\"xml\">        &#125;&#125;</span><br><span class=\"xml\">      &gt;</span><br><span class=\"xml\">        +</span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>抽取成自定义 Hook:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">usePrevious</span>(<span class=\"hljs-params\">value</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> ref = useRef();<br><br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    ref.current = value;<br>  &#125;, [value]);<br><br>  <span class=\"hljs-keyword\">return</span> ref.current;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"场景-3：解决-hooks-时，由于异步闭包无法获取最新-state-的问题\"><a href=\"#场景-3：解决-hooks-时，由于异步闭包无法获取最新-state-的问题\" class=\"headerlink\" title=\"场景 3：解决 hooks 时，由于异步闭包无法获取最新 state 的问题\"></a>场景 3：解决 hooks 时，由于异步闭包无法获取最新 state 的问题</h2><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React, &#123; useState, useEffect, useRef &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> RefComponent = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-comment\">// 使用 useState 存放和改变展示的 number</span><br>  <span class=\"hljs-keyword\">const</span> [number, setNumber] = useState(<span class=\"hljs-number\">0</span>);<br>  <span class=\"hljs-comment\">// 使用 useRef 生成一个独立的 ref 对象</span><br>  <span class=\"hljs-comment\">// 在它的 current 属性单独存放一个展示的 number, 初始值为 0</span><br>  <span class=\"hljs-keyword\">const</span> numRef = useRef(<span class=\"hljs-number\">0</span>);<br><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">incrementAndDelayLogging</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-comment\">// 点击按钮 number + 1</span><br>    setNumber(number + <span class=\"hljs-number\">1</span>);<br>    <span class=\"hljs-comment\">// 同时 ref 对象的 current 属性值也 + 1</span><br>    numRef.current++;<br>    <span class=\"hljs-comment\">// 定时器函数中产生了闭包, 这里 number 的是组件更新前的 number 对象, 所以值一直会滞后 1</span><br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> alert(<span class=\"hljs-string\">`state: <span class=\"hljs-subst\">$&#123;number&#125;</span> | ref: <span class=\"hljs-subst\">$&#123;numRef.current&#125;</span>`</span>), <span class=\"hljs-number\">1000</span>);<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 直接渲染的组件是正常情况, 可以获取到最新的 state,</span><br>  <span class=\"hljs-comment\">// 所以 ref.current 和 state 存储的值显示一致</span><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>solving closure by useRef<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;incrementAndDelayLogging&#125;</span>&gt;</span>alert in setTimeout<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h4</span>&gt;</span>state: &#123;number&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h4</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h4</span>&gt;</span>ref: &#123;numRef.current&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h4</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>\n"},{"title":"map 到底改不改变原数组","index_img":"/img/2022-01-14-3.png","abbrlink":"d177e434","date":"2022-01-14T05:53:44.000Z","_content":"\n\n一般认为 map 不会对原数组进行修改，但事实并不是如此。\n\n## 数组内为基础类型数据时,原数组不变\n\n```js\nlet array = [1, 2, 3, 4, 5];\nlet newArray = array.map((item) => item * 2);\nconsole.log(array); // [1,2,3,4,5]\nconsole.log(newArray); //[2, 4, 6, 8, 10]\n```\n\n## 数据内是引用类型数据时，注意写法\n\n1. item 上直接修改，改变原数组\n\n   ```js\n   let array = [\n     { name: \"Anna\", age: 16 },\n     { name: \"James\", age: 18 }\n   ];\n   let newArray = array.map((item) => {\n     item.like = \"eat\";\n     return item;\n   });\n   console.log(array); // [{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}]\n   console.log(newArray); //[{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}]\n   ```\n\n1. 开辟新的引用地址, 不改变原数组\n\n   ```js\n   let array = [\n     { name: \"Anna\", age: 16 },\n     { name: \"James\", age: 18 }\n   ];\n   let newArray = array.map((item) => {\n     const obj = { ...item, like: \"eat\" };\n     return obj;\n   });\n   console.log(array); // [{ name: 'Anna', age: 16},{ name: 'James', age: 18}]\n   console.log(newArray); //[{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}]\n   ```\n","source":"_posts/2022-01-14-3.md","raw":"---\ntitle: map 到底改不改变原数组\nindex_img: /img/2022-01-14-3.png\ntags: map\ncategories: JS\nabbrlink: d177e434\ndate: 2022-01-14 13:53:44\n---\n\n\n一般认为 map 不会对原数组进行修改，但事实并不是如此。\n\n## 数组内为基础类型数据时,原数组不变\n\n```js\nlet array = [1, 2, 3, 4, 5];\nlet newArray = array.map((item) => item * 2);\nconsole.log(array); // [1,2,3,4,5]\nconsole.log(newArray); //[2, 4, 6, 8, 10]\n```\n\n## 数据内是引用类型数据时，注意写法\n\n1. item 上直接修改，改变原数组\n\n   ```js\n   let array = [\n     { name: \"Anna\", age: 16 },\n     { name: \"James\", age: 18 }\n   ];\n   let newArray = array.map((item) => {\n     item.like = \"eat\";\n     return item;\n   });\n   console.log(array); // [{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}]\n   console.log(newArray); //[{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}]\n   ```\n\n1. 开辟新的引用地址, 不改变原数组\n\n   ```js\n   let array = [\n     { name: \"Anna\", age: 16 },\n     { name: \"James\", age: 18 }\n   ];\n   let newArray = array.map((item) => {\n     const obj = { ...item, like: \"eat\" };\n     return obj;\n   });\n   console.log(array); // [{ name: 'Anna', age: 16},{ name: 'James', age: 18}]\n   console.log(newArray); //[{ name: 'Anna', age: 16,like: \"eat\"},{ name: 'James', age: 18,like: \"eat\"}]\n   ```\n","slug":"3","published":1,"updated":"2022-03-01T02:56:12.119Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0f42s2l000evw3lejffafo3","content":"<p>一般认为 map 不会对原数组进行修改，但事实并不是如此。</p>\n<h2 id=\"数组内为基础类型数据时-原数组不变\"><a href=\"#数组内为基础类型数据时-原数组不变\" class=\"headerlink\" title=\"数组内为基础类型数据时,原数组不变\"></a>数组内为基础类型数据时,原数组不变</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> array = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];<br><span class=\"hljs-keyword\">let</span> newArray = array.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> item * <span class=\"hljs-number\">2</span>);<br><span class=\"hljs-built_in\">console</span>.log(array); <span class=\"hljs-comment\">// [1,2,3,4,5]</span><br><span class=\"hljs-built_in\">console</span>.log(newArray); <span class=\"hljs-comment\">//[2, 4, 6, 8, 10]</span><br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"数据内是引用类型数据时，注意写法\"><a href=\"#数据内是引用类型数据时，注意写法\" class=\"headerlink\" title=\"数据内是引用类型数据时，注意写法\"></a>数据内是引用类型数据时，注意写法</h2><ol>\n<li><p>item 上直接修改，改变原数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> array = [<br>  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Anna&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">16</span> &#125;,<br>  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;James&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span> &#125;<br>];<br><span class=\"hljs-keyword\">let</span> newArray = array.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> &#123;<br>  item.like = <span class=\"hljs-string\">&quot;eat&quot;</span>;<br>  <span class=\"hljs-keyword\">return</span> item;<br>&#125;);<br><span class=\"hljs-built_in\">console</span>.log(array); <span class=\"hljs-comment\">// [&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span><br><span class=\"hljs-built_in\">console</span>.log(newArray); <span class=\"hljs-comment\">//[&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span><br></code></pre></div></td></tr></table></figure></li>\n<li><p>开辟新的引用地址, 不改变原数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> array = [<br>  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Anna&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">16</span> &#125;,<br>  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;James&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span> &#125;<br>];<br><span class=\"hljs-keyword\">let</span> newArray = array.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> obj = &#123; ...item, <span class=\"hljs-attr\">like</span>: <span class=\"hljs-string\">&quot;eat&quot;</span> &#125;;<br>  <span class=\"hljs-keyword\">return</span> obj;<br>&#125;);<br><span class=\"hljs-built_in\">console</span>.log(array); <span class=\"hljs-comment\">// [&#123; name: &#x27;Anna&#x27;, age: 16&#125;,&#123; name: &#x27;James&#x27;, age: 18&#125;]</span><br><span class=\"hljs-built_in\">console</span>.log(newArray); <span class=\"hljs-comment\">//[&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span><br></code></pre></div></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"wordcount":1177,"excerpt":"","more":"<p>一般认为 map 不会对原数组进行修改，但事实并不是如此。</p>\n<h2 id=\"数组内为基础类型数据时-原数组不变\"><a href=\"#数组内为基础类型数据时-原数组不变\" class=\"headerlink\" title=\"数组内为基础类型数据时,原数组不变\"></a>数组内为基础类型数据时,原数组不变</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> array = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];<br><span class=\"hljs-keyword\">let</span> newArray = array.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> item * <span class=\"hljs-number\">2</span>);<br><span class=\"hljs-built_in\">console</span>.log(array); <span class=\"hljs-comment\">// [1,2,3,4,5]</span><br><span class=\"hljs-built_in\">console</span>.log(newArray); <span class=\"hljs-comment\">//[2, 4, 6, 8, 10]</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"数据内是引用类型数据时，注意写法\"><a href=\"#数据内是引用类型数据时，注意写法\" class=\"headerlink\" title=\"数据内是引用类型数据时，注意写法\"></a>数据内是引用类型数据时，注意写法</h2><ol>\n<li><p>item 上直接修改，改变原数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> array = [<br>  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Anna&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">16</span> &#125;,<br>  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;James&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span> &#125;<br>];<br><span class=\"hljs-keyword\">let</span> newArray = array.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> &#123;<br>  item.like = <span class=\"hljs-string\">&quot;eat&quot;</span>;<br>  <span class=\"hljs-keyword\">return</span> item;<br>&#125;);<br><span class=\"hljs-built_in\">console</span>.log(array); <span class=\"hljs-comment\">// [&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span><br><span class=\"hljs-built_in\">console</span>.log(newArray); <span class=\"hljs-comment\">//[&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span><br></code></pre></td></tr></table></figure></li>\n<li><p>开辟新的引用地址, 不改变原数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> array = [<br>  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Anna&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">16</span> &#125;,<br>  &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;James&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span> &#125;<br>];<br><span class=\"hljs-keyword\">let</span> newArray = array.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> obj = &#123; ...item, <span class=\"hljs-attr\">like</span>: <span class=\"hljs-string\">&quot;eat&quot;</span> &#125;;<br>  <span class=\"hljs-keyword\">return</span> obj;<br>&#125;);<br><span class=\"hljs-built_in\">console</span>.log(array); <span class=\"hljs-comment\">// [&#123; name: &#x27;Anna&#x27;, age: 16&#125;,&#123; name: &#x27;James&#x27;, age: 18&#125;]</span><br><span class=\"hljs-built_in\">console</span>.log(newArray); <span class=\"hljs-comment\">//[&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"如何在 class 组件中使用 hooks","index_img":"/img/2022-01-14-2.png","abbrlink":"ee7a9294","date":"2022-01-14T03:03:28.000Z","_content":"\n解决办法\n\n以一个简单的 `useScreenWidthhook` 函数为例，它的目的是获取全屏的宽度，并且去监听浏览器窗口的变化，更新宽度：\n\n```jsx\nimport { useEffect, useState } from \"react\";\n\nexport function useScreenWidth(): number {\n  const [width, setWidth] = useState(window.innerWidth);\n\n  useEffect(() => {\n    const handler = (event: any) => {\n      setWidth(event.target.innerWidth);\n    };\n    // 监听浏览器窗口变化\n    window.addEventListener(\"resize\", handler);\n    // 组件unmount时要解除监听\n    return () => {\n      window.removeEventListener(\"resize\", handler);\n    };\n  }, []);\n\n  return width;\n}\n```\n\n## 方法 1：将 Hook 包装成 HOC\n\nHOC 是 React 中复用组件的高级用法，它的本质是一个函数，它的输入参数是一个组件，返回相同的组件以及一些额外的 props。在我们的例子里，可以让 hook 函数作为 props 传递到目标组件中:\n\n```jsx\nimport React from \"react\";\nimport { useScreenWidth } from \"../hooks/useScreenWidth\";\n\nexport const withHooksHOC = (Component: any) => {\n  return (props: any) => {\n    const screenWidth = useScreenWidth();\n\n    return <Component width={screenWidth} {...props} />;\n  };\n};\n```\n\n将我们的目标组件用上述的 withHooksHOC 包装起来\n\n```jsx\nimport React from \"react\";\nimport { withHooksHOC } from \"./withHooksHOC\";\n\ninterface IHooksHOCProps {\n  width: number;\n}\n\nclass HooksHOC extends React.Component<IHooksHOCProps> {\n  render() {\n    return <p>width: {this.props.width}</p>;\n  }\n}\n\nexport default withHooksHOC(HooksHOC);\n```\n\n## 方法 2：将 Hook 包装成函数组件\n\n将 hook 变成函数组件，它接收一个参数为 width 的 children 函数，然后将 width 作为 render prop 传递：\n\n```jsx\nimport { FunctionComponent } from \"react\";\nimport { useScreenWidth } from \"../hooks/useScreenWidth\";\n\ntype ScreenWidthChildren = (screenWidth: number) => React.ReactNode;\n\ninterface IScreenWidthProps {\n  children: ScreenWidthChildren;\n}\n\nexport const ScreenWidth: FunctionComponent<IScreenWidthProps> = ({ children }) => {\n  const screenWidth: number = useScreenWidth();\n\n  return children(screenWidth);\n};\n```\n\n使用：\n\n```jsx\nimport React from \"react\";\nimport { ScreenWidth } from \"./ScreenWidth\";\n\nexport class HooksRenderProps extends React.Component {\n  render() {\n    return <ScreenWidth>{(width) => <p style={{ fontSize: \"48px\" }}>width: {width}</p>}</ScreenWidth>;\n  }\n}\n```\n","source":"_posts/2022-01-14-2.md","raw":"---\ntitle: 如何在 class 组件中使用 hooks\nindex_img: /img/2022-01-14-2.png\ntags: HooK\ncategories: React\nabbrlink: ee7a9294\ndate: 2022-01-14 11:03:28\n---\n\n解决办法\n\n以一个简单的 `useScreenWidthhook` 函数为例，它的目的是获取全屏的宽度，并且去监听浏览器窗口的变化，更新宽度：\n\n```jsx\nimport { useEffect, useState } from \"react\";\n\nexport function useScreenWidth(): number {\n  const [width, setWidth] = useState(window.innerWidth);\n\n  useEffect(() => {\n    const handler = (event: any) => {\n      setWidth(event.target.innerWidth);\n    };\n    // 监听浏览器窗口变化\n    window.addEventListener(\"resize\", handler);\n    // 组件unmount时要解除监听\n    return () => {\n      window.removeEventListener(\"resize\", handler);\n    };\n  }, []);\n\n  return width;\n}\n```\n\n## 方法 1：将 Hook 包装成 HOC\n\nHOC 是 React 中复用组件的高级用法，它的本质是一个函数，它的输入参数是一个组件，返回相同的组件以及一些额外的 props。在我们的例子里，可以让 hook 函数作为 props 传递到目标组件中:\n\n```jsx\nimport React from \"react\";\nimport { useScreenWidth } from \"../hooks/useScreenWidth\";\n\nexport const withHooksHOC = (Component: any) => {\n  return (props: any) => {\n    const screenWidth = useScreenWidth();\n\n    return <Component width={screenWidth} {...props} />;\n  };\n};\n```\n\n将我们的目标组件用上述的 withHooksHOC 包装起来\n\n```jsx\nimport React from \"react\";\nimport { withHooksHOC } from \"./withHooksHOC\";\n\ninterface IHooksHOCProps {\n  width: number;\n}\n\nclass HooksHOC extends React.Component<IHooksHOCProps> {\n  render() {\n    return <p>width: {this.props.width}</p>;\n  }\n}\n\nexport default withHooksHOC(HooksHOC);\n```\n\n## 方法 2：将 Hook 包装成函数组件\n\n将 hook 变成函数组件，它接收一个参数为 width 的 children 函数，然后将 width 作为 render prop 传递：\n\n```jsx\nimport { FunctionComponent } from \"react\";\nimport { useScreenWidth } from \"../hooks/useScreenWidth\";\n\ntype ScreenWidthChildren = (screenWidth: number) => React.ReactNode;\n\ninterface IScreenWidthProps {\n  children: ScreenWidthChildren;\n}\n\nexport const ScreenWidth: FunctionComponent<IScreenWidthProps> = ({ children }) => {\n  const screenWidth: number = useScreenWidth();\n\n  return children(screenWidth);\n};\n```\n\n使用：\n\n```jsx\nimport React from \"react\";\nimport { ScreenWidth } from \"./ScreenWidth\";\n\nexport class HooksRenderProps extends React.Component {\n  render() {\n    return <ScreenWidth>{(width) => <p style={{ fontSize: \"48px\" }}>width: {width}</p>}</ScreenWidth>;\n  }\n}\n```\n","slug":"2","published":1,"updated":"2022-03-01T02:56:12.119Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0f42s2o000ivw3l4biag6z1","content":"<p>解决办法</p>\n<p>以一个简单的 <code>useScreenWidthhook</code> 函数为例，它的目的是获取全屏的宽度，并且去监听浏览器窗口的变化，更新宽度：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; useEffect, useState &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useScreenWidth</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">number</span> </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> [width, setWidth] = useState(<span class=\"hljs-built_in\">window</span>.innerWidth);<br><br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> handler = <span class=\"hljs-function\">(<span class=\"hljs-params\">event: any</span>) =&gt;</span> &#123;<br>      setWidth(event.target.innerWidth);<br>    &#125;;<br>    <span class=\"hljs-comment\">// 监听浏览器窗口变化</span><br>    <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">&quot;resize&quot;</span>, handler);<br>    <span class=\"hljs-comment\">// 组件unmount时要解除监听</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-built_in\">window</span>.removeEventListener(<span class=\"hljs-string\">&quot;resize&quot;</span>, handler);<br>    &#125;;<br>  &#125;, []);<br><br>  <span class=\"hljs-keyword\">return</span> width;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"方法-1：将-Hook-包装成-HOC\"><a href=\"#方法-1：将-Hook-包装成-HOC\" class=\"headerlink\" title=\"方法 1：将 Hook 包装成 HOC\"></a>方法 1：将 Hook 包装成 HOC</h2><p>HOC 是 React 中复用组件的高级用法，它的本质是一个函数，它的输入参数是一个组件，返回相同的组件以及一些额外的 props。在我们的例子里，可以让 hook 函数作为 props 传递到目标组件中:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; useScreenWidth &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../hooks/useScreenWidth&quot;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> withHooksHOC = <span class=\"hljs-function\">(<span class=\"hljs-params\">Component: any</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">props: any</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> screenWidth = useScreenWidth();<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Component</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&#123;screenWidth&#125;</span> &#123;<span class=\"hljs-attr\">...props</span>&#125; /&gt;</span></span>;<br>  &#125;;<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n\n<p>将我们的目标组件用上述的 withHooksHOC 包装起来</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; withHooksHOC &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./withHooksHOC&quot;</span>;<br><br>interface IHooksHOCProps &#123;<br>  <span class=\"hljs-attr\">width</span>: number;<br>&#125;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HooksHOC</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">IHooksHOCProps</span>&gt; </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>width: &#123;this.props.width&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> withHooksHOC(HooksHOC);<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"方法-2：将-Hook-包装成函数组件\"><a href=\"#方法-2：将-Hook-包装成函数组件\" class=\"headerlink\" title=\"方法 2：将 Hook 包装成函数组件\"></a>方法 2：将 Hook 包装成函数组件</h2><p>将 hook 变成函数组件，它接收一个参数为 width 的 children 函数，然后将 width 作为 render prop 传递：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; FunctionComponent &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; useScreenWidth &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../hooks/useScreenWidth&quot;</span>;<br><br>type ScreenWidthChildren = <span class=\"hljs-function\">(<span class=\"hljs-params\">screenWidth: number</span>) =&gt;</span> React.ReactNode;<br><br>interface IScreenWidthProps &#123;<br>  <span class=\"hljs-attr\">children</span>: ScreenWidthChildren;<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> ScreenWidth: FunctionComponent&lt;IScreenWidthProps&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">&#123; children &#125;</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> screenWidth: number = useScreenWidth();<br><br>  <span class=\"hljs-keyword\">return</span> children(screenWidth);<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n\n<p>使用：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; ScreenWidth &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./ScreenWidth&quot;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HooksRenderProps</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ScreenWidth</span>&gt;</span>&#123;(width) =&gt; <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&#123;&#123;</span> <span class=\"hljs-attr\">fontSize:</span> &quot;<span class=\"hljs-attr\">48px</span>&quot; &#125;&#125;&gt;</span>width: &#123;width&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ScreenWidth</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n","site":{"data":{}},"wordcount":2216,"excerpt":"","more":"<p>解决办法</p>\n<p>以一个简单的 <code>useScreenWidthhook</code> 函数为例，它的目的是获取全屏的宽度，并且去监听浏览器窗口的变化，更新宽度：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; useEffect, useState &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useScreenWidth</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">number</span> </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> [width, setWidth] = useState(<span class=\"hljs-built_in\">window</span>.innerWidth);<br><br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> handler = <span class=\"hljs-function\">(<span class=\"hljs-params\">event: any</span>) =&gt;</span> &#123;<br>      setWidth(event.target.innerWidth);<br>    &#125;;<br>    <span class=\"hljs-comment\">// 监听浏览器窗口变化</span><br>    <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">&quot;resize&quot;</span>, handler);<br>    <span class=\"hljs-comment\">// 组件unmount时要解除监听</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-built_in\">window</span>.removeEventListener(<span class=\"hljs-string\">&quot;resize&quot;</span>, handler);<br>    &#125;;<br>  &#125;, []);<br><br>  <span class=\"hljs-keyword\">return</span> width;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"方法-1：将-Hook-包装成-HOC\"><a href=\"#方法-1：将-Hook-包装成-HOC\" class=\"headerlink\" title=\"方法 1：将 Hook 包装成 HOC\"></a>方法 1：将 Hook 包装成 HOC</h2><p>HOC 是 React 中复用组件的高级用法，它的本质是一个函数，它的输入参数是一个组件，返回相同的组件以及一些额外的 props。在我们的例子里，可以让 hook 函数作为 props 传递到目标组件中:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; useScreenWidth &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../hooks/useScreenWidth&quot;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> withHooksHOC = <span class=\"hljs-function\">(<span class=\"hljs-params\">Component: any</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">props: any</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> screenWidth = useScreenWidth();<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Component</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&#123;screenWidth&#125;</span> &#123;<span class=\"hljs-attr\">...props</span>&#125; /&gt;</span></span>;<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>将我们的目标组件用上述的 withHooksHOC 包装起来</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; withHooksHOC &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./withHooksHOC&quot;</span>;<br><br>interface IHooksHOCProps &#123;<br>  <span class=\"hljs-attr\">width</span>: number;<br>&#125;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HooksHOC</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span>&lt;<span class=\"hljs-title\">IHooksHOCProps</span>&gt; </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>width: &#123;this.props.width&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> withHooksHOC(HooksHOC);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"方法-2：将-Hook-包装成函数组件\"><a href=\"#方法-2：将-Hook-包装成函数组件\" class=\"headerlink\" title=\"方法 2：将 Hook 包装成函数组件\"></a>方法 2：将 Hook 包装成函数组件</h2><p>将 hook 变成函数组件，它接收一个参数为 width 的 children 函数，然后将 width 作为 render prop 传递：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> &#123; FunctionComponent &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; useScreenWidth &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../hooks/useScreenWidth&quot;</span>;<br><br>type ScreenWidthChildren = <span class=\"hljs-function\">(<span class=\"hljs-params\">screenWidth: number</span>) =&gt;</span> React.ReactNode;<br><br>interface IScreenWidthProps &#123;<br>  <span class=\"hljs-attr\">children</span>: ScreenWidthChildren;<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> ScreenWidth: FunctionComponent&lt;IScreenWidthProps&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">&#123; children &#125;</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> screenWidth: number = useScreenWidth();<br><br>  <span class=\"hljs-keyword\">return</span> children(screenWidth);<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>使用：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; ScreenWidth &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./ScreenWidth&quot;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HooksRenderProps</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ScreenWidth</span>&gt;</span>&#123;(width) =&gt; <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&#123;&#123;</span> <span class=\"hljs-attr\">fontSize:</span> &quot;<span class=\"hljs-attr\">48px</span>&quot; &#125;&#125;&gt;</span>width: &#123;width&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ScreenWidth</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"useState 引用类型数据更新不触发重新渲染问题","index_img":"/img/2022-01-14-1.png","abbrlink":"b195fb80","date":"2022-01-14T02:24:50.000Z","_content":"\n## useState 函数式更新\n\n与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。\n\n```jsx\nconst [state, setState] = useState({});\nsetState((prevState) => {\n  // 也可以使用 Object.assign\n  return { ...prevState, ...updatedValues };\n});\n```\n\n## 引用类型 state 更新\n\n经常 state 数据不是简单数据类型(值类型)，而是数组、对象之类(引用类型).而 React 组件的更新机制对 state 只进行浅对比，也就是更新某个复杂类型数据时只要它的引用地址没变，那就不会重新渲染组件。\n\n尤其当被更新的引用类型数据需要依赖之前的数据时，容易踩坑,不触发更新。更新复杂 state 的时候必须传给它一个全新的对象，而不是复制了它引用地址再修改的对象。\n\n两种解决办法：\n\n1. 结合展开运算符返回一个新对象\n\n   ```jsx\n   function nextValue(preValue) {\n     let ipValue = Number.parseInt(newVal, 10);\n\n     if (Number.isNaN(ipValue)) {\n       ipValue = undefined;\n     }\n     if (ipValue < 0) {\n       ipValue = 0;\n     }\n     if (ipValue > 255) {\n       ipValue = 255;\n     }\n     preValue[index] = ipValue; //这里数据引用地址的值同样被修改\n     return [...preValue]; // 数据最外层的引用地址不同即可触发组件更新\n   }\n\n   setValue((preValue) => nextValue(preValue));\n   ```\n\n1. 深拷贝对象，用全新的副本更新数据。\n\n   ```jsx\n   function nextValue(preValue) {\n     const newValue = _.cloneDeep(preValue);\n     let ipValue = Number.parseInt(newVal, 10);\n\n     if (Number.isNaN(ipValue)) {\n       ipValue = undefined;\n     }\n     if (ipValue < 0) {\n       ipValue = 0;\n     }\n     if (ipValue > 255) {\n       ipValue = 255;\n     }\n     newValue[index] = ipValue; //这里数据引用地址的值同样被修改\n     return newValue; // 数据最外层的引用地址不同即可触发组件更新\n   }\n\n   setValue((preValue) => nextValue(preValue));\n   ```\n","source":"_posts/2022-01-14-1.md","raw":"---\ntitle: useState 引用类型数据更新不触发重新渲染问题\ntags: HooK\nindex_img: /img/2022-01-14-1.png\ncategories: React\nabbrlink: b195fb80\ndate: 2022-01-14 10:24:50\n---\n\n## useState 函数式更新\n\n与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。\n\n```jsx\nconst [state, setState] = useState({});\nsetState((prevState) => {\n  // 也可以使用 Object.assign\n  return { ...prevState, ...updatedValues };\n});\n```\n\n## 引用类型 state 更新\n\n经常 state 数据不是简单数据类型(值类型)，而是数组、对象之类(引用类型).而 React 组件的更新机制对 state 只进行浅对比，也就是更新某个复杂类型数据时只要它的引用地址没变，那就不会重新渲染组件。\n\n尤其当被更新的引用类型数据需要依赖之前的数据时，容易踩坑,不触发更新。更新复杂 state 的时候必须传给它一个全新的对象，而不是复制了它引用地址再修改的对象。\n\n两种解决办法：\n\n1. 结合展开运算符返回一个新对象\n\n   ```jsx\n   function nextValue(preValue) {\n     let ipValue = Number.parseInt(newVal, 10);\n\n     if (Number.isNaN(ipValue)) {\n       ipValue = undefined;\n     }\n     if (ipValue < 0) {\n       ipValue = 0;\n     }\n     if (ipValue > 255) {\n       ipValue = 255;\n     }\n     preValue[index] = ipValue; //这里数据引用地址的值同样被修改\n     return [...preValue]; // 数据最外层的引用地址不同即可触发组件更新\n   }\n\n   setValue((preValue) => nextValue(preValue));\n   ```\n\n1. 深拷贝对象，用全新的副本更新数据。\n\n   ```jsx\n   function nextValue(preValue) {\n     const newValue = _.cloneDeep(preValue);\n     let ipValue = Number.parseInt(newVal, 10);\n\n     if (Number.isNaN(ipValue)) {\n       ipValue = undefined;\n     }\n     if (ipValue < 0) {\n       ipValue = 0;\n     }\n     if (ipValue > 255) {\n       ipValue = 255;\n     }\n     newValue[index] = ipValue; //这里数据引用地址的值同样被修改\n     return newValue; // 数据最外层的引用地址不同即可触发组件更新\n   }\n\n   setValue((preValue) => nextValue(preValue));\n   ```\n","slug":"1","published":1,"updated":"2022-03-01T02:56:12.115Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0f42s2o000kvw3l8n6c727b","content":"<h2 id=\"useState-函数式更新\"><a href=\"#useState-函数式更新\" class=\"headerlink\" title=\"useState 函数式更新\"></a>useState 函数式更新</h2><p>与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> [state, setState] = useState(&#123;&#125;);<br>setState(<span class=\"hljs-function\">(<span class=\"hljs-params\">prevState</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-comment\">// 也可以使用 Object.assign</span><br>  <span class=\"hljs-keyword\">return</span> &#123; ...prevState, ...updatedValues &#125;;<br>&#125;);<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"引用类型-state-更新\"><a href=\"#引用类型-state-更新\" class=\"headerlink\" title=\"引用类型 state 更新\"></a>引用类型 state 更新</h2><p>经常 state 数据不是简单数据类型(值类型)，而是数组、对象之类(引用类型).而 React 组件的更新机制对 state 只进行浅对比，也就是更新某个复杂类型数据时只要它的引用地址没变，那就不会重新渲染组件。</p>\n<p>尤其当被更新的引用类型数据需要依赖之前的数据时，容易踩坑,不触发更新。更新复杂 state 的时候必须传给它一个全新的对象，而不是复制了它引用地址再修改的对象。</p>\n<p>两种解决办法：</p>\n<ol>\n<li><p>结合展开运算符返回一个新对象</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">nextValue</span>(<span class=\"hljs-params\">preValue</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> ipValue = <span class=\"hljs-built_in\">Number</span>.parseInt(newVal, <span class=\"hljs-number\">10</span>);<br><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Number</span>.isNaN(ipValue)) &#123;<br>    ipValue = <span class=\"hljs-literal\">undefined</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (ipValue &lt; <span class=\"hljs-number\">0</span>) &#123;<br>    ipValue = <span class=\"hljs-number\">0</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (ipValue &gt; <span class=\"hljs-number\">255</span>) &#123;<br>    ipValue = <span class=\"hljs-number\">255</span>;<br>  &#125;<br>  preValue[index] = ipValue; <span class=\"hljs-comment\">//这里数据引用地址的值同样被修改</span><br>  <span class=\"hljs-keyword\">return</span> [...preValue]; <span class=\"hljs-comment\">// 数据最外层的引用地址不同即可触发组件更新</span><br>&#125;<br><br>setValue(<span class=\"hljs-function\">(<span class=\"hljs-params\">preValue</span>) =&gt;</span> nextValue(preValue));<br></code></pre></div></td></tr></table></figure></li>\n<li><p>深拷贝对象，用全新的副本更新数据。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">nextValue</span>(<span class=\"hljs-params\">preValue</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> newValue = _.cloneDeep(preValue);<br>  <span class=\"hljs-keyword\">let</span> ipValue = <span class=\"hljs-built_in\">Number</span>.parseInt(newVal, <span class=\"hljs-number\">10</span>);<br><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Number</span>.isNaN(ipValue)) &#123;<br>    ipValue = <span class=\"hljs-literal\">undefined</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (ipValue &lt; <span class=\"hljs-number\">0</span>) &#123;<br>    ipValue = <span class=\"hljs-number\">0</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (ipValue &gt; <span class=\"hljs-number\">255</span>) &#123;<br>    ipValue = <span class=\"hljs-number\">255</span>;<br>  &#125;<br>  newValue[index] = ipValue; <span class=\"hljs-comment\">//这里数据引用地址的值同样被修改</span><br>  <span class=\"hljs-keyword\">return</span> newValue; <span class=\"hljs-comment\">// 数据最外层的引用地址不同即可触发组件更新</span><br>&#125;<br><br>setValue(<span class=\"hljs-function\">(<span class=\"hljs-params\">preValue</span>) =&gt;</span> nextValue(preValue));<br></code></pre></div></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"wordcount":1239,"excerpt":"","more":"<h2 id=\"useState-函数式更新\"><a href=\"#useState-函数式更新\" class=\"headerlink\" title=\"useState 函数式更新\"></a>useState 函数式更新</h2><p>与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> [state, setState] = useState(&#123;&#125;);<br>setState(<span class=\"hljs-function\">(<span class=\"hljs-params\">prevState</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-comment\">// 也可以使用 Object.assign</span><br>  <span class=\"hljs-keyword\">return</span> &#123; ...prevState, ...updatedValues &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"引用类型-state-更新\"><a href=\"#引用类型-state-更新\" class=\"headerlink\" title=\"引用类型 state 更新\"></a>引用类型 state 更新</h2><p>经常 state 数据不是简单数据类型(值类型)，而是数组、对象之类(引用类型).而 React 组件的更新机制对 state 只进行浅对比，也就是更新某个复杂类型数据时只要它的引用地址没变，那就不会重新渲染组件。</p>\n<p>尤其当被更新的引用类型数据需要依赖之前的数据时，容易踩坑,不触发更新。更新复杂 state 的时候必须传给它一个全新的对象，而不是复制了它引用地址再修改的对象。</p>\n<p>两种解决办法：</p>\n<ol>\n<li><p>结合展开运算符返回一个新对象</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">nextValue</span>(<span class=\"hljs-params\">preValue</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> ipValue = <span class=\"hljs-built_in\">Number</span>.parseInt(newVal, <span class=\"hljs-number\">10</span>);<br><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Number</span>.isNaN(ipValue)) &#123;<br>    ipValue = <span class=\"hljs-literal\">undefined</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (ipValue &lt; <span class=\"hljs-number\">0</span>) &#123;<br>    ipValue = <span class=\"hljs-number\">0</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (ipValue &gt; <span class=\"hljs-number\">255</span>) &#123;<br>    ipValue = <span class=\"hljs-number\">255</span>;<br>  &#125;<br>  preValue[index] = ipValue; <span class=\"hljs-comment\">//这里数据引用地址的值同样被修改</span><br>  <span class=\"hljs-keyword\">return</span> [...preValue]; <span class=\"hljs-comment\">// 数据最外层的引用地址不同即可触发组件更新</span><br>&#125;<br><br>setValue(<span class=\"hljs-function\">(<span class=\"hljs-params\">preValue</span>) =&gt;</span> nextValue(preValue));<br></code></pre></td></tr></table></figure></li>\n<li><p>深拷贝对象，用全新的副本更新数据。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">nextValue</span>(<span class=\"hljs-params\">preValue</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> newValue = _.cloneDeep(preValue);<br>  <span class=\"hljs-keyword\">let</span> ipValue = <span class=\"hljs-built_in\">Number</span>.parseInt(newVal, <span class=\"hljs-number\">10</span>);<br><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Number</span>.isNaN(ipValue)) &#123;<br>    ipValue = <span class=\"hljs-literal\">undefined</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (ipValue &lt; <span class=\"hljs-number\">0</span>) &#123;<br>    ipValue = <span class=\"hljs-number\">0</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">if</span> (ipValue &gt; <span class=\"hljs-number\">255</span>) &#123;<br>    ipValue = <span class=\"hljs-number\">255</span>;<br>  &#125;<br>  newValue[index] = ipValue; <span class=\"hljs-comment\">//这里数据引用地址的值同样被修改</span><br>  <span class=\"hljs-keyword\">return</span> newValue; <span class=\"hljs-comment\">// 数据最外层的引用地址不同即可触发组件更新</span><br>&#125;<br><br>setValue(<span class=\"hljs-function\">(<span class=\"hljs-params\">preValue</span>) =&gt;</span> nextValue(preValue));<br></code></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"FE-Interview","index_img":"/img/2022-01-01-1.jpeg","abbrlink":"12d2438b","date":"2022-01-01T15:28:37.000Z","_content":"\n## 第 1 天 (2022.02.28)\n\n### 1. 什么时候使用状态管理器？\n\n1. 组件状态要在多个组件共享时\n1. 某个组件状态需要在任何地方可以拿到\n1. 一个组件需要改变全局状态时\n1. 一个组件需要改变另一个组件状态时\n1. 组件状态提升提升不能满足需求时，层级过多时。\n\n### 2. render 函数中 return 如果没有使用()会有什么问题？\n\n避免遇到自动插入分号陷阱。\n\n我们在使用 JSX 语法书写 react 代码时，babel 会将 JSX 语法编译成 js，同时会在每行自动添加分号（；），如果 return 后换行了，那么就会变成 return； 一般情况下会报错：\n\nNothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.\n上面这段英文翻译成中文：\n\n渲染没有返回任何内容。这通常意味着缺少 return 语句。或者，为了不渲染，返回 null。\n为了代码可读性我们一般会在 return 后面添加括号这样代码可以折行书写，否则就在 return 后面紧跟着语句，这样也是可以的。\n\n举两个正确的书写例子：\n\n```jsx\nconst Nav = () => {\n  return (\n    <nav className=\"c_navbar\">\n      { some jsx magic here }\n    </nav>\n    )\n  }\n\nconst Nav = () => {\nreturn <nav className=\"c_navbar\">\n    { some jsx magic here }\n  </nav>\n}\n```\n\n错误的写法：\n\n```jsx\nconst Nav = () => {\n  return\n    <nav className=\"c_navbar\">\n      { some jsx magic here }\n    </nav>\n}\n```\n\n### 3. componentWillUpdate 可以直接修改 state 的值吗？\n\n直接修改不可以，但是加上条件就可以。\n\n文档原文：“你也可以在 componentDidUpdate() 中直接调用 setState()，但请注意它必须被包裹在一个条件语句里，正如上述的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。”\n\ncomponentWillReceiveProps 同理\n\n### 4. 说说你对 React 的渲染原理的理解\n\n1. React 会调用 React.render()构建一颗 DOM 树，生成虚拟 dom。\n2. 通过改变 state 或 props 触发更新。\n3. 对比新旧虚拟 dom，diff 算法，深度优先，将实际需要改变的反应到真实 dom。\n\n## 第 2 天 (2022.03.01)\n\n### 5. 什么渲染劫持？\n\n一般和高阶组件（HOC）一起解释。\n\n高阶组件在 render 的时候可以做其他操作，从而控制原组件的渲染输出，这种改变原组件渲染的方式称为 渲染劫持。\n\n在高阶组件中，组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可实现渲染劫持，还可以增强原组件 render 函数。\n\n除了 HOC，当新写一个组件，继承自一个已有的组件，可以随便修改 render 函数，使用 state、props 等改变原组件的渲染，都叫渲染劫持。\n\n#### PS: HOC 反向继承\n\nTODO：\n\n### 6. React Intl是什么原理？\n\nReact Intl 用途是国际化库，提供组件、日期等国际化方法。\n\n做国际化就类似于字体文件，通过切换语言，加载不同语言包到本地.\n\n最外层包一个Provider。调用库中方法，完成国际化。\n\n前端国际化核心步骤有两步：\n\n- 创建资源文件，以 key-value 方式存储\n- 加载资源文件，将页面上 key 的内容替换为相关 value\n\n### 7. 怎么实现React组件的国际化呢？\n\n 使用 i18next 以及 react-i18next 配合 i18next-scanner，通过 grunt 跑 task 自动扫描生成 json 文件。\n\n 现在大厂比较常用的方案是，使用AST，每次开发完新版本，通过AST去扫描所有的代码，找出代码中的中文，以中文为key，调用智能翻译服务，去帮项目自动生成json文件。这样，再也不需要人为去维护json文件，一切都依赖工具进行自动化。\n\n## 第 3 天（2022.3.2）\n\n### 8. 说说Context有哪些属性？\n\ncontext属于一种解决组件间层级过多传递数据的问题，避免了层层嵌套的通过props传递的形式，同时对于不需要使用到redux时，是一种解决方案。\n\nContext.Provider：生产者，数据提供方；通过value属性来定义需要被传递的数据\nContext.Consumer：消费者，数据获取方；根据是函数组件还是class组件，有不同的使用形式；class组件可以指定contextType来确定要使用哪一个context对象的值，函数组件需要使用回调函数的形式来获取context的值；需要显示的指定context对象；\n\n### 9. 怎么使用Context开发组件？\n\n```jsx\nconst themes = {\n  light: {\n    foreground: \"#000000\",\n    background: \"#eeeeee\"\n  },\n  dark: {\n    foreground: \"#ffffff\",\n    background: \"#222222\"\n  }\n};\n// 首先创建一个 context 对象这里命名为：ThemeContext\nconst ThemeContext = React.createContext(themes.light);\n\n// 创建一个祖先组件组件 内部使用Provier 这个对象创建一个组件 其中 value 属性是真实传递的属性\nfunction App() {\n  return (\n    <ThemeContext.Provider value={themes.dark}>\n      <Toolbar />\n    </ThemeContext.Provider>\n  );\n}\n\n// 渲染 button 组件的外层包裹的属性\nfunction Toolbar(props) {\n  return (\n    <div>\n      <ThemedButton />\n    </div>\n  );\n}\n\n// 在 Toolbar 中渲染的button 组件 使用 useContext，将 value 值跨组件传递给 // ThemeButton 组件\nfunction ThemedButton() {\n  const theme = useContext(ThemeContext);\n  return (\n    <button style={{ background: theme.background, color: theme.foreground }}>\n      I am styled by theme context!\n    </button>\n  );\n}\n```\n\n### 10. 为什么React并不推荐我们优先考虑使用Context？\n\n1、Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。\n2、尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context\n3、对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。\n4、context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注。\n\n## 第 4 天（2022.3.3）\n\n### 11. childContextTypes是什么？它有什么用？\n\nchildContextTypes用来定义context数据类型，该api从16.3开始已被废弃\n\n使用方式\n\n```jsx\nclass MessageList extends React.Component {\n  getChildContext() {\n    return {color: \"purple\"};\n  }\n\n  render() {\n    return <div>MessageList</div>;\n  }\n}\n\nMessageList.childContextTypes = {\n  color: PropTypes.string\n};\n\n```\n\n### 12. Consumer向上找不到Provider的时候怎么办？\n\n当consumer向上层找不到provider时，此时就会取创建context时传给createContext的那个值，也就是当前context对象的默认值，在定义provider时的value中的值不是默认值，而是表示需要被传递的值.\n\n## 第 5 天（2022.3.4）\n\n### 13. 说说你对windowing的了解\n\n展示长列表\n如果你的应用会渲染大量的列表数据，我们建议使用一种称为‘windowing’的技术，这种技术下在任何给定的时间内只会渲染一小部分数据列表，并可以减少列表项的重复渲染（即再次渲染已经渲染过的数据）。\n\nreact-window和react-virtualized都是流行的使用windowing技术的库，他们都提供了一系列可重用的组件，这些组件能够帮助你以最好的性能展示列表以及表格数据\n\n### 14. 举例说明React的 portal 有哪些运用场景？\n\nportal可以将内容插入到除了父节点的dom之外的地方去渲染，所以modal是一个通过portal实现的典型例子；并且对于事件绑定，因为使用了事件冒泡，所以并不用担心被渲染到父组件结构之外的内容，不能去监听事件\n\n### 15. 你有用过React的插槽(Portals)吗？怎么用？\n\n1、首先简单的介绍下react中的插槽（Portals），通过ReactDOM.createPortal(child, container)创建，是ReactDOM提供的接口，可以实现将子节点渲染到父组件DOM层次结构之外的DOM节点。\n2、第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 片段(fragment)。第二个参数（container）则是一个 DOM 元素。\n3、对于 portal 的一个典型用例是当父组件有 overflow: hidden 或 z-index 样式，但你需要子组件能够在视觉上 “跳出(break out)” 其容器。例如，对话框、hovercards以及提示框。所以一般react组件里的模态框，就是这样实现的。\n\n如果一个子组件的真实DOM结构必须渲染到当前组件外，但又想保留这两者的父子关系，就可以用Protals。\n\n```jsx\nconst Modal = (props) => {\n  const modal = document.body.createElement('div');\n  document.appendChild(modal);\n  useEffect(() => {\n    return () => {\n      document.body.removeChild(modal);\n    }\n  }, []);\n  return React.createPortal(this.props.children, modal);\n}\nconst Parent = () => {\n  const [sum, setSum] = useState(0);\n  const add = () => setSum(sum + 1);\n  return <div onClick={add}>\n    <Modal>加一</Modal>\n  </div>\n}\n```\n\n## 第 6 天（2022.3.5）\n\n### 16. React的严格模式有什么用处？\n\nStrictMode 目前有助于：\n\n- 识别不安全的生命周期\n- 关于使用过时字符串 ref API 的警告\n- 关于使用废弃的 findDOMNode 方法的警告\n- 检测意外的副作用\n- 检测过时的 context API\n\n可以为程序的任何部分使用严格模式\n\n```jsx\nimport React from 'react';\n\nfunction ExampleApplication() {\n  return (\n    <div>\n      <Header />\n      <React.StrictMode>\n        <div>\n          <ComponentOne />\n          <ComponentTwo />\n        </div>\n      </React.StrictMode>\n      <Footer />\n    </div>\n  );\n}\n// 不会对 Header 和 Footer 组件运行严格模式检查。但是，ComponentOne 和 ComponentTwo 以及它们的所有后代元素都将进行检查。\n```\n\n### 17. React如何进行代码拆分？拆分的原则是什么？\n\nreact的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。\n\n在我们的react项目中：\n1、在 api 层面我们单独封装，对外暴露http请求的结果。\n2、数据层我们使用的react-redux 异步中间件使用的是redux-thunk 分装处理异步请求，合业务逻辑处理。\n3、视图层，尽量使用 redux 层面的传递过来的数据，修改逻辑 也是重新触发action 更改props。\n4、静态类型的资源单独放置\n5、公共组件、高阶组件、插件单独放置\n6、工具类文件单独放置\n\n### 18. React组件的构造函数有什么作用？\n\n官网中，构造函数仅用于以下两种情况：\n\n- 通过给 this.state 赋值对象来初始化内部 state。\n- 为事件处理函数绑定实例\n\n```jsx\nconstructor(props) {\n  super(props);\n  // 不要在这里调用 this.setState()\n  this.state = { counter: 0 };\n  this.handleClick = this.handleClick.bind(this);\n}\n```\n\n避免将 props 的值复制给 state！这是一个常见的错误：\n\n```jsx\nconstructor(props) {\n super(props);\n // 不要这样做\n this.state = { color: props.color };\n}\n```\n\n如此做毫无必要（你可以直接使用 this.props.color），同时还产生了 bug（更新 prop 中的 color 时，并不会影响 state）。\n\n### 19. React组件的构造函数是必须的吗？\n\nfunction组件不用考虑构造函数；\n对于class组件，如果不写构造函数，默认会被隐式调用.\n\n对于无状态组件，内部没有维护自己的state，只接收外部传入的props 是不需要声明构造函数的.\n\n## 第 7 天（2022.3.6）\n\n### 20. React中在哪捕获错误？\n\n可以使用错误边界组件来捕获异常；这样可以使用替代ui来代替错误位置的渲染；而不是让程序崩溃；\n主要来捕获生命周期异常，渲染中的异常\n\n使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息\n\n定义错误边界当做常规组件包裹ui组件, 官网例子：\n\n```jsx\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    // 更新 state 使下一次渲染能够显示降级后的 UI\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // 你同样可以将错误日志上报给服务器\n    logErrorToMyService(error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // 你可以自定义降级后的 UI 并渲染\n      return <h1>Something went wrong.</h1>;\n    }\n\n    return this.props.children; \n  }\n}\n```\n\n```jsx\n<ErrorBoundary>\n  <MyWidget />\n</ErrorBoundary>\n```\n\n但是错误边界不会捕获 :\n\n```jsx\ntry{}catch(err){}\n///异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）\n///服务端渲染\n///它自身抛出来的错误（并非它的子组件)\n```\n\n### 21. React怎样引入svg的文件？\n\n方法1： 这种写法会由webpack转为url方式引入。\n\n```jsx\n// svg png等类型图片\nimport logo from './logo.svg';\n//...\n<img src={logo} className=\"App-logo\" alt=\"logo\" />\n//...\n```\n\n方法2： 这种方式仅对SVG图片生效，将svg看作组件导入：\n\n```jsx\n// ...\nimport { ReactComponent as Logo } from './logo.svg'\n// ...\n<Logo />\n```\n\n### 22. 在React中你有经常使用常量吗？\n\n在redux的action文件里面定义不同的行为可能会使用常量的形式。\n\n\n## 第 8 天（2022.3.7）\n","source":"_posts/2022-01-01-1.md","raw":"---\ntitle: FE-Interview\nindex_img: /img/2022-01-01-1.jpeg\ntags: 前端\ncategories: 面试\nabbrlink: 12d2438b\ndate: 2022-01-01 23:28:37\n---\n\n## 第 1 天 (2022.02.28)\n\n### 1. 什么时候使用状态管理器？\n\n1. 组件状态要在多个组件共享时\n1. 某个组件状态需要在任何地方可以拿到\n1. 一个组件需要改变全局状态时\n1. 一个组件需要改变另一个组件状态时\n1. 组件状态提升提升不能满足需求时，层级过多时。\n\n### 2. render 函数中 return 如果没有使用()会有什么问题？\n\n避免遇到自动插入分号陷阱。\n\n我们在使用 JSX 语法书写 react 代码时，babel 会将 JSX 语法编译成 js，同时会在每行自动添加分号（；），如果 return 后换行了，那么就会变成 return； 一般情况下会报错：\n\nNothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.\n上面这段英文翻译成中文：\n\n渲染没有返回任何内容。这通常意味着缺少 return 语句。或者，为了不渲染，返回 null。\n为了代码可读性我们一般会在 return 后面添加括号这样代码可以折行书写，否则就在 return 后面紧跟着语句，这样也是可以的。\n\n举两个正确的书写例子：\n\n```jsx\nconst Nav = () => {\n  return (\n    <nav className=\"c_navbar\">\n      { some jsx magic here }\n    </nav>\n    )\n  }\n\nconst Nav = () => {\nreturn <nav className=\"c_navbar\">\n    { some jsx magic here }\n  </nav>\n}\n```\n\n错误的写法：\n\n```jsx\nconst Nav = () => {\n  return\n    <nav className=\"c_navbar\">\n      { some jsx magic here }\n    </nav>\n}\n```\n\n### 3. componentWillUpdate 可以直接修改 state 的值吗？\n\n直接修改不可以，但是加上条件就可以。\n\n文档原文：“你也可以在 componentDidUpdate() 中直接调用 setState()，但请注意它必须被包裹在一个条件语句里，正如上述的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。”\n\ncomponentWillReceiveProps 同理\n\n### 4. 说说你对 React 的渲染原理的理解\n\n1. React 会调用 React.render()构建一颗 DOM 树，生成虚拟 dom。\n2. 通过改变 state 或 props 触发更新。\n3. 对比新旧虚拟 dom，diff 算法，深度优先，将实际需要改变的反应到真实 dom。\n\n## 第 2 天 (2022.03.01)\n\n### 5. 什么渲染劫持？\n\n一般和高阶组件（HOC）一起解释。\n\n高阶组件在 render 的时候可以做其他操作，从而控制原组件的渲染输出，这种改变原组件渲染的方式称为 渲染劫持。\n\n在高阶组件中，组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可实现渲染劫持，还可以增强原组件 render 函数。\n\n除了 HOC，当新写一个组件，继承自一个已有的组件，可以随便修改 render 函数，使用 state、props 等改变原组件的渲染，都叫渲染劫持。\n\n#### PS: HOC 反向继承\n\nTODO：\n\n### 6. React Intl是什么原理？\n\nReact Intl 用途是国际化库，提供组件、日期等国际化方法。\n\n做国际化就类似于字体文件，通过切换语言，加载不同语言包到本地.\n\n最外层包一个Provider。调用库中方法，完成国际化。\n\n前端国际化核心步骤有两步：\n\n- 创建资源文件，以 key-value 方式存储\n- 加载资源文件，将页面上 key 的内容替换为相关 value\n\n### 7. 怎么实现React组件的国际化呢？\n\n 使用 i18next 以及 react-i18next 配合 i18next-scanner，通过 grunt 跑 task 自动扫描生成 json 文件。\n\n 现在大厂比较常用的方案是，使用AST，每次开发完新版本，通过AST去扫描所有的代码，找出代码中的中文，以中文为key，调用智能翻译服务，去帮项目自动生成json文件。这样，再也不需要人为去维护json文件，一切都依赖工具进行自动化。\n\n## 第 3 天（2022.3.2）\n\n### 8. 说说Context有哪些属性？\n\ncontext属于一种解决组件间层级过多传递数据的问题，避免了层层嵌套的通过props传递的形式，同时对于不需要使用到redux时，是一种解决方案。\n\nContext.Provider：生产者，数据提供方；通过value属性来定义需要被传递的数据\nContext.Consumer：消费者，数据获取方；根据是函数组件还是class组件，有不同的使用形式；class组件可以指定contextType来确定要使用哪一个context对象的值，函数组件需要使用回调函数的形式来获取context的值；需要显示的指定context对象；\n\n### 9. 怎么使用Context开发组件？\n\n```jsx\nconst themes = {\n  light: {\n    foreground: \"#000000\",\n    background: \"#eeeeee\"\n  },\n  dark: {\n    foreground: \"#ffffff\",\n    background: \"#222222\"\n  }\n};\n// 首先创建一个 context 对象这里命名为：ThemeContext\nconst ThemeContext = React.createContext(themes.light);\n\n// 创建一个祖先组件组件 内部使用Provier 这个对象创建一个组件 其中 value 属性是真实传递的属性\nfunction App() {\n  return (\n    <ThemeContext.Provider value={themes.dark}>\n      <Toolbar />\n    </ThemeContext.Provider>\n  );\n}\n\n// 渲染 button 组件的外层包裹的属性\nfunction Toolbar(props) {\n  return (\n    <div>\n      <ThemedButton />\n    </div>\n  );\n}\n\n// 在 Toolbar 中渲染的button 组件 使用 useContext，将 value 值跨组件传递给 // ThemeButton 组件\nfunction ThemedButton() {\n  const theme = useContext(ThemeContext);\n  return (\n    <button style={{ background: theme.background, color: theme.foreground }}>\n      I am styled by theme context!\n    </button>\n  );\n}\n```\n\n### 10. 为什么React并不推荐我们优先考虑使用Context？\n\n1、Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。\n2、尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context\n3、对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。\n4、context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注。\n\n## 第 4 天（2022.3.3）\n\n### 11. childContextTypes是什么？它有什么用？\n\nchildContextTypes用来定义context数据类型，该api从16.3开始已被废弃\n\n使用方式\n\n```jsx\nclass MessageList extends React.Component {\n  getChildContext() {\n    return {color: \"purple\"};\n  }\n\n  render() {\n    return <div>MessageList</div>;\n  }\n}\n\nMessageList.childContextTypes = {\n  color: PropTypes.string\n};\n\n```\n\n### 12. Consumer向上找不到Provider的时候怎么办？\n\n当consumer向上层找不到provider时，此时就会取创建context时传给createContext的那个值，也就是当前context对象的默认值，在定义provider时的value中的值不是默认值，而是表示需要被传递的值.\n\n## 第 5 天（2022.3.4）\n\n### 13. 说说你对windowing的了解\n\n展示长列表\n如果你的应用会渲染大量的列表数据，我们建议使用一种称为‘windowing’的技术，这种技术下在任何给定的时间内只会渲染一小部分数据列表，并可以减少列表项的重复渲染（即再次渲染已经渲染过的数据）。\n\nreact-window和react-virtualized都是流行的使用windowing技术的库，他们都提供了一系列可重用的组件，这些组件能够帮助你以最好的性能展示列表以及表格数据\n\n### 14. 举例说明React的 portal 有哪些运用场景？\n\nportal可以将内容插入到除了父节点的dom之外的地方去渲染，所以modal是一个通过portal实现的典型例子；并且对于事件绑定，因为使用了事件冒泡，所以并不用担心被渲染到父组件结构之外的内容，不能去监听事件\n\n### 15. 你有用过React的插槽(Portals)吗？怎么用？\n\n1、首先简单的介绍下react中的插槽（Portals），通过ReactDOM.createPortal(child, container)创建，是ReactDOM提供的接口，可以实现将子节点渲染到父组件DOM层次结构之外的DOM节点。\n2、第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 片段(fragment)。第二个参数（container）则是一个 DOM 元素。\n3、对于 portal 的一个典型用例是当父组件有 overflow: hidden 或 z-index 样式，但你需要子组件能够在视觉上 “跳出(break out)” 其容器。例如，对话框、hovercards以及提示框。所以一般react组件里的模态框，就是这样实现的。\n\n如果一个子组件的真实DOM结构必须渲染到当前组件外，但又想保留这两者的父子关系，就可以用Protals。\n\n```jsx\nconst Modal = (props) => {\n  const modal = document.body.createElement('div');\n  document.appendChild(modal);\n  useEffect(() => {\n    return () => {\n      document.body.removeChild(modal);\n    }\n  }, []);\n  return React.createPortal(this.props.children, modal);\n}\nconst Parent = () => {\n  const [sum, setSum] = useState(0);\n  const add = () => setSum(sum + 1);\n  return <div onClick={add}>\n    <Modal>加一</Modal>\n  </div>\n}\n```\n\n## 第 6 天（2022.3.5）\n\n### 16. React的严格模式有什么用处？\n\nStrictMode 目前有助于：\n\n- 识别不安全的生命周期\n- 关于使用过时字符串 ref API 的警告\n- 关于使用废弃的 findDOMNode 方法的警告\n- 检测意外的副作用\n- 检测过时的 context API\n\n可以为程序的任何部分使用严格模式\n\n```jsx\nimport React from 'react';\n\nfunction ExampleApplication() {\n  return (\n    <div>\n      <Header />\n      <React.StrictMode>\n        <div>\n          <ComponentOne />\n          <ComponentTwo />\n        </div>\n      </React.StrictMode>\n      <Footer />\n    </div>\n  );\n}\n// 不会对 Header 和 Footer 组件运行严格模式检查。但是，ComponentOne 和 ComponentTwo 以及它们的所有后代元素都将进行检查。\n```\n\n### 17. React如何进行代码拆分？拆分的原则是什么？\n\nreact的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。\n\n在我们的react项目中：\n1、在 api 层面我们单独封装，对外暴露http请求的结果。\n2、数据层我们使用的react-redux 异步中间件使用的是redux-thunk 分装处理异步请求，合业务逻辑处理。\n3、视图层，尽量使用 redux 层面的传递过来的数据，修改逻辑 也是重新触发action 更改props。\n4、静态类型的资源单独放置\n5、公共组件、高阶组件、插件单独放置\n6、工具类文件单独放置\n\n### 18. React组件的构造函数有什么作用？\n\n官网中，构造函数仅用于以下两种情况：\n\n- 通过给 this.state 赋值对象来初始化内部 state。\n- 为事件处理函数绑定实例\n\n```jsx\nconstructor(props) {\n  super(props);\n  // 不要在这里调用 this.setState()\n  this.state = { counter: 0 };\n  this.handleClick = this.handleClick.bind(this);\n}\n```\n\n避免将 props 的值复制给 state！这是一个常见的错误：\n\n```jsx\nconstructor(props) {\n super(props);\n // 不要这样做\n this.state = { color: props.color };\n}\n```\n\n如此做毫无必要（你可以直接使用 this.props.color），同时还产生了 bug（更新 prop 中的 color 时，并不会影响 state）。\n\n### 19. React组件的构造函数是必须的吗？\n\nfunction组件不用考虑构造函数；\n对于class组件，如果不写构造函数，默认会被隐式调用.\n\n对于无状态组件，内部没有维护自己的state，只接收外部传入的props 是不需要声明构造函数的.\n\n## 第 7 天（2022.3.6）\n\n### 20. React中在哪捕获错误？\n\n可以使用错误边界组件来捕获异常；这样可以使用替代ui来代替错误位置的渲染；而不是让程序崩溃；\n主要来捕获生命周期异常，渲染中的异常\n\n使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息\n\n定义错误边界当做常规组件包裹ui组件, 官网例子：\n\n```jsx\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    // 更新 state 使下一次渲染能够显示降级后的 UI\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // 你同样可以将错误日志上报给服务器\n    logErrorToMyService(error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // 你可以自定义降级后的 UI 并渲染\n      return <h1>Something went wrong.</h1>;\n    }\n\n    return this.props.children; \n  }\n}\n```\n\n```jsx\n<ErrorBoundary>\n  <MyWidget />\n</ErrorBoundary>\n```\n\n但是错误边界不会捕获 :\n\n```jsx\ntry{}catch(err){}\n///异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）\n///服务端渲染\n///它自身抛出来的错误（并非它的子组件)\n```\n\n### 21. React怎样引入svg的文件？\n\n方法1： 这种写法会由webpack转为url方式引入。\n\n```jsx\n// svg png等类型图片\nimport logo from './logo.svg';\n//...\n<img src={logo} className=\"App-logo\" alt=\"logo\" />\n//...\n```\n\n方法2： 这种方式仅对SVG图片生效，将svg看作组件导入：\n\n```jsx\n// ...\nimport { ReactComponent as Logo } from './logo.svg'\n// ...\n<Logo />\n```\n\n### 22. 在React中你有经常使用常量吗？\n\n在redux的action文件里面定义不同的行为可能会使用常量的形式。\n\n\n## 第 8 天（2022.3.7）\n","slug":"1","published":1,"updated":"2022-03-06T10:08:02.020Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0f42s2p000ovw3l0dmmakvq","content":"<h2 id=\"第-1-天-2022-02-28\"><a href=\"#第-1-天-2022-02-28\" class=\"headerlink\" title=\"第 1 天 (2022.02.28)\"></a>第 1 天 (2022.02.28)</h2><h3 id=\"1-什么时候使用状态管理器？\"><a href=\"#1-什么时候使用状态管理器？\" class=\"headerlink\" title=\"1. 什么时候使用状态管理器？\"></a>1. 什么时候使用状态管理器？</h3><ol>\n<li>组件状态要在多个组件共享时</li>\n<li>某个组件状态需要在任何地方可以拿到</li>\n<li>一个组件需要改变全局状态时</li>\n<li>一个组件需要改变另一个组件状态时</li>\n<li>组件状态提升提升不能满足需求时，层级过多时。</li>\n</ol>\n<h3 id=\"2-render-函数中-return-如果没有使用-会有什么问题？\"><a href=\"#2-render-函数中-return-如果没有使用-会有什么问题？\" class=\"headerlink\" title=\"2. render 函数中 return 如果没有使用()会有什么问题？\"></a>2. render 函数中 return 如果没有使用()会有什么问题？</h3><p>避免遇到自动插入分号陷阱。</p>\n<p>我们在使用 JSX 语法书写 react 代码时，babel 会将 JSX 语法编译成 js，同时会在每行自动添加分号（；），如果 return 后换行了，那么就会变成 return； 一般情况下会报错：</p>\n<p>Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.<br>上面这段英文翻译成中文：</p>\n<p>渲染没有返回任何内容。这通常意味着缺少 return 语句。或者，为了不渲染，返回 null。<br>为了代码可读性我们一般会在 return 后面添加括号这样代码可以折行书写，否则就在 return 后面紧跟着语句，这样也是可以的。</p>\n<p>举两个正确的书写例子：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Nav = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;c_navbar&quot;</span>&gt;</span></span><br><span class=\"xml\">      &#123; some jsx magic here &#125;</span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span></span><br>    )<br>  &#125;<br><br><span class=\"hljs-keyword\">const</span> Nav = <span class=\"hljs-function\">() =&gt;</span> &#123;<br><span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;c_navbar&quot;</span>&gt;</span></span><br><span class=\"xml\">    &#123; some jsx magic here &#125;</span><br><span class=\"xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span></span><br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>错误的写法：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Nav = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span><br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;c_navbar&quot;</span>&gt;</span></span><br><span class=\"xml\">      &#123; some jsx magic here &#125;</span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span></span><br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"3-componentWillUpdate-可以直接修改-state-的值吗？\"><a href=\"#3-componentWillUpdate-可以直接修改-state-的值吗？\" class=\"headerlink\" title=\"3. componentWillUpdate 可以直接修改 state 的值吗？\"></a>3. componentWillUpdate 可以直接修改 state 的值吗？</h3><p>直接修改不可以，但是加上条件就可以。</p>\n<p>文档原文：“你也可以在 componentDidUpdate() 中直接调用 setState()，但请注意它必须被包裹在一个条件语句里，正如上述的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。”</p>\n<p>componentWillReceiveProps 同理</p>\n<h3 id=\"4-说说你对-React-的渲染原理的理解\"><a href=\"#4-说说你对-React-的渲染原理的理解\" class=\"headerlink\" title=\"4. 说说你对 React 的渲染原理的理解\"></a>4. 说说你对 React 的渲染原理的理解</h3><ol>\n<li>React 会调用 React.render()构建一颗 DOM 树，生成虚拟 dom。</li>\n<li>通过改变 state 或 props 触发更新。</li>\n<li>对比新旧虚拟 dom，diff 算法，深度优先，将实际需要改变的反应到真实 dom。</li>\n</ol>\n<h2 id=\"第-2-天-2022-03-01\"><a href=\"#第-2-天-2022-03-01\" class=\"headerlink\" title=\"第 2 天 (2022.03.01)\"></a>第 2 天 (2022.03.01)</h2><h3 id=\"5-什么渲染劫持？\"><a href=\"#5-什么渲染劫持？\" class=\"headerlink\" title=\"5. 什么渲染劫持？\"></a>5. 什么渲染劫持？</h3><p>一般和高阶组件（HOC）一起解释。</p>\n<p>高阶组件在 render 的时候可以做其他操作，从而控制原组件的渲染输出，这种改变原组件渲染的方式称为 渲染劫持。</p>\n<p>在高阶组件中，组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可实现渲染劫持，还可以增强原组件 render 函数。</p>\n<p>除了 HOC，当新写一个组件，继承自一个已有的组件，可以随便修改 render 函数，使用 state、props 等改变原组件的渲染，都叫渲染劫持。</p>\n<h4 id=\"PS-HOC-反向继承\"><a href=\"#PS-HOC-反向继承\" class=\"headerlink\" title=\"PS: HOC 反向继承\"></a>PS: HOC 反向继承</h4><p>TODO：</p>\n<h3 id=\"6-React-Intl是什么原理？\"><a href=\"#6-React-Intl是什么原理？\" class=\"headerlink\" title=\"6. React Intl是什么原理？\"></a>6. React Intl是什么原理？</h3><p>React Intl 用途是国际化库，提供组件、日期等国际化方法。</p>\n<p>做国际化就类似于字体文件，通过切换语言，加载不同语言包到本地.</p>\n<p>最外层包一个Provider。调用库中方法，完成国际化。</p>\n<p>前端国际化核心步骤有两步：</p>\n<ul>\n<li>创建资源文件，以 key-value 方式存储</li>\n<li>加载资源文件，将页面上 key 的内容替换为相关 value</li>\n</ul>\n<h3 id=\"7-怎么实现React组件的国际化呢？\"><a href=\"#7-怎么实现React组件的国际化呢？\" class=\"headerlink\" title=\"7. 怎么实现React组件的国际化呢？\"></a>7. 怎么实现React组件的国际化呢？</h3><p> 使用 i18next 以及 react-i18next 配合 i18next-scanner，通过 grunt 跑 task 自动扫描生成 json 文件。</p>\n<p> 现在大厂比较常用的方案是，使用AST，每次开发完新版本，通过AST去扫描所有的代码，找出代码中的中文，以中文为key，调用智能翻译服务，去帮项目自动生成json文件。这样，再也不需要人为去维护json文件，一切都依赖工具进行自动化。</p>\n<h2 id=\"第-3-天（2022-3-2）\"><a href=\"#第-3-天（2022-3-2）\" class=\"headerlink\" title=\"第 3 天（2022.3.2）\"></a>第 3 天（2022.3.2）</h2><h3 id=\"8-说说Context有哪些属性？\"><a href=\"#8-说说Context有哪些属性？\" class=\"headerlink\" title=\"8. 说说Context有哪些属性？\"></a>8. 说说Context有哪些属性？</h3><p>context属于一种解决组件间层级过多传递数据的问题，避免了层层嵌套的通过props传递的形式，同时对于不需要使用到redux时，是一种解决方案。</p>\n<p>Context.Provider：生产者，数据提供方；通过value属性来定义需要被传递的数据<br>Context.Consumer：消费者，数据获取方；根据是函数组件还是class组件，有不同的使用形式；class组件可以指定contextType来确定要使用哪一个context对象的值，函数组件需要使用回调函数的形式来获取context的值；需要显示的指定context对象；</p>\n<h3 id=\"9-怎么使用Context开发组件？\"><a href=\"#9-怎么使用Context开发组件？\" class=\"headerlink\" title=\"9. 怎么使用Context开发组件？\"></a>9. 怎么使用Context开发组件？</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> themes = &#123;<br>  <span class=\"hljs-attr\">light</span>: &#123;<br>    <span class=\"hljs-attr\">foreground</span>: <span class=\"hljs-string\">&quot;#000000&quot;</span>,<br>    <span class=\"hljs-attr\">background</span>: <span class=\"hljs-string\">&quot;#eeeeee&quot;</span><br>  &#125;,<br>  <span class=\"hljs-attr\">dark</span>: &#123;<br>    <span class=\"hljs-attr\">foreground</span>: <span class=\"hljs-string\">&quot;#ffffff&quot;</span>,<br>    <span class=\"hljs-attr\">background</span>: <span class=\"hljs-string\">&quot;#222222&quot;</span><br>  &#125;<br>&#125;;<br><span class=\"hljs-comment\">// 首先创建一个 context 对象这里命名为：ThemeContext</span><br><span class=\"hljs-keyword\">const</span> ThemeContext = React.createContext(themes.light);<br><br><span class=\"hljs-comment\">// 创建一个祖先组件组件 内部使用Provier 这个对象创建一个组件 其中 value 属性是真实传递的属性</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ThemeContext.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;themes.dark&#125;</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Toolbar</span> /&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ThemeContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class=\"hljs-comment\">// 渲染 button 组件的外层包裹的属性</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Toolbar</span>(<span class=\"hljs-params\">props</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ThemedButton</span> /&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class=\"hljs-comment\">// 在 Toolbar 中渲染的button 组件 使用 useContext，将 value 值跨组件传递给 // ThemeButton 组件</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ThemedButton</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> theme = useContext(ThemeContext);<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&#123;&#123;</span> <span class=\"hljs-attr\">background:</span> <span class=\"hljs-attr\">theme.background</span>, <span class=\"hljs-attr\">color:</span> <span class=\"hljs-attr\">theme.foreground</span> &#125;&#125;&gt;</span></span><br><span class=\"xml\">      I am styled by theme context!</span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"10-为什么React并不推荐我们优先考虑使用Context？\"><a href=\"#10-为什么React并不推荐我们优先考虑使用Context？\" class=\"headerlink\" title=\"10. 为什么React并不推荐我们优先考虑使用Context？\"></a>10. 为什么React并不推荐我们优先考虑使用Context？</h3><p>1、Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。<br>2、尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context<br>3、对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。<br>4、context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注。</p>\n<h2 id=\"第-4-天（2022-3-3）\"><a href=\"#第-4-天（2022-3-3）\" class=\"headerlink\" title=\"第 4 天（2022.3.3）\"></a>第 4 天（2022.3.3）</h2><h3 id=\"11-childContextTypes是什么？它有什么用？\"><a href=\"#11-childContextTypes是什么？它有什么用？\" class=\"headerlink\" title=\"11. childContextTypes是什么？它有什么用？\"></a>11. childContextTypes是什么？它有什么用？</h3><p>childContextTypes用来定义context数据类型，该api从16.3开始已被废弃</p>\n<p>使用方式</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MessageList</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">getChildContext</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;purple&quot;</span>&#125;;<br>  &#125;<br><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>MessageList<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br><br>MessageList.childContextTypes = &#123;<br>  <span class=\"hljs-attr\">color</span>: PropTypes.string<br>&#125;;<br><br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"12-Consumer向上找不到Provider的时候怎么办？\"><a href=\"#12-Consumer向上找不到Provider的时候怎么办？\" class=\"headerlink\" title=\"12. Consumer向上找不到Provider的时候怎么办？\"></a>12. Consumer向上找不到Provider的时候怎么办？</h3><p>当consumer向上层找不到provider时，此时就会取创建context时传给createContext的那个值，也就是当前context对象的默认值，在定义provider时的value中的值不是默认值，而是表示需要被传递的值.</p>\n<h2 id=\"第-5-天（2022-3-4）\"><a href=\"#第-5-天（2022-3-4）\" class=\"headerlink\" title=\"第 5 天（2022.3.4）\"></a>第 5 天（2022.3.4）</h2><h3 id=\"13-说说你对windowing的了解\"><a href=\"#13-说说你对windowing的了解\" class=\"headerlink\" title=\"13. 说说你对windowing的了解\"></a>13. 说说你对windowing的了解</h3><p>展示长列表<br>如果你的应用会渲染大量的列表数据，我们建议使用一种称为‘windowing’的技术，这种技术下在任何给定的时间内只会渲染一小部分数据列表，并可以减少列表项的重复渲染（即再次渲染已经渲染过的数据）。</p>\n<p>react-window和react-virtualized都是流行的使用windowing技术的库，他们都提供了一系列可重用的组件，这些组件能够帮助你以最好的性能展示列表以及表格数据</p>\n<h3 id=\"14-举例说明React的-portal-有哪些运用场景？\"><a href=\"#14-举例说明React的-portal-有哪些运用场景？\" class=\"headerlink\" title=\"14. 举例说明React的 portal 有哪些运用场景？\"></a>14. 举例说明React的 portal 有哪些运用场景？</h3><p>portal可以将内容插入到除了父节点的dom之外的地方去渲染，所以modal是一个通过portal实现的典型例子；并且对于事件绑定，因为使用了事件冒泡，所以并不用担心被渲染到父组件结构之外的内容，不能去监听事件</p>\n<h3 id=\"15-你有用过React的插槽-Portals-吗？怎么用？\"><a href=\"#15-你有用过React的插槽-Portals-吗？怎么用？\" class=\"headerlink\" title=\"15. 你有用过React的插槽(Portals)吗？怎么用？\"></a>15. 你有用过React的插槽(Portals)吗？怎么用？</h3><p>1、首先简单的介绍下react中的插槽（Portals），通过ReactDOM.createPortal(child, container)创建，是ReactDOM提供的接口，可以实现将子节点渲染到父组件DOM层次结构之外的DOM节点。<br>2、第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 片段(fragment)。第二个参数（container）则是一个 DOM 元素。<br>3、对于 portal 的一个典型用例是当父组件有 overflow: hidden 或 z-index 样式，但你需要子组件能够在视觉上 “跳出(break out)” 其容器。例如，对话框、hovercards以及提示框。所以一般react组件里的模态框，就是这样实现的。</p>\n<p>如果一个子组件的真实DOM结构必须渲染到当前组件外，但又想保留这两者的父子关系，就可以用Protals。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Modal = <span class=\"hljs-function\">(<span class=\"hljs-params\">props</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> modal = <span class=\"hljs-built_in\">document</span>.body.createElement(<span class=\"hljs-string\">&#x27;div&#x27;</span>);<br>  <span class=\"hljs-built_in\">document</span>.appendChild(modal);<br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-built_in\">document</span>.body.removeChild(modal);<br>    &#125;<br>  &#125;, []);<br>  <span class=\"hljs-keyword\">return</span> React.createPortal(<span class=\"hljs-built_in\">this</span>.props.children, modal);<br>&#125;<br><span class=\"hljs-keyword\">const</span> Parent = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> [sum, setSum] = useState(<span class=\"hljs-number\">0</span>);<br>  <span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\">() =&gt;</span> setSum(sum + <span class=\"hljs-number\">1</span>);<br>  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;add&#125;</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Modal</span>&gt;</span>加一<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Modal</span>&gt;</span></span><br><span class=\"xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"第-6-天（2022-3-5）\"><a href=\"#第-6-天（2022-3-5）\" class=\"headerlink\" title=\"第 6 天（2022.3.5）\"></a>第 6 天（2022.3.5）</h2><h3 id=\"16-React的严格模式有什么用处？\"><a href=\"#16-React的严格模式有什么用处？\" class=\"headerlink\" title=\"16. React的严格模式有什么用处？\"></a>16. React的严格模式有什么用处？</h3><p>StrictMode 目前有助于：</p>\n<ul>\n<li>识别不安全的生命周期</li>\n<li>关于使用过时字符串 ref API 的警告</li>\n<li>关于使用废弃的 findDOMNode 方法的警告</li>\n<li>检测意外的副作用</li>\n<li>检测过时的 context API</li>\n</ul>\n<p>可以为程序的任何部分使用严格模式</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ExampleApplication</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Header</span> /&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">React.StrictMode</span>&gt;</span></span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ComponentOne</span> /&gt;</span></span><br><span class=\"xml\">          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ComponentTwo</span> /&gt;</span></span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">React.StrictMode</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Footer</span> /&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;<br><span class=\"hljs-comment\">// 不会对 Header 和 Footer 组件运行严格模式检查。但是，ComponentOne 和 ComponentTwo 以及它们的所有后代元素都将进行检查。</span><br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"17-React如何进行代码拆分？拆分的原则是什么？\"><a href=\"#17-React如何进行代码拆分？拆分的原则是什么？\" class=\"headerlink\" title=\"17. React如何进行代码拆分？拆分的原则是什么？\"></a>17. React如何进行代码拆分？拆分的原则是什么？</h3><p>react的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。</p>\n<p>在我们的react项目中：<br>1、在 api 层面我们单独封装，对外暴露http请求的结果。<br>2、数据层我们使用的react-redux 异步中间件使用的是redux-thunk 分装处理异步请求，合业务逻辑处理。<br>3、视图层，尽量使用 redux 层面的传递过来的数据，修改逻辑 也是重新触发action 更改props。<br>4、静态类型的资源单独放置<br>5、公共组件、高阶组件、插件单独放置<br>6、工具类文件单独放置</p>\n<h3 id=\"18-React组件的构造函数有什么作用？\"><a href=\"#18-React组件的构造函数有什么作用？\" class=\"headerlink\" title=\"18. React组件的构造函数有什么作用？\"></a>18. React组件的构造函数有什么作用？</h3><p>官网中，构造函数仅用于以下两种情况：</p>\n<ul>\n<li>通过给 this.state 赋值对象来初始化内部 state。</li>\n<li>为事件处理函数绑定实例</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;<br>  <span class=\"hljs-built_in\">super</span>(props);<br>  <span class=\"hljs-comment\">// 不要在这里调用 this.setState()</span><br>  <span class=\"hljs-built_in\">this</span>.state = &#123; <span class=\"hljs-attr\">counter</span>: <span class=\"hljs-number\">0</span> &#125;;<br>  <span class=\"hljs-built_in\">this</span>.handleClick = <span class=\"hljs-built_in\">this</span>.handleClick.bind(<span class=\"hljs-built_in\">this</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>避免将 props 的值复制给 state！这是一个常见的错误：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;<br> <span class=\"hljs-built_in\">super</span>(props);<br> <span class=\"hljs-comment\">// 不要这样做</span><br> <span class=\"hljs-built_in\">this</span>.state = &#123; <span class=\"hljs-attr\">color</span>: props.color &#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>如此做毫无必要（你可以直接使用 this.props.color），同时还产生了 bug（更新 prop 中的 color 时，并不会影响 state）。</p>\n<h3 id=\"19-React组件的构造函数是必须的吗？\"><a href=\"#19-React组件的构造函数是必须的吗？\" class=\"headerlink\" title=\"19. React组件的构造函数是必须的吗？\"></a>19. React组件的构造函数是必须的吗？</h3><p>function组件不用考虑构造函数；<br>对于class组件，如果不写构造函数，默认会被隐式调用.</p>\n<p>对于无状态组件，内部没有维护自己的state，只接收外部传入的props 是不需要声明构造函数的.</p>\n<h2 id=\"第-7-天（2022-3-6）\"><a href=\"#第-7-天（2022-3-6）\" class=\"headerlink\" title=\"第 7 天（2022.3.6）\"></a>第 7 天（2022.3.6）</h2><h3 id=\"20-React中在哪捕获错误？\"><a href=\"#20-React中在哪捕获错误？\" class=\"headerlink\" title=\"20. React中在哪捕获错误？\"></a>20. React中在哪捕获错误？</h3><p>可以使用错误边界组件来捕获异常；这样可以使用替代ui来代替错误位置的渲染；而不是让程序崩溃；<br>主要来捕获生命周期异常，渲染中的异常</p>\n<p>使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息</p>\n<p>定义错误边界当做常规组件包裹ui组件, 官网例子：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ErrorBoundary</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">super</span>(props);<br>    <span class=\"hljs-built_in\">this</span>.state = &#123; <span class=\"hljs-attr\">hasError</span>: <span class=\"hljs-literal\">false</span> &#125;;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-function\"><span class=\"hljs-title\">getDerivedStateFromError</span>(<span class=\"hljs-params\">error</span>)</span> &#123;<br>    <span class=\"hljs-comment\">// 更新 state 使下一次渲染能够显示降级后的 UI</span><br>    <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">hasError</span>: <span class=\"hljs-literal\">true</span> &#125;;<br>  &#125;<br><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidCatch</span>(<span class=\"hljs-params\">error, errorInfo</span>)</span> &#123;<br>    <span class=\"hljs-comment\">// 你同样可以将错误日志上报给服务器</span><br>    logErrorToMyService(error, errorInfo);<br>  &#125;<br><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.state.hasError) &#123;<br>      <span class=\"hljs-comment\">// 你可以自定义降级后的 UI 并渲染</span><br>      <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Something went wrong.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.props.children; <br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\">&lt;ErrorBoundary&gt;<br>  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyWidget</span> /&gt;</span></span><br>&lt;/ErrorBoundary&gt;<br></code></pre></div></td></tr></table></figure>\n\n<p>但是错误边界不会捕获 :</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">try</span>&#123;&#125;<span class=\"hljs-keyword\">catch</span>(err)&#123;&#125;<br><span class=\"hljs-comment\">///异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）</span><br><span class=\"hljs-comment\">///服务端渲染</span><br><span class=\"hljs-comment\">///它自身抛出来的错误（并非它的子组件)</span><br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"21-React怎样引入svg的文件？\"><a href=\"#21-React怎样引入svg的文件？\" class=\"headerlink\" title=\"21. React怎样引入svg的文件？\"></a>21. React怎样引入svg的文件？</h3><p>方法1： 这种写法会由webpack转为url方式引入。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// svg png等类型图片</span><br><span class=\"hljs-keyword\">import</span> logo <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./logo.svg&#x27;</span>;<br><span class=\"hljs-comment\">//...</span><br><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&#123;logo&#125;</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;App-logo&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;logo&quot;</span> /&gt;</span></span><br><span class=\"hljs-comment\">//...</span><br></code></pre></div></td></tr></table></figure>\n\n<p>方法2： 这种方式仅对SVG图片生效，将svg看作组件导入：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// ...</span><br><span class=\"hljs-keyword\">import</span> &#123; ReactComponent <span class=\"hljs-keyword\">as</span> Logo &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./logo.svg&#x27;</span><br><span class=\"hljs-comment\">// ...</span><br>&lt;Logo /&gt;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"22-在React中你有经常使用常量吗？\"><a href=\"#22-在React中你有经常使用常量吗？\" class=\"headerlink\" title=\"22. 在React中你有经常使用常量吗？\"></a>22. 在React中你有经常使用常量吗？</h3><p>在redux的action文件里面定义不同的行为可能会使用常量的形式。</p>\n<h2 id=\"第-8-天（2022-3-7）\"><a href=\"#第-8-天（2022-3-7）\" class=\"headerlink\" title=\"第 8 天（2022.3.7）\"></a>第 8 天（2022.3.7）</h2>","site":{"data":{}},"wordcount":7775,"excerpt":"","more":"<h2 id=\"第-1-天-2022-02-28\"><a href=\"#第-1-天-2022-02-28\" class=\"headerlink\" title=\"第 1 天 (2022.02.28)\"></a>第 1 天 (2022.02.28)</h2><h3 id=\"1-什么时候使用状态管理器？\"><a href=\"#1-什么时候使用状态管理器？\" class=\"headerlink\" title=\"1. 什么时候使用状态管理器？\"></a>1. 什么时候使用状态管理器？</h3><ol>\n<li>组件状态要在多个组件共享时</li>\n<li>某个组件状态需要在任何地方可以拿到</li>\n<li>一个组件需要改变全局状态时</li>\n<li>一个组件需要改变另一个组件状态时</li>\n<li>组件状态提升提升不能满足需求时，层级过多时。</li>\n</ol>\n<h3 id=\"2-render-函数中-return-如果没有使用-会有什么问题？\"><a href=\"#2-render-函数中-return-如果没有使用-会有什么问题？\" class=\"headerlink\" title=\"2. render 函数中 return 如果没有使用()会有什么问题？\"></a>2. render 函数中 return 如果没有使用()会有什么问题？</h3><p>避免遇到自动插入分号陷阱。</p>\n<p>我们在使用 JSX 语法书写 react 代码时，babel 会将 JSX 语法编译成 js，同时会在每行自动添加分号（；），如果 return 后换行了，那么就会变成 return； 一般情况下会报错：</p>\n<p>Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.<br>上面这段英文翻译成中文：</p>\n<p>渲染没有返回任何内容。这通常意味着缺少 return 语句。或者，为了不渲染，返回 null。<br>为了代码可读性我们一般会在 return 后面添加括号这样代码可以折行书写，否则就在 return 后面紧跟着语句，这样也是可以的。</p>\n<p>举两个正确的书写例子：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Nav = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;c_navbar&quot;</span>&gt;</span></span><br><span class=\"xml\">      &#123; some jsx magic here &#125;</span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span></span><br>    )<br>  &#125;<br><br><span class=\"hljs-keyword\">const</span> Nav = <span class=\"hljs-function\">() =&gt;</span> &#123;<br><span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;c_navbar&quot;</span>&gt;</span></span><br><span class=\"xml\">    &#123; some jsx magic here &#125;</span><br><span class=\"xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>错误的写法：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Nav = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span><br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">nav</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;c_navbar&quot;</span>&gt;</span></span><br><span class=\"xml\">      &#123; some jsx magic here &#125;</span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">nav</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-componentWillUpdate-可以直接修改-state-的值吗？\"><a href=\"#3-componentWillUpdate-可以直接修改-state-的值吗？\" class=\"headerlink\" title=\"3. componentWillUpdate 可以直接修改 state 的值吗？\"></a>3. componentWillUpdate 可以直接修改 state 的值吗？</h3><p>直接修改不可以，但是加上条件就可以。</p>\n<p>文档原文：“你也可以在 componentDidUpdate() 中直接调用 setState()，但请注意它必须被包裹在一个条件语句里，正如上述的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。”</p>\n<p>componentWillReceiveProps 同理</p>\n<h3 id=\"4-说说你对-React-的渲染原理的理解\"><a href=\"#4-说说你对-React-的渲染原理的理解\" class=\"headerlink\" title=\"4. 说说你对 React 的渲染原理的理解\"></a>4. 说说你对 React 的渲染原理的理解</h3><ol>\n<li>React 会调用 React.render()构建一颗 DOM 树，生成虚拟 dom。</li>\n<li>通过改变 state 或 props 触发更新。</li>\n<li>对比新旧虚拟 dom，diff 算法，深度优先，将实际需要改变的反应到真实 dom。</li>\n</ol>\n<h2 id=\"第-2-天-2022-03-01\"><a href=\"#第-2-天-2022-03-01\" class=\"headerlink\" title=\"第 2 天 (2022.03.01)\"></a>第 2 天 (2022.03.01)</h2><h3 id=\"5-什么渲染劫持？\"><a href=\"#5-什么渲染劫持？\" class=\"headerlink\" title=\"5. 什么渲染劫持？\"></a>5. 什么渲染劫持？</h3><p>一般和高阶组件（HOC）一起解释。</p>\n<p>高阶组件在 render 的时候可以做其他操作，从而控制原组件的渲染输出，这种改变原组件渲染的方式称为 渲染劫持。</p>\n<p>在高阶组件中，组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可实现渲染劫持，还可以增强原组件 render 函数。</p>\n<p>除了 HOC，当新写一个组件，继承自一个已有的组件，可以随便修改 render 函数，使用 state、props 等改变原组件的渲染，都叫渲染劫持。</p>\n<h4 id=\"PS-HOC-反向继承\"><a href=\"#PS-HOC-反向继承\" class=\"headerlink\" title=\"PS: HOC 反向继承\"></a>PS: HOC 反向继承</h4><p>TODO：</p>\n<h3 id=\"6-React-Intl是什么原理？\"><a href=\"#6-React-Intl是什么原理？\" class=\"headerlink\" title=\"6. React Intl是什么原理？\"></a>6. React Intl是什么原理？</h3><p>React Intl 用途是国际化库，提供组件、日期等国际化方法。</p>\n<p>做国际化就类似于字体文件，通过切换语言，加载不同语言包到本地.</p>\n<p>最外层包一个Provider。调用库中方法，完成国际化。</p>\n<p>前端国际化核心步骤有两步：</p>\n<ul>\n<li>创建资源文件，以 key-value 方式存储</li>\n<li>加载资源文件，将页面上 key 的内容替换为相关 value</li>\n</ul>\n<h3 id=\"7-怎么实现React组件的国际化呢？\"><a href=\"#7-怎么实现React组件的国际化呢？\" class=\"headerlink\" title=\"7. 怎么实现React组件的国际化呢？\"></a>7. 怎么实现React组件的国际化呢？</h3><p> 使用 i18next 以及 react-i18next 配合 i18next-scanner，通过 grunt 跑 task 自动扫描生成 json 文件。</p>\n<p> 现在大厂比较常用的方案是，使用AST，每次开发完新版本，通过AST去扫描所有的代码，找出代码中的中文，以中文为key，调用智能翻译服务，去帮项目自动生成json文件。这样，再也不需要人为去维护json文件，一切都依赖工具进行自动化。</p>\n<h2 id=\"第-3-天（2022-3-2）\"><a href=\"#第-3-天（2022-3-2）\" class=\"headerlink\" title=\"第 3 天（2022.3.2）\"></a>第 3 天（2022.3.2）</h2><h3 id=\"8-说说Context有哪些属性？\"><a href=\"#8-说说Context有哪些属性？\" class=\"headerlink\" title=\"8. 说说Context有哪些属性？\"></a>8. 说说Context有哪些属性？</h3><p>context属于一种解决组件间层级过多传递数据的问题，避免了层层嵌套的通过props传递的形式，同时对于不需要使用到redux时，是一种解决方案。</p>\n<p>Context.Provider：生产者，数据提供方；通过value属性来定义需要被传递的数据<br>Context.Consumer：消费者，数据获取方；根据是函数组件还是class组件，有不同的使用形式；class组件可以指定contextType来确定要使用哪一个context对象的值，函数组件需要使用回调函数的形式来获取context的值；需要显示的指定context对象；</p>\n<h3 id=\"9-怎么使用Context开发组件？\"><a href=\"#9-怎么使用Context开发组件？\" class=\"headerlink\" title=\"9. 怎么使用Context开发组件？\"></a>9. 怎么使用Context开发组件？</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> themes = &#123;<br>  <span class=\"hljs-attr\">light</span>: &#123;<br>    <span class=\"hljs-attr\">foreground</span>: <span class=\"hljs-string\">&quot;#000000&quot;</span>,<br>    <span class=\"hljs-attr\">background</span>: <span class=\"hljs-string\">&quot;#eeeeee&quot;</span><br>  &#125;,<br>  <span class=\"hljs-attr\">dark</span>: &#123;<br>    <span class=\"hljs-attr\">foreground</span>: <span class=\"hljs-string\">&quot;#ffffff&quot;</span>,<br>    <span class=\"hljs-attr\">background</span>: <span class=\"hljs-string\">&quot;#222222&quot;</span><br>  &#125;<br>&#125;;<br><span class=\"hljs-comment\">// 首先创建一个 context 对象这里命名为：ThemeContext</span><br><span class=\"hljs-keyword\">const</span> ThemeContext = React.createContext(themes.light);<br><br><span class=\"hljs-comment\">// 创建一个祖先组件组件 内部使用Provier 这个对象创建一个组件 其中 value 属性是真实传递的属性</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ThemeContext.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;themes.dark&#125;</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Toolbar</span> /&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ThemeContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class=\"hljs-comment\">// 渲染 button 组件的外层包裹的属性</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Toolbar</span>(<span class=\"hljs-params\">props</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ThemedButton</span> /&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class=\"hljs-comment\">// 在 Toolbar 中渲染的button 组件 使用 useContext，将 value 值跨组件传递给 // ThemeButton 组件</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ThemedButton</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> theme = useContext(ThemeContext);<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&#123;&#123;</span> <span class=\"hljs-attr\">background:</span> <span class=\"hljs-attr\">theme.background</span>, <span class=\"hljs-attr\">color:</span> <span class=\"hljs-attr\">theme.foreground</span> &#125;&#125;&gt;</span></span><br><span class=\"xml\">      I am styled by theme context!</span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"10-为什么React并不推荐我们优先考虑使用Context？\"><a href=\"#10-为什么React并不推荐我们优先考虑使用Context？\" class=\"headerlink\" title=\"10. 为什么React并不推荐我们优先考虑使用Context？\"></a>10. 为什么React并不推荐我们优先考虑使用Context？</h3><p>1、Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。<br>2、尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context<br>3、对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。<br>4、context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注。</p>\n<h2 id=\"第-4-天（2022-3-3）\"><a href=\"#第-4-天（2022-3-3）\" class=\"headerlink\" title=\"第 4 天（2022.3.3）\"></a>第 4 天（2022.3.3）</h2><h3 id=\"11-childContextTypes是什么？它有什么用？\"><a href=\"#11-childContextTypes是什么？它有什么用？\" class=\"headerlink\" title=\"11. childContextTypes是什么？它有什么用？\"></a>11. childContextTypes是什么？它有什么用？</h3><p>childContextTypes用来定义context数据类型，该api从16.3开始已被废弃</p>\n<p>使用方式</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MessageList</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">getChildContext</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;purple&quot;</span>&#125;;<br>  &#125;<br><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>MessageList<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br><br>MessageList.childContextTypes = &#123;<br>  <span class=\"hljs-attr\">color</span>: PropTypes.string<br>&#125;;<br><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"12-Consumer向上找不到Provider的时候怎么办？\"><a href=\"#12-Consumer向上找不到Provider的时候怎么办？\" class=\"headerlink\" title=\"12. Consumer向上找不到Provider的时候怎么办？\"></a>12. Consumer向上找不到Provider的时候怎么办？</h3><p>当consumer向上层找不到provider时，此时就会取创建context时传给createContext的那个值，也就是当前context对象的默认值，在定义provider时的value中的值不是默认值，而是表示需要被传递的值.</p>\n<h2 id=\"第-5-天（2022-3-4）\"><a href=\"#第-5-天（2022-3-4）\" class=\"headerlink\" title=\"第 5 天（2022.3.4）\"></a>第 5 天（2022.3.4）</h2><h3 id=\"13-说说你对windowing的了解\"><a href=\"#13-说说你对windowing的了解\" class=\"headerlink\" title=\"13. 说说你对windowing的了解\"></a>13. 说说你对windowing的了解</h3><p>展示长列表<br>如果你的应用会渲染大量的列表数据，我们建议使用一种称为‘windowing’的技术，这种技术下在任何给定的时间内只会渲染一小部分数据列表，并可以减少列表项的重复渲染（即再次渲染已经渲染过的数据）。</p>\n<p>react-window和react-virtualized都是流行的使用windowing技术的库，他们都提供了一系列可重用的组件，这些组件能够帮助你以最好的性能展示列表以及表格数据</p>\n<h3 id=\"14-举例说明React的-portal-有哪些运用场景？\"><a href=\"#14-举例说明React的-portal-有哪些运用场景？\" class=\"headerlink\" title=\"14. 举例说明React的 portal 有哪些运用场景？\"></a>14. 举例说明React的 portal 有哪些运用场景？</h3><p>portal可以将内容插入到除了父节点的dom之外的地方去渲染，所以modal是一个通过portal实现的典型例子；并且对于事件绑定，因为使用了事件冒泡，所以并不用担心被渲染到父组件结构之外的内容，不能去监听事件</p>\n<h3 id=\"15-你有用过React的插槽-Portals-吗？怎么用？\"><a href=\"#15-你有用过React的插槽-Portals-吗？怎么用？\" class=\"headerlink\" title=\"15. 你有用过React的插槽(Portals)吗？怎么用？\"></a>15. 你有用过React的插槽(Portals)吗？怎么用？</h3><p>1、首先简单的介绍下react中的插槽（Portals），通过ReactDOM.createPortal(child, container)创建，是ReactDOM提供的接口，可以实现将子节点渲染到父组件DOM层次结构之外的DOM节点。<br>2、第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 片段(fragment)。第二个参数（container）则是一个 DOM 元素。<br>3、对于 portal 的一个典型用例是当父组件有 overflow: hidden 或 z-index 样式，但你需要子组件能够在视觉上 “跳出(break out)” 其容器。例如，对话框、hovercards以及提示框。所以一般react组件里的模态框，就是这样实现的。</p>\n<p>如果一个子组件的真实DOM结构必须渲染到当前组件外，但又想保留这两者的父子关系，就可以用Protals。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> Modal = <span class=\"hljs-function\">(<span class=\"hljs-params\">props</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> modal = <span class=\"hljs-built_in\">document</span>.body.createElement(<span class=\"hljs-string\">&#x27;div&#x27;</span>);<br>  <span class=\"hljs-built_in\">document</span>.appendChild(modal);<br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-built_in\">document</span>.body.removeChild(modal);<br>    &#125;<br>  &#125;, []);<br>  <span class=\"hljs-keyword\">return</span> React.createPortal(<span class=\"hljs-built_in\">this</span>.props.children, modal);<br>&#125;<br><span class=\"hljs-keyword\">const</span> Parent = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> [sum, setSum] = useState(<span class=\"hljs-number\">0</span>);<br>  <span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-function\">() =&gt;</span> setSum(sum + <span class=\"hljs-number\">1</span>);<br>  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;add&#125;</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Modal</span>&gt;</span>加一<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Modal</span>&gt;</span></span><br><span class=\"xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"第-6-天（2022-3-5）\"><a href=\"#第-6-天（2022-3-5）\" class=\"headerlink\" title=\"第 6 天（2022.3.5）\"></a>第 6 天（2022.3.5）</h2><h3 id=\"16-React的严格模式有什么用处？\"><a href=\"#16-React的严格模式有什么用处？\" class=\"headerlink\" title=\"16. React的严格模式有什么用处？\"></a>16. React的严格模式有什么用处？</h3><p>StrictMode 目前有助于：</p>\n<ul>\n<li>识别不安全的生命周期</li>\n<li>关于使用过时字符串 ref API 的警告</li>\n<li>关于使用废弃的 findDOMNode 方法的警告</li>\n<li>检测意外的副作用</li>\n<li>检测过时的 context API</li>\n</ul>\n<p>可以为程序的任何部分使用严格模式</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ExampleApplication</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Header</span> /&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">React.StrictMode</span>&gt;</span></span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ComponentOne</span> /&gt;</span></span><br><span class=\"xml\">          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ComponentTwo</span> /&gt;</span></span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">React.StrictMode</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Footer</span> /&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;<br><span class=\"hljs-comment\">// 不会对 Header 和 Footer 组件运行严格模式检查。但是，ComponentOne 和 ComponentTwo 以及它们的所有后代元素都将进行检查。</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"17-React如何进行代码拆分？拆分的原则是什么？\"><a href=\"#17-React如何进行代码拆分？拆分的原则是什么？\" class=\"headerlink\" title=\"17. React如何进行代码拆分？拆分的原则是什么？\"></a>17. React如何进行代码拆分？拆分的原则是什么？</h3><p>react的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。</p>\n<p>在我们的react项目中：<br>1、在 api 层面我们单独封装，对外暴露http请求的结果。<br>2、数据层我们使用的react-redux 异步中间件使用的是redux-thunk 分装处理异步请求，合业务逻辑处理。<br>3、视图层，尽量使用 redux 层面的传递过来的数据，修改逻辑 也是重新触发action 更改props。<br>4、静态类型的资源单独放置<br>5、公共组件、高阶组件、插件单独放置<br>6、工具类文件单独放置</p>\n<h3 id=\"18-React组件的构造函数有什么作用？\"><a href=\"#18-React组件的构造函数有什么作用？\" class=\"headerlink\" title=\"18. React组件的构造函数有什么作用？\"></a>18. React组件的构造函数有什么作用？</h3><p>官网中，构造函数仅用于以下两种情况：</p>\n<ul>\n<li>通过给 this.state 赋值对象来初始化内部 state。</li>\n<li>为事件处理函数绑定实例</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;<br>  <span class=\"hljs-built_in\">super</span>(props);<br>  <span class=\"hljs-comment\">// 不要在这里调用 this.setState()</span><br>  <span class=\"hljs-built_in\">this</span>.state = &#123; <span class=\"hljs-attr\">counter</span>: <span class=\"hljs-number\">0</span> &#125;;<br>  <span class=\"hljs-built_in\">this</span>.handleClick = <span class=\"hljs-built_in\">this</span>.handleClick.bind(<span class=\"hljs-built_in\">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>避免将 props 的值复制给 state！这是一个常见的错误：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;<br> <span class=\"hljs-built_in\">super</span>(props);<br> <span class=\"hljs-comment\">// 不要这样做</span><br> <span class=\"hljs-built_in\">this</span>.state = &#123; <span class=\"hljs-attr\">color</span>: props.color &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如此做毫无必要（你可以直接使用 this.props.color），同时还产生了 bug（更新 prop 中的 color 时，并不会影响 state）。</p>\n<h3 id=\"19-React组件的构造函数是必须的吗？\"><a href=\"#19-React组件的构造函数是必须的吗？\" class=\"headerlink\" title=\"19. React组件的构造函数是必须的吗？\"></a>19. React组件的构造函数是必须的吗？</h3><p>function组件不用考虑构造函数；<br>对于class组件，如果不写构造函数，默认会被隐式调用.</p>\n<p>对于无状态组件，内部没有维护自己的state，只接收外部传入的props 是不需要声明构造函数的.</p>\n<h2 id=\"第-7-天（2022-3-6）\"><a href=\"#第-7-天（2022-3-6）\" class=\"headerlink\" title=\"第 7 天（2022.3.6）\"></a>第 7 天（2022.3.6）</h2><h3 id=\"20-React中在哪捕获错误？\"><a href=\"#20-React中在哪捕获错误？\" class=\"headerlink\" title=\"20. React中在哪捕获错误？\"></a>20. React中在哪捕获错误？</h3><p>可以使用错误边界组件来捕获异常；这样可以使用替代ui来代替错误位置的渲染；而不是让程序崩溃；<br>主要来捕获生命周期异常，渲染中的异常</p>\n<p>使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息</p>\n<p>定义错误边界当做常规组件包裹ui组件, 官网例子：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ErrorBoundary</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">super</span>(props);<br>    <span class=\"hljs-built_in\">this</span>.state = &#123; <span class=\"hljs-attr\">hasError</span>: <span class=\"hljs-literal\">false</span> &#125;;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-function\"><span class=\"hljs-title\">getDerivedStateFromError</span>(<span class=\"hljs-params\">error</span>)</span> &#123;<br>    <span class=\"hljs-comment\">// 更新 state 使下一次渲染能够显示降级后的 UI</span><br>    <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">hasError</span>: <span class=\"hljs-literal\">true</span> &#125;;<br>  &#125;<br><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidCatch</span>(<span class=\"hljs-params\">error, errorInfo</span>)</span> &#123;<br>    <span class=\"hljs-comment\">// 你同样可以将错误日志上报给服务器</span><br>    logErrorToMyService(error, errorInfo);<br>  &#125;<br><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.state.hasError) &#123;<br>      <span class=\"hljs-comment\">// 你可以自定义降级后的 UI 并渲染</span><br>      <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Something went wrong.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.props.children; <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\">&lt;ErrorBoundary&gt;<br>  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyWidget</span> /&gt;</span></span><br>&lt;/ErrorBoundary&gt;<br></code></pre></td></tr></table></figure>\n\n<p>但是错误边界不会捕获 :</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">try</span>&#123;&#125;<span class=\"hljs-keyword\">catch</span>(err)&#123;&#125;<br><span class=\"hljs-comment\">///异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）</span><br><span class=\"hljs-comment\">///服务端渲染</span><br><span class=\"hljs-comment\">///它自身抛出来的错误（并非它的子组件)</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"21-React怎样引入svg的文件？\"><a href=\"#21-React怎样引入svg的文件？\" class=\"headerlink\" title=\"21. React怎样引入svg的文件？\"></a>21. React怎样引入svg的文件？</h3><p>方法1： 这种写法会由webpack转为url方式引入。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// svg png等类型图片</span><br><span class=\"hljs-keyword\">import</span> logo <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./logo.svg&#x27;</span>;<br><span class=\"hljs-comment\">//...</span><br><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&#123;logo&#125;</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;App-logo&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;logo&quot;</span> /&gt;</span></span><br><span class=\"hljs-comment\">//...</span><br></code></pre></td></tr></table></figure>\n\n<p>方法2： 这种方式仅对SVG图片生效，将svg看作组件导入：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-comment\">// ...</span><br><span class=\"hljs-keyword\">import</span> &#123; ReactComponent <span class=\"hljs-keyword\">as</span> Logo &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./logo.svg&#x27;</span><br><span class=\"hljs-comment\">// ...</span><br>&lt;Logo /&gt;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"22-在React中你有经常使用常量吗？\"><a href=\"#22-在React中你有经常使用常量吗？\" class=\"headerlink\" title=\"22. 在React中你有经常使用常量吗？\"></a>22. 在React中你有经常使用常量吗？</h3><p>在redux的action文件里面定义不同的行为可能会使用常量的形式。</p>\n<h2 id=\"第-8-天（2022-3-7）\"><a href=\"#第-8-天（2022-3-7）\" class=\"headerlink\" title=\"第 8 天（2022.3.7）\"></a>第 8 天（2022.3.7）</h2>"},{"title":"Vue3 学习笔记","index_img":"/img/2022-01-22-1.jpeg","abbrlink":"e372be48","date":"2022-01-22T02:46:00.000Z","_content":"\n## Vue 和 React 数据驱动原理对比\n\nVue1 解决方案是使用响应式，初始化的时候，watcher 监听数据的每个属性，数据发生变化的时候，就能够知道数据的哪个 key 变了，去修改对应的 DOM。\n\nReact 是虚拟 DOM 方案，用 JS 对象描述 DOM 树，这个对象就像数据和实际 DOM 的一个缓存层，通过管理这个对象的变化，来减少对实际 DOM 的操作。\n\n描述实际 DOM 的虚拟 DOM 对象如下：\n\nDOM:\n\n```html\n<div id=\"app\">\n  <p class=\"item\">Item1</p>\n  <div class=\"item\">Item2</div>\n</div>\n```\n\n虚拟 DOM：\n\n```js\n\n{\n  tag: \"div\",\n  attrs: {\n    id: \"app\"\n  },\n  children: [\n    {\n      tag: \"p\",\n      attrs: { className: \"item\" },\n      children: [\"Item1\"]\n    },\n    {\n      tag: \"div\",\n      attrs: { className: \"item\" },\n      children: [\"Item2\"]\n    }\n  ]\n}\n```\n\n数据变化的时候生成一个新的虚拟 DOM 数据，对比之前的虚拟 DOM 进行 diff 计算，算出要修改的 DOM，再对页面进行操作。\n\n通知页面更新的方式不同：\n\n- vue 中，数据变化，框架主动告诉你修改了哪些数据；\n- react 中，变化变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化\n\n性能问题：\n\n- vue 的响应式，在项目大了之后，每个数据都有一个 watcher 会影响性能\n- 如果 react 虚拟 dom 过于庞大，使得 diff 计算时间大于 16.6 ms(屏幕刷新率 60HZ, 1/60)，可能造成性能卡顿。\n\n为了解决性能问题， Vue 和 react 走了不同的道路。\n\n- react 借鉴操作系统时间分片概念，引入 Fiber 架构。把整个虚拟 DOM 树 微观化，变成链表，然后利用浏览器的空闲时间计算 diff。\n- vue1 的问题在于响应式数据过多，会带来内存占用过多的问题。vue2 引入虚拟 DOM 来解决响应式数据过多问题。\n\n响应式数据是主动推送变化，虚拟 DOM 是被动计算数据的 diff。vue2 将两者结合在一起，在组件级别来划分。\n\n组件间的变化，通过响应式来通知更新。组件内部的数据变化，通过虚拟 DOM 去更新页面。最终，把响应式监听器控制在组件级别，而虚拟 DOM 的量级控制在组件的大小。\n\n在模板书写上，vue 和 react 分别走了 template 和 jsx 两个路线。\n\n- react 世界只有 jsx，最终 jsx 都会在 Compiler 那层，即工程化那里编译成 js 来执行。\n- vue 默认 template。vue3 优秀的其中一点是在虚拟 DOM 的静态标记上做到了极致，让静态的部分越过虚拟 DOM 的计算，真正做到按需更新，很好的提高了性能。\n\n## Vue3 的新特性\n\n### 响应式系统\n\nVue 2 的响应式机制是基于 Object.defineProperty() 这个 API 实现的.Vue3 是基于 proxy。两者区别是 defineProperty 是拦截具体某个属性， Proxy 是全部拦截，是代理。\n\ndefineProperty 示例如下：\n\n```js\nObject.defineProperty(obj, \"title\", {\n  get() {},\n  set() {}\n});\n```\n\n当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。\n\n但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的 $set。\n\nProxy API 是真正的代理，示例如下：\n\n```js\nnew Proxy(obj, {\n  get() {},\n  set() {}\n});\n```\n\nProxy 拦截 obj 这个数据，不关心 obj 里面属性，统一拦截。\n\n### 自定义渲染器\n\nvue2 内部所有模块是揉在一起，导致不好扩展。vue3 采用 monorepo 方式进行拆包，响应式、编译和运行时全部独立。独立出来的响应式，甚至可以在 react、node 中使用。\n\n![vue 架构](/img/2022-01-24-1.png)\n\n渲染逻辑拆成 **平台无关渲染逻辑** 和 **浏览器渲染 API**。\n\n### 全部模块使用 TS 重构\n\nVue2 使用 Flow.js 做类型检测；Flow.js 已被抛弃，vue3 选择 TS。\n\n### Composition API 组合语法\n\nvue2 中示例：\n\n```js\nlet App = {\n  data() {\n    return { count: 1 };\n  },\n  methods: {\n    add() {\n      this.count++;\n    }\n  },\n  computed: {\n    double() {\n      return this.count * 2;\n    }\n  }\n};\n```\n\nvue2 中 Options API 存在以下问题：\n\n- 所有数据都挂载在 this 上，Options API 写法对 TS 类型推导不友好。\n- 新增的功能基本都要修改 data、method 等，代码行数多了以后，会经常需要上下反复横跳。\n- 代码不好复用，vue2 的组件很难抽离通用逻辑，只能使用 mixin，还会导致命名冲突问题。\n\nvue3 中采用新增的 setup 写法：\n\n```js\nconst { reactive, computed } = Vue;\nlet App = {\n  setup() {\n    const state = reactive({ count: 1 });\n    function add() {\n      state.count++;\n    }\n    const double = computed(() => state.count * 2);\n    return { state, add, double };\n  }\n};\n```\n\nComposition API 好处如下：\n\n- 所有 API 都是 import 引入。对 Tree-shaking 很友好，没用到功能，打包的时候会被清理掉 ，减小包的大小\n- 一个功能模块的 methods、data 放一起书写，避免上下反复横跳。\n- 代码复用方便，一个功能的所有 methods、data 封装在一个独立的函数里。\n- Composotion API 新增的 return 等语句，在实际项目中使用。\n\n![Composition API](/img/2022-01-24-2.png)\n\n### 新的组件\n\nVue 3 还内置了 Fragment、Teleport 和 Suspense 三个新组件。\n\n- Fragment: Vue 3 组件不再要求有一个唯一的根节点，清除了很多无用的占位 div。\n- Teleport: 允许组件渲染在别的元素内，主要开发弹窗组件的时候特别有用。\n- Suspense: 异步组件，更方便开发有异步请求的组件。\n\n### 新一代工程化工具 Vite\n\nwebpack 工程化的原理是 根据 import 依赖逻辑形成一个依赖图，然后调用对应的处理工具，把整个项目打包后，放在内存中再启动调试。因为要预打包，复杂项目开发时，启动开发环境和热更新时间都比较长，Vite 就是为了解决这个问题而出现的。\n\n现代浏览器已经默认支持 ES6 的 import 语法，Vite 就是基于这个原理实现的。\n\n在开发环境下，不需要全部预打包，只要把首页依赖的文件，依次通过网络请求去获取，开发体验得到巨大提升，做到复杂项目时，也能做到秒级调试和热更新。\n\nwebpack 工作原理如下，需要把所有路由依赖打包后，才能开始调试。\n\n![webpack 工作原理](/img/2022-01-24-3.png)\n\nVite 工作原理，根据首页的依赖模块，再去获取路由 1 的模块，按需加载。\n\n![Vite 工作原理](/img/2022-01-24-4.png)\n\n## Vue3 响应式机制\n\n响应式原理：Vue 中用过三种响应式解决方案，分别是 defineProperty、Proxy 和 value setter。\n\n---\n\ntodo: 07\n\n## Vue3 实践常见问题汇总\n\n1. vetur 报错， xx has no export.\n\n   使用 Vue3 `script setup` 语法糖时,VsCode 插件 Vetur 会报该错误，原因是 Vetur(v0.35.0) 暂不支持 ts。\n\n   解决办法： 卸载 Vetur， 用 Volar(尤大推荐) 以取代 Vetur。\n\n---\n\n上述笔记源于学习极客时间-大圣的 [玩转 Vue3 全家桶](http://gk.link/a/115Qp) 课程笔记整理。\n\n---\n","source":"_posts/2022-01-22-1.md","raw":"---\ntitle: Vue3 学习笔记\nindex_img: /img/2022-01-22-1.jpeg\ntags: Vue3\ncategories: Vue\nabbrlink: e372be48\ndate: 2022-01-22 10:46:00\n---\n\n## Vue 和 React 数据驱动原理对比\n\nVue1 解决方案是使用响应式，初始化的时候，watcher 监听数据的每个属性，数据发生变化的时候，就能够知道数据的哪个 key 变了，去修改对应的 DOM。\n\nReact 是虚拟 DOM 方案，用 JS 对象描述 DOM 树，这个对象就像数据和实际 DOM 的一个缓存层，通过管理这个对象的变化，来减少对实际 DOM 的操作。\n\n描述实际 DOM 的虚拟 DOM 对象如下：\n\nDOM:\n\n```html\n<div id=\"app\">\n  <p class=\"item\">Item1</p>\n  <div class=\"item\">Item2</div>\n</div>\n```\n\n虚拟 DOM：\n\n```js\n\n{\n  tag: \"div\",\n  attrs: {\n    id: \"app\"\n  },\n  children: [\n    {\n      tag: \"p\",\n      attrs: { className: \"item\" },\n      children: [\"Item1\"]\n    },\n    {\n      tag: \"div\",\n      attrs: { className: \"item\" },\n      children: [\"Item2\"]\n    }\n  ]\n}\n```\n\n数据变化的时候生成一个新的虚拟 DOM 数据，对比之前的虚拟 DOM 进行 diff 计算，算出要修改的 DOM，再对页面进行操作。\n\n通知页面更新的方式不同：\n\n- vue 中，数据变化，框架主动告诉你修改了哪些数据；\n- react 中，变化变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化\n\n性能问题：\n\n- vue 的响应式，在项目大了之后，每个数据都有一个 watcher 会影响性能\n- 如果 react 虚拟 dom 过于庞大，使得 diff 计算时间大于 16.6 ms(屏幕刷新率 60HZ, 1/60)，可能造成性能卡顿。\n\n为了解决性能问题， Vue 和 react 走了不同的道路。\n\n- react 借鉴操作系统时间分片概念，引入 Fiber 架构。把整个虚拟 DOM 树 微观化，变成链表，然后利用浏览器的空闲时间计算 diff。\n- vue1 的问题在于响应式数据过多，会带来内存占用过多的问题。vue2 引入虚拟 DOM 来解决响应式数据过多问题。\n\n响应式数据是主动推送变化，虚拟 DOM 是被动计算数据的 diff。vue2 将两者结合在一起，在组件级别来划分。\n\n组件间的变化，通过响应式来通知更新。组件内部的数据变化，通过虚拟 DOM 去更新页面。最终，把响应式监听器控制在组件级别，而虚拟 DOM 的量级控制在组件的大小。\n\n在模板书写上，vue 和 react 分别走了 template 和 jsx 两个路线。\n\n- react 世界只有 jsx，最终 jsx 都会在 Compiler 那层，即工程化那里编译成 js 来执行。\n- vue 默认 template。vue3 优秀的其中一点是在虚拟 DOM 的静态标记上做到了极致，让静态的部分越过虚拟 DOM 的计算，真正做到按需更新，很好的提高了性能。\n\n## Vue3 的新特性\n\n### 响应式系统\n\nVue 2 的响应式机制是基于 Object.defineProperty() 这个 API 实现的.Vue3 是基于 proxy。两者区别是 defineProperty 是拦截具体某个属性， Proxy 是全部拦截，是代理。\n\ndefineProperty 示例如下：\n\n```js\nObject.defineProperty(obj, \"title\", {\n  get() {},\n  set() {}\n});\n```\n\n当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。\n\n但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的 $set。\n\nProxy API 是真正的代理，示例如下：\n\n```js\nnew Proxy(obj, {\n  get() {},\n  set() {}\n});\n```\n\nProxy 拦截 obj 这个数据，不关心 obj 里面属性，统一拦截。\n\n### 自定义渲染器\n\nvue2 内部所有模块是揉在一起，导致不好扩展。vue3 采用 monorepo 方式进行拆包，响应式、编译和运行时全部独立。独立出来的响应式，甚至可以在 react、node 中使用。\n\n![vue 架构](/img/2022-01-24-1.png)\n\n渲染逻辑拆成 **平台无关渲染逻辑** 和 **浏览器渲染 API**。\n\n### 全部模块使用 TS 重构\n\nVue2 使用 Flow.js 做类型检测；Flow.js 已被抛弃，vue3 选择 TS。\n\n### Composition API 组合语法\n\nvue2 中示例：\n\n```js\nlet App = {\n  data() {\n    return { count: 1 };\n  },\n  methods: {\n    add() {\n      this.count++;\n    }\n  },\n  computed: {\n    double() {\n      return this.count * 2;\n    }\n  }\n};\n```\n\nvue2 中 Options API 存在以下问题：\n\n- 所有数据都挂载在 this 上，Options API 写法对 TS 类型推导不友好。\n- 新增的功能基本都要修改 data、method 等，代码行数多了以后，会经常需要上下反复横跳。\n- 代码不好复用，vue2 的组件很难抽离通用逻辑，只能使用 mixin，还会导致命名冲突问题。\n\nvue3 中采用新增的 setup 写法：\n\n```js\nconst { reactive, computed } = Vue;\nlet App = {\n  setup() {\n    const state = reactive({ count: 1 });\n    function add() {\n      state.count++;\n    }\n    const double = computed(() => state.count * 2);\n    return { state, add, double };\n  }\n};\n```\n\nComposition API 好处如下：\n\n- 所有 API 都是 import 引入。对 Tree-shaking 很友好，没用到功能，打包的时候会被清理掉 ，减小包的大小\n- 一个功能模块的 methods、data 放一起书写，避免上下反复横跳。\n- 代码复用方便，一个功能的所有 methods、data 封装在一个独立的函数里。\n- Composotion API 新增的 return 等语句，在实际项目中使用。\n\n![Composition API](/img/2022-01-24-2.png)\n\n### 新的组件\n\nVue 3 还内置了 Fragment、Teleport 和 Suspense 三个新组件。\n\n- Fragment: Vue 3 组件不再要求有一个唯一的根节点，清除了很多无用的占位 div。\n- Teleport: 允许组件渲染在别的元素内，主要开发弹窗组件的时候特别有用。\n- Suspense: 异步组件，更方便开发有异步请求的组件。\n\n### 新一代工程化工具 Vite\n\nwebpack 工程化的原理是 根据 import 依赖逻辑形成一个依赖图，然后调用对应的处理工具，把整个项目打包后，放在内存中再启动调试。因为要预打包，复杂项目开发时，启动开发环境和热更新时间都比较长，Vite 就是为了解决这个问题而出现的。\n\n现代浏览器已经默认支持 ES6 的 import 语法，Vite 就是基于这个原理实现的。\n\n在开发环境下，不需要全部预打包，只要把首页依赖的文件，依次通过网络请求去获取，开发体验得到巨大提升，做到复杂项目时，也能做到秒级调试和热更新。\n\nwebpack 工作原理如下，需要把所有路由依赖打包后，才能开始调试。\n\n![webpack 工作原理](/img/2022-01-24-3.png)\n\nVite 工作原理，根据首页的依赖模块，再去获取路由 1 的模块，按需加载。\n\n![Vite 工作原理](/img/2022-01-24-4.png)\n\n## Vue3 响应式机制\n\n响应式原理：Vue 中用过三种响应式解决方案，分别是 defineProperty、Proxy 和 value setter。\n\n---\n\ntodo: 07\n\n## Vue3 实践常见问题汇总\n\n1. vetur 报错， xx has no export.\n\n   使用 Vue3 `script setup` 语法糖时,VsCode 插件 Vetur 会报该错误，原因是 Vetur(v0.35.0) 暂不支持 ts。\n\n   解决办法： 卸载 Vetur， 用 Volar(尤大推荐) 以取代 Vetur。\n\n---\n\n上述笔记源于学习极客时间-大圣的 [玩转 Vue3 全家桶](http://gk.link/a/115Qp) 课程笔记整理。\n\n---\n","slug":"1","published":1,"updated":"2022-03-01T02:56:12.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0f42s2z001dvw3la2oc1prn","content":"<h2 id=\"Vue-和-React-数据驱动原理对比\"><a href=\"#Vue-和-React-数据驱动原理对比\" class=\"headerlink\" title=\"Vue 和 React 数据驱动原理对比\"></a>Vue 和 React 数据驱动原理对比</h2><p>Vue1 解决方案是使用响应式，初始化的时候，watcher 监听数据的每个属性，数据发生变化的时候，就能够知道数据的哪个 key 变了，去修改对应的 DOM。</p>\n<p>React 是虚拟 DOM 方案，用 JS 对象描述 DOM 树，这个对象就像数据和实际 DOM 的一个缓存层，通过管理这个对象的变化，来减少对实际 DOM 的操作。</p>\n<p>描述实际 DOM 的虚拟 DOM 对象如下：</p>\n<p>DOM:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>Item1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>Item2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>\n\n<p>虚拟 DOM：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><br>&#123;<br>  <span class=\"hljs-attr\">tag</span>: <span class=\"hljs-string\">&quot;div&quot;</span>,<br>  <span class=\"hljs-attr\">attrs</span>: &#123;<br>    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">&quot;app&quot;</span><br>  &#125;,<br>  <span class=\"hljs-attr\">children</span>: [<br>    &#123;<br>      <span class=\"hljs-attr\">tag</span>: <span class=\"hljs-string\">&quot;p&quot;</span>,<br>      <span class=\"hljs-attr\">attrs</span>: &#123; <span class=\"hljs-attr\">className</span>: <span class=\"hljs-string\">&quot;item&quot;</span> &#125;,<br>      <span class=\"hljs-attr\">children</span>: [<span class=\"hljs-string\">&quot;Item1&quot;</span>]<br>    &#125;,<br>    &#123;<br>      <span class=\"hljs-attr\">tag</span>: <span class=\"hljs-string\">&quot;div&quot;</span>,<br>      <span class=\"hljs-attr\">attrs</span>: &#123; <span class=\"hljs-attr\">className</span>: <span class=\"hljs-string\">&quot;item&quot;</span> &#125;,<br>      <span class=\"hljs-attr\">children</span>: [<span class=\"hljs-string\">&quot;Item2&quot;</span>]<br>    &#125;<br>  ]<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>数据变化的时候生成一个新的虚拟 DOM 数据，对比之前的虚拟 DOM 进行 diff 计算，算出要修改的 DOM，再对页面进行操作。</p>\n<p>通知页面更新的方式不同：</p>\n<ul>\n<li>vue 中，数据变化，框架主动告诉你修改了哪些数据；</li>\n<li>react 中，变化变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化</li>\n</ul>\n<p>性能问题：</p>\n<ul>\n<li>vue 的响应式，在项目大了之后，每个数据都有一个 watcher 会影响性能</li>\n<li>如果 react 虚拟 dom 过于庞大，使得 diff 计算时间大于 16.6 ms(屏幕刷新率 60HZ, 1/60)，可能造成性能卡顿。</li>\n</ul>\n<p>为了解决性能问题， Vue 和 react 走了不同的道路。</p>\n<ul>\n<li>react 借鉴操作系统时间分片概念，引入 Fiber 架构。把整个虚拟 DOM 树 微观化，变成链表，然后利用浏览器的空闲时间计算 diff。</li>\n<li>vue1 的问题在于响应式数据过多，会带来内存占用过多的问题。vue2 引入虚拟 DOM 来解决响应式数据过多问题。</li>\n</ul>\n<p>响应式数据是主动推送变化，虚拟 DOM 是被动计算数据的 diff。vue2 将两者结合在一起，在组件级别来划分。</p>\n<p>组件间的变化，通过响应式来通知更新。组件内部的数据变化，通过虚拟 DOM 去更新页面。最终，把响应式监听器控制在组件级别，而虚拟 DOM 的量级控制在组件的大小。</p>\n<p>在模板书写上，vue 和 react 分别走了 template 和 jsx 两个路线。</p>\n<ul>\n<li>react 世界只有 jsx，最终 jsx 都会在 Compiler 那层，即工程化那里编译成 js 来执行。</li>\n<li>vue 默认 template。vue3 优秀的其中一点是在虚拟 DOM 的静态标记上做到了极致，让静态的部分越过虚拟 DOM 的计算，真正做到按需更新，很好的提高了性能。</li>\n</ul>\n<h2 id=\"Vue3-的新特性\"><a href=\"#Vue3-的新特性\" class=\"headerlink\" title=\"Vue3 的新特性\"></a>Vue3 的新特性</h2><h3 id=\"响应式系统\"><a href=\"#响应式系统\" class=\"headerlink\" title=\"响应式系统\"></a>响应式系统</h3><p>Vue 2 的响应式机制是基于 Object.defineProperty() 这个 API 实现的.Vue3 是基于 proxy。两者区别是 defineProperty 是拦截具体某个属性， Proxy 是全部拦截，是代理。</p>\n<p>defineProperty 示例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">Object</span>.defineProperty(obj, <span class=\"hljs-string\">&quot;title&quot;</span>, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;,<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">set</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure>\n\n<p>当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。</p>\n<p>但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的 $set。</p>\n<p>Proxy API 是真正的代理，示例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>(obj, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;,<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">set</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure>\n\n<p>Proxy 拦截 obj 这个数据，不关心 obj 里面属性，统一拦截。</p>\n<h3 id=\"自定义渲染器\"><a href=\"#自定义渲染器\" class=\"headerlink\" title=\"自定义渲染器\"></a>自定义渲染器</h3><p>vue2 内部所有模块是揉在一起，导致不好扩展。vue3 采用 monorepo 方式进行拆包，响应式、编译和运行时全部独立。独立出来的响应式，甚至可以在 react、node 中使用。</p>\n<p><img src=\"/img/2022-01-24-1.png\" alt=\"vue 架构\"></p>\n<p>渲染逻辑拆成 <strong>平台无关渲染逻辑</strong> 和 <strong>浏览器渲染 API</strong>。</p>\n<h3 id=\"全部模块使用-TS-重构\"><a href=\"#全部模块使用-TS-重构\" class=\"headerlink\" title=\"全部模块使用 TS 重构\"></a>全部模块使用 TS 重构</h3><p>Vue2 使用 Flow.js 做类型检测；Flow.js 已被抛弃，vue3 选择 TS。</p>\n<h3 id=\"Composition-API-组合语法\"><a href=\"#Composition-API-组合语法\" class=\"headerlink\" title=\"Composition API 组合语法\"></a>Composition API 组合语法</h3><p>vue2 中示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> App = &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">1</span> &#125;;<br>  &#125;,<br>  <span class=\"hljs-attr\">methods</span>: &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">add</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>      <span class=\"hljs-built_in\">this</span>.count++;<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">computed</span>: &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">double</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.count * <span class=\"hljs-number\">2</span>;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n\n<p>vue2 中 Options API 存在以下问题：</p>\n<ul>\n<li>所有数据都挂载在 this 上，Options API 写法对 TS 类型推导不友好。</li>\n<li>新增的功能基本都要修改 data、method 等，代码行数多了以后，会经常需要上下反复横跳。</li>\n<li>代码不好复用，vue2 的组件很难抽离通用逻辑，只能使用 mixin，还会导致命名冲突问题。</li>\n</ul>\n<p>vue3 中采用新增的 setup 写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> &#123; reactive, computed &#125; = Vue;<br><span class=\"hljs-keyword\">let</span> App = &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">setup</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> state = reactive(&#123; <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">1</span> &#125;);<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>      state.count++;<br>    &#125;<br>    <span class=\"hljs-keyword\">const</span> double = computed(<span class=\"hljs-function\">() =&gt;</span> state.count * <span class=\"hljs-number\">2</span>);<br>    <span class=\"hljs-keyword\">return</span> &#123; state, add, double &#125;;<br>  &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n\n<p>Composition API 好处如下：</p>\n<ul>\n<li>所有 API 都是 import 引入。对 Tree-shaking 很友好，没用到功能，打包的时候会被清理掉 ，减小包的大小</li>\n<li>一个功能模块的 methods、data 放一起书写，避免上下反复横跳。</li>\n<li>代码复用方便，一个功能的所有 methods、data 封装在一个独立的函数里。</li>\n<li>Composotion API 新增的 return 等语句，在实际项目中使用。</li>\n</ul>\n<p><img src=\"/img/2022-01-24-2.png\" alt=\"Composition API\"></p>\n<h3 id=\"新的组件\"><a href=\"#新的组件\" class=\"headerlink\" title=\"新的组件\"></a>新的组件</h3><p>Vue 3 还内置了 Fragment、Teleport 和 Suspense 三个新组件。</p>\n<ul>\n<li>Fragment: Vue 3 组件不再要求有一个唯一的根节点，清除了很多无用的占位 div。</li>\n<li>Teleport: 允许组件渲染在别的元素内，主要开发弹窗组件的时候特别有用。</li>\n<li>Suspense: 异步组件，更方便开发有异步请求的组件。</li>\n</ul>\n<h3 id=\"新一代工程化工具-Vite\"><a href=\"#新一代工程化工具-Vite\" class=\"headerlink\" title=\"新一代工程化工具 Vite\"></a>新一代工程化工具 Vite</h3><p>webpack 工程化的原理是 根据 import 依赖逻辑形成一个依赖图，然后调用对应的处理工具，把整个项目打包后，放在内存中再启动调试。因为要预打包，复杂项目开发时，启动开发环境和热更新时间都比较长，Vite 就是为了解决这个问题而出现的。</p>\n<p>现代浏览器已经默认支持 ES6 的 import 语法，Vite 就是基于这个原理实现的。</p>\n<p>在开发环境下，不需要全部预打包，只要把首页依赖的文件，依次通过网络请求去获取，开发体验得到巨大提升，做到复杂项目时，也能做到秒级调试和热更新。</p>\n<p>webpack 工作原理如下，需要把所有路由依赖打包后，才能开始调试。</p>\n<p><img src=\"/img/2022-01-24-3.png\" alt=\"webpack 工作原理\"></p>\n<p>Vite 工作原理，根据首页的依赖模块，再去获取路由 1 的模块，按需加载。</p>\n<p><img src=\"/img/2022-01-24-4.png\" alt=\"Vite 工作原理\"></p>\n<h2 id=\"Vue3-响应式机制\"><a href=\"#Vue3-响应式机制\" class=\"headerlink\" title=\"Vue3 响应式机制\"></a>Vue3 响应式机制</h2><p>响应式原理：Vue 中用过三种响应式解决方案，分别是 defineProperty、Proxy 和 value setter。</p>\n<hr>\n<p>todo: 07</p>\n<h2 id=\"Vue3-实践常见问题汇总\"><a href=\"#Vue3-实践常见问题汇总\" class=\"headerlink\" title=\"Vue3 实践常见问题汇总\"></a>Vue3 实践常见问题汇总</h2><ol>\n<li><p>vetur 报错， xx has no export.</p>\n<p>使用 Vue3 <code>script setup</code> 语法糖时,VsCode 插件 Vetur 会报该错误，原因是 Vetur(v0.35.0) 暂不支持 ts。</p>\n<p>解决办法： 卸载 Vetur， 用 Volar(尤大推荐) 以取代 Vetur。</p>\n</li>\n</ol>\n<hr>\n<p>上述笔记源于学习极客时间-大圣的 <a href=\"http://gk.link/a/115Qp\">玩转 Vue3 全家桶</a> 课程笔记整理。</p>\n<hr>\n","site":{"data":{}},"wordcount":3552,"excerpt":"","more":"<h2 id=\"Vue-和-React-数据驱动原理对比\"><a href=\"#Vue-和-React-数据驱动原理对比\" class=\"headerlink\" title=\"Vue 和 React 数据驱动原理对比\"></a>Vue 和 React 数据驱动原理对比</h2><p>Vue1 解决方案是使用响应式，初始化的时候，watcher 监听数据的每个属性，数据发生变化的时候，就能够知道数据的哪个 key 变了，去修改对应的 DOM。</p>\n<p>React 是虚拟 DOM 方案，用 JS 对象描述 DOM 树，这个对象就像数据和实际 DOM 的一个缓存层，通过管理这个对象的变化，来减少对实际 DOM 的操作。</p>\n<p>描述实际 DOM 的虚拟 DOM 对象如下：</p>\n<p>DOM:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>Item1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>Item2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>虚拟 DOM：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><br>&#123;<br>  <span class=\"hljs-attr\">tag</span>: <span class=\"hljs-string\">&quot;div&quot;</span>,<br>  <span class=\"hljs-attr\">attrs</span>: &#123;<br>    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">&quot;app&quot;</span><br>  &#125;,<br>  <span class=\"hljs-attr\">children</span>: [<br>    &#123;<br>      <span class=\"hljs-attr\">tag</span>: <span class=\"hljs-string\">&quot;p&quot;</span>,<br>      <span class=\"hljs-attr\">attrs</span>: &#123; <span class=\"hljs-attr\">className</span>: <span class=\"hljs-string\">&quot;item&quot;</span> &#125;,<br>      <span class=\"hljs-attr\">children</span>: [<span class=\"hljs-string\">&quot;Item1&quot;</span>]<br>    &#125;,<br>    &#123;<br>      <span class=\"hljs-attr\">tag</span>: <span class=\"hljs-string\">&quot;div&quot;</span>,<br>      <span class=\"hljs-attr\">attrs</span>: &#123; <span class=\"hljs-attr\">className</span>: <span class=\"hljs-string\">&quot;item&quot;</span> &#125;,<br>      <span class=\"hljs-attr\">children</span>: [<span class=\"hljs-string\">&quot;Item2&quot;</span>]<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>数据变化的时候生成一个新的虚拟 DOM 数据，对比之前的虚拟 DOM 进行 diff 计算，算出要修改的 DOM，再对页面进行操作。</p>\n<p>通知页面更新的方式不同：</p>\n<ul>\n<li>vue 中，数据变化，框架主动告诉你修改了哪些数据；</li>\n<li>react 中，变化变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化</li>\n</ul>\n<p>性能问题：</p>\n<ul>\n<li>vue 的响应式，在项目大了之后，每个数据都有一个 watcher 会影响性能</li>\n<li>如果 react 虚拟 dom 过于庞大，使得 diff 计算时间大于 16.6 ms(屏幕刷新率 60HZ, 1/60)，可能造成性能卡顿。</li>\n</ul>\n<p>为了解决性能问题， Vue 和 react 走了不同的道路。</p>\n<ul>\n<li>react 借鉴操作系统时间分片概念，引入 Fiber 架构。把整个虚拟 DOM 树 微观化，变成链表，然后利用浏览器的空闲时间计算 diff。</li>\n<li>vue1 的问题在于响应式数据过多，会带来内存占用过多的问题。vue2 引入虚拟 DOM 来解决响应式数据过多问题。</li>\n</ul>\n<p>响应式数据是主动推送变化，虚拟 DOM 是被动计算数据的 diff。vue2 将两者结合在一起，在组件级别来划分。</p>\n<p>组件间的变化，通过响应式来通知更新。组件内部的数据变化，通过虚拟 DOM 去更新页面。最终，把响应式监听器控制在组件级别，而虚拟 DOM 的量级控制在组件的大小。</p>\n<p>在模板书写上，vue 和 react 分别走了 template 和 jsx 两个路线。</p>\n<ul>\n<li>react 世界只有 jsx，最终 jsx 都会在 Compiler 那层，即工程化那里编译成 js 来执行。</li>\n<li>vue 默认 template。vue3 优秀的其中一点是在虚拟 DOM 的静态标记上做到了极致，让静态的部分越过虚拟 DOM 的计算，真正做到按需更新，很好的提高了性能。</li>\n</ul>\n<h2 id=\"Vue3-的新特性\"><a href=\"#Vue3-的新特性\" class=\"headerlink\" title=\"Vue3 的新特性\"></a>Vue3 的新特性</h2><h3 id=\"响应式系统\"><a href=\"#响应式系统\" class=\"headerlink\" title=\"响应式系统\"></a>响应式系统</h3><p>Vue 2 的响应式机制是基于 Object.defineProperty() 这个 API 实现的.Vue3 是基于 proxy。两者区别是 defineProperty 是拦截具体某个属性， Proxy 是全部拦截，是代理。</p>\n<p>defineProperty 示例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">Object</span>.defineProperty(obj, <span class=\"hljs-string\">&quot;title&quot;</span>, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;,<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">set</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。</p>\n<p>但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的 $set。</p>\n<p>Proxy API 是真正的代理，示例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>(obj, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;,<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">set</span>(<span class=\"hljs-params\"></span>)</span> &#123;&#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>Proxy 拦截 obj 这个数据，不关心 obj 里面属性，统一拦截。</p>\n<h3 id=\"自定义渲染器\"><a href=\"#自定义渲染器\" class=\"headerlink\" title=\"自定义渲染器\"></a>自定义渲染器</h3><p>vue2 内部所有模块是揉在一起，导致不好扩展。vue3 采用 monorepo 方式进行拆包，响应式、编译和运行时全部独立。独立出来的响应式，甚至可以在 react、node 中使用。</p>\n<p><img src=\"/img/2022-01-24-1.png\" alt=\"vue 架构\"></p>\n<p>渲染逻辑拆成 <strong>平台无关渲染逻辑</strong> 和 <strong>浏览器渲染 API</strong>。</p>\n<h3 id=\"全部模块使用-TS-重构\"><a href=\"#全部模块使用-TS-重构\" class=\"headerlink\" title=\"全部模块使用 TS 重构\"></a>全部模块使用 TS 重构</h3><p>Vue2 使用 Flow.js 做类型检测；Flow.js 已被抛弃，vue3 选择 TS。</p>\n<h3 id=\"Composition-API-组合语法\"><a href=\"#Composition-API-组合语法\" class=\"headerlink\" title=\"Composition API 组合语法\"></a>Composition API 组合语法</h3><p>vue2 中示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> App = &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">1</span> &#125;;<br>  &#125;,<br>  <span class=\"hljs-attr\">methods</span>: &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">add</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>      <span class=\"hljs-built_in\">this</span>.count++;<br>    &#125;<br>  &#125;,<br>  <span class=\"hljs-attr\">computed</span>: &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">double</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.count * <span class=\"hljs-number\">2</span>;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>vue2 中 Options API 存在以下问题：</p>\n<ul>\n<li>所有数据都挂载在 this 上，Options API 写法对 TS 类型推导不友好。</li>\n<li>新增的功能基本都要修改 data、method 等，代码行数多了以后，会经常需要上下反复横跳。</li>\n<li>代码不好复用，vue2 的组件很难抽离通用逻辑，只能使用 mixin，还会导致命名冲突问题。</li>\n</ul>\n<p>vue3 中采用新增的 setup 写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> &#123; reactive, computed &#125; = Vue;<br><span class=\"hljs-keyword\">let</span> App = &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">setup</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> state = reactive(&#123; <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">1</span> &#125;);<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">add</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>      state.count++;<br>    &#125;<br>    <span class=\"hljs-keyword\">const</span> double = computed(<span class=\"hljs-function\">() =&gt;</span> state.count * <span class=\"hljs-number\">2</span>);<br>    <span class=\"hljs-keyword\">return</span> &#123; state, add, double &#125;;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>Composition API 好处如下：</p>\n<ul>\n<li>所有 API 都是 import 引入。对 Tree-shaking 很友好，没用到功能，打包的时候会被清理掉 ，减小包的大小</li>\n<li>一个功能模块的 methods、data 放一起书写，避免上下反复横跳。</li>\n<li>代码复用方便，一个功能的所有 methods、data 封装在一个独立的函数里。</li>\n<li>Composotion API 新增的 return 等语句，在实际项目中使用。</li>\n</ul>\n<p><img src=\"/img/2022-01-24-2.png\" alt=\"Composition API\"></p>\n<h3 id=\"新的组件\"><a href=\"#新的组件\" class=\"headerlink\" title=\"新的组件\"></a>新的组件</h3><p>Vue 3 还内置了 Fragment、Teleport 和 Suspense 三个新组件。</p>\n<ul>\n<li>Fragment: Vue 3 组件不再要求有一个唯一的根节点，清除了很多无用的占位 div。</li>\n<li>Teleport: 允许组件渲染在别的元素内，主要开发弹窗组件的时候特别有用。</li>\n<li>Suspense: 异步组件，更方便开发有异步请求的组件。</li>\n</ul>\n<h3 id=\"新一代工程化工具-Vite\"><a href=\"#新一代工程化工具-Vite\" class=\"headerlink\" title=\"新一代工程化工具 Vite\"></a>新一代工程化工具 Vite</h3><p>webpack 工程化的原理是 根据 import 依赖逻辑形成一个依赖图，然后调用对应的处理工具，把整个项目打包后，放在内存中再启动调试。因为要预打包，复杂项目开发时，启动开发环境和热更新时间都比较长，Vite 就是为了解决这个问题而出现的。</p>\n<p>现代浏览器已经默认支持 ES6 的 import 语法，Vite 就是基于这个原理实现的。</p>\n<p>在开发环境下，不需要全部预打包，只要把首页依赖的文件，依次通过网络请求去获取，开发体验得到巨大提升，做到复杂项目时，也能做到秒级调试和热更新。</p>\n<p>webpack 工作原理如下，需要把所有路由依赖打包后，才能开始调试。</p>\n<p><img src=\"/img/2022-01-24-3.png\" alt=\"webpack 工作原理\"></p>\n<p>Vite 工作原理，根据首页的依赖模块，再去获取路由 1 的模块，按需加载。</p>\n<p><img src=\"/img/2022-01-24-4.png\" alt=\"Vite 工作原理\"></p>\n<h2 id=\"Vue3-响应式机制\"><a href=\"#Vue3-响应式机制\" class=\"headerlink\" title=\"Vue3 响应式机制\"></a>Vue3 响应式机制</h2><p>响应式原理：Vue 中用过三种响应式解决方案，分别是 defineProperty、Proxy 和 value setter。</p>\n<hr>\n<p>todo: 07</p>\n<h2 id=\"Vue3-实践常见问题汇总\"><a href=\"#Vue3-实践常见问题汇总\" class=\"headerlink\" title=\"Vue3 实践常见问题汇总\"></a>Vue3 实践常见问题汇总</h2><ol>\n<li><p>vetur 报错， xx has no export.</p>\n<p>使用 Vue3 <code>script setup</code> 语法糖时,VsCode 插件 Vetur 会报该错误，原因是 Vetur(v0.35.0) 暂不支持 ts。</p>\n<p>解决办法： 卸载 Vetur， 用 Volar(尤大推荐) 以取代 Vetur。</p>\n</li>\n</ol>\n<hr>\n<p>上述笔记源于学习极客时间-大圣的 <a href=\"http://gk.link/a/115Qp\">玩转 Vue3 全家桶</a> 课程笔记整理。</p>\n<hr>\n"},{"title":"中高级前端工程师面试题","index_img":"/img/2022-02-16-1.jpeg","abbrlink":"a18c0ac9","date":"2022-02-15T02:39:21.000Z","_content":"\n## 基础\n\n1、浏览器地址栏输入 URL 到页面打开的整个解析过程？\n\n## JS\n\n1、请你讲一下闭包?\n\n> 简单：闭包是有权限访问其他函数作用域内的变量的一个函数。\n>\n> 完整：由于在JS中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之回收，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数——也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后作用域内的值也不会被销毁。\n\n- 闭包解决了什么？\n\n> 由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。以平时使用的Ajax成功回调为例，这里其实就是个闭包，由于上述的特性，回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。开发者不用去写钩子函数来操作上级函数作用域内部的变量了。\n\n- 闭包有哪些应用场景?\n\n> 闭包随处可见，一个Ajax请求的成功回调，一个事件绑定的回调方法，一个setTimeout的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。\n\n2、介绍一下 JS 里面的原型？\n\n> 每个对象都有一个 prototype 属性，就是原型，是一个对象，叫原型对象。\n\n- 原型的作用是什么？\n\n > 共享方法\n\n- 原型中this的指向是什么？\n\n> 原型中this的指向是实例。\n\n- 说一下平时开发使用到 prototype 的例子？\n\n3、如何理解 es6 class 中 constructor 方法？ 和 super的作用？\n\n> constructor 方法是类的构造函数。\n通过 new 命令创建对象实例时，自动调用该方法。\nconstructor 内定义的方法是 实例方法；class 内直接定义的方法是原型方法。\n>\n> super...\n\n4、eventloop\n\n## React\n\n1、介绍一下 Virtual DOM 的工作原理？\n\n> Virtual DOM 是一个轻量级的 JavaScript 对象，它最初只是 real DOM 的副本。它是一个节点树，它将元素、它们的属性和内容作为对象及其属性。 React 的渲染函数从 React 组件中创建一个节点树。然后它响应数据模型中的变化来更新该树，该变化是由用户或系统完成的各种动作引起的。\n\nVirtual DOM 工作过程有三步：\n\n  1. 每当底层数据发生改变时，整个 UI 都将在 Virtual DOM 描述中重新渲染。\n  2. 然后计算之前 DOM 表示与新表示的之间的差异。\n  3. 完成计算后，将只用实际更改的内容更新 real DOM。\n\n2、react 里什么是高阶组件？使用高阶组件的场景？\n\n> 高阶组件(HOC)是接受一个组件并返回一个新组件的函数。\n\n3、React Hooks 解决了哪些问题？\n\n> 在组件之间复用状态逻辑很难;复杂组件变得难以理解\n\n4、说一下 useRef 有哪些用法？\n\n> useRef 除了获取 dom，另一个用法：\n保存数据，不造成 rerender\n想要保存数据，又不想触发函数的更新，该数据的更新不会造成组件 rerender\n\n5、什么情况下使用 useCallback ？\n子组件接收一个方法，避免子组件重复渲染\n\n- react 中只要父组件的 render 了，那么默认情况下就会触发子组的 render，react 提供了来避免这种重渲染的性能开销的一些方法：React.PureComponent、React.memo ，shouldComponentUpdate()\n- 使用 React.memo 避免子组件做没必要的渲染。\n- Reace.memo 只会对 props 做浅比较，也就是父组件重新 render 之后会传入 不同引用的方法 getList，浅比较之后不相等，导致子组件还是依然会渲染。\n- useCallback 缓存一个函数，当依赖没有改变的时候，会一直返回同一个引用\n\n6、useCallback 与 useMemo 作用用来缓存，两者的区别是什么？\n\n> useMemo 缓存值；useCallback 缓存函数\n\n7、 react 项目里做过哪些性能优化？\n\n代码层面：\n\n- 使用return null而不是CSS的display:none来控制节点的显示隐藏。保证同一时间页面的DOM节点尽可能的少。\n- props和state的数据尽可能简单明了，扁平化。\n- 不要使用数组下标作为key\n- 利用 shouldComponentUpdate 和 PureComponent 避免过多 render function\n- render里面尽量减少新建变量和bind函数，传递参数是尽量减少传递参数的数量。\n- 尽量将 props 和 state 扁平化，只传递 component 需要的 props（传得太多，或者层次传得太深，都会加重shouldComponentUpdate里面的数据比较负担），慎将 component 当作 props 传入\n\n代码体积优化:\n\n- 使用 babel-plugin-import 优化业务组件的引入，实现按需加载\n- 使用 生产版本\n- 使用 SplitChunksPlugin 拆分公共代码\n- 分析 CSS 和 JS 代码覆盖率\n- 优化 Webpack 中的库\n- 使用动态 import，懒加载 React 组件\n- 使用 webpack-bundle-analyzer 可视化 webpack 输出文件的大小\n- 使用动态 import，懒加载 React 组件\n- 使用 Tree Shaking & 教程 & Tree Shaking 优化\n\n## Vue\n\n1、Vue 组件 data 为什么必须是函数？\n\n> 因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染。\n所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。\n\n2、直接给一个数组项赋值，Vue 能检测到变化吗？\n\n由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。\n\n> Vue 不能检测到以下数组的变动:\n>\n> 1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue\n>\n> 2.当你修改数组的长度时，例如：vm.items.length = newLength\n\n```js\nvm.$set(vm.items, indexOfItem, newValue)\n\nvm.items.splice(newLength)\n```\n\n- 检测不到的原因是什么？\n\n> 当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。\n>\n> 但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的 $set。\n\n3、vue2 中响应式（双向绑定）的原理？vue3 的原理？\nProxy 与 Object.defineProperty 的优劣对比?\n为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？\n\n> Proxy的优势如下:\nProxy 可以直接监听对象而非属性\nProxy 可以直接监听数组的变化\nProxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的\nProxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改\nProxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利\n>\n> Object.defineProperty 的优势如下:\n>\n> 兼容性好,支持 IE9\n\n4、vuex 的工作流程是怎么样？\n\n> Vuex有5个重要的属性，分别是 State、Getter、Mutation、Action、Module，由 view 层发起一个 Action 给 Mutation，在 Mutation 中修改状态，返回新的状态，通过 Getter暴露给 view层的组件或者页面，页面监测到状态改变于是更新页面。\n\n5、 Vue3 有哪些新的新特性？\n\n- 响应式系统\n- 自定义渲染器\n- 全部模块使用 TS 重构\n- Composition API 组合语法\n- 新一代工程化工具 Vite\n\n6、父组件可以监听到子组件的生命周期吗？\n\n比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理。\n\n方法一：手动通过 $emit 触发父组件的事件\n\n```js\n// Parent.vue\n<Child @mounted=\"doSomething\"/>\n    \n// Child.vue\nmounted() {\n  this.$emit(\"mounted\");\n}\n```\n\n方法二：父组件引用子组件时通过 @hook 来监听\n\n```js\n//  Parent.vue\n<Child @hook:mounted=\"doSomething\" ></Child>\n    \n//  Child.vue\nmounted(){\n   console.log('子组件触发 mounted 钩子函数 ...');\n},       \n```\n@hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。\n\n7、比较 Vue 和 React 两个框架，你觉得有哪些区别？\n\n- 监听数据变化的实现原理不同:\n\n    Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化.\n    react 中，数据变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化。\n- 数据流的不同:\n- 模板渲染方式的不同:\n\n8、什么是异步组件？\n\n在声明或注册组件时，Vue 接受提供 Promise 的工厂函数。然后可以在调用该组件时对其进行“解析”。\n\n```js\nnew Vue({\n    components: {\n        ‘tweet-box’: () => import(‘./components/async/TweetBox’)\n    }\n}); \n```\n\n## http\n\n1、HTTP有哪些请求方法？PUT 和 PATCH 有什么区别？\n\n- GET, POST 和 HEAD方法；OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT\n- PUT和PATCH都是更新资源，而PATCH用来对资源进行局部更新。\n\n2、http 状态码 403 是什么错误？\n\n- 403 forbidden，表示对请求资源的访问被服务器拒绝\n\n3、知道哪些 http 的缓存策略 ？控制缓存的请求头有哪些？\n\n- HTTP缓存机制分为强制缓存和协商缓存两类。\n- 强制缓存的意思就是不要问了(不发起请求)，直接用缓存吧。\n- 强制缓存常见技术有Expires和Cache-Control。\n- Expires的值是一个时间，表示这个时间前缓存都有效，都不需要发起请求。\n- Cache-Control有很多属性值，常用属性max-age设置了缓存有效的时间长度，单位为秒，这个时间没到，都不用发起请求。\n- immutable也是Cache-Control的一个属性，表示这个资源这辈子都不用再请求了，但是他兼容性不好，Cache-Control其他属性可以参考MDN的文档。\n- Cache-Control的max-age优先级比Expires高。\n- 协商缓存是为了知道有没有更新，必须跟服务端沟通过才知道的。常见技术有ETag和Last-Modified。\n- ETag其实就是给资源算一个hash值或者版本号，对应的常用request header为If-None-Match。\n- Last-Modified其实就是加上资源修改的时间，对应的常用request header为If-Modified-Since，精度为秒。\n- ETag每次修改都会改变，而Last-Modified的精度只到秒，所以ETag更准确，优先级更高，但是需要计算，所以服务端开销更大。\n- 强制缓存和协商缓存都存在的情况下，先判断强制缓存是否生效，如果生效，不用发起请求，直接用缓存。如果强制缓存不生效再发起请求判断协商缓存。\n\n> Cache-Control，ETag，Last-Modified\n\n## 其他\n\n1、有没有读过哪些源码？\n2、最近开发的项目具体业务是怎么样的？介绍一下？\n\n## Devops 相关\n\n### nginx\n\n1. 谈谈一下对 nginx 的理解，项目中用到 nginx 的哪些功能？\n\n- Nginx ，是一个 Web 服务器和反向代理服务器用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。\n- 主要功能如下：\n    正向、反向代理 2、负载均衡、分流 3、虚拟主机（绑定host）\n\n2、正向代理和反向代理区别是什么？\n\n- 正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定原始服务器，然后代理向原始服务器转交请求并将获得的内容返回给客户端。代理服务器和客户端处于同一个局域网内。\n- 比如说fanqiang。我知道我要访问谷歌，于是我就告诉代理服务器让它帮我转发。\n- 反向代理实际运行方式是代理服务器接受网络上的连接请求。它将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给网络上请求连接的客户端 。代理服务器和原始服务器处于同一个局域网内。\n- 比如说我要访问taobao，对我来说不知道图片、json、css 是不是同一个服务器返回回来的，但是我不关心，是反向代理 处理的，我不知道原始服务器。\n\n3、nginx 如何来实现负载均衡？\n\n负载均衡的5种策略:\n\n```sh\n\n 1.轮询（默认）\n 每个请求按时间顺序逐一分配到不同的后端服务器\n\n upstream backserver {\n    server 192.168.0.14;\n    server 192.168.0.15;\n}\n\n2.weight\n指定轮询几率，weight和访问概率成正比\n\nupstream backserver {\n    server 192.168.0.14 weight=3;\n    server 192.168.0.15 weight=7;\n}\n\n3.ip_hash\n已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的.ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。\n\nupstream backserver {\n    ip_hash;\n    server 192.168.0.14:88;\n    server 192.168.0.15:80;\n}\n\n4.fair\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n\nupstream backserver {\n    server server1;\n    server server2;\n    fair;\n}\n\n5.url_hash\n按访问url的hash结果来分配请求，使每个url定向到同一个（对应的）后端服务器，后端服务器为缓存时比较有效。\n\nupstream backserver {\n    server squid1:3128;\n    server squid2:3128;\n    hash $request_uri;\n    hash_method crc32;\n}\n```\n\n### docker\n\n1、什么是 Docker？\n\n- Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。\n\n2、Dockerfile中最常见的指令是什么？\n\n- FROM：指定基础镜像；LABEL：功能是为镜像指定标签；RUN：运行指定的命令；CMD：容器启动时要运行的命令。\n\n### k8s\n\n1、k8s是什么？请说出你的了解？\n\n- Kubernetes 是一个针对容器应用，进行自动部署，弹性伸缩和管理的开源系统。主要功能是生产环境中的容器编排。\n\n2、k8s 集群里面最小的单位是什么？\n\n- pod 是最小单位。每个pod里边可以运行一个或多个container（容器）\n\n3、Service这种资源对象的作用是什么？\n\n- 用来给相同的多个pod对象提供一个固定的统一访问接口，常用于服务发现和服务访问。\n\n### openstack\n\n1、openstack 里 KeyStone 组件是用于提供什么服务的？Nova 组件是做什么用？\n\n- 认证服务（KeyStone）\nNova – 用于在计算级别管理虚拟机，并在计算或管理程序级别执行其他计算任务。\n\n### linux 基本命令\n\n```sh\nsudo\nls\ncd\nmkdir\nrm\napt-get\ngrep\ncat\n```\n","source":"_posts/2022-02-15-1.md","raw":"---\ntitle: 中高级前端工程师面试题\nindex_img: /img/2022-02-16-1.jpeg\ntags: 面试\ncategories: 面试\nabbrlink: a18c0ac9\ndate: 2022-02-15 10:39:21\n---\n\n## 基础\n\n1、浏览器地址栏输入 URL 到页面打开的整个解析过程？\n\n## JS\n\n1、请你讲一下闭包?\n\n> 简单：闭包是有权限访问其他函数作用域内的变量的一个函数。\n>\n> 完整：由于在JS中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之回收，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数——也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后作用域内的值也不会被销毁。\n\n- 闭包解决了什么？\n\n> 由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。以平时使用的Ajax成功回调为例，这里其实就是个闭包，由于上述的特性，回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。开发者不用去写钩子函数来操作上级函数作用域内部的变量了。\n\n- 闭包有哪些应用场景?\n\n> 闭包随处可见，一个Ajax请求的成功回调，一个事件绑定的回调方法，一个setTimeout的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。\n\n2、介绍一下 JS 里面的原型？\n\n> 每个对象都有一个 prototype 属性，就是原型，是一个对象，叫原型对象。\n\n- 原型的作用是什么？\n\n > 共享方法\n\n- 原型中this的指向是什么？\n\n> 原型中this的指向是实例。\n\n- 说一下平时开发使用到 prototype 的例子？\n\n3、如何理解 es6 class 中 constructor 方法？ 和 super的作用？\n\n> constructor 方法是类的构造函数。\n通过 new 命令创建对象实例时，自动调用该方法。\nconstructor 内定义的方法是 实例方法；class 内直接定义的方法是原型方法。\n>\n> super...\n\n4、eventloop\n\n## React\n\n1、介绍一下 Virtual DOM 的工作原理？\n\n> Virtual DOM 是一个轻量级的 JavaScript 对象，它最初只是 real DOM 的副本。它是一个节点树，它将元素、它们的属性和内容作为对象及其属性。 React 的渲染函数从 React 组件中创建一个节点树。然后它响应数据模型中的变化来更新该树，该变化是由用户或系统完成的各种动作引起的。\n\nVirtual DOM 工作过程有三步：\n\n  1. 每当底层数据发生改变时，整个 UI 都将在 Virtual DOM 描述中重新渲染。\n  2. 然后计算之前 DOM 表示与新表示的之间的差异。\n  3. 完成计算后，将只用实际更改的内容更新 real DOM。\n\n2、react 里什么是高阶组件？使用高阶组件的场景？\n\n> 高阶组件(HOC)是接受一个组件并返回一个新组件的函数。\n\n3、React Hooks 解决了哪些问题？\n\n> 在组件之间复用状态逻辑很难;复杂组件变得难以理解\n\n4、说一下 useRef 有哪些用法？\n\n> useRef 除了获取 dom，另一个用法：\n保存数据，不造成 rerender\n想要保存数据，又不想触发函数的更新，该数据的更新不会造成组件 rerender\n\n5、什么情况下使用 useCallback ？\n子组件接收一个方法，避免子组件重复渲染\n\n- react 中只要父组件的 render 了，那么默认情况下就会触发子组的 render，react 提供了来避免这种重渲染的性能开销的一些方法：React.PureComponent、React.memo ，shouldComponentUpdate()\n- 使用 React.memo 避免子组件做没必要的渲染。\n- Reace.memo 只会对 props 做浅比较，也就是父组件重新 render 之后会传入 不同引用的方法 getList，浅比较之后不相等，导致子组件还是依然会渲染。\n- useCallback 缓存一个函数，当依赖没有改变的时候，会一直返回同一个引用\n\n6、useCallback 与 useMemo 作用用来缓存，两者的区别是什么？\n\n> useMemo 缓存值；useCallback 缓存函数\n\n7、 react 项目里做过哪些性能优化？\n\n代码层面：\n\n- 使用return null而不是CSS的display:none来控制节点的显示隐藏。保证同一时间页面的DOM节点尽可能的少。\n- props和state的数据尽可能简单明了，扁平化。\n- 不要使用数组下标作为key\n- 利用 shouldComponentUpdate 和 PureComponent 避免过多 render function\n- render里面尽量减少新建变量和bind函数，传递参数是尽量减少传递参数的数量。\n- 尽量将 props 和 state 扁平化，只传递 component 需要的 props（传得太多，或者层次传得太深，都会加重shouldComponentUpdate里面的数据比较负担），慎将 component 当作 props 传入\n\n代码体积优化:\n\n- 使用 babel-plugin-import 优化业务组件的引入，实现按需加载\n- 使用 生产版本\n- 使用 SplitChunksPlugin 拆分公共代码\n- 分析 CSS 和 JS 代码覆盖率\n- 优化 Webpack 中的库\n- 使用动态 import，懒加载 React 组件\n- 使用 webpack-bundle-analyzer 可视化 webpack 输出文件的大小\n- 使用动态 import，懒加载 React 组件\n- 使用 Tree Shaking & 教程 & Tree Shaking 优化\n\n## Vue\n\n1、Vue 组件 data 为什么必须是函数？\n\n> 因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染。\n所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。\n\n2、直接给一个数组项赋值，Vue 能检测到变化吗？\n\n由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。\n\n> Vue 不能检测到以下数组的变动:\n>\n> 1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue\n>\n> 2.当你修改数组的长度时，例如：vm.items.length = newLength\n\n```js\nvm.$set(vm.items, indexOfItem, newValue)\n\nvm.items.splice(newLength)\n```\n\n- 检测不到的原因是什么？\n\n> 当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。\n>\n> 但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的 $set。\n\n3、vue2 中响应式（双向绑定）的原理？vue3 的原理？\nProxy 与 Object.defineProperty 的优劣对比?\n为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？\n\n> Proxy的优势如下:\nProxy 可以直接监听对象而非属性\nProxy 可以直接监听数组的变化\nProxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的\nProxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改\nProxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利\n>\n> Object.defineProperty 的优势如下:\n>\n> 兼容性好,支持 IE9\n\n4、vuex 的工作流程是怎么样？\n\n> Vuex有5个重要的属性，分别是 State、Getter、Mutation、Action、Module，由 view 层发起一个 Action 给 Mutation，在 Mutation 中修改状态，返回新的状态，通过 Getter暴露给 view层的组件或者页面，页面监测到状态改变于是更新页面。\n\n5、 Vue3 有哪些新的新特性？\n\n- 响应式系统\n- 自定义渲染器\n- 全部模块使用 TS 重构\n- Composition API 组合语法\n- 新一代工程化工具 Vite\n\n6、父组件可以监听到子组件的生命周期吗？\n\n比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理。\n\n方法一：手动通过 $emit 触发父组件的事件\n\n```js\n// Parent.vue\n<Child @mounted=\"doSomething\"/>\n    \n// Child.vue\nmounted() {\n  this.$emit(\"mounted\");\n}\n```\n\n方法二：父组件引用子组件时通过 @hook 来监听\n\n```js\n//  Parent.vue\n<Child @hook:mounted=\"doSomething\" ></Child>\n    \n//  Child.vue\nmounted(){\n   console.log('子组件触发 mounted 钩子函数 ...');\n},       \n```\n@hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。\n\n7、比较 Vue 和 React 两个框架，你觉得有哪些区别？\n\n- 监听数据变化的实现原理不同:\n\n    Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化.\n    react 中，数据变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化。\n- 数据流的不同:\n- 模板渲染方式的不同:\n\n8、什么是异步组件？\n\n在声明或注册组件时，Vue 接受提供 Promise 的工厂函数。然后可以在调用该组件时对其进行“解析”。\n\n```js\nnew Vue({\n    components: {\n        ‘tweet-box’: () => import(‘./components/async/TweetBox’)\n    }\n}); \n```\n\n## http\n\n1、HTTP有哪些请求方法？PUT 和 PATCH 有什么区别？\n\n- GET, POST 和 HEAD方法；OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT\n- PUT和PATCH都是更新资源，而PATCH用来对资源进行局部更新。\n\n2、http 状态码 403 是什么错误？\n\n- 403 forbidden，表示对请求资源的访问被服务器拒绝\n\n3、知道哪些 http 的缓存策略 ？控制缓存的请求头有哪些？\n\n- HTTP缓存机制分为强制缓存和协商缓存两类。\n- 强制缓存的意思就是不要问了(不发起请求)，直接用缓存吧。\n- 强制缓存常见技术有Expires和Cache-Control。\n- Expires的值是一个时间，表示这个时间前缓存都有效，都不需要发起请求。\n- Cache-Control有很多属性值，常用属性max-age设置了缓存有效的时间长度，单位为秒，这个时间没到，都不用发起请求。\n- immutable也是Cache-Control的一个属性，表示这个资源这辈子都不用再请求了，但是他兼容性不好，Cache-Control其他属性可以参考MDN的文档。\n- Cache-Control的max-age优先级比Expires高。\n- 协商缓存是为了知道有没有更新，必须跟服务端沟通过才知道的。常见技术有ETag和Last-Modified。\n- ETag其实就是给资源算一个hash值或者版本号，对应的常用request header为If-None-Match。\n- Last-Modified其实就是加上资源修改的时间，对应的常用request header为If-Modified-Since，精度为秒。\n- ETag每次修改都会改变，而Last-Modified的精度只到秒，所以ETag更准确，优先级更高，但是需要计算，所以服务端开销更大。\n- 强制缓存和协商缓存都存在的情况下，先判断强制缓存是否生效，如果生效，不用发起请求，直接用缓存。如果强制缓存不生效再发起请求判断协商缓存。\n\n> Cache-Control，ETag，Last-Modified\n\n## 其他\n\n1、有没有读过哪些源码？\n2、最近开发的项目具体业务是怎么样的？介绍一下？\n\n## Devops 相关\n\n### nginx\n\n1. 谈谈一下对 nginx 的理解，项目中用到 nginx 的哪些功能？\n\n- Nginx ，是一个 Web 服务器和反向代理服务器用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。\n- 主要功能如下：\n    正向、反向代理 2、负载均衡、分流 3、虚拟主机（绑定host）\n\n2、正向代理和反向代理区别是什么？\n\n- 正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定原始服务器，然后代理向原始服务器转交请求并将获得的内容返回给客户端。代理服务器和客户端处于同一个局域网内。\n- 比如说fanqiang。我知道我要访问谷歌，于是我就告诉代理服务器让它帮我转发。\n- 反向代理实际运行方式是代理服务器接受网络上的连接请求。它将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给网络上请求连接的客户端 。代理服务器和原始服务器处于同一个局域网内。\n- 比如说我要访问taobao，对我来说不知道图片、json、css 是不是同一个服务器返回回来的，但是我不关心，是反向代理 处理的，我不知道原始服务器。\n\n3、nginx 如何来实现负载均衡？\n\n负载均衡的5种策略:\n\n```sh\n\n 1.轮询（默认）\n 每个请求按时间顺序逐一分配到不同的后端服务器\n\n upstream backserver {\n    server 192.168.0.14;\n    server 192.168.0.15;\n}\n\n2.weight\n指定轮询几率，weight和访问概率成正比\n\nupstream backserver {\n    server 192.168.0.14 weight=3;\n    server 192.168.0.15 weight=7;\n}\n\n3.ip_hash\n已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的.ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。\n\nupstream backserver {\n    ip_hash;\n    server 192.168.0.14:88;\n    server 192.168.0.15:80;\n}\n\n4.fair\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n\nupstream backserver {\n    server server1;\n    server server2;\n    fair;\n}\n\n5.url_hash\n按访问url的hash结果来分配请求，使每个url定向到同一个（对应的）后端服务器，后端服务器为缓存时比较有效。\n\nupstream backserver {\n    server squid1:3128;\n    server squid2:3128;\n    hash $request_uri;\n    hash_method crc32;\n}\n```\n\n### docker\n\n1、什么是 Docker？\n\n- Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。\n\n2、Dockerfile中最常见的指令是什么？\n\n- FROM：指定基础镜像；LABEL：功能是为镜像指定标签；RUN：运行指定的命令；CMD：容器启动时要运行的命令。\n\n### k8s\n\n1、k8s是什么？请说出你的了解？\n\n- Kubernetes 是一个针对容器应用，进行自动部署，弹性伸缩和管理的开源系统。主要功能是生产环境中的容器编排。\n\n2、k8s 集群里面最小的单位是什么？\n\n- pod 是最小单位。每个pod里边可以运行一个或多个container（容器）\n\n3、Service这种资源对象的作用是什么？\n\n- 用来给相同的多个pod对象提供一个固定的统一访问接口，常用于服务发现和服务访问。\n\n### openstack\n\n1、openstack 里 KeyStone 组件是用于提供什么服务的？Nova 组件是做什么用？\n\n- 认证服务（KeyStone）\nNova – 用于在计算级别管理虚拟机，并在计算或管理程序级别执行其他计算任务。\n\n### linux 基本命令\n\n```sh\nsudo\nls\ncd\nmkdir\nrm\napt-get\ngrep\ncat\n```\n","slug":"1","published":1,"updated":"2022-03-01T02:56:12.120Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0f42s30001evw3lamezhfd9","content":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><p>1、浏览器地址栏输入 URL 到页面打开的整个解析过程？</p>\n<h2 id=\"JS\"><a href=\"#JS\" class=\"headerlink\" title=\"JS\"></a>JS</h2><p>1、请你讲一下闭包?</p>\n<blockquote>\n<p>简单：闭包是有权限访问其他函数作用域内的变量的一个函数。</p>\n<p>完整：由于在JS中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之回收，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数——也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后作用域内的值也不会被销毁。</p>\n</blockquote>\n<ul>\n<li>闭包解决了什么？</li>\n</ul>\n<blockquote>\n<p>由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。以平时使用的Ajax成功回调为例，这里其实就是个闭包，由于上述的特性，回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。开发者不用去写钩子函数来操作上级函数作用域内部的变量了。</p>\n</blockquote>\n<ul>\n<li>闭包有哪些应用场景?</li>\n</ul>\n<blockquote>\n<p>闭包随处可见，一个Ajax请求的成功回调，一个事件绑定的回调方法，一个setTimeout的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。</p>\n</blockquote>\n<p>2、介绍一下 JS 里面的原型？</p>\n<blockquote>\n<p>每个对象都有一个 prototype 属性，就是原型，是一个对象，叫原型对象。</p>\n</blockquote>\n<ul>\n<li>原型的作用是什么？</li>\n</ul>\n<blockquote>\n<p>共享方法</p>\n</blockquote>\n<ul>\n<li>原型中this的指向是什么？</li>\n</ul>\n<blockquote>\n<p>原型中this的指向是实例。</p>\n</blockquote>\n<ul>\n<li>说一下平时开发使用到 prototype 的例子？</li>\n</ul>\n<p>3、如何理解 es6 class 中 constructor 方法？ 和 super的作用？</p>\n<blockquote>\n<p>constructor 方法是类的构造函数。<br>通过 new 命令创建对象实例时，自动调用该方法。<br>constructor 内定义的方法是 实例方法；class 内直接定义的方法是原型方法。</p>\n<p>super…</p>\n</blockquote>\n<p>4、eventloop</p>\n<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><p>1、介绍一下 Virtual DOM 的工作原理？</p>\n<blockquote>\n<p>Virtual DOM 是一个轻量级的 JavaScript 对象，它最初只是 real DOM 的副本。它是一个节点树，它将元素、它们的属性和内容作为对象及其属性。 React 的渲染函数从 React 组件中创建一个节点树。然后它响应数据模型中的变化来更新该树，该变化是由用户或系统完成的各种动作引起的。</p>\n</blockquote>\n<p>Virtual DOM 工作过程有三步：</p>\n<ol>\n<li>每当底层数据发生改变时，整个 UI 都将在 Virtual DOM 描述中重新渲染。</li>\n<li>然后计算之前 DOM 表示与新表示的之间的差异。</li>\n<li>完成计算后，将只用实际更改的内容更新 real DOM。</li>\n</ol>\n<p>2、react 里什么是高阶组件？使用高阶组件的场景？</p>\n<blockquote>\n<p>高阶组件(HOC)是接受一个组件并返回一个新组件的函数。</p>\n</blockquote>\n<p>3、React Hooks 解决了哪些问题？</p>\n<blockquote>\n<p>在组件之间复用状态逻辑很难;复杂组件变得难以理解</p>\n</blockquote>\n<p>4、说一下 useRef 有哪些用法？</p>\n<blockquote>\n<p>useRef 除了获取 dom，另一个用法：<br>保存数据，不造成 rerender<br>想要保存数据，又不想触发函数的更新，该数据的更新不会造成组件 rerender</p>\n</blockquote>\n<p>5、什么情况下使用 useCallback ？<br>子组件接收一个方法，避免子组件重复渲染</p>\n<ul>\n<li>react 中只要父组件的 render 了，那么默认情况下就会触发子组的 render，react 提供了来避免这种重渲染的性能开销的一些方法：React.PureComponent、React.memo ，shouldComponentUpdate()</li>\n<li>使用 React.memo 避免子组件做没必要的渲染。</li>\n<li>Reace.memo 只会对 props 做浅比较，也就是父组件重新 render 之后会传入 不同引用的方法 getList，浅比较之后不相等，导致子组件还是依然会渲染。</li>\n<li>useCallback 缓存一个函数，当依赖没有改变的时候，会一直返回同一个引用</li>\n</ul>\n<p>6、useCallback 与 useMemo 作用用来缓存，两者的区别是什么？</p>\n<blockquote>\n<p>useMemo 缓存值；useCallback 缓存函数</p>\n</blockquote>\n<p>7、 react 项目里做过哪些性能优化？</p>\n<p>代码层面：</p>\n<ul>\n<li>使用return null而不是CSS的display:none来控制节点的显示隐藏。保证同一时间页面的DOM节点尽可能的少。</li>\n<li>props和state的数据尽可能简单明了，扁平化。</li>\n<li>不要使用数组下标作为key</li>\n<li>利用 shouldComponentUpdate 和 PureComponent 避免过多 render function</li>\n<li>render里面尽量减少新建变量和bind函数，传递参数是尽量减少传递参数的数量。</li>\n<li>尽量将 props 和 state 扁平化，只传递 component 需要的 props（传得太多，或者层次传得太深，都会加重shouldComponentUpdate里面的数据比较负担），慎将 component 当作 props 传入</li>\n</ul>\n<p>代码体积优化:</p>\n<ul>\n<li>使用 babel-plugin-import 优化业务组件的引入，实现按需加载</li>\n<li>使用 生产版本</li>\n<li>使用 SplitChunksPlugin 拆分公共代码</li>\n<li>分析 CSS 和 JS 代码覆盖率</li>\n<li>优化 Webpack 中的库</li>\n<li>使用动态 import，懒加载 React 组件</li>\n<li>使用 webpack-bundle-analyzer 可视化 webpack 输出文件的大小</li>\n<li>使用动态 import，懒加载 React 组件</li>\n<li>使用 Tree Shaking &amp; 教程 &amp; Tree Shaking 优化</li>\n</ul>\n<h2 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h2><p>1、Vue 组件 data 为什么必须是函数？</p>\n<blockquote>\n<p>因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染。<br>所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。</p>\n</blockquote>\n<p>2、直接给一个数组项赋值，Vue 能检测到变化吗？</p>\n<p>由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。</p>\n<blockquote>\n<p>Vue 不能检测到以下数组的变动:</p>\n<p>1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue</p>\n<p>2.当你修改数组的长度时，例如：vm.items.length = newLength</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\">vm.$set(vm.items, indexOfItem, newValue)<br><br>vm.items.splice(newLength)<br></code></pre></div></td></tr></table></figure>\n\n<ul>\n<li>检测不到的原因是什么？</li>\n</ul>\n<blockquote>\n<p>当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。</p>\n<p>但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的 $set。</p>\n</blockquote>\n<p>3、vue2 中响应式（双向绑定）的原理？vue3 的原理？<br>Proxy 与 Object.defineProperty 的优劣对比?<br>为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？</p>\n<blockquote>\n<p>Proxy的优势如下:<br>Proxy 可以直接监听对象而非属性<br>Proxy 可以直接监听数组的变化<br>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的<br>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改<br>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利</p>\n<p>Object.defineProperty 的优势如下:</p>\n<p>兼容性好,支持 IE9</p>\n</blockquote>\n<p>4、vuex 的工作流程是怎么样？</p>\n<blockquote>\n<p>Vuex有5个重要的属性，分别是 State、Getter、Mutation、Action、Module，由 view 层发起一个 Action 给 Mutation，在 Mutation 中修改状态，返回新的状态，通过 Getter暴露给 view层的组件或者页面，页面监测到状态改变于是更新页面。</p>\n</blockquote>\n<p>5、 Vue3 有哪些新的新特性？</p>\n<ul>\n<li>响应式系统</li>\n<li>自定义渲染器</li>\n<li>全部模块使用 TS 重构</li>\n<li>Composition API 组合语法</li>\n<li>新一代工程化工具 Vite</li>\n</ul>\n<p>6、父组件可以监听到子组件的生命周期吗？</p>\n<p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理。</p>\n<p>方法一：手动通过 $emit 触发父组件的事件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Parent.vue</span><br>&lt;Child @mounted=<span class=\"hljs-string\">&quot;doSomething&quot;</span>/&gt;<br>    <br><span class=\"hljs-comment\">// Child.vue</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">mounted</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>  <span class=\"hljs-built_in\">this</span>.$emit(<span class=\"hljs-string\">&quot;mounted&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>方法二：父组件引用子组件时通过 @hook 来监听</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//  Parent.vue</span><br>&lt;Child @hook:mounted=<span class=\"hljs-string\">&quot;doSomething&quot;</span> &gt;&lt;/Child&gt;<br>    <br><span class=\"hljs-comment\">//  Child.vue</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">mounted</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>   <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;子组件触发 mounted 钩子函数 ...&#x27;</span>);<br>&#125;,       <br></code></pre></div></td></tr></table></figure>\n<p>@hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p>\n<p>7、比较 Vue 和 React 两个框架，你觉得有哪些区别？</p>\n<ul>\n<li><p>监听数据变化的实现原理不同:</p>\n<p>  Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化.<br>  react 中，数据变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化。</p>\n</li>\n<li><p>数据流的不同:</p>\n</li>\n<li><p>模板渲染方式的不同:</p>\n</li>\n</ul>\n<p>8、什么是异步组件？</p>\n<p>在声明或注册组件时，Vue 接受提供 Promise 的工厂函数。然后可以在调用该组件时对其进行“解析”。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;<br>    <span class=\"hljs-attr\">components</span>: &#123;<br>        ‘tweet-box’: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">import</span>(‘./components/<span class=\"hljs-keyword\">async</span>/TweetBox’)<br>    &#125;<br>&#125;); <br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"http\"><a href=\"#http\" class=\"headerlink\" title=\"http\"></a>http</h2><p>1、HTTP有哪些请求方法？PUT 和 PATCH 有什么区别？</p>\n<ul>\n<li>GET, POST 和 HEAD方法；OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT</li>\n<li>PUT和PATCH都是更新资源，而PATCH用来对资源进行局部更新。</li>\n</ul>\n<p>2、http 状态码 403 是什么错误？</p>\n<ul>\n<li>403 forbidden，表示对请求资源的访问被服务器拒绝</li>\n</ul>\n<p>3、知道哪些 http 的缓存策略 ？控制缓存的请求头有哪些？</p>\n<ul>\n<li>HTTP缓存机制分为强制缓存和协商缓存两类。</li>\n<li>强制缓存的意思就是不要问了(不发起请求)，直接用缓存吧。</li>\n<li>强制缓存常见技术有Expires和Cache-Control。</li>\n<li>Expires的值是一个时间，表示这个时间前缓存都有效，都不需要发起请求。</li>\n<li>Cache-Control有很多属性值，常用属性max-age设置了缓存有效的时间长度，单位为秒，这个时间没到，都不用发起请求。</li>\n<li>immutable也是Cache-Control的一个属性，表示这个资源这辈子都不用再请求了，但是他兼容性不好，Cache-Control其他属性可以参考MDN的文档。</li>\n<li>Cache-Control的max-age优先级比Expires高。</li>\n<li>协商缓存是为了知道有没有更新，必须跟服务端沟通过才知道的。常见技术有ETag和Last-Modified。</li>\n<li>ETag其实就是给资源算一个hash值或者版本号，对应的常用request header为If-None-Match。</li>\n<li>Last-Modified其实就是加上资源修改的时间，对应的常用request header为If-Modified-Since，精度为秒。</li>\n<li>ETag每次修改都会改变，而Last-Modified的精度只到秒，所以ETag更准确，优先级更高，但是需要计算，所以服务端开销更大。</li>\n<li>强制缓存和协商缓存都存在的情况下，先判断强制缓存是否生效，如果生效，不用发起请求，直接用缓存。如果强制缓存不生效再发起请求判断协商缓存。</li>\n</ul>\n<blockquote>\n<p>Cache-Control，ETag，Last-Modified</p>\n</blockquote>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>1、有没有读过哪些源码？<br>2、最近开发的项目具体业务是怎么样的？介绍一下？</p>\n<h2 id=\"Devops-相关\"><a href=\"#Devops-相关\" class=\"headerlink\" title=\"Devops 相关\"></a>Devops 相关</h2><h3 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h3><ol>\n<li>谈谈一下对 nginx 的理解，项目中用到 nginx 的哪些功能？</li>\n</ol>\n<ul>\n<li>Nginx ，是一个 Web 服务器和反向代理服务器用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。</li>\n<li>主要功能如下：<br>  正向、反向代理 2、负载均衡、分流 3、虚拟主机（绑定host）</li>\n</ul>\n<p>2、正向代理和反向代理区别是什么？</p>\n<ul>\n<li>正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定原始服务器，然后代理向原始服务器转交请求并将获得的内容返回给客户端。代理服务器和客户端处于同一个局域网内。</li>\n<li>比如说fanqiang。我知道我要访问谷歌，于是我就告诉代理服务器让它帮我转发。</li>\n<li>反向代理实际运行方式是代理服务器接受网络上的连接请求。它将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给网络上请求连接的客户端 。代理服务器和原始服务器处于同一个局域网内。</li>\n<li>比如说我要访问taobao，对我来说不知道图片、json、css 是不是同一个服务器返回回来的，但是我不关心，是反向代理 处理的，我不知道原始服务器。</li>\n</ul>\n<p>3、nginx 如何来实现负载均衡？</p>\n<p>负载均衡的5种策略:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\"><br> 1.轮询（默认）<br> 每个请求按时间顺序逐一分配到不同的后端服务器<br><br> upstream backserver &#123;<br>    server 192.168.0.14;<br>    server 192.168.0.15;<br>&#125;<br><br>2.weight<br>指定轮询几率，weight和访问概率成正比<br><br>upstream backserver &#123;<br>    server 192.168.0.14 weight=3;<br>    server 192.168.0.15 weight=7;<br>&#125;<br><br>3.ip_hash<br>已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的.ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。<br><br>upstream backserver &#123;<br>    ip_hash;<br>    server 192.168.0.14:88;<br>    server 192.168.0.15:80;<br>&#125;<br><br>4.fair<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br><br>upstream backserver &#123;<br>    server server1;<br>    server server2;<br>    fair;<br>&#125;<br><br>5.url_hash<br>按访问url的<span class=\"hljs-built_in\">hash</span>结果来分配请求，使每个url定向到同一个（对应的）后端服务器，后端服务器为缓存时比较有效。<br><br>upstream backserver &#123;<br>    server squid1:3128;<br>    server squid2:3128;<br>    <span class=\"hljs-built_in\">hash</span> <span class=\"hljs-variable\">$request_uri</span>;<br>    hash_method crc32;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h3 id=\"docker\"><a href=\"#docker\" class=\"headerlink\" title=\"docker\"></a>docker</h3><p>1、什么是 Docker？</p>\n<ul>\n<li>Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。</li>\n</ul>\n<p>2、Dockerfile中最常见的指令是什么？</p>\n<ul>\n<li>FROM：指定基础镜像；LABEL：功能是为镜像指定标签；RUN：运行指定的命令；CMD：容器启动时要运行的命令。</li>\n</ul>\n<h3 id=\"k8s\"><a href=\"#k8s\" class=\"headerlink\" title=\"k8s\"></a>k8s</h3><p>1、k8s是什么？请说出你的了解？</p>\n<ul>\n<li>Kubernetes 是一个针对容器应用，进行自动部署，弹性伸缩和管理的开源系统。主要功能是生产环境中的容器编排。</li>\n</ul>\n<p>2、k8s 集群里面最小的单位是什么？</p>\n<ul>\n<li>pod 是最小单位。每个pod里边可以运行一个或多个container（容器）</li>\n</ul>\n<p>3、Service这种资源对象的作用是什么？</p>\n<ul>\n<li>用来给相同的多个pod对象提供一个固定的统一访问接口，常用于服务发现和服务访问。</li>\n</ul>\n<h3 id=\"openstack\"><a href=\"#openstack\" class=\"headerlink\" title=\"openstack\"></a>openstack</h3><p>1、openstack 里 KeyStone 组件是用于提供什么服务的？Nova 组件是做什么用？</p>\n<ul>\n<li>认证服务（KeyStone）<br>Nova – 用于在计算级别管理虚拟机，并在计算或管理程序级别执行其他计算任务。</li>\n</ul>\n<h3 id=\"linux-基本命令\"><a href=\"#linux-基本命令\" class=\"headerlink\" title=\"linux 基本命令\"></a>linux 基本命令</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs sh\">sudo<br>ls<br><span class=\"hljs-built_in\">cd</span><br>mkdir<br>rm<br>apt-get<br>grep<br>cat<br></code></pre></div></td></tr></table></figure>\n","site":{"data":{}},"wordcount":6722,"excerpt":"","more":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><p>1、浏览器地址栏输入 URL 到页面打开的整个解析过程？</p>\n<h2 id=\"JS\"><a href=\"#JS\" class=\"headerlink\" title=\"JS\"></a>JS</h2><p>1、请你讲一下闭包?</p>\n<blockquote>\n<p>简单：闭包是有权限访问其他函数作用域内的变量的一个函数。</p>\n<p>完整：由于在JS中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之回收，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数——也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后作用域内的值也不会被销毁。</p>\n</blockquote>\n<ul>\n<li>闭包解决了什么？</li>\n</ul>\n<blockquote>\n<p>由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。以平时使用的Ajax成功回调为例，这里其实就是个闭包，由于上述的特性，回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。开发者不用去写钩子函数来操作上级函数作用域内部的变量了。</p>\n</blockquote>\n<ul>\n<li>闭包有哪些应用场景?</li>\n</ul>\n<blockquote>\n<p>闭包随处可见，一个Ajax请求的成功回调，一个事件绑定的回调方法，一个setTimeout的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。</p>\n</blockquote>\n<p>2、介绍一下 JS 里面的原型？</p>\n<blockquote>\n<p>每个对象都有一个 prototype 属性，就是原型，是一个对象，叫原型对象。</p>\n</blockquote>\n<ul>\n<li>原型的作用是什么？</li>\n</ul>\n<blockquote>\n<p>共享方法</p>\n</blockquote>\n<ul>\n<li>原型中this的指向是什么？</li>\n</ul>\n<blockquote>\n<p>原型中this的指向是实例。</p>\n</blockquote>\n<ul>\n<li>说一下平时开发使用到 prototype 的例子？</li>\n</ul>\n<p>3、如何理解 es6 class 中 constructor 方法？ 和 super的作用？</p>\n<blockquote>\n<p>constructor 方法是类的构造函数。<br>通过 new 命令创建对象实例时，自动调用该方法。<br>constructor 内定义的方法是 实例方法；class 内直接定义的方法是原型方法。</p>\n<p>super…</p>\n</blockquote>\n<p>4、eventloop</p>\n<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><p>1、介绍一下 Virtual DOM 的工作原理？</p>\n<blockquote>\n<p>Virtual DOM 是一个轻量级的 JavaScript 对象，它最初只是 real DOM 的副本。它是一个节点树，它将元素、它们的属性和内容作为对象及其属性。 React 的渲染函数从 React 组件中创建一个节点树。然后它响应数据模型中的变化来更新该树，该变化是由用户或系统完成的各种动作引起的。</p>\n</blockquote>\n<p>Virtual DOM 工作过程有三步：</p>\n<ol>\n<li>每当底层数据发生改变时，整个 UI 都将在 Virtual DOM 描述中重新渲染。</li>\n<li>然后计算之前 DOM 表示与新表示的之间的差异。</li>\n<li>完成计算后，将只用实际更改的内容更新 real DOM。</li>\n</ol>\n<p>2、react 里什么是高阶组件？使用高阶组件的场景？</p>\n<blockquote>\n<p>高阶组件(HOC)是接受一个组件并返回一个新组件的函数。</p>\n</blockquote>\n<p>3、React Hooks 解决了哪些问题？</p>\n<blockquote>\n<p>在组件之间复用状态逻辑很难;复杂组件变得难以理解</p>\n</blockquote>\n<p>4、说一下 useRef 有哪些用法？</p>\n<blockquote>\n<p>useRef 除了获取 dom，另一个用法：<br>保存数据，不造成 rerender<br>想要保存数据，又不想触发函数的更新，该数据的更新不会造成组件 rerender</p>\n</blockquote>\n<p>5、什么情况下使用 useCallback ？<br>子组件接收一个方法，避免子组件重复渲染</p>\n<ul>\n<li>react 中只要父组件的 render 了，那么默认情况下就会触发子组的 render，react 提供了来避免这种重渲染的性能开销的一些方法：React.PureComponent、React.memo ，shouldComponentUpdate()</li>\n<li>使用 React.memo 避免子组件做没必要的渲染。</li>\n<li>Reace.memo 只会对 props 做浅比较，也就是父组件重新 render 之后会传入 不同引用的方法 getList，浅比较之后不相等，导致子组件还是依然会渲染。</li>\n<li>useCallback 缓存一个函数，当依赖没有改变的时候，会一直返回同一个引用</li>\n</ul>\n<p>6、useCallback 与 useMemo 作用用来缓存，两者的区别是什么？</p>\n<blockquote>\n<p>useMemo 缓存值；useCallback 缓存函数</p>\n</blockquote>\n<p>7、 react 项目里做过哪些性能优化？</p>\n<p>代码层面：</p>\n<ul>\n<li>使用return null而不是CSS的display:none来控制节点的显示隐藏。保证同一时间页面的DOM节点尽可能的少。</li>\n<li>props和state的数据尽可能简单明了，扁平化。</li>\n<li>不要使用数组下标作为key</li>\n<li>利用 shouldComponentUpdate 和 PureComponent 避免过多 render function</li>\n<li>render里面尽量减少新建变量和bind函数，传递参数是尽量减少传递参数的数量。</li>\n<li>尽量将 props 和 state 扁平化，只传递 component 需要的 props（传得太多，或者层次传得太深，都会加重shouldComponentUpdate里面的数据比较负担），慎将 component 当作 props 传入</li>\n</ul>\n<p>代码体积优化:</p>\n<ul>\n<li>使用 babel-plugin-import 优化业务组件的引入，实现按需加载</li>\n<li>使用 生产版本</li>\n<li>使用 SplitChunksPlugin 拆分公共代码</li>\n<li>分析 CSS 和 JS 代码覆盖率</li>\n<li>优化 Webpack 中的库</li>\n<li>使用动态 import，懒加载 React 组件</li>\n<li>使用 webpack-bundle-analyzer 可视化 webpack 输出文件的大小</li>\n<li>使用动态 import，懒加载 React 组件</li>\n<li>使用 Tree Shaking &amp; 教程 &amp; Tree Shaking 优化</li>\n</ul>\n<h2 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h2><p>1、Vue 组件 data 为什么必须是函数？</p>\n<blockquote>\n<p>因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染。<br>所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。</p>\n</blockquote>\n<p>2、直接给一个数组项赋值，Vue 能检测到变化吗？</p>\n<p>由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。</p>\n<blockquote>\n<p>Vue 不能检测到以下数组的变动:</p>\n<p>1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue</p>\n<p>2.当你修改数组的长度时，例如：vm.items.length = newLength</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">vm.$set(vm.items, indexOfItem, newValue)<br><br>vm.items.splice(newLength)<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>检测不到的原因是什么？</li>\n</ul>\n<blockquote>\n<p>当读取 obj.title 和修改 obj.title 的时候被 defineProperty 拦截，但 defineProperty 对不存在的属性无法拦截，所以 Vue 2 中所有数据必须要在 data 里声明。</p>\n<p>但是，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，才能让它是响应的。需要额外的 $set。</p>\n</blockquote>\n<p>3、vue2 中响应式（双向绑定）的原理？vue3 的原理？<br>Proxy 与 Object.defineProperty 的优劣对比?<br>为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？</p>\n<blockquote>\n<p>Proxy的优势如下:<br>Proxy 可以直接监听对象而非属性<br>Proxy 可以直接监听数组的变化<br>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的<br>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改<br>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利</p>\n<p>Object.defineProperty 的优势如下:</p>\n<p>兼容性好,支持 IE9</p>\n</blockquote>\n<p>4、vuex 的工作流程是怎么样？</p>\n<blockquote>\n<p>Vuex有5个重要的属性，分别是 State、Getter、Mutation、Action、Module，由 view 层发起一个 Action 给 Mutation，在 Mutation 中修改状态，返回新的状态，通过 Getter暴露给 view层的组件或者页面，页面监测到状态改变于是更新页面。</p>\n</blockquote>\n<p>5、 Vue3 有哪些新的新特性？</p>\n<ul>\n<li>响应式系统</li>\n<li>自定义渲染器</li>\n<li>全部模块使用 TS 重构</li>\n<li>Composition API 组合语法</li>\n<li>新一代工程化工具 Vite</li>\n</ul>\n<p>6、父组件可以监听到子组件的生命周期吗？</p>\n<p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理。</p>\n<p>方法一：手动通过 $emit 触发父组件的事件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Parent.vue</span><br>&lt;Child @mounted=<span class=\"hljs-string\">&quot;doSomething&quot;</span>/&gt;<br>    <br><span class=\"hljs-comment\">// Child.vue</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">mounted</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>  <span class=\"hljs-built_in\">this</span>.$emit(<span class=\"hljs-string\">&quot;mounted&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>方法二：父组件引用子组件时通过 @hook 来监听</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//  Parent.vue</span><br>&lt;Child @hook:mounted=<span class=\"hljs-string\">&quot;doSomething&quot;</span> &gt;&lt;/Child&gt;<br>    <br><span class=\"hljs-comment\">//  Child.vue</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">mounted</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>   <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;子组件触发 mounted 钩子函数 ...&#x27;</span>);<br>&#125;,       <br></code></pre></td></tr></table></figure>\n<p>@hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p>\n<p>7、比较 Vue 和 React 两个框架，你觉得有哪些区别？</p>\n<ul>\n<li><p>监听数据变化的实现原理不同:</p>\n<p>  Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化.<br>  react 中，数据变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化。</p>\n</li>\n<li><p>数据流的不同:</p>\n</li>\n<li><p>模板渲染方式的不同:</p>\n</li>\n</ul>\n<p>8、什么是异步组件？</p>\n<p>在声明或注册组件时，Vue 接受提供 Promise 的工厂函数。然后可以在调用该组件时对其进行“解析”。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;<br>    <span class=\"hljs-attr\">components</span>: &#123;<br>        ‘tweet-box’: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">import</span>(‘./components/<span class=\"hljs-keyword\">async</span>/TweetBox’)<br>    &#125;<br>&#125;); <br></code></pre></td></tr></table></figure>\n\n<h2 id=\"http\"><a href=\"#http\" class=\"headerlink\" title=\"http\"></a>http</h2><p>1、HTTP有哪些请求方法？PUT 和 PATCH 有什么区别？</p>\n<ul>\n<li>GET, POST 和 HEAD方法；OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT</li>\n<li>PUT和PATCH都是更新资源，而PATCH用来对资源进行局部更新。</li>\n</ul>\n<p>2、http 状态码 403 是什么错误？</p>\n<ul>\n<li>403 forbidden，表示对请求资源的访问被服务器拒绝</li>\n</ul>\n<p>3、知道哪些 http 的缓存策略 ？控制缓存的请求头有哪些？</p>\n<ul>\n<li>HTTP缓存机制分为强制缓存和协商缓存两类。</li>\n<li>强制缓存的意思就是不要问了(不发起请求)，直接用缓存吧。</li>\n<li>强制缓存常见技术有Expires和Cache-Control。</li>\n<li>Expires的值是一个时间，表示这个时间前缓存都有效，都不需要发起请求。</li>\n<li>Cache-Control有很多属性值，常用属性max-age设置了缓存有效的时间长度，单位为秒，这个时间没到，都不用发起请求。</li>\n<li>immutable也是Cache-Control的一个属性，表示这个资源这辈子都不用再请求了，但是他兼容性不好，Cache-Control其他属性可以参考MDN的文档。</li>\n<li>Cache-Control的max-age优先级比Expires高。</li>\n<li>协商缓存是为了知道有没有更新，必须跟服务端沟通过才知道的。常见技术有ETag和Last-Modified。</li>\n<li>ETag其实就是给资源算一个hash值或者版本号，对应的常用request header为If-None-Match。</li>\n<li>Last-Modified其实就是加上资源修改的时间，对应的常用request header为If-Modified-Since，精度为秒。</li>\n<li>ETag每次修改都会改变，而Last-Modified的精度只到秒，所以ETag更准确，优先级更高，但是需要计算，所以服务端开销更大。</li>\n<li>强制缓存和协商缓存都存在的情况下，先判断强制缓存是否生效，如果生效，不用发起请求，直接用缓存。如果强制缓存不生效再发起请求判断协商缓存。</li>\n</ul>\n<blockquote>\n<p>Cache-Control，ETag，Last-Modified</p>\n</blockquote>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>1、有没有读过哪些源码？<br>2、最近开发的项目具体业务是怎么样的？介绍一下？</p>\n<h2 id=\"Devops-相关\"><a href=\"#Devops-相关\" class=\"headerlink\" title=\"Devops 相关\"></a>Devops 相关</h2><h3 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h3><ol>\n<li>谈谈一下对 nginx 的理解，项目中用到 nginx 的哪些功能？</li>\n</ol>\n<ul>\n<li>Nginx ，是一个 Web 服务器和反向代理服务器用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。</li>\n<li>主要功能如下：<br>  正向、反向代理 2、负载均衡、分流 3、虚拟主机（绑定host）</li>\n</ul>\n<p>2、正向代理和反向代理区别是什么？</p>\n<ul>\n<li>正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定原始服务器，然后代理向原始服务器转交请求并将获得的内容返回给客户端。代理服务器和客户端处于同一个局域网内。</li>\n<li>比如说fanqiang。我知道我要访问谷歌，于是我就告诉代理服务器让它帮我转发。</li>\n<li>反向代理实际运行方式是代理服务器接受网络上的连接请求。它将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给网络上请求连接的客户端 。代理服务器和原始服务器处于同一个局域网内。</li>\n<li>比如说我要访问taobao，对我来说不知道图片、json、css 是不是同一个服务器返回回来的，但是我不关心，是反向代理 处理的，我不知道原始服务器。</li>\n</ul>\n<p>3、nginx 如何来实现负载均衡？</p>\n<p>负载均衡的5种策略:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><br> 1.轮询（默认）<br> 每个请求按时间顺序逐一分配到不同的后端服务器<br><br> upstream backserver &#123;<br>    server 192.168.0.14;<br>    server 192.168.0.15;<br>&#125;<br><br>2.weight<br>指定轮询几率，weight和访问概率成正比<br><br>upstream backserver &#123;<br>    server 192.168.0.14 weight=3;<br>    server 192.168.0.15 weight=7;<br>&#125;<br><br>3.ip_hash<br>已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的.ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。<br><br>upstream backserver &#123;<br>    ip_hash;<br>    server 192.168.0.14:88;<br>    server 192.168.0.15:80;<br>&#125;<br><br>4.fair<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br><br>upstream backserver &#123;<br>    server server1;<br>    server server2;<br>    fair;<br>&#125;<br><br>5.url_hash<br>按访问url的<span class=\"hljs-built_in\">hash</span>结果来分配请求，使每个url定向到同一个（对应的）后端服务器，后端服务器为缓存时比较有效。<br><br>upstream backserver &#123;<br>    server squid1:3128;<br>    server squid2:3128;<br>    <span class=\"hljs-built_in\">hash</span> <span class=\"hljs-variable\">$request_uri</span>;<br>    hash_method crc32;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"docker\"><a href=\"#docker\" class=\"headerlink\" title=\"docker\"></a>docker</h3><p>1、什么是 Docker？</p>\n<ul>\n<li>Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。</li>\n</ul>\n<p>2、Dockerfile中最常见的指令是什么？</p>\n<ul>\n<li>FROM：指定基础镜像；LABEL：功能是为镜像指定标签；RUN：运行指定的命令；CMD：容器启动时要运行的命令。</li>\n</ul>\n<h3 id=\"k8s\"><a href=\"#k8s\" class=\"headerlink\" title=\"k8s\"></a>k8s</h3><p>1、k8s是什么？请说出你的了解？</p>\n<ul>\n<li>Kubernetes 是一个针对容器应用，进行自动部署，弹性伸缩和管理的开源系统。主要功能是生产环境中的容器编排。</li>\n</ul>\n<p>2、k8s 集群里面最小的单位是什么？</p>\n<ul>\n<li>pod 是最小单位。每个pod里边可以运行一个或多个container（容器）</li>\n</ul>\n<p>3、Service这种资源对象的作用是什么？</p>\n<ul>\n<li>用来给相同的多个pod对象提供一个固定的统一访问接口，常用于服务发现和服务访问。</li>\n</ul>\n<h3 id=\"openstack\"><a href=\"#openstack\" class=\"headerlink\" title=\"openstack\"></a>openstack</h3><p>1、openstack 里 KeyStone 组件是用于提供什么服务的？Nova 组件是做什么用？</p>\n<ul>\n<li>认证服务（KeyStone）<br>Nova – 用于在计算级别管理虚拟机，并在计算或管理程序级别执行其他计算任务。</li>\n</ul>\n<h3 id=\"linux-基本命令\"><a href=\"#linux-基本命令\" class=\"headerlink\" title=\"linux 基本命令\"></a>linux 基本命令</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">sudo<br>ls<br><span class=\"hljs-built_in\">cd</span><br>mkdir<br>rm<br>apt-get<br>grep<br>cat<br></code></pre></td></tr></table></figure>\n"},{"title":"每日 3+1","index_img":"/img/index-img.png","date":"2022-01-01T00:28:12.000Z","_content":"\n\n\n\n- [为什么说React中的props是只读的？](https://github.com/haizlin/fe-interview/issues/924)\n- [你有使用过formik库吗？说说它的优缺点](https://github.com/haizlin/fe-interview/issues/923)\n- [你有用过哪些React的表单库吗？说说它们的优缺点](https://github.com/haizlin/fe-interview/issues/901)\n- [如果组件的属性没有传值，那么它的默认值是什么？](https://github.com/haizlin/fe-interview/issues/900)\n- [可以使用TypeScript写React应用吗？怎么操作？](https://github.com/haizlin/fe-interview/issues/899)\n- [`super()`和`super(props)`有什么区别？](https://github.com/haizlin/fe-interview/issues/898)\n- [你有使用过loadable组件吗？它帮我们解决了什么问题？](https://github.com/haizlin/fe-interview/issues/897)\n- [你有使用过suspense组件吗？它帮我们解决了什么问题？](https://github.com/haizlin/fe-interview/issues/896)\n- [怎样动态导入组件？](https://github.com/haizlin/fe-interview/issues/895)\n- [如何给非控组件设置默认的值？](https://github.com/haizlin/fe-interview/issues/894)\n- [怎么在React中引入其它的UI库，例如Bootstrap](https://github.com/haizlin/fe-interview/issues/893)\n- [怎样将事件传递给子组件？](https://github.com/haizlin/fe-interview/issues/892)\n- [怎样使用Hooks获取服务端数据？](https://github.com/haizlin/fe-interview/issues/891)\n- [使用Hooks要遵守哪些原则？](https://github.com/haizlin/fe-interview/issues/890)\n- [render方法的原理你有了解吗？它返回的数据类型是什么？](https://github.com/haizlin/fe-interview/issues/889)\n- [useEffect和useLayoutEffect有什么区别？](https://github.com/haizlin/fe-interview/issues/888)\n- [在React项目中你用过哪些动画的包？](https://github.com/haizlin/fe-interview/issues/887)\n- [React必须使用JSX吗？](https://github.com/haizlin/fe-interview/issues/886)\n- [自定义组件时render是可选的吗？为什么？](https://github.com/haizlin/fe-interview/issues/885)\n- [需要把keys设置为全局唯一吗？](https://github.com/haizlin/fe-interview/issues/884)\n- [怎么定时更新一个组件？](https://github.com/haizlin/fe-interview/issues/883)\n- [React根据不同的环境打包不同的域名？](https://github.com/haizlin/fe-interview/issues/882)\n- [使用webpack打包React项目，怎么减小生成的js大小？](https://github.com/haizlin/fe-interview/issues/881)\n- [在React中怎么使用async/await？](https://github.com/haizlin/fe-interview/issues/880)\n- [你阅读了几遍React的源码？都有哪些收获？你是怎么阅读的？](https://github.com/haizlin/fe-interview/issues/879)\n- [什么是React.forwardRef？它有什么作用？](https://github.com/haizlin/fe-interview/issues/878)\n- [写个例子说明什么是JSX的内联条件渲染](https://github.com/haizlin/fe-interview/issues/877)\n- [在React中怎么将参数传递给事件？](https://github.com/haizlin/fe-interview/issues/876)\n- [React的事件和普通的HTML事件有什么不同？](https://github.com/haizlin/fe-interview/issues/875)\n- [在React中怎么阻止事件的默认行为？](https://github.com/haizlin/fe-interview/issues/874)\n- [你最喜欢React的哪一个特性（说一个就好）？](https://github.com/haizlin/fe-interview/issues/873)\n- [在React中什么时候使用箭头函数更方便呢？](https://github.com/haizlin/fe-interview/issues/872)\n- [你最不喜欢React的哪一个特性（说一个就好）？](https://github.com/haizlin/fe-interview/issues/871)\n- [说说你对React的reconciliation（一致化算法）的理解](https://github.com/haizlin/fe-interview/issues/870)\n- [使用PropTypes和Flow有什么区别？](https://github.com/haizlin/fe-interview/issues/869)\n- [怎样有条件地渲染组件？](https://github.com/haizlin/fe-interview/issues/868)\n- [在JSX中如何写注释？](https://github.com/haizlin/fe-interview/issues/867)\n- [constructor和getInitialState有不同？](https://github.com/haizlin/fe-interview/issues/866)\n- [写例子说明React如何在JSX中实现for循环](https://github.com/haizlin/fe-interview/issues/865)\n- [为什么建议Fragment包裹元素？它的简写是什么？](https://github.com/haizlin/fe-interview/issues/864)\n- [你有用过React.Fragment吗？说说它有什么用途？](https://github.com/haizlin/fe-interview/issues/863)\n- [在React中你有遇到过安全问题吗？怎么解决？](https://github.com/haizlin/fe-interview/issues/862)\n- [React中如何监听state的变化？](https://github.com/haizlin/fe-interview/issues/861)\n- [React什么是有状态组件？](https://github.com/haizlin/fe-interview/issues/860)\n- [React v15中怎么处理错误边界？](https://github.com/haizlin/fe-interview/issues/859)\n- [React Fiber它的目的是解决什么问题？](https://github.com/haizlin/fe-interview/issues/858)\n- [React为什么不要直接修改state？如果想修改怎么做？](https://github.com/haizlin/fe-interview/issues/857)\n- [create-react-app有什么好处？](https://github.com/haizlin/fe-interview/issues/856)\n- [装饰器(Decorator)在React中有什么应用？](https://github.com/haizlin/fe-interview/issues/855)\n- [使用高阶组件(HOC)实现一个loading组件](https://github.com/haizlin/fe-interview/issues/854)\n- [如何用React实现滚动动画？](https://github.com/haizlin/fe-interview/issues/853)\n- [说出几点你认为的React最佳实践](https://github.com/haizlin/fe-interview/issues/852)\n- [你是如何划分React组件的？](https://github.com/haizlin/fe-interview/issues/851)\n- [举例说明如何在React创建一个事件](https://github.com/haizlin/fe-interview/issues/850)\n- [如何更新组件的状态？](https://github.com/haizlin/fe-interview/issues/849)\n- [怎样将多个组件嵌入到一个组件中？](https://github.com/haizlin/fe-interview/issues/848)\n- [React的render中可以写{if else}这样的判断吗？](https://github.com/haizlin/fe-interview/issues/847)\n- [React为什么要搞一个Hooks？](https://github.com/haizlin/fe-interview/issues/846)\n- [React Hooks帮我们解决了哪些问题？](https://github.com/haizlin/fe-interview/issues/845)\n- [使用React的memo和forwardRef包装的组件为什么提示children类型不对？](https://github.com/haizlin/fe-interview/issues/844)\n- [有在项目中使用过Antd吗？说说它的好处](https://github.com/haizlin/fe-interview/issues/843)\n- [在React中如果去除生产环境上的sourcemap？](https://github.com/haizlin/fe-interview/issues/842)\n- [在React中怎么引用sass或less？](https://github.com/haizlin/fe-interview/issues/841)\n- [组件卸载前，加在DOM元素的监听事件和定时器要不要手动清除？为什么？](https://github.com/haizlin/fe-interview/issues/840)\n- [为什么标签里的for要写成htmlFor呢？](https://github.com/haizlin/fe-interview/issues/839)\n- [状态管理器解决了什么问题？什么时候用状态管理器？](https://github.com/haizlin/fe-interview/issues/838)\n- [状态管理器它精髓是什么？](https://github.com/haizlin/fe-interview/issues/837)\n- [函数式组件有没有生命周期？为什么？](https://github.com/haizlin/fe-interview/issues/836)\n- [在React中怎么引用第三方插件？比如说jQuery等](https://github.com/haizlin/fe-interview/issues/835)\n- [React的触摸事件有哪几种？](https://github.com/haizlin/fe-interview/issues/834)\n- [路由切换时同一组件无法重新渲染的有什么方法可以解决？](https://github.com/haizlin/fe-interview/issues/833)\n- [React16新特性有哪些？](https://github.com/haizlin/fe-interview/issues/832)\n- [你有用过哪些React的UI库？它们的优缺点分别是什么？](https://github.com/haizlin/fe-interview/issues/831)\n- [`<div onClick={handlerClick}>单击</div>`和`<div onClick={handlerClick(1)}>单击</div>`有什么区别？](https://github.com/haizlin/fe-interview/issues/830)\n- [在React中如何引入图片？哪种方式更好？](https://github.com/haizlin/fe-interview/issues/829)\n- [在React中怎么使用字体图标？](https://github.com/haizlin/fe-interview/issues/828)\n- [React的应用如何打包发布？它的步骤是什么？](https://github.com/haizlin/fe-interview/issues/827)\n- [ES6的语法'...'在React中有哪些应用？](https://github.com/haizlin/fe-interview/issues/826)\n- [如何封装一个React的全局公共组件？](https://github.com/haizlin/fe-interview/issues/825)\n- [在React中组件的props改变时更新组件的有哪些方法？](https://github.com/haizlin/fe-interview/issues/824)\n- [immutable的原理是什么？](https://github.com/haizlin/fe-interview/issues/823)\n- [你对immutable有了解吗？它有什么作用？](https://github.com/haizlin/fe-interview/issues/822)\n- [如何提高组件的渲染效率呢？](https://github.com/haizlin/fe-interview/issues/821)\n- [在React中如何避免不必要的render？](https://github.com/haizlin/fe-interview/issues/820)\n- [render在什么时候会被触发？](https://github.com/haizlin/fe-interview/issues/819)\n- [写出React动态改变class切换组件样式](https://github.com/haizlin/fe-interview/issues/818)\n- [React中怎么操作虚拟DOM的Class属性？](https://github.com/haizlin/fe-interview/issues/817)\n- [为什么属性使用className而不是class呢？](https://github.com/haizlin/fe-interview/issues/816)\n- [请说下react组件更新的机制是什么？](https://github.com/haizlin/fe-interview/issues/815)\n- [怎么在JSX里属性可以被覆盖吗？覆盖的原则是什么？](https://github.com/haizlin/fe-interview/issues/814)\n- [怎么在JSX里使用自定义属性？](https://github.com/haizlin/fe-interview/issues/813)\n- [怎么防止HTML被转义？](https://github.com/haizlin/fe-interview/issues/812)\n- [经常用React，你知道React的核心思想是什么吗？](https://github.com/haizlin/fe-interview/issues/811)\n- [在React中我们怎么做静态类型检测？都有哪些方法可以做到？](https://github.com/haizlin/fe-interview/issues/810)\n- [在React中组件的state和setState有什么区别？](https://github.com/haizlin/fe-interview/issues/809)\n- [React怎样跳过重新渲染？](https://github.com/haizlin/fe-interview/issues/808)\n- [React怎么判断什么时候重新渲染组件呢？](https://github.com/haizlin/fe-interview/issues/807)\n- [什么是React的实例？函数式组件有没有实例？](https://github.com/haizlin/fe-interview/issues/806)\n- [在React中如何判断点击元素属于哪一个组件？](https://github.com/haizlin/fe-interview/issues/805)\n- [在React中组件和元素有什么区别？](https://github.com/haizlin/fe-interview/issues/804)\n- [在React中声明组件时组件名的第一个字母必须是大写吗？为什么？](https://github.com/haizlin/fe-interview/issues/803)\n- [举例说明什么是高阶组件(HOC)的反向继承？](https://github.com/haizlin/fe-interview/issues/802)\n- [有用过React Devtools吗？说说它的优缺点分别是什么？](https://github.com/haizlin/fe-interview/issues/801)\n- [举例说明什么是高阶组件(HOC)的属性代理？](https://github.com/haizlin/fe-interview/issues/800)\n- [React的isMounted有什么作用？](https://github.com/haizlin/fe-interview/issues/799)\n- [React组件命名推荐的方式是哪个？为什么不推荐使用displayName？](https://github.com/haizlin/fe-interview/issues/798)\n- [React的displayName有什么作用？](https://github.com/haizlin/fe-interview/issues/797)\n- [说说你对React的组件命名规范的理解](https://github.com/haizlin/fe-interview/issues/796)\n- [说说你对React的项目结构的理解](https://github.com/haizlin/fe-interview/issues/795)\n- [React16废弃了哪些生命周期？为什么？](https://github.com/haizlin/fe-interview/issues/794)\n- [怎样在React中开启生产模式？](https://github.com/haizlin/fe-interview/issues/793)\n- [React中getInitialState方法的作用是什么？](https://github.com/haizlin/fe-interview/issues/792)\n- [React中你知道creatClass的原理吗？](https://github.com/haizlin/fe-interview/issues/791)\n- [React中验证props的目的是什么？](https://github.com/haizlin/fe-interview/issues/790)\n- [React中你有使用过getDefaultProps吗？它有什么作用？](https://github.com/haizlin/fe-interview/issues/789)\n- [React中你有使用过propType吗？它有什么作用？](https://github.com/haizlin/fe-interview/issues/788)\n- [React中怎么检验props？](https://github.com/haizlin/fe-interview/issues/787)\n- [React.createClass和extends Component的区别有哪些？](https://github.com/haizlin/fe-interview/issues/786)\n- [高阶组件(HOC)有哪些优点和缺点？](https://github.com/haizlin/fe-interview/issues/785)\n- [给组件设置很多属性时不想一个个去设置有什么办法可以解决这问题呢？](https://github.com/haizlin/fe-interview/issues/784)\n- [React16跟之前的版本生命周期有哪些变化？](https://github.com/haizlin/fe-interview/issues/756)\n- [怎样实现React组件的记忆？原理是什么？](https://github.com/haizlin/fe-interview/issues/755)\n- [创建React动画有哪些方式？](https://github.com/haizlin/fe-interview/issues/754)\n- [为什么建议不要过渡使用Refs？](https://github.com/haizlin/fe-interview/issues/753)\n- [在React使用高阶组件(HOC)有遇到过哪些问题？如何解决？](https://github.com/haizlin/fe-interview/issues/752)\n- [在使用React过程中什么时候用高阶组件(HOC)？](https://github.com/haizlin/fe-interview/issues/751)\n- [说说React diff的原理是什么？](https://github.com/haizlin/fe-interview/issues/724)\n- [React怎么提高列表渲染的性能？](https://github.com/haizlin/fe-interview/issues/723)\n- [使用ES6的class定义的组件不支持mixins了，那用什么可以替代呢？](https://github.com/haizlin/fe-interview/issues/722)\n- [为何说虚拟DOM会提高性能？](https://github.com/haizlin/fe-interview/issues/720)\n- [React的性能优化在哪个生命周期？它优化的原理是什么？](https://github.com/haizlin/fe-interview/issues/719)\n- [你知道的React性能优化有哪些方法？](https://github.com/haizlin/fe-interview/issues/718)\n- [举例说明在React中怎么使用样式？](https://github.com/haizlin/fe-interview/issues/717)\n- [React有哪几种方法来处理表单输入？](https://github.com/haizlin/fe-interview/issues/716)\n- [什么是浅层渲染？](https://github.com/haizlin/fe-interview/issues/715)\n- [你有做过React的单元测试吗？如果有，用的是哪些工具？怎么做的？](https://github.com/haizlin/fe-interview/issues/714)\n- [在React中什么是合成事件？有什么用？](https://github.com/haizlin/fe-interview/issues/713)\n- [使用React写一个todo应用，说说你的思路](https://github.com/haizlin/fe-interview/issues/712)\n- [React16的reconciliation和commit分别是什么？](https://github.com/haizlin/fe-interview/issues/711)\n- [React的函数式组件有没有生命周期？](https://github.com/haizlin/fe-interview/issues/710)\n- [useState和this.state的区别是什么？](https://github.com/haizlin/fe-interview/issues/709)\n- [请说说什么是useImperativeHandle？](https://github.com/haizlin/fe-interview/issues/708)\n- [请说说什么是useReducer？](https://github.com/haizlin/fe-interview/issues/707)\n- [请说说什么是useRef？](https://github.com/haizlin/fe-interview/issues/706)\n- [请说说什么是useEffect？](https://github.com/haizlin/fe-interview/issues/705)\n- [举例说明useState](https://github.com/haizlin/fe-interview/issues/704)\n- [请说说什么是useState？为什么要使用useState？](https://github.com/haizlin/fe-interview/issues/703)\n- [请描述下你对React的新特性Hooks的理解？它有哪些应用场景？](https://github.com/haizlin/fe-interview/issues/702)\n- [说说你对Error Boundaries的理解](https://github.com/haizlin/fe-interview/issues/701)\n- [说说你对Fiber架构的理解](https://github.com/haizlin/fe-interview/issues/700)\n- [说说你是怎么理解React的业务组件和技术组件的？](https://github.com/haizlin/fe-interview/issues/699)\n- [为什么建议setState的第一个参数是callback而不是一个对象呢？](https://github.com/haizlin/fe-interview/issues/698)\n- [展示组件和容器组件有什么区别？](https://github.com/haizlin/fe-interview/issues/697)\n- [Mern和Yeoman脚手架有什么区别？](https://github.com/haizlin/fe-interview/issues/696)\n- [你有在项目中使用过Yeoman脚手架吗？](https://github.com/haizlin/fe-interview/issues/695)\n- [你有在项目中使用过Mern脚手架吗？](https://github.com/haizlin/fe-interview/issues/694)\n- [shouldComponentUpdate方法是做什么的？](https://github.com/haizlin/fe-interview/issues/693)\n- [怎样在React中使用innerHTML？](https://github.com/haizlin/fe-interview/issues/692)\n- [你有写过React的中间件插件吗？](https://github.com/haizlin/fe-interview/issues/691)\n- [React的中间件机制是怎么样的？这种机制有什么作用？](https://github.com/haizlin/fe-interview/issues/690)\n- [React中你用过哪些第三方的中间件？](https://github.com/haizlin/fe-interview/issues/689)\n- [不用脚手架，你会手动搭建React项目吗？](https://github.com/haizlin/fe-interview/issues/688)\n- [请说说React中Portal是什么？](https://github.com/haizlin/fe-interview/issues/687)\n- [React中修改prop引发的生命周期有哪几个？](https://github.com/haizlin/fe-interview/issues/686)\n- [React多个setState调用的原理是什么？](https://github.com/haizlin/fe-interview/issues/685)\n- [React中调用setState会更新的生命周期有哪几个？](https://github.com/haizlin/fe-interview/issues/684)\n- [React中setState的第二个参数作用是什么呢？](https://github.com/haizlin/fe-interview/issues/683)\n- [React中的setState是同步还是异步的呢？为什么state并不一定会同步更新？](https://github.com/haizlin/fe-interview/issues/682)\n- [React中的setState批量更新的过程是什么？](https://github.com/haizlin/fe-interview/issues/681)\n- [React中的setState执行机制是什么呢？](https://github.com/haizlin/fe-interview/issues/680)\n- [在React中遍历的方法有哪些？它们有什么区别呢？](https://github.com/haizlin/fe-interview/issues/679)\n- [请说说你对React的render方法的理解](https://github.com/haizlin/fe-interview/issues/678)\n- [props.children.map和js的map有什么区别？为什么优先选择React的？](https://github.com/haizlin/fe-interview/issues/677)\n- [有用过React的严格模式吗？](https://github.com/haizlin/fe-interview/issues/676)\n- [React中的setState和replaceState的区别是什么？](https://github.com/haizlin/fe-interview/issues/675)\n- [React中的setState缺点是什么呢？](https://github.com/haizlin/fe-interview/issues/674)\n- [有用过React的Fragment吗？它的运用场景是什么？](https://github.com/haizlin/fe-interview/issues/673)\n- [React组件间共享数据方法有哪些？](https://github.com/haizlin/fe-interview/issues/672)\n- [React的状态提升是什么？使用场景有哪些？](https://github.com/haizlin/fe-interview/issues/671)\n- [简单描述下你有做过哪些React项目？](https://github.com/haizlin/fe-interview/issues/670)\n- [在构造函数中调用super(props)的目的是什么？](https://github.com/haizlin/fe-interview/issues/669)\n- [你是如何学习React的？](https://github.com/haizlin/fe-interview/issues/668)\n- [从旧版本的React升级到新版本的React有做过吗？有遇到过什么坑？](https://github.com/haizlin/fe-interview/issues/667)\n- [你用过React版本有哪些？](https://github.com/haizlin/fe-interview/issues/666)\n- [有用过React的服务端渲染吗？怎么做的？](https://github.com/haizlin/fe-interview/issues/665)\n- [React的mixins有什么作用？适用于什么场景？](https://github.com/haizlin/fe-interview/issues/664)\n- [React怎么拿到组件对应的DOM元素？](https://github.com/haizlin/fe-interview/issues/663)\n- [请描述下事件在React中的处理方式是什么？](https://github.com/haizlin/fe-interview/issues/662)\n- [JSX和HTML有什么区别？](https://github.com/haizlin/fe-interview/issues/661)\n- [React的书写规范有哪些？](https://github.com/haizlin/fe-interview/issues/660)\n- [create-react-app创建新运用怎么解决卡的问题？](https://github.com/haizlin/fe-interview/issues/659)\n- [使用React的方式有哪几种？](https://github.com/haizlin/fe-interview/issues/658)\n- [说说你对reader的context的理解](https://github.com/haizlin/fe-interview/issues/657)\n- [同时引用这三个库React.js、React-dom.js和babel.js它们都有什么作用？](https://github.com/haizlin/fe-interview/issues/656)\n- [你知道Virtual DOM的工作原理吗？](https://github.com/haizlin/fe-interview/issues/655)\n- [你阅读过React的源码吗？简要说下它的执行流程](https://github.com/haizlin/fe-interview/issues/654)\n- [React中怎样阻止组件渲染？](https://github.com/haizlin/fe-interview/issues/653)\n- [React非兄弟组件如何通信？](https://github.com/haizlin/fe-interview/issues/652)\n- [React兄弟组件如何通信？](https://github.com/haizlin/fe-interview/issues/651)\n- [React非父子组件如何通信？](https://github.com/haizlin/fe-interview/issues/650)\n- [React父子组件如何通信？](https://github.com/haizlin/fe-interview/issues/649)\n- [React组件间的通信有哪些？](https://github.com/haizlin/fe-interview/issues/648)\n- [类组件和函数式组件有什么区别？](https://github.com/haizlin/fe-interview/issues/647)\n- [React自定义组件你写过吗？说说看都写过哪些？](https://github.com/haizlin/fe-interview/issues/646)\n- [React组件的state和props两者有什么区别？](https://github.com/haizlin/fe-interview/issues/645)\n- [React有几种构建组件的方式？可以写出来吗？](https://github.com/haizlin/fe-interview/issues/644)\n- [React中遍历时为什么不用索引作为唯一的key值？](https://github.com/haizlin/fe-interview/issues/643)\n- [React中的key有什么作用？](https://github.com/haizlin/fe-interview/issues/642)\n- [React中除了在构造函数中绑定this,还有别的方式吗？](https://github.com/haizlin/fe-interview/issues/641)\n- [在React中页面重新加载时怎样保留数据？](https://github.com/haizlin/fe-interview/issues/640)\n- [请描述下React的事件机制](https://github.com/haizlin/fe-interview/issues/639)\n- [怎样在React中创建一个事件？](https://github.com/haizlin/fe-interview/issues/638)\n- [在React中无状态组件有什么运用场景？](https://github.com/haizlin/fe-interview/issues/637)\n- [描述下在React中无状态组件和有状态组件的区别是什么？](https://github.com/haizlin/fe-interview/issues/636)\n- [写一个React的高阶组件(HOC)并说明你对它的理解](https://github.com/haizlin/fe-interview/issues/635)\n- [React中可以在render访问refs吗？为什么？](https://github.com/haizlin/fe-interview/issues/634)\n- [React中refs的作用是什么？有哪些应用场景？](https://github.com/haizlin/fe-interview/issues/633)\n- [请描述你对纯函数的理解？](https://github.com/haizlin/fe-interview/issues/632)\n- [受控组件和非受控组件有什么区别？](https://github.com/haizlin/fe-interview/issues/631)\n- [React中什么是非控组件？](https://github.com/haizlin/fe-interview/issues/630)\n- [React中什么是受控组件？](https://github.com/haizlin/fe-interview/issues/629)\n- [React中发起网络请求应该在哪个生命周期中进行？为什么？](https://github.com/haizlin/fe-interview/issues/628)\n- [说说React的生命周期有哪些？](https://github.com/haizlin/fe-interview/issues/627)\n- [说说你对“在React中，一切都是组件”的理解](https://github.com/haizlin/fe-interview/issues/626)\n- [写React你是用es6还是es5的语法？有什么区别？](https://github.com/haizlin/fe-interview/issues/625)\n- [浏览器为什么无法直接JSX？怎么解决呢？](https://github.com/haizlin/fe-interview/issues/624)\n- [在使用React过程中你都踩过哪些坑？你是怎么填坑的？](https://github.com/haizlin/fe-interview/issues/623)\n- [说说你喜欢React的原因是什么？它有什么优缺点？](https://github.com/haizlin/fe-interview/issues/622)\n- [如何解决引用类型在pureComponent下修改值的时候，页面不渲染的问题？](https://github.com/haizlin/fe-interview/issues/621)\n- [createElement与cloneElement两者有什么区别？](https://github.com/haizlin/fe-interview/issues/620)\n- [解释下React中Element 和Component两者的区别是什么？](https://github.com/haizlin/fe-interview/issues/619)\n- [解释下React中component和pureComponent两者的区别是什么？](https://github.com/haizlin/fe-interview/issues/618)\n- [React的虚拟DOM和vue的虚拟DOM有什么区别？](https://github.com/haizlin/fe-interview/issues/617)\n- [你觉得React上手快不快？它有哪些限制？](https://github.com/haizlin/fe-interview/issues/616)\n- [说说你对声明式编程的理解？](https://github.com/haizlin/fe-interview/issues/615)\n- [React与angular、vue有什么区别？](https://github.com/haizlin/fe-interview/issues/614)\n- [React是哪个公司开发的？](https://github.com/haizlin/fe-interview/issues/613)\n- [React是什么？它的主要特点是什么？](https://github.com/haizlin/fe-interview/issues/612)\n- [简要描述下你知道的React工作原理是什么？](https://github.com/haizlin/fe-interview/issues/611)\n- [在React中怎样改变组件状态，以及状态改变的过程是什么？](https://github.com/haizlin/fe-interview/issues/606)\n- [在React中你是怎么进行状态管理的？](https://github.com/haizlin/fe-interview/issues/605)\n- [React声明组件有哪几种方法，各有什么不同？](https://github.com/haizlin/fe-interview/issues/604)\n\n### ReactNative\n- [如何在React Native中设置环境变量？]()\n- [请描述下Code Push的原理是什么？](https://github.com/haizlin/fe-interview/issues/783)\n- [React Native怎样查看日记？](https://github.com/haizlin/fe-interview/issues/782)\n- [React Native怎样测试？](https://github.com/haizlin/fe-interview/issues/781)\n- [React Native怎样调试？](https://github.com/haizlin/fe-interview/issues/780)\n- [React Native和React有什么区别？](https://github.com/haizlin/fe-interview/issues/779)\n- [有做过React Native项目吗？](https://github.com/haizlin/fe-interview/issues/725)\n\n### React-Router\n- [React-Router怎么获取历史对象？](https://github.com/haizlin/fe-interview/issues/922)\n- [React-Router怎么获取URL的参数？](https://github.com/haizlin/fe-interview/issues/921)\n- [在history模式中push和replace有什么区别？](https://github.com/haizlin/fe-interview/issues/778)\n- [React-Router怎么设置重定向？](https://github.com/haizlin/fe-interview/issues/777)\n- [React-Router 4中`<Router>`组件有几种类型？](https://github.com/haizlin/fe-interview/issues/776)\n- [React-Router 3和React-Router 4有什么变化？添加了什么好的特性？](https://github.com/haizlin/fe-interview/issues/775)\n- [React-Router的实现原理是什么？](https://github.com/haizlin/fe-interview/issues/774)\n- [React-Router 4的switch有什么用？](https://github.com/haizlin/fe-interview/issues/773)\n- [React-Router的路由有几种模式？](https://github.com/haizlin/fe-interview/issues/772)\n- [React-Router 4怎样在路由变化时重新渲染同一个组件？](https://github.com/haizlin/fe-interview/issues/771)\n- [React-Router的`<Link>`标签和`<a>`标签有什么区别？](https://github.com/haizlin/fe-interview/issues/770)\n- [React的路由和普通路由有什么区别？](https://github.com/haizlin/fe-interview/issues/728)\n- [请你说说React的路由的优缺点？](https://github.com/haizlin/fe-interview/issues/727)\n- [请你说说React的路由是什么？](https://github.com/haizlin/fe-interview/issues/726)\n\n### Redux/Mobx\n- [你有了解Rxjs是什么吗？它是做什么的？](https://github.com/haizlin/fe-interview/issues/920)\n- [在Redux中怎么发起网络请求？](https://github.com/haizlin/fe-interview/issues/919)\n- [Redux怎样重置状态？](https://github.com/haizlin/fe-interview/issues/918)\n- [Redux怎样设置初始状态？](https://github.com/haizlin/fe-interview/issues/917)\n- [Context api可以取代Redux吗？为什么？](https://github.com/haizlin/fe-interview/issues/916)\n- [推荐在reducer中触发Action吗？为什么？](https://github.com/haizlin/fe-interview/issues/915)\n- [Redux怎么添加新的中间件？](https://github.com/haizlin/fe-interview/issues/914)\n- [redux-saga和redux-thunk有什么本质的区别？](https://github.com/haizlin/fe-interview/issues/913)\n- [在React中你是怎么对异步方案进行选型的？](https://github.com/haizlin/fe-interview/issues/912)\n- [你知道redux-saga的原理吗？](https://github.com/haizlin/fe-interview/issues/911)\n- [你有使用过redux-saga中间件吗？它是干什么的？](https://github.com/haizlin/fe-interview/issues/910)\n- [Redux中异步action和同步action最大的区别是什么？](https://github.com/haizlin/fe-interview/issues/769)\n- [Redux和vuex有什么区别？](https://github.com/haizlin/fe-interview/issues/768)\n- [Redux的中间件是什么？你有用过哪些Redux的中间件？](https://github.com/haizlin/fe-interview/issues/767)\n- [说说Redux的实现流程](https://github.com/haizlin/fe-interview/issues/766)\n- [Mobx的设计思想是什么？](https://github.com/haizlin/fe-interview/issues/765)\n- [Redux由哪些组件构成？](https://github.com/haizlin/fe-interview/issues/764)\n- [Mobx和Redux有什么区别？](https://github.com/haizlin/fe-interview/issues/763)\n- [在React项目中你是如何选择Redux和Mobx的？说说你的理解](https://github.com/haizlin/fe-interview/issues/762)\n- [你有在React中使用过Mobx吗？它的运用场景有哪些？](https://github.com/haizlin/fe-interview/issues/761)\n- [Redux的thunk作用是什么？](https://github.com/haizlin/fe-interview/issues/740)\n- [Redux的数据存储和本地储存有什么区别？](https://github.com/haizlin/fe-interview/issues/739)\n- [在Redux中，什么是reducer？它有什么作用？](https://github.com/haizlin/fe-interview/issues/738)\n- [举例说明怎么在Redux中定义action？](https://github.com/haizlin/fe-interview/issues/737)\n- [在Redux中，什么是action？](https://github.com/haizlin/fe-interview/issues/736)\n- [在Redux中，什么是store？](https://github.com/haizlin/fe-interview/issues/735)\n- [为什么Redux能做到局部渲染呢？](https://github.com/haizlin/fe-interview/issues/734)\n- [说说Redux的优缺点分别是什么？](https://github.com/haizlin/fe-interview/issues/733)\n- [Redux和Flux的区别是什么？](https://github.com/haizlin/fe-interview/issues/732)\n- [Redux它的三个原则是什么？](https://github.com/haizlin/fe-interview/issues/731)\n- [什么是单一数据源？](https://github.com/haizlin/fe-interview/issues/730)\n- [什么是Redux？说说你对Redux的理解？有哪些运用场景？](https://github.com/haizlin/fe-interview/issues/729)\n\n### Flux\n- [请说说点击按钮触发到状态更改，数据的流向？](https://github.com/haizlin/fe-interview/issues/742)\n- [请描述下Flux的思想](https://github.com/haizlin/fe-interview/issues/742)\n- [什么是Flux？说说你对Flux的理解？有哪些运用场景？](https://github.com/haizlin/fe-interview/issues/741)\n\n## Reference\n\n- <https://github.com/qiu-deqing/FE-interview>\n- <https://github.com/haizlin/fe-interview>\n","source":"_drafts/2022-01-01-1.md","raw":"---\ntitle: 每日 3+1\nindex_img: /img/index-img.png\ndate: 2022-01-01 08:28:12\ntags:\ncategories:\n---\n\n\n\n\n- [为什么说React中的props是只读的？](https://github.com/haizlin/fe-interview/issues/924)\n- [你有使用过formik库吗？说说它的优缺点](https://github.com/haizlin/fe-interview/issues/923)\n- [你有用过哪些React的表单库吗？说说它们的优缺点](https://github.com/haizlin/fe-interview/issues/901)\n- [如果组件的属性没有传值，那么它的默认值是什么？](https://github.com/haizlin/fe-interview/issues/900)\n- [可以使用TypeScript写React应用吗？怎么操作？](https://github.com/haizlin/fe-interview/issues/899)\n- [`super()`和`super(props)`有什么区别？](https://github.com/haizlin/fe-interview/issues/898)\n- [你有使用过loadable组件吗？它帮我们解决了什么问题？](https://github.com/haizlin/fe-interview/issues/897)\n- [你有使用过suspense组件吗？它帮我们解决了什么问题？](https://github.com/haizlin/fe-interview/issues/896)\n- [怎样动态导入组件？](https://github.com/haizlin/fe-interview/issues/895)\n- [如何给非控组件设置默认的值？](https://github.com/haizlin/fe-interview/issues/894)\n- [怎么在React中引入其它的UI库，例如Bootstrap](https://github.com/haizlin/fe-interview/issues/893)\n- [怎样将事件传递给子组件？](https://github.com/haizlin/fe-interview/issues/892)\n- [怎样使用Hooks获取服务端数据？](https://github.com/haizlin/fe-interview/issues/891)\n- [使用Hooks要遵守哪些原则？](https://github.com/haizlin/fe-interview/issues/890)\n- [render方法的原理你有了解吗？它返回的数据类型是什么？](https://github.com/haizlin/fe-interview/issues/889)\n- [useEffect和useLayoutEffect有什么区别？](https://github.com/haizlin/fe-interview/issues/888)\n- [在React项目中你用过哪些动画的包？](https://github.com/haizlin/fe-interview/issues/887)\n- [React必须使用JSX吗？](https://github.com/haizlin/fe-interview/issues/886)\n- [自定义组件时render是可选的吗？为什么？](https://github.com/haizlin/fe-interview/issues/885)\n- [需要把keys设置为全局唯一吗？](https://github.com/haizlin/fe-interview/issues/884)\n- [怎么定时更新一个组件？](https://github.com/haizlin/fe-interview/issues/883)\n- [React根据不同的环境打包不同的域名？](https://github.com/haizlin/fe-interview/issues/882)\n- [使用webpack打包React项目，怎么减小生成的js大小？](https://github.com/haizlin/fe-interview/issues/881)\n- [在React中怎么使用async/await？](https://github.com/haizlin/fe-interview/issues/880)\n- [你阅读了几遍React的源码？都有哪些收获？你是怎么阅读的？](https://github.com/haizlin/fe-interview/issues/879)\n- [什么是React.forwardRef？它有什么作用？](https://github.com/haizlin/fe-interview/issues/878)\n- [写个例子说明什么是JSX的内联条件渲染](https://github.com/haizlin/fe-interview/issues/877)\n- [在React中怎么将参数传递给事件？](https://github.com/haizlin/fe-interview/issues/876)\n- [React的事件和普通的HTML事件有什么不同？](https://github.com/haizlin/fe-interview/issues/875)\n- [在React中怎么阻止事件的默认行为？](https://github.com/haizlin/fe-interview/issues/874)\n- [你最喜欢React的哪一个特性（说一个就好）？](https://github.com/haizlin/fe-interview/issues/873)\n- [在React中什么时候使用箭头函数更方便呢？](https://github.com/haizlin/fe-interview/issues/872)\n- [你最不喜欢React的哪一个特性（说一个就好）？](https://github.com/haizlin/fe-interview/issues/871)\n- [说说你对React的reconciliation（一致化算法）的理解](https://github.com/haizlin/fe-interview/issues/870)\n- [使用PropTypes和Flow有什么区别？](https://github.com/haizlin/fe-interview/issues/869)\n- [怎样有条件地渲染组件？](https://github.com/haizlin/fe-interview/issues/868)\n- [在JSX中如何写注释？](https://github.com/haizlin/fe-interview/issues/867)\n- [constructor和getInitialState有不同？](https://github.com/haizlin/fe-interview/issues/866)\n- [写例子说明React如何在JSX中实现for循环](https://github.com/haizlin/fe-interview/issues/865)\n- [为什么建议Fragment包裹元素？它的简写是什么？](https://github.com/haizlin/fe-interview/issues/864)\n- [你有用过React.Fragment吗？说说它有什么用途？](https://github.com/haizlin/fe-interview/issues/863)\n- [在React中你有遇到过安全问题吗？怎么解决？](https://github.com/haizlin/fe-interview/issues/862)\n- [React中如何监听state的变化？](https://github.com/haizlin/fe-interview/issues/861)\n- [React什么是有状态组件？](https://github.com/haizlin/fe-interview/issues/860)\n- [React v15中怎么处理错误边界？](https://github.com/haizlin/fe-interview/issues/859)\n- [React Fiber它的目的是解决什么问题？](https://github.com/haizlin/fe-interview/issues/858)\n- [React为什么不要直接修改state？如果想修改怎么做？](https://github.com/haizlin/fe-interview/issues/857)\n- [create-react-app有什么好处？](https://github.com/haizlin/fe-interview/issues/856)\n- [装饰器(Decorator)在React中有什么应用？](https://github.com/haizlin/fe-interview/issues/855)\n- [使用高阶组件(HOC)实现一个loading组件](https://github.com/haizlin/fe-interview/issues/854)\n- [如何用React实现滚动动画？](https://github.com/haizlin/fe-interview/issues/853)\n- [说出几点你认为的React最佳实践](https://github.com/haizlin/fe-interview/issues/852)\n- [你是如何划分React组件的？](https://github.com/haizlin/fe-interview/issues/851)\n- [举例说明如何在React创建一个事件](https://github.com/haizlin/fe-interview/issues/850)\n- [如何更新组件的状态？](https://github.com/haizlin/fe-interview/issues/849)\n- [怎样将多个组件嵌入到一个组件中？](https://github.com/haizlin/fe-interview/issues/848)\n- [React的render中可以写{if else}这样的判断吗？](https://github.com/haizlin/fe-interview/issues/847)\n- [React为什么要搞一个Hooks？](https://github.com/haizlin/fe-interview/issues/846)\n- [React Hooks帮我们解决了哪些问题？](https://github.com/haizlin/fe-interview/issues/845)\n- [使用React的memo和forwardRef包装的组件为什么提示children类型不对？](https://github.com/haizlin/fe-interview/issues/844)\n- [有在项目中使用过Antd吗？说说它的好处](https://github.com/haizlin/fe-interview/issues/843)\n- [在React中如果去除生产环境上的sourcemap？](https://github.com/haizlin/fe-interview/issues/842)\n- [在React中怎么引用sass或less？](https://github.com/haizlin/fe-interview/issues/841)\n- [组件卸载前，加在DOM元素的监听事件和定时器要不要手动清除？为什么？](https://github.com/haizlin/fe-interview/issues/840)\n- [为什么标签里的for要写成htmlFor呢？](https://github.com/haizlin/fe-interview/issues/839)\n- [状态管理器解决了什么问题？什么时候用状态管理器？](https://github.com/haizlin/fe-interview/issues/838)\n- [状态管理器它精髓是什么？](https://github.com/haizlin/fe-interview/issues/837)\n- [函数式组件有没有生命周期？为什么？](https://github.com/haizlin/fe-interview/issues/836)\n- [在React中怎么引用第三方插件？比如说jQuery等](https://github.com/haizlin/fe-interview/issues/835)\n- [React的触摸事件有哪几种？](https://github.com/haizlin/fe-interview/issues/834)\n- [路由切换时同一组件无法重新渲染的有什么方法可以解决？](https://github.com/haizlin/fe-interview/issues/833)\n- [React16新特性有哪些？](https://github.com/haizlin/fe-interview/issues/832)\n- [你有用过哪些React的UI库？它们的优缺点分别是什么？](https://github.com/haizlin/fe-interview/issues/831)\n- [`<div onClick={handlerClick}>单击</div>`和`<div onClick={handlerClick(1)}>单击</div>`有什么区别？](https://github.com/haizlin/fe-interview/issues/830)\n- [在React中如何引入图片？哪种方式更好？](https://github.com/haizlin/fe-interview/issues/829)\n- [在React中怎么使用字体图标？](https://github.com/haizlin/fe-interview/issues/828)\n- [React的应用如何打包发布？它的步骤是什么？](https://github.com/haizlin/fe-interview/issues/827)\n- [ES6的语法'...'在React中有哪些应用？](https://github.com/haizlin/fe-interview/issues/826)\n- [如何封装一个React的全局公共组件？](https://github.com/haizlin/fe-interview/issues/825)\n- [在React中组件的props改变时更新组件的有哪些方法？](https://github.com/haizlin/fe-interview/issues/824)\n- [immutable的原理是什么？](https://github.com/haizlin/fe-interview/issues/823)\n- [你对immutable有了解吗？它有什么作用？](https://github.com/haizlin/fe-interview/issues/822)\n- [如何提高组件的渲染效率呢？](https://github.com/haizlin/fe-interview/issues/821)\n- [在React中如何避免不必要的render？](https://github.com/haizlin/fe-interview/issues/820)\n- [render在什么时候会被触发？](https://github.com/haizlin/fe-interview/issues/819)\n- [写出React动态改变class切换组件样式](https://github.com/haizlin/fe-interview/issues/818)\n- [React中怎么操作虚拟DOM的Class属性？](https://github.com/haizlin/fe-interview/issues/817)\n- [为什么属性使用className而不是class呢？](https://github.com/haizlin/fe-interview/issues/816)\n- [请说下react组件更新的机制是什么？](https://github.com/haizlin/fe-interview/issues/815)\n- [怎么在JSX里属性可以被覆盖吗？覆盖的原则是什么？](https://github.com/haizlin/fe-interview/issues/814)\n- [怎么在JSX里使用自定义属性？](https://github.com/haizlin/fe-interview/issues/813)\n- [怎么防止HTML被转义？](https://github.com/haizlin/fe-interview/issues/812)\n- [经常用React，你知道React的核心思想是什么吗？](https://github.com/haizlin/fe-interview/issues/811)\n- [在React中我们怎么做静态类型检测？都有哪些方法可以做到？](https://github.com/haizlin/fe-interview/issues/810)\n- [在React中组件的state和setState有什么区别？](https://github.com/haizlin/fe-interview/issues/809)\n- [React怎样跳过重新渲染？](https://github.com/haizlin/fe-interview/issues/808)\n- [React怎么判断什么时候重新渲染组件呢？](https://github.com/haizlin/fe-interview/issues/807)\n- [什么是React的实例？函数式组件有没有实例？](https://github.com/haizlin/fe-interview/issues/806)\n- [在React中如何判断点击元素属于哪一个组件？](https://github.com/haizlin/fe-interview/issues/805)\n- [在React中组件和元素有什么区别？](https://github.com/haizlin/fe-interview/issues/804)\n- [在React中声明组件时组件名的第一个字母必须是大写吗？为什么？](https://github.com/haizlin/fe-interview/issues/803)\n- [举例说明什么是高阶组件(HOC)的反向继承？](https://github.com/haizlin/fe-interview/issues/802)\n- [有用过React Devtools吗？说说它的优缺点分别是什么？](https://github.com/haizlin/fe-interview/issues/801)\n- [举例说明什么是高阶组件(HOC)的属性代理？](https://github.com/haizlin/fe-interview/issues/800)\n- [React的isMounted有什么作用？](https://github.com/haizlin/fe-interview/issues/799)\n- [React组件命名推荐的方式是哪个？为什么不推荐使用displayName？](https://github.com/haizlin/fe-interview/issues/798)\n- [React的displayName有什么作用？](https://github.com/haizlin/fe-interview/issues/797)\n- [说说你对React的组件命名规范的理解](https://github.com/haizlin/fe-interview/issues/796)\n- [说说你对React的项目结构的理解](https://github.com/haizlin/fe-interview/issues/795)\n- [React16废弃了哪些生命周期？为什么？](https://github.com/haizlin/fe-interview/issues/794)\n- [怎样在React中开启生产模式？](https://github.com/haizlin/fe-interview/issues/793)\n- [React中getInitialState方法的作用是什么？](https://github.com/haizlin/fe-interview/issues/792)\n- [React中你知道creatClass的原理吗？](https://github.com/haizlin/fe-interview/issues/791)\n- [React中验证props的目的是什么？](https://github.com/haizlin/fe-interview/issues/790)\n- [React中你有使用过getDefaultProps吗？它有什么作用？](https://github.com/haizlin/fe-interview/issues/789)\n- [React中你有使用过propType吗？它有什么作用？](https://github.com/haizlin/fe-interview/issues/788)\n- [React中怎么检验props？](https://github.com/haizlin/fe-interview/issues/787)\n- [React.createClass和extends Component的区别有哪些？](https://github.com/haizlin/fe-interview/issues/786)\n- [高阶组件(HOC)有哪些优点和缺点？](https://github.com/haizlin/fe-interview/issues/785)\n- [给组件设置很多属性时不想一个个去设置有什么办法可以解决这问题呢？](https://github.com/haizlin/fe-interview/issues/784)\n- [React16跟之前的版本生命周期有哪些变化？](https://github.com/haizlin/fe-interview/issues/756)\n- [怎样实现React组件的记忆？原理是什么？](https://github.com/haizlin/fe-interview/issues/755)\n- [创建React动画有哪些方式？](https://github.com/haizlin/fe-interview/issues/754)\n- [为什么建议不要过渡使用Refs？](https://github.com/haizlin/fe-interview/issues/753)\n- [在React使用高阶组件(HOC)有遇到过哪些问题？如何解决？](https://github.com/haizlin/fe-interview/issues/752)\n- [在使用React过程中什么时候用高阶组件(HOC)？](https://github.com/haizlin/fe-interview/issues/751)\n- [说说React diff的原理是什么？](https://github.com/haizlin/fe-interview/issues/724)\n- [React怎么提高列表渲染的性能？](https://github.com/haizlin/fe-interview/issues/723)\n- [使用ES6的class定义的组件不支持mixins了，那用什么可以替代呢？](https://github.com/haizlin/fe-interview/issues/722)\n- [为何说虚拟DOM会提高性能？](https://github.com/haizlin/fe-interview/issues/720)\n- [React的性能优化在哪个生命周期？它优化的原理是什么？](https://github.com/haizlin/fe-interview/issues/719)\n- [你知道的React性能优化有哪些方法？](https://github.com/haizlin/fe-interview/issues/718)\n- [举例说明在React中怎么使用样式？](https://github.com/haizlin/fe-interview/issues/717)\n- [React有哪几种方法来处理表单输入？](https://github.com/haizlin/fe-interview/issues/716)\n- [什么是浅层渲染？](https://github.com/haizlin/fe-interview/issues/715)\n- [你有做过React的单元测试吗？如果有，用的是哪些工具？怎么做的？](https://github.com/haizlin/fe-interview/issues/714)\n- [在React中什么是合成事件？有什么用？](https://github.com/haizlin/fe-interview/issues/713)\n- [使用React写一个todo应用，说说你的思路](https://github.com/haizlin/fe-interview/issues/712)\n- [React16的reconciliation和commit分别是什么？](https://github.com/haizlin/fe-interview/issues/711)\n- [React的函数式组件有没有生命周期？](https://github.com/haizlin/fe-interview/issues/710)\n- [useState和this.state的区别是什么？](https://github.com/haizlin/fe-interview/issues/709)\n- [请说说什么是useImperativeHandle？](https://github.com/haizlin/fe-interview/issues/708)\n- [请说说什么是useReducer？](https://github.com/haizlin/fe-interview/issues/707)\n- [请说说什么是useRef？](https://github.com/haizlin/fe-interview/issues/706)\n- [请说说什么是useEffect？](https://github.com/haizlin/fe-interview/issues/705)\n- [举例说明useState](https://github.com/haizlin/fe-interview/issues/704)\n- [请说说什么是useState？为什么要使用useState？](https://github.com/haizlin/fe-interview/issues/703)\n- [请描述下你对React的新特性Hooks的理解？它有哪些应用场景？](https://github.com/haizlin/fe-interview/issues/702)\n- [说说你对Error Boundaries的理解](https://github.com/haizlin/fe-interview/issues/701)\n- [说说你对Fiber架构的理解](https://github.com/haizlin/fe-interview/issues/700)\n- [说说你是怎么理解React的业务组件和技术组件的？](https://github.com/haizlin/fe-interview/issues/699)\n- [为什么建议setState的第一个参数是callback而不是一个对象呢？](https://github.com/haizlin/fe-interview/issues/698)\n- [展示组件和容器组件有什么区别？](https://github.com/haizlin/fe-interview/issues/697)\n- [Mern和Yeoman脚手架有什么区别？](https://github.com/haizlin/fe-interview/issues/696)\n- [你有在项目中使用过Yeoman脚手架吗？](https://github.com/haizlin/fe-interview/issues/695)\n- [你有在项目中使用过Mern脚手架吗？](https://github.com/haizlin/fe-interview/issues/694)\n- [shouldComponentUpdate方法是做什么的？](https://github.com/haizlin/fe-interview/issues/693)\n- [怎样在React中使用innerHTML？](https://github.com/haizlin/fe-interview/issues/692)\n- [你有写过React的中间件插件吗？](https://github.com/haizlin/fe-interview/issues/691)\n- [React的中间件机制是怎么样的？这种机制有什么作用？](https://github.com/haizlin/fe-interview/issues/690)\n- [React中你用过哪些第三方的中间件？](https://github.com/haizlin/fe-interview/issues/689)\n- [不用脚手架，你会手动搭建React项目吗？](https://github.com/haizlin/fe-interview/issues/688)\n- [请说说React中Portal是什么？](https://github.com/haizlin/fe-interview/issues/687)\n- [React中修改prop引发的生命周期有哪几个？](https://github.com/haizlin/fe-interview/issues/686)\n- [React多个setState调用的原理是什么？](https://github.com/haizlin/fe-interview/issues/685)\n- [React中调用setState会更新的生命周期有哪几个？](https://github.com/haizlin/fe-interview/issues/684)\n- [React中setState的第二个参数作用是什么呢？](https://github.com/haizlin/fe-interview/issues/683)\n- [React中的setState是同步还是异步的呢？为什么state并不一定会同步更新？](https://github.com/haizlin/fe-interview/issues/682)\n- [React中的setState批量更新的过程是什么？](https://github.com/haizlin/fe-interview/issues/681)\n- [React中的setState执行机制是什么呢？](https://github.com/haizlin/fe-interview/issues/680)\n- [在React中遍历的方法有哪些？它们有什么区别呢？](https://github.com/haizlin/fe-interview/issues/679)\n- [请说说你对React的render方法的理解](https://github.com/haizlin/fe-interview/issues/678)\n- [props.children.map和js的map有什么区别？为什么优先选择React的？](https://github.com/haizlin/fe-interview/issues/677)\n- [有用过React的严格模式吗？](https://github.com/haizlin/fe-interview/issues/676)\n- [React中的setState和replaceState的区别是什么？](https://github.com/haizlin/fe-interview/issues/675)\n- [React中的setState缺点是什么呢？](https://github.com/haizlin/fe-interview/issues/674)\n- [有用过React的Fragment吗？它的运用场景是什么？](https://github.com/haizlin/fe-interview/issues/673)\n- [React组件间共享数据方法有哪些？](https://github.com/haizlin/fe-interview/issues/672)\n- [React的状态提升是什么？使用场景有哪些？](https://github.com/haizlin/fe-interview/issues/671)\n- [简单描述下你有做过哪些React项目？](https://github.com/haizlin/fe-interview/issues/670)\n- [在构造函数中调用super(props)的目的是什么？](https://github.com/haizlin/fe-interview/issues/669)\n- [你是如何学习React的？](https://github.com/haizlin/fe-interview/issues/668)\n- [从旧版本的React升级到新版本的React有做过吗？有遇到过什么坑？](https://github.com/haizlin/fe-interview/issues/667)\n- [你用过React版本有哪些？](https://github.com/haizlin/fe-interview/issues/666)\n- [有用过React的服务端渲染吗？怎么做的？](https://github.com/haizlin/fe-interview/issues/665)\n- [React的mixins有什么作用？适用于什么场景？](https://github.com/haizlin/fe-interview/issues/664)\n- [React怎么拿到组件对应的DOM元素？](https://github.com/haizlin/fe-interview/issues/663)\n- [请描述下事件在React中的处理方式是什么？](https://github.com/haizlin/fe-interview/issues/662)\n- [JSX和HTML有什么区别？](https://github.com/haizlin/fe-interview/issues/661)\n- [React的书写规范有哪些？](https://github.com/haizlin/fe-interview/issues/660)\n- [create-react-app创建新运用怎么解决卡的问题？](https://github.com/haizlin/fe-interview/issues/659)\n- [使用React的方式有哪几种？](https://github.com/haizlin/fe-interview/issues/658)\n- [说说你对reader的context的理解](https://github.com/haizlin/fe-interview/issues/657)\n- [同时引用这三个库React.js、React-dom.js和babel.js它们都有什么作用？](https://github.com/haizlin/fe-interview/issues/656)\n- [你知道Virtual DOM的工作原理吗？](https://github.com/haizlin/fe-interview/issues/655)\n- [你阅读过React的源码吗？简要说下它的执行流程](https://github.com/haizlin/fe-interview/issues/654)\n- [React中怎样阻止组件渲染？](https://github.com/haizlin/fe-interview/issues/653)\n- [React非兄弟组件如何通信？](https://github.com/haizlin/fe-interview/issues/652)\n- [React兄弟组件如何通信？](https://github.com/haizlin/fe-interview/issues/651)\n- [React非父子组件如何通信？](https://github.com/haizlin/fe-interview/issues/650)\n- [React父子组件如何通信？](https://github.com/haizlin/fe-interview/issues/649)\n- [React组件间的通信有哪些？](https://github.com/haizlin/fe-interview/issues/648)\n- [类组件和函数式组件有什么区别？](https://github.com/haizlin/fe-interview/issues/647)\n- [React自定义组件你写过吗？说说看都写过哪些？](https://github.com/haizlin/fe-interview/issues/646)\n- [React组件的state和props两者有什么区别？](https://github.com/haizlin/fe-interview/issues/645)\n- [React有几种构建组件的方式？可以写出来吗？](https://github.com/haizlin/fe-interview/issues/644)\n- [React中遍历时为什么不用索引作为唯一的key值？](https://github.com/haizlin/fe-interview/issues/643)\n- [React中的key有什么作用？](https://github.com/haizlin/fe-interview/issues/642)\n- [React中除了在构造函数中绑定this,还有别的方式吗？](https://github.com/haizlin/fe-interview/issues/641)\n- [在React中页面重新加载时怎样保留数据？](https://github.com/haizlin/fe-interview/issues/640)\n- [请描述下React的事件机制](https://github.com/haizlin/fe-interview/issues/639)\n- [怎样在React中创建一个事件？](https://github.com/haizlin/fe-interview/issues/638)\n- [在React中无状态组件有什么运用场景？](https://github.com/haizlin/fe-interview/issues/637)\n- [描述下在React中无状态组件和有状态组件的区别是什么？](https://github.com/haizlin/fe-interview/issues/636)\n- [写一个React的高阶组件(HOC)并说明你对它的理解](https://github.com/haizlin/fe-interview/issues/635)\n- [React中可以在render访问refs吗？为什么？](https://github.com/haizlin/fe-interview/issues/634)\n- [React中refs的作用是什么？有哪些应用场景？](https://github.com/haizlin/fe-interview/issues/633)\n- [请描述你对纯函数的理解？](https://github.com/haizlin/fe-interview/issues/632)\n- [受控组件和非受控组件有什么区别？](https://github.com/haizlin/fe-interview/issues/631)\n- [React中什么是非控组件？](https://github.com/haizlin/fe-interview/issues/630)\n- [React中什么是受控组件？](https://github.com/haizlin/fe-interview/issues/629)\n- [React中发起网络请求应该在哪个生命周期中进行？为什么？](https://github.com/haizlin/fe-interview/issues/628)\n- [说说React的生命周期有哪些？](https://github.com/haizlin/fe-interview/issues/627)\n- [说说你对“在React中，一切都是组件”的理解](https://github.com/haizlin/fe-interview/issues/626)\n- [写React你是用es6还是es5的语法？有什么区别？](https://github.com/haizlin/fe-interview/issues/625)\n- [浏览器为什么无法直接JSX？怎么解决呢？](https://github.com/haizlin/fe-interview/issues/624)\n- [在使用React过程中你都踩过哪些坑？你是怎么填坑的？](https://github.com/haizlin/fe-interview/issues/623)\n- [说说你喜欢React的原因是什么？它有什么优缺点？](https://github.com/haizlin/fe-interview/issues/622)\n- [如何解决引用类型在pureComponent下修改值的时候，页面不渲染的问题？](https://github.com/haizlin/fe-interview/issues/621)\n- [createElement与cloneElement两者有什么区别？](https://github.com/haizlin/fe-interview/issues/620)\n- [解释下React中Element 和Component两者的区别是什么？](https://github.com/haizlin/fe-interview/issues/619)\n- [解释下React中component和pureComponent两者的区别是什么？](https://github.com/haizlin/fe-interview/issues/618)\n- [React的虚拟DOM和vue的虚拟DOM有什么区别？](https://github.com/haizlin/fe-interview/issues/617)\n- [你觉得React上手快不快？它有哪些限制？](https://github.com/haizlin/fe-interview/issues/616)\n- [说说你对声明式编程的理解？](https://github.com/haizlin/fe-interview/issues/615)\n- [React与angular、vue有什么区别？](https://github.com/haizlin/fe-interview/issues/614)\n- [React是哪个公司开发的？](https://github.com/haizlin/fe-interview/issues/613)\n- [React是什么？它的主要特点是什么？](https://github.com/haizlin/fe-interview/issues/612)\n- [简要描述下你知道的React工作原理是什么？](https://github.com/haizlin/fe-interview/issues/611)\n- [在React中怎样改变组件状态，以及状态改变的过程是什么？](https://github.com/haizlin/fe-interview/issues/606)\n- [在React中你是怎么进行状态管理的？](https://github.com/haizlin/fe-interview/issues/605)\n- [React声明组件有哪几种方法，各有什么不同？](https://github.com/haizlin/fe-interview/issues/604)\n\n### ReactNative\n- [如何在React Native中设置环境变量？]()\n- [请描述下Code Push的原理是什么？](https://github.com/haizlin/fe-interview/issues/783)\n- [React Native怎样查看日记？](https://github.com/haizlin/fe-interview/issues/782)\n- [React Native怎样测试？](https://github.com/haizlin/fe-interview/issues/781)\n- [React Native怎样调试？](https://github.com/haizlin/fe-interview/issues/780)\n- [React Native和React有什么区别？](https://github.com/haizlin/fe-interview/issues/779)\n- [有做过React Native项目吗？](https://github.com/haizlin/fe-interview/issues/725)\n\n### React-Router\n- [React-Router怎么获取历史对象？](https://github.com/haizlin/fe-interview/issues/922)\n- [React-Router怎么获取URL的参数？](https://github.com/haizlin/fe-interview/issues/921)\n- [在history模式中push和replace有什么区别？](https://github.com/haizlin/fe-interview/issues/778)\n- [React-Router怎么设置重定向？](https://github.com/haizlin/fe-interview/issues/777)\n- [React-Router 4中`<Router>`组件有几种类型？](https://github.com/haizlin/fe-interview/issues/776)\n- [React-Router 3和React-Router 4有什么变化？添加了什么好的特性？](https://github.com/haizlin/fe-interview/issues/775)\n- [React-Router的实现原理是什么？](https://github.com/haizlin/fe-interview/issues/774)\n- [React-Router 4的switch有什么用？](https://github.com/haizlin/fe-interview/issues/773)\n- [React-Router的路由有几种模式？](https://github.com/haizlin/fe-interview/issues/772)\n- [React-Router 4怎样在路由变化时重新渲染同一个组件？](https://github.com/haizlin/fe-interview/issues/771)\n- [React-Router的`<Link>`标签和`<a>`标签有什么区别？](https://github.com/haizlin/fe-interview/issues/770)\n- [React的路由和普通路由有什么区别？](https://github.com/haizlin/fe-interview/issues/728)\n- [请你说说React的路由的优缺点？](https://github.com/haizlin/fe-interview/issues/727)\n- [请你说说React的路由是什么？](https://github.com/haizlin/fe-interview/issues/726)\n\n### Redux/Mobx\n- [你有了解Rxjs是什么吗？它是做什么的？](https://github.com/haizlin/fe-interview/issues/920)\n- [在Redux中怎么发起网络请求？](https://github.com/haizlin/fe-interview/issues/919)\n- [Redux怎样重置状态？](https://github.com/haizlin/fe-interview/issues/918)\n- [Redux怎样设置初始状态？](https://github.com/haizlin/fe-interview/issues/917)\n- [Context api可以取代Redux吗？为什么？](https://github.com/haizlin/fe-interview/issues/916)\n- [推荐在reducer中触发Action吗？为什么？](https://github.com/haizlin/fe-interview/issues/915)\n- [Redux怎么添加新的中间件？](https://github.com/haizlin/fe-interview/issues/914)\n- [redux-saga和redux-thunk有什么本质的区别？](https://github.com/haizlin/fe-interview/issues/913)\n- [在React中你是怎么对异步方案进行选型的？](https://github.com/haizlin/fe-interview/issues/912)\n- [你知道redux-saga的原理吗？](https://github.com/haizlin/fe-interview/issues/911)\n- [你有使用过redux-saga中间件吗？它是干什么的？](https://github.com/haizlin/fe-interview/issues/910)\n- [Redux中异步action和同步action最大的区别是什么？](https://github.com/haizlin/fe-interview/issues/769)\n- [Redux和vuex有什么区别？](https://github.com/haizlin/fe-interview/issues/768)\n- [Redux的中间件是什么？你有用过哪些Redux的中间件？](https://github.com/haizlin/fe-interview/issues/767)\n- [说说Redux的实现流程](https://github.com/haizlin/fe-interview/issues/766)\n- [Mobx的设计思想是什么？](https://github.com/haizlin/fe-interview/issues/765)\n- [Redux由哪些组件构成？](https://github.com/haizlin/fe-interview/issues/764)\n- [Mobx和Redux有什么区别？](https://github.com/haizlin/fe-interview/issues/763)\n- [在React项目中你是如何选择Redux和Mobx的？说说你的理解](https://github.com/haizlin/fe-interview/issues/762)\n- [你有在React中使用过Mobx吗？它的运用场景有哪些？](https://github.com/haizlin/fe-interview/issues/761)\n- [Redux的thunk作用是什么？](https://github.com/haizlin/fe-interview/issues/740)\n- [Redux的数据存储和本地储存有什么区别？](https://github.com/haizlin/fe-interview/issues/739)\n- [在Redux中，什么是reducer？它有什么作用？](https://github.com/haizlin/fe-interview/issues/738)\n- [举例说明怎么在Redux中定义action？](https://github.com/haizlin/fe-interview/issues/737)\n- [在Redux中，什么是action？](https://github.com/haizlin/fe-interview/issues/736)\n- [在Redux中，什么是store？](https://github.com/haizlin/fe-interview/issues/735)\n- [为什么Redux能做到局部渲染呢？](https://github.com/haizlin/fe-interview/issues/734)\n- [说说Redux的优缺点分别是什么？](https://github.com/haizlin/fe-interview/issues/733)\n- [Redux和Flux的区别是什么？](https://github.com/haizlin/fe-interview/issues/732)\n- [Redux它的三个原则是什么？](https://github.com/haizlin/fe-interview/issues/731)\n- [什么是单一数据源？](https://github.com/haizlin/fe-interview/issues/730)\n- [什么是Redux？说说你对Redux的理解？有哪些运用场景？](https://github.com/haizlin/fe-interview/issues/729)\n\n### Flux\n- [请说说点击按钮触发到状态更改，数据的流向？](https://github.com/haizlin/fe-interview/issues/742)\n- [请描述下Flux的思想](https://github.com/haizlin/fe-interview/issues/742)\n- [什么是Flux？说说你对Flux的理解？有哪些运用场景？](https://github.com/haizlin/fe-interview/issues/741)\n\n## Reference\n\n- <https://github.com/qiu-deqing/FE-interview>\n- <https://github.com/haizlin/fe-interview>\n","slug":"1","published":0,"updated":"2022-03-06T02:37:45.437Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0f42s31001hvw3lc2nddhiz","content":"<ul>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/924\">为什么说React中的props是只读的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/923\">你有使用过formik库吗？说说它的优缺点</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/901\">你有用过哪些React的表单库吗？说说它们的优缺点</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/900\">如果组件的属性没有传值，那么它的默认值是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/899\">可以使用TypeScript写React应用吗？怎么操作？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/898\"><code>super()</code>和<code>super(props)</code>有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/897\">你有使用过loadable组件吗？它帮我们解决了什么问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/896\">你有使用过suspense组件吗？它帮我们解决了什么问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/895\">怎样动态导入组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/894\">如何给非控组件设置默认的值？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/893\">怎么在React中引入其它的UI库，例如Bootstrap</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/892\">怎样将事件传递给子组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/891\">怎样使用Hooks获取服务端数据？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/890\">使用Hooks要遵守哪些原则？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/889\">render方法的原理你有了解吗？它返回的数据类型是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/888\">useEffect和useLayoutEffect有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/887\">在React项目中你用过哪些动画的包？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/886\">React必须使用JSX吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/885\">自定义组件时render是可选的吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/884\">需要把keys设置为全局唯一吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/883\">怎么定时更新一个组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/882\">React根据不同的环境打包不同的域名？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/881\">使用webpack打包React项目，怎么减小生成的js大小？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/880\">在React中怎么使用async/await？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/879\">你阅读了几遍React的源码？都有哪些收获？你是怎么阅读的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/878\">什么是React.forwardRef？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/877\">写个例子说明什么是JSX的内联条件渲染</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/876\">在React中怎么将参数传递给事件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/875\">React的事件和普通的HTML事件有什么不同？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/874\">在React中怎么阻止事件的默认行为？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/873\">你最喜欢React的哪一个特性（说一个就好）？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/872\">在React中什么时候使用箭头函数更方便呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/871\">你最不喜欢React的哪一个特性（说一个就好）？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/870\">说说你对React的reconciliation（一致化算法）的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/869\">使用PropTypes和Flow有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/868\">怎样有条件地渲染组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/867\">在JSX中如何写注释？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/866\">constructor和getInitialState有不同？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/865\">写例子说明React如何在JSX中实现for循环</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/864\">为什么建议Fragment包裹元素？它的简写是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/863\">你有用过React.Fragment吗？说说它有什么用途？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/862\">在React中你有遇到过安全问题吗？怎么解决？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/861\">React中如何监听state的变化？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/860\">React什么是有状态组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/859\">React v15中怎么处理错误边界？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/858\">React Fiber它的目的是解决什么问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/857\">React为什么不要直接修改state？如果想修改怎么做？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/856\">create-react-app有什么好处？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/855\">装饰器(Decorator)在React中有什么应用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/854\">使用高阶组件(HOC)实现一个loading组件</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/853\">如何用React实现滚动动画？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/852\">说出几点你认为的React最佳实践</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/851\">你是如何划分React组件的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/850\">举例说明如何在React创建一个事件</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/849\">如何更新组件的状态？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/848\">怎样将多个组件嵌入到一个组件中？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/847\">React的render中可以写{if else}这样的判断吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/846\">React为什么要搞一个Hooks？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/845\">React Hooks帮我们解决了哪些问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/844\">使用React的memo和forwardRef包装的组件为什么提示children类型不对？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/843\">有在项目中使用过Antd吗？说说它的好处</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/842\">在React中如果去除生产环境上的sourcemap？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/841\">在React中怎么引用sass或less？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/840\">组件卸载前，加在DOM元素的监听事件和定时器要不要手动清除？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/839\">为什么标签里的for要写成htmlFor呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/838\">状态管理器解决了什么问题？什么时候用状态管理器？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/837\">状态管理器它精髓是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/836\">函数式组件有没有生命周期？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/835\">在React中怎么引用第三方插件？比如说jQuery等</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/834\">React的触摸事件有哪几种？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/833\">路由切换时同一组件无法重新渲染的有什么方法可以解决？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/832\">React16新特性有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/831\">你有用过哪些React的UI库？它们的优缺点分别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/830\"><code>&lt;div onClick=&#123;handlerClick&#125;&gt;单击&lt;/div&gt;</code>和<code>&lt;div onClick=&#123;handlerClick(1)&#125;&gt;单击&lt;/div&gt;</code>有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/829\">在React中如何引入图片？哪种方式更好？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/828\">在React中怎么使用字体图标？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/827\">React的应用如何打包发布？它的步骤是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/826\">ES6的语法’…’在React中有哪些应用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/825\">如何封装一个React的全局公共组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/824\">在React中组件的props改变时更新组件的有哪些方法？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/823\">immutable的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/822\">你对immutable有了解吗？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/821\">如何提高组件的渲染效率呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/820\">在React中如何避免不必要的render？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/819\">render在什么时候会被触发？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/818\">写出React动态改变class切换组件样式</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/817\">React中怎么操作虚拟DOM的Class属性？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/816\">为什么属性使用className而不是class呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/815\">请说下react组件更新的机制是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/814\">怎么在JSX里属性可以被覆盖吗？覆盖的原则是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/813\">怎么在JSX里使用自定义属性？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/812\">怎么防止HTML被转义？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/811\">经常用React，你知道React的核心思想是什么吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/810\">在React中我们怎么做静态类型检测？都有哪些方法可以做到？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/809\">在React中组件的state和setState有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/808\">React怎样跳过重新渲染？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/807\">React怎么判断什么时候重新渲染组件呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/806\">什么是React的实例？函数式组件有没有实例？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/805\">在React中如何判断点击元素属于哪一个组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/804\">在React中组件和元素有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/803\">在React中声明组件时组件名的第一个字母必须是大写吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/802\">举例说明什么是高阶组件(HOC)的反向继承？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/801\">有用过React Devtools吗？说说它的优缺点分别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/800\">举例说明什么是高阶组件(HOC)的属性代理？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/799\">React的isMounted有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/798\">React组件命名推荐的方式是哪个？为什么不推荐使用displayName？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/797\">React的displayName有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/796\">说说你对React的组件命名规范的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/795\">说说你对React的项目结构的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/794\">React16废弃了哪些生命周期？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/793\">怎样在React中开启生产模式？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/792\">React中getInitialState方法的作用是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/791\">React中你知道creatClass的原理吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/790\">React中验证props的目的是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/789\">React中你有使用过getDefaultProps吗？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/788\">React中你有使用过propType吗？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/787\">React中怎么检验props？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/786\">React.createClass和extends Component的区别有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/785\">高阶组件(HOC)有哪些优点和缺点？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/784\">给组件设置很多属性时不想一个个去设置有什么办法可以解决这问题呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/756\">React16跟之前的版本生命周期有哪些变化？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/755\">怎样实现React组件的记忆？原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/754\">创建React动画有哪些方式？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/753\">为什么建议不要过渡使用Refs？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/752\">在React使用高阶组件(HOC)有遇到过哪些问题？如何解决？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/751\">在使用React过程中什么时候用高阶组件(HOC)？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/724\">说说React diff的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/723\">React怎么提高列表渲染的性能？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/722\">使用ES6的class定义的组件不支持mixins了，那用什么可以替代呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/720\">为何说虚拟DOM会提高性能？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/719\">React的性能优化在哪个生命周期？它优化的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/718\">你知道的React性能优化有哪些方法？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/717\">举例说明在React中怎么使用样式？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/716\">React有哪几种方法来处理表单输入？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/715\">什么是浅层渲染？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/714\">你有做过React的单元测试吗？如果有，用的是哪些工具？怎么做的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/713\">在React中什么是合成事件？有什么用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/712\">使用React写一个todo应用，说说你的思路</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/711\">React16的reconciliation和commit分别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/710\">React的函数式组件有没有生命周期？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/709\">useState和this.state的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/708\">请说说什么是useImperativeHandle？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/707\">请说说什么是useReducer？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/706\">请说说什么是useRef？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/705\">请说说什么是useEffect？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/704\">举例说明useState</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/703\">请说说什么是useState？为什么要使用useState？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/702\">请描述下你对React的新特性Hooks的理解？它有哪些应用场景？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/701\">说说你对Error Boundaries的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/700\">说说你对Fiber架构的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/699\">说说你是怎么理解React的业务组件和技术组件的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/698\">为什么建议setState的第一个参数是callback而不是一个对象呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/697\">展示组件和容器组件有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/696\">Mern和Yeoman脚手架有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/695\">你有在项目中使用过Yeoman脚手架吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/694\">你有在项目中使用过Mern脚手架吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/693\">shouldComponentUpdate方法是做什么的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/692\">怎样在React中使用innerHTML？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/691\">你有写过React的中间件插件吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/690\">React的中间件机制是怎么样的？这种机制有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/689\">React中你用过哪些第三方的中间件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/688\">不用脚手架，你会手动搭建React项目吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/687\">请说说React中Portal是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/686\">React中修改prop引发的生命周期有哪几个？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/685\">React多个setState调用的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/684\">React中调用setState会更新的生命周期有哪几个？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/683\">React中setState的第二个参数作用是什么呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/682\">React中的setState是同步还是异步的呢？为什么state并不一定会同步更新？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/681\">React中的setState批量更新的过程是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/680\">React中的setState执行机制是什么呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/679\">在React中遍历的方法有哪些？它们有什么区别呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/678\">请说说你对React的render方法的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/677\">props.children.map和js的map有什么区别？为什么优先选择React的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/676\">有用过React的严格模式吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/675\">React中的setState和replaceState的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/674\">React中的setState缺点是什么呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/673\">有用过React的Fragment吗？它的运用场景是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/672\">React组件间共享数据方法有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/671\">React的状态提升是什么？使用场景有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/670\">简单描述下你有做过哪些React项目？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/669\">在构造函数中调用super(props)的目的是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/668\">你是如何学习React的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/667\">从旧版本的React升级到新版本的React有做过吗？有遇到过什么坑？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/666\">你用过React版本有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/665\">有用过React的服务端渲染吗？怎么做的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/664\">React的mixins有什么作用？适用于什么场景？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/663\">React怎么拿到组件对应的DOM元素？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/662\">请描述下事件在React中的处理方式是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/661\">JSX和HTML有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/660\">React的书写规范有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/659\">create-react-app创建新运用怎么解决卡的问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/658\">使用React的方式有哪几种？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/657\">说说你对reader的context的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/656\">同时引用这三个库React.js、React-dom.js和babel.js它们都有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/655\">你知道Virtual DOM的工作原理吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/654\">你阅读过React的源码吗？简要说下它的执行流程</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/653\">React中怎样阻止组件渲染？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/652\">React非兄弟组件如何通信？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/651\">React兄弟组件如何通信？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/650\">React非父子组件如何通信？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/649\">React父子组件如何通信？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/648\">React组件间的通信有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/647\">类组件和函数式组件有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/646\">React自定义组件你写过吗？说说看都写过哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/645\">React组件的state和props两者有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/644\">React有几种构建组件的方式？可以写出来吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/643\">React中遍历时为什么不用索引作为唯一的key值？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/642\">React中的key有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/641\">React中除了在构造函数中绑定this,还有别的方式吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/640\">在React中页面重新加载时怎样保留数据？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/639\">请描述下React的事件机制</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/638\">怎样在React中创建一个事件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/637\">在React中无状态组件有什么运用场景？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/636\">描述下在React中无状态组件和有状态组件的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/635\">写一个React的高阶组件(HOC)并说明你对它的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/634\">React中可以在render访问refs吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/633\">React中refs的作用是什么？有哪些应用场景？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/632\">请描述你对纯函数的理解？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/631\">受控组件和非受控组件有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/630\">React中什么是非控组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/629\">React中什么是受控组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/628\">React中发起网络请求应该在哪个生命周期中进行？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/627\">说说React的生命周期有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/626\">说说你对“在React中，一切都是组件”的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/625\">写React你是用es6还是es5的语法？有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/624\">浏览器为什么无法直接JSX？怎么解决呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/623\">在使用React过程中你都踩过哪些坑？你是怎么填坑的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/622\">说说你喜欢React的原因是什么？它有什么优缺点？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/621\">如何解决引用类型在pureComponent下修改值的时候，页面不渲染的问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/620\">createElement与cloneElement两者有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/619\">解释下React中Element 和Component两者的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/618\">解释下React中component和pureComponent两者的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/617\">React的虚拟DOM和vue的虚拟DOM有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/616\">你觉得React上手快不快？它有哪些限制？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/615\">说说你对声明式编程的理解？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/614\">React与angular、vue有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/613\">React是哪个公司开发的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/612\">React是什么？它的主要特点是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/611\">简要描述下你知道的React工作原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/606\">在React中怎样改变组件状态，以及状态改变的过程是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/605\">在React中你是怎么进行状态管理的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/604\">React声明组件有哪几种方法，各有什么不同？</a></li>\n</ul>\n<h3 id=\"ReactNative\"><a href=\"#ReactNative\" class=\"headerlink\" title=\"ReactNative\"></a>ReactNative</h3><ul>\n<li><a href=\"\">如何在React Native中设置环境变量？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/783\">请描述下Code Push的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/782\">React Native怎样查看日记？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/781\">React Native怎样测试？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/780\">React Native怎样调试？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/779\">React Native和React有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/725\">有做过React Native项目吗？</a></li>\n</ul>\n<h3 id=\"React-Router\"><a href=\"#React-Router\" class=\"headerlink\" title=\"React-Router\"></a>React-Router</h3><ul>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/922\">React-Router怎么获取历史对象？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/921\">React-Router怎么获取URL的参数？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/778\">在history模式中push和replace有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/777\">React-Router怎么设置重定向？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/776\">React-Router 4中<code>&lt;Router&gt;</code>组件有几种类型？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/775\">React-Router 3和React-Router 4有什么变化？添加了什么好的特性？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/774\">React-Router的实现原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/773\">React-Router 4的switch有什么用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/772\">React-Router的路由有几种模式？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/771\">React-Router 4怎样在路由变化时重新渲染同一个组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/770\">React-Router的<code>&lt;Link&gt;</code>标签和<code>&lt;a&gt;</code>标签有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/728\">React的路由和普通路由有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/727\">请你说说React的路由的优缺点？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/726\">请你说说React的路由是什么？</a></li>\n</ul>\n<h3 id=\"Redux-Mobx\"><a href=\"#Redux-Mobx\" class=\"headerlink\" title=\"Redux/Mobx\"></a>Redux/Mobx</h3><ul>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/920\">你有了解Rxjs是什么吗？它是做什么的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/919\">在Redux中怎么发起网络请求？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/918\">Redux怎样重置状态？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/917\">Redux怎样设置初始状态？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/916\">Context api可以取代Redux吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/915\">推荐在reducer中触发Action吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/914\">Redux怎么添加新的中间件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/913\">redux-saga和redux-thunk有什么本质的区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/912\">在React中你是怎么对异步方案进行选型的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/911\">你知道redux-saga的原理吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/910\">你有使用过redux-saga中间件吗？它是干什么的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/769\">Redux中异步action和同步action最大的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/768\">Redux和vuex有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/767\">Redux的中间件是什么？你有用过哪些Redux的中间件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/766\">说说Redux的实现流程</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/765\">Mobx的设计思想是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/764\">Redux由哪些组件构成？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/763\">Mobx和Redux有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/762\">在React项目中你是如何选择Redux和Mobx的？说说你的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/761\">你有在React中使用过Mobx吗？它的运用场景有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/740\">Redux的thunk作用是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/739\">Redux的数据存储和本地储存有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/738\">在Redux中，什么是reducer？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/737\">举例说明怎么在Redux中定义action？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/736\">在Redux中，什么是action？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/735\">在Redux中，什么是store？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/734\">为什么Redux能做到局部渲染呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/733\">说说Redux的优缺点分别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/732\">Redux和Flux的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/731\">Redux它的三个原则是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/730\">什么是单一数据源？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/729\">什么是Redux？说说你对Redux的理解？有哪些运用场景？</a></li>\n</ul>\n<h3 id=\"Flux\"><a href=\"#Flux\" class=\"headerlink\" title=\"Flux\"></a>Flux</h3><ul>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/742\">请说说点击按钮触发到状态更改，数据的流向？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/742\">请描述下Flux的思想</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/741\">什么是Flux？说说你对Flux的理解？有哪些运用场景？</a></li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ul>\n<li><a href=\"https://github.com/qiu-deqing/FE-interview\">https://github.com/qiu-deqing/FE-interview</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview\">https://github.com/haizlin/fe-interview</a></li>\n</ul>\n","site":{"data":{}},"wordcount":6866,"excerpt":"","more":"<ul>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/924\">为什么说React中的props是只读的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/923\">你有使用过formik库吗？说说它的优缺点</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/901\">你有用过哪些React的表单库吗？说说它们的优缺点</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/900\">如果组件的属性没有传值，那么它的默认值是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/899\">可以使用TypeScript写React应用吗？怎么操作？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/898\"><code>super()</code>和<code>super(props)</code>有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/897\">你有使用过loadable组件吗？它帮我们解决了什么问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/896\">你有使用过suspense组件吗？它帮我们解决了什么问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/895\">怎样动态导入组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/894\">如何给非控组件设置默认的值？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/893\">怎么在React中引入其它的UI库，例如Bootstrap</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/892\">怎样将事件传递给子组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/891\">怎样使用Hooks获取服务端数据？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/890\">使用Hooks要遵守哪些原则？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/889\">render方法的原理你有了解吗？它返回的数据类型是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/888\">useEffect和useLayoutEffect有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/887\">在React项目中你用过哪些动画的包？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/886\">React必须使用JSX吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/885\">自定义组件时render是可选的吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/884\">需要把keys设置为全局唯一吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/883\">怎么定时更新一个组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/882\">React根据不同的环境打包不同的域名？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/881\">使用webpack打包React项目，怎么减小生成的js大小？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/880\">在React中怎么使用async/await？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/879\">你阅读了几遍React的源码？都有哪些收获？你是怎么阅读的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/878\">什么是React.forwardRef？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/877\">写个例子说明什么是JSX的内联条件渲染</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/876\">在React中怎么将参数传递给事件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/875\">React的事件和普通的HTML事件有什么不同？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/874\">在React中怎么阻止事件的默认行为？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/873\">你最喜欢React的哪一个特性（说一个就好）？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/872\">在React中什么时候使用箭头函数更方便呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/871\">你最不喜欢React的哪一个特性（说一个就好）？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/870\">说说你对React的reconciliation（一致化算法）的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/869\">使用PropTypes和Flow有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/868\">怎样有条件地渲染组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/867\">在JSX中如何写注释？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/866\">constructor和getInitialState有不同？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/865\">写例子说明React如何在JSX中实现for循环</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/864\">为什么建议Fragment包裹元素？它的简写是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/863\">你有用过React.Fragment吗？说说它有什么用途？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/862\">在React中你有遇到过安全问题吗？怎么解决？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/861\">React中如何监听state的变化？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/860\">React什么是有状态组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/859\">React v15中怎么处理错误边界？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/858\">React Fiber它的目的是解决什么问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/857\">React为什么不要直接修改state？如果想修改怎么做？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/856\">create-react-app有什么好处？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/855\">装饰器(Decorator)在React中有什么应用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/854\">使用高阶组件(HOC)实现一个loading组件</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/853\">如何用React实现滚动动画？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/852\">说出几点你认为的React最佳实践</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/851\">你是如何划分React组件的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/850\">举例说明如何在React创建一个事件</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/849\">如何更新组件的状态？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/848\">怎样将多个组件嵌入到一个组件中？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/847\">React的render中可以写{if else}这样的判断吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/846\">React为什么要搞一个Hooks？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/845\">React Hooks帮我们解决了哪些问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/844\">使用React的memo和forwardRef包装的组件为什么提示children类型不对？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/843\">有在项目中使用过Antd吗？说说它的好处</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/842\">在React中如果去除生产环境上的sourcemap？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/841\">在React中怎么引用sass或less？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/840\">组件卸载前，加在DOM元素的监听事件和定时器要不要手动清除？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/839\">为什么标签里的for要写成htmlFor呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/838\">状态管理器解决了什么问题？什么时候用状态管理器？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/837\">状态管理器它精髓是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/836\">函数式组件有没有生命周期？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/835\">在React中怎么引用第三方插件？比如说jQuery等</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/834\">React的触摸事件有哪几种？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/833\">路由切换时同一组件无法重新渲染的有什么方法可以解决？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/832\">React16新特性有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/831\">你有用过哪些React的UI库？它们的优缺点分别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/830\"><code>&lt;div onClick=&#123;handlerClick&#125;&gt;单击&lt;/div&gt;</code>和<code>&lt;div onClick=&#123;handlerClick(1)&#125;&gt;单击&lt;/div&gt;</code>有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/829\">在React中如何引入图片？哪种方式更好？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/828\">在React中怎么使用字体图标？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/827\">React的应用如何打包发布？它的步骤是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/826\">ES6的语法’…’在React中有哪些应用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/825\">如何封装一个React的全局公共组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/824\">在React中组件的props改变时更新组件的有哪些方法？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/823\">immutable的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/822\">你对immutable有了解吗？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/821\">如何提高组件的渲染效率呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/820\">在React中如何避免不必要的render？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/819\">render在什么时候会被触发？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/818\">写出React动态改变class切换组件样式</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/817\">React中怎么操作虚拟DOM的Class属性？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/816\">为什么属性使用className而不是class呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/815\">请说下react组件更新的机制是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/814\">怎么在JSX里属性可以被覆盖吗？覆盖的原则是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/813\">怎么在JSX里使用自定义属性？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/812\">怎么防止HTML被转义？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/811\">经常用React，你知道React的核心思想是什么吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/810\">在React中我们怎么做静态类型检测？都有哪些方法可以做到？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/809\">在React中组件的state和setState有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/808\">React怎样跳过重新渲染？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/807\">React怎么判断什么时候重新渲染组件呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/806\">什么是React的实例？函数式组件有没有实例？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/805\">在React中如何判断点击元素属于哪一个组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/804\">在React中组件和元素有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/803\">在React中声明组件时组件名的第一个字母必须是大写吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/802\">举例说明什么是高阶组件(HOC)的反向继承？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/801\">有用过React Devtools吗？说说它的优缺点分别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/800\">举例说明什么是高阶组件(HOC)的属性代理？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/799\">React的isMounted有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/798\">React组件命名推荐的方式是哪个？为什么不推荐使用displayName？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/797\">React的displayName有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/796\">说说你对React的组件命名规范的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/795\">说说你对React的项目结构的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/794\">React16废弃了哪些生命周期？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/793\">怎样在React中开启生产模式？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/792\">React中getInitialState方法的作用是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/791\">React中你知道creatClass的原理吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/790\">React中验证props的目的是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/789\">React中你有使用过getDefaultProps吗？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/788\">React中你有使用过propType吗？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/787\">React中怎么检验props？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/786\">React.createClass和extends Component的区别有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/785\">高阶组件(HOC)有哪些优点和缺点？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/784\">给组件设置很多属性时不想一个个去设置有什么办法可以解决这问题呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/756\">React16跟之前的版本生命周期有哪些变化？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/755\">怎样实现React组件的记忆？原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/754\">创建React动画有哪些方式？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/753\">为什么建议不要过渡使用Refs？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/752\">在React使用高阶组件(HOC)有遇到过哪些问题？如何解决？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/751\">在使用React过程中什么时候用高阶组件(HOC)？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/724\">说说React diff的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/723\">React怎么提高列表渲染的性能？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/722\">使用ES6的class定义的组件不支持mixins了，那用什么可以替代呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/720\">为何说虚拟DOM会提高性能？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/719\">React的性能优化在哪个生命周期？它优化的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/718\">你知道的React性能优化有哪些方法？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/717\">举例说明在React中怎么使用样式？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/716\">React有哪几种方法来处理表单输入？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/715\">什么是浅层渲染？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/714\">你有做过React的单元测试吗？如果有，用的是哪些工具？怎么做的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/713\">在React中什么是合成事件？有什么用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/712\">使用React写一个todo应用，说说你的思路</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/711\">React16的reconciliation和commit分别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/710\">React的函数式组件有没有生命周期？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/709\">useState和this.state的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/708\">请说说什么是useImperativeHandle？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/707\">请说说什么是useReducer？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/706\">请说说什么是useRef？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/705\">请说说什么是useEffect？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/704\">举例说明useState</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/703\">请说说什么是useState？为什么要使用useState？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/702\">请描述下你对React的新特性Hooks的理解？它有哪些应用场景？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/701\">说说你对Error Boundaries的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/700\">说说你对Fiber架构的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/699\">说说你是怎么理解React的业务组件和技术组件的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/698\">为什么建议setState的第一个参数是callback而不是一个对象呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/697\">展示组件和容器组件有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/696\">Mern和Yeoman脚手架有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/695\">你有在项目中使用过Yeoman脚手架吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/694\">你有在项目中使用过Mern脚手架吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/693\">shouldComponentUpdate方法是做什么的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/692\">怎样在React中使用innerHTML？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/691\">你有写过React的中间件插件吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/690\">React的中间件机制是怎么样的？这种机制有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/689\">React中你用过哪些第三方的中间件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/688\">不用脚手架，你会手动搭建React项目吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/687\">请说说React中Portal是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/686\">React中修改prop引发的生命周期有哪几个？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/685\">React多个setState调用的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/684\">React中调用setState会更新的生命周期有哪几个？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/683\">React中setState的第二个参数作用是什么呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/682\">React中的setState是同步还是异步的呢？为什么state并不一定会同步更新？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/681\">React中的setState批量更新的过程是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/680\">React中的setState执行机制是什么呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/679\">在React中遍历的方法有哪些？它们有什么区别呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/678\">请说说你对React的render方法的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/677\">props.children.map和js的map有什么区别？为什么优先选择React的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/676\">有用过React的严格模式吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/675\">React中的setState和replaceState的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/674\">React中的setState缺点是什么呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/673\">有用过React的Fragment吗？它的运用场景是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/672\">React组件间共享数据方法有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/671\">React的状态提升是什么？使用场景有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/670\">简单描述下你有做过哪些React项目？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/669\">在构造函数中调用super(props)的目的是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/668\">你是如何学习React的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/667\">从旧版本的React升级到新版本的React有做过吗？有遇到过什么坑？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/666\">你用过React版本有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/665\">有用过React的服务端渲染吗？怎么做的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/664\">React的mixins有什么作用？适用于什么场景？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/663\">React怎么拿到组件对应的DOM元素？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/662\">请描述下事件在React中的处理方式是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/661\">JSX和HTML有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/660\">React的书写规范有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/659\">create-react-app创建新运用怎么解决卡的问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/658\">使用React的方式有哪几种？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/657\">说说你对reader的context的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/656\">同时引用这三个库React.js、React-dom.js和babel.js它们都有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/655\">你知道Virtual DOM的工作原理吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/654\">你阅读过React的源码吗？简要说下它的执行流程</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/653\">React中怎样阻止组件渲染？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/652\">React非兄弟组件如何通信？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/651\">React兄弟组件如何通信？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/650\">React非父子组件如何通信？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/649\">React父子组件如何通信？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/648\">React组件间的通信有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/647\">类组件和函数式组件有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/646\">React自定义组件你写过吗？说说看都写过哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/645\">React组件的state和props两者有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/644\">React有几种构建组件的方式？可以写出来吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/643\">React中遍历时为什么不用索引作为唯一的key值？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/642\">React中的key有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/641\">React中除了在构造函数中绑定this,还有别的方式吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/640\">在React中页面重新加载时怎样保留数据？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/639\">请描述下React的事件机制</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/638\">怎样在React中创建一个事件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/637\">在React中无状态组件有什么运用场景？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/636\">描述下在React中无状态组件和有状态组件的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/635\">写一个React的高阶组件(HOC)并说明你对它的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/634\">React中可以在render访问refs吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/633\">React中refs的作用是什么？有哪些应用场景？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/632\">请描述你对纯函数的理解？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/631\">受控组件和非受控组件有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/630\">React中什么是非控组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/629\">React中什么是受控组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/628\">React中发起网络请求应该在哪个生命周期中进行？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/627\">说说React的生命周期有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/626\">说说你对“在React中，一切都是组件”的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/625\">写React你是用es6还是es5的语法？有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/624\">浏览器为什么无法直接JSX？怎么解决呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/623\">在使用React过程中你都踩过哪些坑？你是怎么填坑的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/622\">说说你喜欢React的原因是什么？它有什么优缺点？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/621\">如何解决引用类型在pureComponent下修改值的时候，页面不渲染的问题？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/620\">createElement与cloneElement两者有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/619\">解释下React中Element 和Component两者的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/618\">解释下React中component和pureComponent两者的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/617\">React的虚拟DOM和vue的虚拟DOM有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/616\">你觉得React上手快不快？它有哪些限制？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/615\">说说你对声明式编程的理解？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/614\">React与angular、vue有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/613\">React是哪个公司开发的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/612\">React是什么？它的主要特点是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/611\">简要描述下你知道的React工作原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/606\">在React中怎样改变组件状态，以及状态改变的过程是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/605\">在React中你是怎么进行状态管理的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/604\">React声明组件有哪几种方法，各有什么不同？</a></li>\n</ul>\n<h3 id=\"ReactNative\"><a href=\"#ReactNative\" class=\"headerlink\" title=\"ReactNative\"></a>ReactNative</h3><ul>\n<li><a href=\"\">如何在React Native中设置环境变量？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/783\">请描述下Code Push的原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/782\">React Native怎样查看日记？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/781\">React Native怎样测试？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/780\">React Native怎样调试？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/779\">React Native和React有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/725\">有做过React Native项目吗？</a></li>\n</ul>\n<h3 id=\"React-Router\"><a href=\"#React-Router\" class=\"headerlink\" title=\"React-Router\"></a>React-Router</h3><ul>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/922\">React-Router怎么获取历史对象？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/921\">React-Router怎么获取URL的参数？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/778\">在history模式中push和replace有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/777\">React-Router怎么设置重定向？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/776\">React-Router 4中<code>&lt;Router&gt;</code>组件有几种类型？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/775\">React-Router 3和React-Router 4有什么变化？添加了什么好的特性？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/774\">React-Router的实现原理是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/773\">React-Router 4的switch有什么用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/772\">React-Router的路由有几种模式？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/771\">React-Router 4怎样在路由变化时重新渲染同一个组件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/770\">React-Router的<code>&lt;Link&gt;</code>标签和<code>&lt;a&gt;</code>标签有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/728\">React的路由和普通路由有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/727\">请你说说React的路由的优缺点？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/726\">请你说说React的路由是什么？</a></li>\n</ul>\n<h3 id=\"Redux-Mobx\"><a href=\"#Redux-Mobx\" class=\"headerlink\" title=\"Redux/Mobx\"></a>Redux/Mobx</h3><ul>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/920\">你有了解Rxjs是什么吗？它是做什么的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/919\">在Redux中怎么发起网络请求？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/918\">Redux怎样重置状态？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/917\">Redux怎样设置初始状态？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/916\">Context api可以取代Redux吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/915\">推荐在reducer中触发Action吗？为什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/914\">Redux怎么添加新的中间件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/913\">redux-saga和redux-thunk有什么本质的区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/912\">在React中你是怎么对异步方案进行选型的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/911\">你知道redux-saga的原理吗？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/910\">你有使用过redux-saga中间件吗？它是干什么的？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/769\">Redux中异步action和同步action最大的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/768\">Redux和vuex有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/767\">Redux的中间件是什么？你有用过哪些Redux的中间件？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/766\">说说Redux的实现流程</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/765\">Mobx的设计思想是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/764\">Redux由哪些组件构成？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/763\">Mobx和Redux有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/762\">在React项目中你是如何选择Redux和Mobx的？说说你的理解</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/761\">你有在React中使用过Mobx吗？它的运用场景有哪些？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/740\">Redux的thunk作用是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/739\">Redux的数据存储和本地储存有什么区别？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/738\">在Redux中，什么是reducer？它有什么作用？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/737\">举例说明怎么在Redux中定义action？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/736\">在Redux中，什么是action？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/735\">在Redux中，什么是store？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/734\">为什么Redux能做到局部渲染呢？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/733\">说说Redux的优缺点分别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/732\">Redux和Flux的区别是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/731\">Redux它的三个原则是什么？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/730\">什么是单一数据源？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/729\">什么是Redux？说说你对Redux的理解？有哪些运用场景？</a></li>\n</ul>\n<h3 id=\"Flux\"><a href=\"#Flux\" class=\"headerlink\" title=\"Flux\"></a>Flux</h3><ul>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/742\">请说说点击按钮触发到状态更改，数据的流向？</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/742\">请描述下Flux的思想</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview/issues/741\">什么是Flux？说说你对Flux的理解？有哪些运用场景？</a></li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ul>\n<li><a href=\"https://github.com/qiu-deqing/FE-interview\">https://github.com/qiu-deqing/FE-interview</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview\">https://github.com/haizlin/fe-interview</a></li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl0f42s2b0001vw3le6ow7azd","category_id":"cl0f42s2g0004vw3lf8zyh7ry","_id":"cl0f42s2n000fvw3l38t9b1q4"},{"post_id":"cl0f42s2f0003vw3l6c453t6j","category_id":"cl0f42s2j000avw3l8ubbdv5i","_id":"cl0f42s2p000lvw3l6b6j2j4t"},{"post_id":"cl0f42s2l000evw3lejffafo3","category_id":"cl0f42s2g0004vw3lf8zyh7ry","_id":"cl0f42s2r000pvw3lc26h1qmz"},{"post_id":"cl0f42s2h0007vw3l5ddqf42n","category_id":"cl0f42s2n000gvw3lcyazasuo","_id":"cl0f42s2r000rvw3ldhn70pjk"},{"post_id":"cl0f42s2p000ovw3l0dmmakvq","category_id":"cl0f42s2p000mvw3l1oq7cphr","_id":"cl0f42s2r000vvw3l9db8a1dz"},{"post_id":"cl0f42s2j0008vw3lblvbc3h5","category_id":"cl0f42s2p000mvw3l1oq7cphr","_id":"cl0f42s2r000wvw3lb8ljdh6t"},{"post_id":"cl0f42s2k000dvw3lacz572a0","category_id":"cl0f42s2r000svw3l5xln9m0y","_id":"cl0f42s2v0010vw3lb79w4ql2"},{"post_id":"cl0f42s2o000ivw3l4biag6z1","category_id":"cl0f42s2r000svw3l5xln9m0y","_id":"cl0f42s2x0013vw3ldfsz6wqm"},{"post_id":"cl0f42s2o000kvw3l8n6c727b","category_id":"cl0f42s2r000svw3l5xln9m0y","_id":"cl0f42s2x0017vw3ldkxiawn3"},{"post_id":"cl0f42s30001evw3lamezhfd9","category_id":"cl0f42s2p000mvw3l1oq7cphr","_id":"cl0f42s31001ivw3l22g30biq"},{"post_id":"cl0f42s2z001dvw3la2oc1prn","category_id":"cl0f42s30001fvw3l22miffh5","_id":"cl0f42s31001lvw3leorq6qz9"}],"PostTag":[{"post_id":"cl0f42s2b0001vw3le6ow7azd","tag_id":"cl0f42s2h0005vw3lhwh5gbei","_id":"cl0f42s2k000cvw3lg8k9e3pb"},{"post_id":"cl0f42s2f0003vw3l6c453t6j","tag_id":"cl0f42s2k000bvw3lcwl5f1j2","_id":"cl0f42s2o000jvw3lgfr2f9q0"},{"post_id":"cl0f42s2h0007vw3l5ddqf42n","tag_id":"cl0f42s2n000hvw3l2xts9scb","_id":"cl0f42s2r000qvw3ld4kwgmn9"},{"post_id":"cl0f42s2j0008vw3lblvbc3h5","tag_id":"cl0f42s2p000nvw3l5lf5dm7f","_id":"cl0f42s2r000uvw3l02lp9hcc"},{"post_id":"cl0f42s2k000dvw3lacz572a0","tag_id":"cl0f42s2r000tvw3lcsv3gnjc","_id":"cl0f42s2w0012vw3l7lnudtvo"},{"post_id":"cl0f42s2k000dvw3lacz572a0","tag_id":"cl0f42s2s000yvw3l1iva4jmm","_id":"cl0f42s2x0014vw3la81dapxg"},{"post_id":"cl0f42s2l000evw3lejffafo3","tag_id":"cl0f42s2v0011vw3l5s588f53","_id":"cl0f42s2x0016vw3l6cop0m6s"},{"post_id":"cl0f42s2o000ivw3l4biag6z1","tag_id":"cl0f42s2s000yvw3l1iva4jmm","_id":"cl0f42s2y0019vw3leh4h5l21"},{"post_id":"cl0f42s2o000kvw3l8n6c727b","tag_id":"cl0f42s2s000yvw3l1iva4jmm","_id":"cl0f42s2y001bvw3lgoyddgmg"},{"post_id":"cl0f42s2p000ovw3l0dmmakvq","tag_id":"cl0f42s2y001avw3l0yyy1bov","_id":"cl0f42s2y001cvw3lgy05hjtz"},{"post_id":"cl0f42s2z001dvw3la2oc1prn","tag_id":"cl0f42s30001gvw3lemhg6j9w","_id":"cl0f42s31001kvw3lbxqv65g8"},{"post_id":"cl0f42s30001evw3lamezhfd9","tag_id":"cl0f42s31001jvw3lcbrv3sor","_id":"cl0f42s31001mvw3lfcs5dx41"}],"Tag":[{"name":"Bad&Good","_id":"cl0f42s2h0005vw3lhwh5gbei"},{"name":"webpack","_id":"cl0f42s2k000bvw3lcwl5f1j2"},{"name":"Mobx","_id":"cl0f42s2n000hvw3l2xts9scb"},{"name":"前端实习生","_id":"cl0f42s2p000nvw3l5lf5dm7f"},{"name":"React","_id":"cl0f42s2r000tvw3lcsv3gnjc"},{"name":"HooK","_id":"cl0f42s2s000yvw3l1iva4jmm"},{"name":"map","_id":"cl0f42s2v0011vw3l5s588f53"},{"name":"前端","_id":"cl0f42s2y001avw3l0yyy1bov"},{"name":"Vue3","_id":"cl0f42s30001gvw3lemhg6j9w"},{"name":"面试","_id":"cl0f42s31001jvw3lcbrv3sor"}]}}