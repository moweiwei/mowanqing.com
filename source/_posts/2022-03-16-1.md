---
title: TypeScript 笔记
index_img: /img/2022-03-16-1.png
abbrlink: 81dvefb9
date: 2022-03-16 23:19:28
tags: TypeScript
categories: TypeScript
---

## 声明空间

ts 中有两种：类型声明空间与变量声明空间

类型声明空间：

```ts
class Foo {}
interface Bar {}
type Bas = {};
```

如下当做类型注解使用

```ts
let foo: Foo;
let bar: Bar;
let bas: Bas;
```

定义 interface Bar {} 不能当做变量来用，因为它没有定义在变量声明空间中。

## 模块

如下方式定义在 **全局模块** 中

```ts
const foo = 123;
```

如下方式文件的根级别位置含有 import 或者 export,在文件中创建本地作用域，是定义在 **文件模块** 中

```ts
export const foo = 123;
```

## 命名空间

命名空间一个最明确的目的就是解决重名问题。

命名空间是位于全局命名空间下的一个普通的带有名字的 JavaScript 对象。作用是将一系列相关的全局变量组织到一个对象的属性。

```ts
namespace Letter { 
  export let a = 1; 
  export let b = 2; 
} 
```

编译成 js 如下：

```ts
var Letter; 
(function (Letter) { 
    Letter.a = 1; 
    Letter.b = 2; 
})(Letter || (Letter = {})); 
```

## 动态导入表达式 import()

import() 异步加载一个模块, 该语句用于 Webpack Code Splitting。

```ts
import(/* webpackChunkName: "momentjs" */ 'moment')
  .then(moment => {
    const time = moment().format();
    console.log('TypeScript >= 2.4.0 Dynamic Import Expression:');
    console.log(time);
  })
  .catch(err => {
    console.log('Failed to load moment', err);
  });
```

## TS 类型系统

原始类型 string、number、boolean 可以被用作类型注解。

### 数组

两种方式定义数组：

1、元素类型后加 []

```ts
let list: number[] = [1, 2, 3];
```

2、 数组泛型 Array<元素类型>

```js
let list: Array<number> = [1, 2, 3];
```

### 接口

合并众多类型声明至一个类型声明

```ts
interface Name {
  first: string;
  second: string;
}

let name: Name = {
  first: 'John',
  second: 'Doe'
};

```

### 内联类型注解

```ts
let name: {
  first: string;
  second: string;
};

name = {
  first: 'John',
  second: 'Doe'
};
```

内联类型注解可以省去为类型起名的麻烦。

如果你发现需要多次使用相同的内联注解时，那么考虑把它重构为一个接口（或者是 type alias)

### 特殊类型

any、 null、 undefined 以及 void

:void 来表示一个函数没有一个返回值

```ts
function log(message: string): void {
  console.log(message);
}
```

### 泛型

在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。

```ts
function reverse<T>(items: T[]): T[] {
  const toreturn = [];
  for (let i = items.length - 1; i >= 0; i--) {
    toreturn.push(items[i]);
  }
  return toreturn;
}
```

### 联合类型

多种类型之一

```ts
function formatCommandline(command: string[] | string) {
  let line = '';
  if (typeof command === 'string') {
    line = command.trim();
  } else {
    line = command.join(' ').trim();
  }

  // Do stuff with line: string
}
```

### 交叉类型

extend 是一种非常常见的模式，从两个对象中创建一个新对象，新对象拥有着两个对象所有的功能。

```ts
function extend<T extends object, U extends object>(first: T, second: U): T & U {
  const result = <T & U>{};
  for (let id in first) {
    (<T>result)[id] = first[id];
  }
  for (let id in second) {
    if (!result.hasOwnProperty(id)) {
      (<U>result)[id] = second[id];
    }
  }

  return result;
}

const x = extend({ a: 'hello' }, { b: 42 });

// 现在 x 拥有了 a 属性与 b 属性
const a = x.a;
const b = x.b;
```

## 元祖类型 Tuple

固定长度的，元素数据类型不同的数组。数据不可变。

```js
type FixedArray = [string, number, string];

const mixedArray: FixedArray = ['a', 2, 'c'];
```

### 类型别名

以为任意的类型注解提供类型别名,在联合类型和交叉类型中比较实用。

```ts
type StrOrNum = string | number;

// 使用
let sample: StrOrNum;
sample = 123;
sample = '123';

// 会检查类型
sample = true; // Error
```

```ts
type Text = string | { text: string };
type Coordinates = [number, number];
type Callback = (data: string) => void;
```

### @types

通过 npm 来安装使用 @types,如 `npm install @types/jquery --save-dev`

### declare 声明文件

.d.ts文件是ts用来声明变量，模块，type，interface等等的。

在这种后缀的ts文件声明这些东西和在纯ts文件声明这些东西又什么区别呢？

在.d.ts声明变量或者模块等东西之后，在其他地方可以不用import导入这些东西就可以直接用，用，而且有语法提示。

declare声明一个类型:

```ts
declare type Asd {
    name: string;
}
```

在tsconfig.json文件里面的include数组里面添加这个文件, 在include包含的文件范围内可以直接使用Asd这个type。

declare声明一个模块:

```ts
declare module '*.css';
declare module '*.less';
declare module '*.png';
```

编译ts文件的时候，导入一个.css/.less/.png格式的文件，如果没有经过declare的话是会提示语法错误的

declare声明一个变量:

在项目中引入了一个sdk，这个sdk（我们以微信的sdk为例）里面有一些全局的对象（比如wx），但是如果不经过任何的声明，在ts文件里面直接用wx.config()的话，肯定会报错。

declare声明一个作用域:

```ts
declare namespace API {
    interface ResponseList {}
}
```

声明完之后在其他地方的ts就可以直接API.ResponseList引用到这个接口类型



## 参考

- [深入理解 TypeScript](https://jkchao.github.io/typescript-book-chinese/)
