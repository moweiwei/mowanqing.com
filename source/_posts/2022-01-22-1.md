---
title: Vue3 学习笔记
index_img: /img/2022.01.22.1.jpeg
date: 2022-01-22 10:46:00
tags:
categories:
---

# Vue3 学习笔记

## Vue 和 React 数据驱动原理对比

Vue1 解决方案是使用响应式，初始化的时候，watcher 监听数据的每个属性，数据发生变化的时候，就能够知道数据的哪个 key 变了，去修改对应的 DOM。

React 是虚拟 DOM 方案，用 JS 对象描述 DOM 树，这个对象就像数据和实际 DOM 的一个缓存层，通过管理这个对象的变化，来减少对实际 DOM 的操作。

描述实际 DOM 的虚拟 DOM 对象如下：

DOM:

```html
<div id="app">
  <p class="item">Item1</p>
  <div class="item">Item2</div>
</div>
```

虚拟 DOM：

```js

{
  tag: "div",
  attrs: {
    id: "app"
  },
  children: [
    {
      tag: "p",
      attrs: { className: "item" },
      children: ["Item1"]
    },
    {
      tag: "div",
      attrs: { className: "item" },
      children: ["Item2"]
    }
  ]
}
```

数据变化的时候生成一个新的虚拟 DOM 数据，对比之前的虚拟 DOM 进行 diff 计算，算出要修改的 DOM，再对页面进行操作。

通知页面更新的方式不同：

- vue 中，数据变化，框架主动告诉你修改了哪些数据；
- react 中，变化变化后，通过新老数据的计算 Diff 来得知哪些数据发生变化

性能问题：

- vue 的响应式，在项目大了之后，每个数据都有一个 watcher 会影响性能
- 如果 react 虚拟 dom 过于庞大，使得 diff 计算时间大于 16.6 ms(屏幕刷新率 60HZ, 1/60)，可能造成性能卡顿。

为了解决性能问题， Vue 和 react 走了不同的道路。

- react 借鉴操作系统时间分片概念，引入 Fiber 架构。把整个虚拟 DOM 树 微观化，变成链表，然后利用浏览器的空闲时间计算 diff。
- vue1 的问题在于响应式数据过多，会带来内存占用过多的问题。vue2 引入虚拟 DOM 来解决响应式数据过多问题。

响应式数据是主动推送变化，虚拟 DOM 是被动计算数据的 diff。vue2 将两者结合在一起，在组件级别来划分。

组件间的变化，通过响应式来通知更新。组件内部的数据变化，通过虚拟 DOM 去更新页面。最终，把响应式监听器控制在组件级别，而虚拟 DOM 的量级控制在组件的大小。

在模板书写上，vue 和 react 分别走了 template 和 jsx 两个路线。

- react 世界只有 jsx，最终 jsx 都会在 Compiler 那层，即工程化那里编译成 js 来执行。
- vue 默认 template。vue3 优秀的其中一点是在虚拟 DOM 的静态标记上做到了极致，让静态的部分越过虚拟 DOM 的计算，真正做到按需更新，很好的提高了性能。

---

上述笔记源于学习极客时间-大圣的 [玩转 Vue3 全家桶](http://gk.link/a/115Qp) 课程笔记整理。

---
