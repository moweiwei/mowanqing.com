

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Moweiwei">
  <meta name="keywords" content="博客 mowanqing">
  
    <meta name="description" content="Function Component 是更彻底的状态驱动抽象。要彻底理解 Hooks 需要忘掉 Class Component 生命周期,理解 FC 的思维方式。 每次渲染都有他自己的 props 和 state123456789101112function Counter() &amp;#123;  const [count, setCount] &#x3D; useState(0);  return (">
<meta property="og:type" content="article">
<meta property="og:title" content="React Hooks 之 useEffect">
<meta property="og:url" content="http://mowanqing.com/posts/0/index.html">
<meta property="og:site_name" content="Just.Upward">
<meta property="og:description" content="Function Component 是更彻底的状态驱动抽象。要彻底理解 Hooks 需要忘掉 Class Component 生命周期,理解 FC 的思维方式。 每次渲染都有他自己的 props 和 state123456789101112function Counter() &amp;#123;  const [count, setCount] &#x3D; useState(0);  return (">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://mowanqing.com/img/2022-04-07-1.png">
<meta property="article:published_time" content="2022-04-07T14:04:17.000Z">
<meta property="article:modified_time" content="2022-04-15T10:00:28.363Z">
<meta property="article:author" content="Moweiwei">
<meta property="article:tag" content="useEffect">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://mowanqing.com/img/2022-04-07-1.png">
  
  
  <title>React Hooks 之 useEffect - Just.Upward</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/atom-one-dark-reasonable.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"mowanqing.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":true,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="Just.Upward" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Just.Upward</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="React Hooks 之 useEffect">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-04-07 22:04" pubdate>
        2022年4月7日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      95 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">React Hooks 之 useEffect</h1>
            
            <div class="markdown-body">
              <p>Function Component 是更彻底的状态驱动抽象。要彻底理解 Hooks 需要忘掉 Class Component 生命周期,理解 FC 的思维方式。</p>
<h2 id="每次渲染都有他自己的-props-和-state"><a href="#每次渲染都有他自己的-props-和-state" class="headerlink" title="每次渲染都有他自己的 props 和 state"></a>每次渲染都有他自己的 props 和 state</h2><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span><br><span class="xml">        Click me</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</code> 该行中的 count 如何理解？</p>
<p>第一感觉是 count 是会“监听”状态变化自动更新。它不是 data binding、watcher、proxy。</p>
<figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> count = <span class="hljs-number">42</span>; <span class="hljs-comment">// count 只是一个数字</span><br><span class="hljs-comment">// ...</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="hljs-comment">// ...</span><br></code></pre></div></td></tr></table></figure>

<p>组件第一次渲染，count 初始值是 0。 调用 setCount(1),react 再次渲染组件，这次 count 是 1。以此类推。。。</p>
<figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-comment">// During first render</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// Returned by useState()</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// After a click, our function is called again</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> count = <span class="hljs-number">1</span>; <span class="hljs-comment">// Returned by useState()</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// After another click, our function is called again</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> count = <span class="hljs-number">2</span>; <span class="hljs-comment">// Returned by useState()</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>每次状态更新，react 重新渲染组件。每一次的渲染中的 count 都是独立的值，这个状态值是函数中的一个常量。</p>
<p>任意一次渲染中的count常量都不会随着时间改变。渲染输出会变是因为我们的组件被一次次调用，而每一次调用引起的渲染中，它包含的count值独立于其他渲染。</p>
<h2 id="每次渲染都有它自己的事件处理函数"><a href="#每次渲染都有它自己的事件处理函数" class="headerlink" title="每次渲染都有它自己的事件处理函数"></a>每次渲染都有它自己的事件处理函数</h2><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> [temp, setTemp] = React.useState(<span class="hljs-number">5</span>);<br><br>  <span class="hljs-keyword">const</span> log = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;3 秒前 temp = 5，现在 temp =&quot;</span>, temp);<br>    &#125;, <span class="hljs-number">3000</span>);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span></span></span><br><span class="hljs-tag"><span class="xml">      <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="xml">        log();</span><br><span class="xml">        setTemp(3);</span><br><span class="xml">        // 3 秒前 temp = 5，现在 temp = 5</span><br><span class="xml">      &#125;&#125;</span><br><span class="xml">    &gt;</span><br><span class="xml">      xyz</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></div></td></tr></table></figure>

<p>上述代码输出 5，而不是 3</p>
<p>log 函数执行的那个 render 过程， temp 可以看作常量 5。执行 setTemp(3) 后会由一个全新的 render 渲染。所以不会执行 log 函数。而 3 秒后执行的内容是由 temp 为 5 的那个 render 发出的。所以结果为 5。</p>
<h2 id="每次-Render-都有自己的-Effects"><a href="#每次-Render-都有自己的-Effects" class="headerlink" title="每次 Render 都有自己的 Effects"></a>每次 Render 都有自己的 Effects</h2><p>useEffect 在 DOM 渲染完毕后执行， 也一样拿到的是某次渲染时的值。</p>
<p>每次 render 过程，拿到的 count 都是固化的常量。</p>
<figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;count&#125;</span> times`</span>;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="单次渲染内，props-和-state-始终保持不变"><a href="#单次渲染内，props-和-state-始终保持不变" class="headerlink" title="单次渲染内，props 和 state 始终保持不变"></a>单次渲染内，props 和 state 始终保持不变</h2><p>所以，每一个组件内的函数（包括事件处理函数，effects，定时器或者API调用等等）会捕获某次渲染中定义的props 和 state。</p>
<p>下面两个例子是相等的：</p>
<figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(props.counter);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> counter = props.counter;<br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(counter);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在组件内，什么时候读 props 和 state 都一样。在单次渲染内，他们始终保持不变。</p>
<h2 id="如何拿最新的值，而不是捕获的值"><a href="#如何拿最新的值，而不是捕获的值" class="headerlink" title="如何拿最新的值，而不是捕获的值"></a>如何拿最新的值，而不是捕获的值</h2><p>useRef 可以绕过 Capture Value 的特性。可以认为 ref 在所有 Render 过程中保持着唯一引用，因此所有对 ref 的赋值或取值，拿到的都只有一个最终状态，而不会在每个 Render 间存在隔离。</p>
<figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> latestCount = useRef(count);<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// Set the mutable latest value</span><br>    latestCount.current = count;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// Read the mutable latest value</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;latestCount.current&#125;</span> times`</span>);<br>    &#125;, <span class="hljs-number">3000</span>);<br>  &#125;);<br>  <span class="hljs-comment">// ...</span><br></code></pre></div></td></tr></table></figure>

<p>也可以认为，ref 是 Mutable 的，而 state 是 Immutable 的。</p>
<h2 id="useEffect-回收机制"><a href="#useEffect-回收机制" class="headerlink" title="useEffect 回收机制"></a>useEffect 回收机制</h2><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx">useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    ChatAPI.subscribeToFriendStatus(props.id, handleStatusChange);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      ChatAPI.unsubscribeFromFriendStatus(props.id, handleStatusChange);<br>    &#125;;<br>  &#125;);<br></code></pre></div></td></tr></table></figure>

<p>假设第一次渲染的时候props是{id: 10}，第二次渲染的时候是{id: 20}。你可能认为顺序如下：</p>
<ul>
<li>React 清除了 {id: 10}的effect。</li>
<li>React 渲染{id: 20}的UI。</li>
<li>React 运行{id: 20}的effect。</li>
</ul>
<p>实际上并不是这样，react 只会在浏览器绘制之后运行 useEffect。上一次的 effect 会在重新渲染后被清楚。</p>
<ul>
<li>React 渲染{id: 20}的UI。</li>
<li>浏览器绘制。我们在屏幕上看到{id: 20}的UI。</li>
<li>React 清除{id: 10}的effect。</li>
<li>React 运行{id: 20}的effect。</li>
</ul>
<p>那为什么清楚上一次的 effect 发生在 props 变为 {id: 20} 之后，却还能看到旧的 {id: 10} ？</p>
<p>effect的清除并不会读取“最新”的props。它只能读取到定义它的那次渲染中的props值。由于 Capture Value 特性，每次 “注册” “回收” 拿到的都是成对的固定值。</p>
<p>确切的说清除上一次的副作用发生在“每次重新渲染之后，副作用函数重新运行执行”。</p>
<h2 id="同步，而非生命周期"><a href="#同步，而非生命周期" class="headerlink" title="同步，而非生命周期"></a>同步，而非生命周期</h2><p>React会根据我们当前的props和state同步到DOM。“mount”和“update”之于渲染并没有什么区别。</p>
<p>用相同的方式去思考effects。useEffect使你能够根据props和state同步React tree之外的东西。</p>
<h2 id="告诉-React-如何对比-Effect"><a href="#告诉-React-如何对比-Effect" class="headerlink" title="告诉 React 如何对比 Effect"></a>告诉 React 如何对比 Effect</h2><p>react 在 DOM渲染时会 diff 内容，只对改变的部分做修改。但是对于 effect 却做不到这样。</p>
<p>如何避免 effect 重复调用，需要给 effect 提供一个 deps，deps 内变量改变的时候才执行。</p>
<figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx">useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">&#x27;Hello, &#x27;</span> + name;<br>  &#125;, [name]); <span class="hljs-comment">// Our deps</span><br></code></pre></div></td></tr></table></figure>

<h2 id="依赖项不要撒谎"><a href="#依赖项不要撒谎" class="headerlink" title="依赖项不要撒谎"></a>依赖项不要撒谎</h2><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SearchResults</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchData</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    fetchData();<br>  &#125;, []); <span class="hljs-comment">// Is this okay? Not always -- and there&#x27;s a better way to write it.</span><br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>你设置了依赖项，effect中用到的所有组件内的值都要包含在依赖中。这包括 props，state，函数。</p>
<p>这样做可能会遇到一些问题，比如会遇到重复渲染、无限请求等。解决问题的办法不是移除依赖性。后续再说。</p>
<figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> id = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      setCount(count + <span class="hljs-number">1</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(id);<br>  &#125;, []);<br><br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>setInterval 只想只想一次，依赖写为 []。</p>
<p>但是，因为 useEffect 拿到的是那次渲染时候的值。count 值永远是 0。setCount 没产生作用。</p>
<h2 id="对依赖诚实的代价"><a href="#对依赖诚实的代价" class="headerlink" title="对依赖诚实的代价"></a>对依赖诚实的代价</h2><p>对依赖诚实，那就把 count 加到依赖中：</p>
<figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx">useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> id = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    setCount(count + <span class="hljs-number">1</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(id);<br>&#125;, [count]);<br></code></pre></div></td></tr></table></figure>

<p>此时能够拿到最新的 count，但是有问题：</p>
<ul>
<li>每次变化都生成、销毁定时器，性能不好。</li>
<li>每次重新定时，不准。</li>
</ul>
<h2 id="让-useEffect-自给自足"><a href="#让-useEffect-自给自足" class="headerlink" title="让 useEffect 自给自足"></a>让 useEffect 自给自足</h2><p>上述代码 对只想执行一次的 useEffect 里依赖了外部变量。</p>
<p>解决办法就是 不依赖外部变量。</p>
<figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx">useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> id = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    setCount(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(id);<br>&#125;, []);<br></code></pre></div></td></tr></table></figure>

<p>setCount 回调写法，对旧值进行修改。此时 useEffect 只允许一次，count 也能拿到最新的值。</p>
<h2 id="解耦来自-Actions-的更新"><a href="#解耦来自-Actions-的更新" class="headerlink" title="解耦来自 Actions 的更新"></a>解耦来自 Actions 的更新</h2><p>setCount(c =&gt; c + 1) 并不能解决所有场景问题。如果我们有两个互相依赖的状态，或者我们想基于一个prop来计算下一次的state，它并不能做到。幸运的是， setCount(c =&gt; c + 1)有一个更强大的姐妹模式，它的名字叫useReducer。</p>
<figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> [step, setStep] = useState(<span class="hljs-number">1</span>);<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> id = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      setCount(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + step);<br>    &#125;, <span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(id);<br>  &#125;, [step]);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;step&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> setStep(Number(e.target.value))&#125; /&gt;</span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>上述例子中没有依赖撒谎。但是 step 改变时，不想重启定时器怎么办？</p>
<p>当你想更新一个状态，并且这个状态更新依赖于另一个状态的值时，你可能需要用useReducer去替换它们。</p>
<p>利用 useReducer 函数，将更新与动作解耦：</p>
<figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);<br><span class="hljs-keyword">const</span> &#123; count, step &#125; = state;<br><br>useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> id = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;tick&quot;</span> &#125;); <span class="hljs-comment">// Instead of setCount(c =&gt; c + step);</span><br>  &#125;, <span class="hljs-number">1000</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(id);<br>&#125;, [dispatch]);<br></code></pre></div></td></tr></table></figure>

<p>React会保证 dispatc 在组件的声明周期内保持不变。</p>
<h2 id="依赖-props-计算状态"><a href="#依赖-props-计算状态" class="headerlink" title="依赖 props 计算状态"></a>依赖 props 计算状态</h2><p>前面介绍了如何移除effect的依赖，不管状态更新是依赖上一个状态还是依赖另一个状态。</p>
<p>但假如我们需要依赖props去计算下一个状态呢。</p>
<p><code>&lt;Counter step=&#123;1&#125; /&gt;</code>，此时如何避免依赖 props.step 呢？</p>
<p>把 reducer 函数放到组件内部去读取 props：</p>
<figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params">&#123; step &#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, dispatch] = useReducer(reducer, <span class="hljs-number">0</span>);<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span>(<span class="hljs-params">state, action</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (action.type === <span class="hljs-string">&#x27;tick&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span> state + step;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>();<br>    &#125;<br>  &#125;<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> id = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;tick&#x27;</span> &#125;);<br>    &#125;, <span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(id);<br>  &#125;, [dispatch]);<br><br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>此时 react 仍能保证 dispatch 在每次渲染中都是一样的。</p>
<p>这可以帮助我移除不必需的依赖，避免不必要的effect调用。</p>
<h2 id="把函数移到-Effects-里"><a href="#把函数移到-Effects-里" class="headerlink" title="把函数移到 Effects 里"></a>把函数移到 Effects 里</h2><p>如果某些函数仅在effect中调用，你可以把它们的定义移到effect中：</p>
<figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SearchResults</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [query, setQuery] = useState(<span class="hljs-string">&#x27;react&#x27;</span>);<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFetchUrl</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;<br>    &#125;<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchData</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> axios(getFetchUrl());<br>      setData(result.data);<br>    &#125;<br><br>    fetchData();<br>  &#125;, [query]); <span class="hljs-comment">// ✅ Deps are OK</span><br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure>

<h2 id="当函数不能放在-Effects-里"><a href="#当函数不能放在-Effects-里" class="headerlink" title="当函数不能放在 Effects 里"></a>当函数不能放在 Effects 里</h2><p>有时函数不能放在 effects 里，如：</p>
<ul>
<li>组件内几个函数使用了相同的函数</li>
<li>这个函数是一个 prop</li>
</ul>
<p>此时能忽略对函数的依赖么？最好不要，effects 对依赖不要撒谎。</p>
<p>两种情况：</p>
<ul>
<li>1、函数内没有使用组件内的任何值，就提到组件外。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx">/ ✅ Not affected by the data flow<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFetchUrl</span>(<span class="hljs-params">query</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SearchResults</span>(<span class="hljs-params"></span>) </span>&#123;<br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> url = getFetchUrl(<span class="hljs-string">&#x27;react&#x27;</span>);<br>    <span class="hljs-comment">// ... Fetch data and do something ...</span><br>  &#125;, []); <span class="hljs-comment">// ✅ Deps are OK</span><br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> url = getFetchUrl(<span class="hljs-string">&#x27;redux&#x27;</span>);<br>    <span class="hljs-comment">// ... Fetch data and do something ...</span><br>  &#125;, []); <span class="hljs-comment">// ✅ Deps are OK</span><br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>2、放组件内，用 useCallback 包装, 将函数添加到依赖</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SearchResults</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [query, setQuery] = useState(<span class="hljs-string">&#x27;react&#x27;</span>);<br><br>  <span class="hljs-comment">// ✅ Preserves identity until query changes</span><br>  <span class="hljs-keyword">const</span> getFetchUrl = useCallback(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;<br>  &#125;, [query]);  <span class="hljs-comment">// ✅ Callback deps are OK</span><br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> url = getFetchUrl();<br>    <span class="hljs-comment">// ... Fetch data and do something ...</span><br>  &#125;, [getFetchUrl]); <span class="hljs-comment">// ✅ Effect deps are OK</span><br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>使用 useCallback，因为如果query 保持不变，getFetchUrl也会保持不变，我们的effect也不会重新运行。</p>
<p>父组件传入函数的情况，也适用该方法：</p>
<figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [query, setQuery] = useState(<span class="hljs-string">&#x27;react&#x27;</span>);<br><br>  <span class="hljs-comment">// ✅ Preserves identity until query changes</span><br>  <span class="hljs-keyword">const</span> fetchData = useCallback(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> url = <span class="hljs-string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;<br>    <span class="hljs-comment">// ... Fetch data and return it ...</span><br>  &#125;, [query]);  <span class="hljs-comment">// ✅ Callback deps are OK</span><br><br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">fetchData</span>=<span class="hljs-string">&#123;fetchData&#125;</span> /&gt;</span></span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">&#123; fetchData &#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> [data, setData] = useState(<span class="hljs-literal">null</span>);<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    fetchData().then(setData);<br>  &#125;, [fetchData]); <span class="hljs-comment">// ✅ Effect deps are OK</span><br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>避免到处使用 useCallback。</p>
<p>当我们需要将函数传递下去并且函数会在子组件的effect中被调用的时候，useCallback 是很好的技巧且非常有用。或者你想试图减少对子组件的记忆负担，也不妨一试。</p>
<ul>
<li>3、更好的方式可能是把他抽成自定义 Hook，把 fetchData 放在 effect 里。</li>
</ul>
<p>useEffect 只是底层 API，未来业务接触到的是更多封装后的上层 API，比如 useFetch 或者 useTheme，它们会更好用。</p>
<figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> React, &#123; useState, useEffect, useReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">const</span> GITHUB_API = <span class="hljs-string">&#x27;https://api.github.com/repos/chanshiyucx/blog/issues?page=10&amp;per_page=&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [list, setList] = useState([])<br>  <span class="hljs-keyword">const</span> [page, setPage] = useState(<span class="hljs-number">1</span>)<br><br>  <span class="hljs-keyword">const</span> &#123; data, doFetch &#125; = useDataApi(<span class="hljs-string">`<span class="hljs-subst">$&#123;GITHUB_API&#125;</span><span class="hljs-subst">$&#123;page&#125;</span>`</span>, [])<br>  <span class="hljs-comment">// 翻页时重新获取列表</span><br>  useEffect(<span class="hljs-function">() =&gt;</span> doFetch(<span class="hljs-string">`<span class="hljs-subst">$&#123;GITHUB_API&#125;</span><span class="hljs-subst">$&#123;page&#125;</span>`</span>), [page])<br>  useEffect(<span class="hljs-function">() =&gt;</span> setList(data), [data])<br><br>  <span class="hljs-keyword">const</span> handleNextPage = <span class="hljs-function">() =&gt;</span> setPage(page + <span class="hljs-number">1</span>)<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleNextPage&#125;</span>&gt;</span>NextPage<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">        &#123;list.map(o =&gt; (</span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;o.id&#125;</span>&gt;</span>&#123;o.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        ))&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml">      &#123;isError &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Something went wrong ...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>&#125;</span><br><span class="xml">      &#123;isLoading &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Loading ...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>reducer:</p>
<figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> dataFetchReducer = <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">switch</span> (action.type) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;FETCH_INIT&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        ...state,<br>        <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">isError</span>: <span class="hljs-literal">false</span><br>      &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;FETCH_SUCCESS&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        ...state,<br>        <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">isError</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">data</span>: action.payload<br>      &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;FETCH_FAILURE&#x27;</span>:<br>      <span class="hljs-keyword">return</span> &#123;<br>        ...state,<br>        <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">isError</span>: <span class="hljs-literal">true</span><br>      &#125;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>()<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>自定义 Hook：</p>
<figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> useDataApi = <span class="hljs-function">(<span class="hljs-params">initialUrl, initialData</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> [url, setUrl] = useState(initialUrl)<br><br>  <span class="hljs-keyword">const</span> [state, dispatch] = useReducer(dataFetchReducer, &#123;<br>    <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">isError</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">data</span>: initialData<br>  &#125;)<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> didCancel = <span class="hljs-literal">false</span><br><br>    <span class="hljs-keyword">const</span> fetchData = <span class="hljs-keyword">async</span> () =&gt; &#123;<br>      dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_INIT&#x27;</span> &#125;)<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(url)<br>        <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.json()<br>        <span class="hljs-keyword">if</span> (!didCancel) &#123;<br>          dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_SUCCESS&#x27;</span>, <span class="hljs-attr">payload</span>: data &#125;)<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-keyword">if</span> (!didCancel) &#123;<br>          dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_FAILURE&#x27;</span> &#125;)<br>        &#125;<br>      &#125;<br>    &#125;<br>    fetchData()<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      didCancel = <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;, [url])<br><br>  <span class="hljs-keyword">const</span> doFetch = <span class="hljs-function"><span class="hljs-params">url</span> =&gt;</span> &#123;<br>    setUrl(url)<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> &#123; ...state, doFetch &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://overreacted.io/a-complete-guide-to-useeffect/">a-complete-guide-to-useeffect</a></li>
<li><a target="_blank" rel="noopener" href="https://www.robinwieruch.de/react-hooks-fetch-data/">https://www.robinwieruch.de/react-hooks-fetch-data/</a></li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/React-Hook/">React Hook</a>
                    
                      <a class="hover-with-bg" href="/categories/React-Hook/React/">React</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/useEffect/">useEffect</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/25e26362/">
                        <span class="hidden-mobile">React 中常用 TS 类型</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@waline/client@1/dist/Waline.min.js', function() {
        var options = Object.assign(
          {"serverURL":"https://blog-api-1dffumf4g-moweiwei.vercel.app/","path":"window.location.pathname","placeholder":null,"meta":["nick","mail","link"],"requiredMeta":[],"lang":"zh-CN","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],"dark":"html[data-user-color-scheme=\"dark\"]","avatar":"retro","avatarCDN":"https://seccdn.libravatar.org/avatar/","avatarForce":false,"wordLimit":0,"pageSize":10,"highlight":true},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        new Waline(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          Fluid.plugins.initFancyBox('#waline .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        苏ICP备2022005904号-1
      </a>
    </span>
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":true,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>














  
<script src="/js/custom.js"></script>



<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
