<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>使用 useRef 跨生命周期保存变量</title>
    <link href="/2022/01/13/useRef/"/>
    <url>/2022/01/13/useRef/</url>
    
    <content type="html"><![CDATA[<p>ref 这一种访问 DOM 的主要方式。然而，useRef() 比 ref 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式.</p><p>当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。</p><h2 id="场景-1：只在更新时运行-useEffect"><a href="#场景-1：只在更新时运行-useEffect" class="headerlink" title="场景 1：只在更新时运行 useEffect"></a>场景 1：只在更新时运行 useEffect</h2><p>使用一个可变的 ref 手动存储一个布尔值来表示是首次渲染还是后续渲染.</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">const</span> prevCountRef = useRef(<span class="hljs-literal">false</span>);<br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (prevCountRef.current) &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;只在更新时候执行&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;首次渲染执行&quot;</span>);<br>      prevCountRef.current = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="xml">          setCount(count + 1);</span><br><span class="xml">        &#125;&#125;</span><br><span class="xml">      &gt;</span><br><span class="xml">        +</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></div></td></tr></table></figure><p>抽成自定义 hook：</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">const</span> update = useUpdate();<br>  <span class="hljs-built_in">console</span>.log(update, <span class="hljs-string">&quot;是否更新&quot;</span>);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="xml">          setCount(count + 1);</span><br><span class="xml">        &#125;&#125;</span><br><span class="xml">      &gt;</span><br><span class="xml">        +</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useUpdate</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> ref = useRef(<span class="hljs-literal">false</span>);<br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    ref.current = <span class="hljs-literal">true</span>;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> ref.current;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="场景-2：获取上一轮的-props-或-state"><a href="#场景-2：获取上一轮的-props-或-state" class="headerlink" title="场景 2：获取上一轮的 props 或 state"></a>场景 2：获取上一轮的 props 或 state</h2><p>为什么 ref.current 拿到是上次的值？原因：</p><ol><li>useEffect 很重要的一点是：它是在每次渲染之后才会触发的，是延迟执行的。</li><li>return 语句是同步的，所以 return 的时候，ref.current 还是旧值。</li><li>以下代码的执行顺序是 1 3 2</li></ol><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">const</span> prevCountRef = useRef();<br><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1&quot;</span>, count);<br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2.&quot;</span>, count);<br>    prevCountRef.current = count;<br>  &#125;);<br><br>  <span class="hljs-keyword">const</span> prevCount = prevCountRef.current;<br><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`3.之前的状态: <span class="hljs-subst">$&#123;prevCount&#125;</span>;现在状态: <span class="hljs-subst">$&#123;count&#125;</span>`</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="xml">          setCount(count + 1);</span><br><span class="xml">        &#125;&#125;</span><br><span class="xml">      &gt;</span><br><span class="xml">        +</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></div></td></tr></table></figure><p>抽取成自定义 Hook:</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">usePrevious</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> ref = useRef();<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    ref.current = value;<br>  &#125;, [value]);<br><br>  <span class="hljs-keyword">return</span> ref.current;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="场景-3：-解决-hooks-时，由于异步闭包无法获取最新-state-的问题"><a href="#场景-3：-解决-hooks-时，由于异步闭包无法获取最新-state-的问题" class="headerlink" title="场景 3： 解决 hooks 时，由于异步闭包无法获取最新 state 的问题"></a>场景 3： 解决 hooks 时，由于异步闭包无法获取最新 state 的问题</h2><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> React, &#123; useState, useEffect, useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">const</span> RefComponent = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 使用 useState 存放和改变展示的 number</span><br>  <span class="hljs-keyword">const</span> [number, setNumber] = useState(<span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 使用 useRef 生成一个独立的 ref 对象</span><br>  <span class="hljs-comment">// 在它的 current 属性单独存放一个展示的 number, 初始值为 0</span><br>  <span class="hljs-keyword">const</span> numRef = useRef(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">incrementAndDelayLogging</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 点击按钮 number + 1</span><br>    setNumber(number + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 同时 ref 对象的 current 属性值也 + 1</span><br>    numRef.current++;<br>    <span class="hljs-comment">// 定时器函数中产生了闭包, 这里 number 的是组件更新前的 number 对象, 所以值一直会滞后 1</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">`state: <span class="hljs-subst">$&#123;number&#125;</span> | ref: <span class="hljs-subst">$&#123;numRef.current&#125;</span>`</span>), <span class="hljs-number">1000</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 直接渲染的组件是正常情况, 可以获取到最新的 state,</span><br>  <span class="hljs-comment">// 所以 ref.current 和 state 存储的值显示一致</span><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>solving closure by useRef<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;incrementAndDelayLogging&#125;</span>&gt;</span>alert in setTimeout<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>state: &#123;number&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>ref: &#123;numRef.current&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
